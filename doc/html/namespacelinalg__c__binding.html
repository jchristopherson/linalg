<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>linalg: linalg_c_binding Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linalg
   &#160;<span id="projectnumber">1.4.3</span>
   </div>
   <div id="projectbrief">A linear algebra library that provides a user-friendly interface to several BLAS and LAPACK routines.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Types&#160;List</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Modules&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Module&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelinalg__c__binding.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">linalg_c_binding Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b><a class="el" href="namespacelinalg__c__binding.html" title="linalg_c_binding ">linalg_c_binding</a></b>  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a7cbe605511e1d19ecccdacbf76abc2e6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a7cbe605511e1d19ecccdacbf76abc2e6">mtx_mult_c</a> (transa, transb, m, n, k, alpha, a, lda, b, ldb,                                           beta, c)</td></tr>
<tr class="memdesc:a7cbe605511e1d19ecccdacbf76abc2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the matrix operation: C = alpha * op(A) * op(B) + beta * C.  <a href="#a7cbe605511e1d19ecccdacbf76abc2e6">More...</a><br /></td></tr>
<tr class="separator:a7cbe605511e1d19ecccdacbf76abc2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30846d79f49024432caa4b8186742810"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a30846d79f49024432caa4b8186742810">cmtx_mult_c</a> (transa, transb, m, n, k, alpha, a, lda, b, ldb,                                           beta, c)</td></tr>
<tr class="memdesc:a30846d79f49024432caa4b8186742810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the matrix operation: C = alpha * op(A) * op(B) + beta * C.  <a href="#a30846d79f49024432caa4b8186742810">More...</a><br /></td></tr>
<tr class="separator:a30846d79f49024432caa4b8186742810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c321e1758a1b3fb1a0a85f826ec7d68"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a7c321e1758a1b3fb1a0a85f826ec7d68">diag_mtx_mult_left_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:a7c321e1758a1b3fb1a0a85f826ec7d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix.  <a href="#a7c321e1758a1b3fb1a0a85f826ec7d68">More...</a><br /></td></tr>
<tr class="separator:a7c321e1758a1b3fb1a0a85f826ec7d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de8fae56b5e00dba7b3cb4c8eee3c88"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a5de8fae56b5e00dba7b3cb4c8eee3c88">disg_mtx_mult_right_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:a5de8fae56b5e00dba7b3cb4c8eee3c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix.  <a href="#a5de8fae56b5e00dba7b3cb4c8eee3c88">More...</a><br /></td></tr>
<tr class="separator:a5de8fae56b5e00dba7b3cb4c8eee3c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed3672e434e835eba0b5a90224f076"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a52ed3672e434e835eba0b5a90224f076">diag_mtx_mult_cmplx_left_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:a52ed3672e434e835eba0b5a90224f076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix.  <a href="#a52ed3672e434e835eba0b5a90224f076">More...</a><br /></td></tr>
<tr class="separator:a52ed3672e434e835eba0b5a90224f076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9011f36861d28a6a66b322f06354397d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a9011f36861d28a6a66b322f06354397d">diag_mtx_mult_cmplx_right_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:a9011f36861d28a6a66b322f06354397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix.  <a href="#a9011f36861d28a6a66b322f06354397d">More...</a><br /></td></tr>
<tr class="separator:a9011f36861d28a6a66b322f06354397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8d75b44685315225b41c91a6b1bb00"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a1e8d75b44685315225b41c91a6b1bb00">diag_cmtx_mult_left_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:a1e8d75b44685315225b41c91a6b1bb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix.  <a href="#a1e8d75b44685315225b41c91a6b1bb00">More...</a><br /></td></tr>
<tr class="separator:a1e8d75b44685315225b41c91a6b1bb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d5df3f4370e0fa17e02b5c50ce846"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#abb5d5df3f4370e0fa17e02b5c50ce846">diag_cmtx_mult_right_c</a> (m, n, k, alpha, a, b, beta, c)</td></tr>
<tr class="memdesc:abb5d5df3f4370e0fa17e02b5c50ce846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix.  <a href="#abb5d5df3f4370e0fa17e02b5c50ce846">More...</a><br /></td></tr>
<tr class="separator:abb5d5df3f4370e0fa17e02b5c50ce846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad166279ad4bef86d67195c4854f3f8d9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad166279ad4bef86d67195c4854f3f8d9">rank1_update_c</a> (m, n, alpha, x, y, a)</td></tr>
<tr class="memdesc:ad166279ad4bef86d67195c4854f3f8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the rank-1 update to matrix A such that: A = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar, X is an M-element array, and N is an N-element array.  <a href="#ad166279ad4bef86d67195c4854f3f8d9">More...</a><br /></td></tr>
<tr class="separator:ad166279ad4bef86d67195c4854f3f8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359a0b386de6e6e0a8bea2aa5df08fc5"><td class="memItemLeft" align="right" valign="top">pure real(dp) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a359a0b386de6e6e0a8bea2aa5df08fc5">trace_c</a> (m, n, x)</td></tr>
<tr class="memdesc:a359a0b386de6e6e0a8bea2aa5df08fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the trace of a matrix (the sum of the main diagonal elements).  <a href="#a359a0b386de6e6e0a8bea2aa5df08fc5">More...</a><br /></td></tr>
<tr class="separator:a359a0b386de6e6e0a8bea2aa5df08fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad079eb8c17d4c0bafb4c7483bab6d614"><td class="memItemLeft" align="right" valign="top">integer(i32) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad079eb8c17d4c0bafb4c7483bab6d614">mtx_rank_c</a> (m, n, a, err)</td></tr>
<tr class="memdesc:ad079eb8c17d4c0bafb4c7483bab6d614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of a matrix.  <a href="#ad079eb8c17d4c0bafb4c7483bab6d614">More...</a><br /></td></tr>
<tr class="separator:ad079eb8c17d4c0bafb4c7483bab6d614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d35954c375badb374c863746ae0b33"><td class="memItemLeft" align="right" valign="top">real(dp) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a30d35954c375badb374c863746ae0b33">det_c</a> (n, a, err)</td></tr>
<tr class="memdesc:a30d35954c375badb374c863746ae0b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a square matrix.  <a href="#a30d35954c375badb374c863746ae0b33">More...</a><br /></td></tr>
<tr class="separator:a30d35954c375badb374c863746ae0b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8585a8b92cfc6f1b2dc10028c5e3a0f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad8585a8b92cfc6f1b2dc10028c5e3a0f">swap_c</a> (n, x, y)</td></tr>
<tr class="memdesc:ad8585a8b92cfc6f1b2dc10028c5e3a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two arrays.  <a href="#ad8585a8b92cfc6f1b2dc10028c5e3a0f">More...</a><br /></td></tr>
<tr class="separator:ad8585a8b92cfc6f1b2dc10028c5e3a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa87ac5e32229bf80fe5a7b002f7c9bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa87ac5e32229bf80fe5a7b002f7c9bf"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><b>tri_mtx_mult_c</b> (upper, n, alpha, a, beta, b, err)</td></tr>
<tr class="separator:afa87ac5e32229bf80fe5a7b002f7c9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56b68663844796fb3d20fb1ee0e75c8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad56b68663844796fb3d20fb1ee0e75c8">lu_factor_c</a> (m, n, a, ipvt, err)</td></tr>
<tr class="memdesc:ad56b68663844796fb3d20fb1ee0e75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LU factorization of an M-by-N matrix.  <a href="#ad56b68663844796fb3d20fb1ee0e75c8">More...</a><br /></td></tr>
<tr class="separator:ad56b68663844796fb3d20fb1ee0e75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8285c85a2b972f436a9b06573ed61a0c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a8285c85a2b972f436a9b06573ed61a0c">form_lu_c</a> (n, lu, ipvt, u, p)</td></tr>
<tr class="memdesc:a8285c85a2b972f436a9b06573ed61a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the L, U, and P matrices from the output of the lu_factor routine.  <a href="#a8285c85a2b972f436a9b06573ed61a0c">More...</a><br /></td></tr>
<tr class="separator:a8285c85a2b972f436a9b06573ed61a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0c1703806a14d1134f49f54da9804d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a6d0c1703806a14d1134f49f54da9804d">qr_factor_c</a> (m, n, a, tau, err)</td></tr>
<tr class="memdesc:a6d0c1703806a14d1134f49f54da9804d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR factorization of an M-by-N matrix without pivoting.  <a href="#a6d0c1703806a14d1134f49f54da9804d">More...</a><br /></td></tr>
<tr class="separator:a6d0c1703806a14d1134f49f54da9804d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1157b047a3e01fbefd9e6752e16ed"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a17a1157b047a3e01fbefd9e6752e16ed">qr_factor_pivot_c</a> (m, n, a, tau, jpvt, err)</td></tr>
<tr class="memdesc:a17a1157b047a3e01fbefd9e6752e16ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR factorization of an M-by-N matrix with column pivoting such that A * P = Q * R.  <a href="#a17a1157b047a3e01fbefd9e6752e16ed">More...</a><br /></td></tr>
<tr class="separator:a17a1157b047a3e01fbefd9e6752e16ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae594d5d52674a91481d5513b1bec30ba"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ae594d5d52674a91481d5513b1bec30ba">form_qr_c</a> (m, n, r, tau, q, err)</td></tr>
<tr class="memdesc:ae594d5d52674a91481d5513b1bec30ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.  <a href="#ae594d5d52674a91481d5513b1bec30ba">More...</a><br /></td></tr>
<tr class="separator:ae594d5d52674a91481d5513b1bec30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c59585ad7a55fdcf8f08d15fa355970"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2c59585ad7a55fdcf8f08d15fa355970">form_qr_pivot_c</a> (m, n, r, tau, pvt, q, p, err)</td></tr>
<tr class="memdesc:a2c59585ad7a55fdcf8f08d15fa355970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.  <a href="#a2c59585ad7a55fdcf8f08d15fa355970">More...</a><br /></td></tr>
<tr class="separator:a2c59585ad7a55fdcf8f08d15fa355970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4d0438b16155f34db5bb151db1e808"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a6b4d0438b16155f34db5bb151db1e808">mult_qr_c</a> (trans, m, n, q, tau, c, err)</td></tr>
<tr class="memdesc:a6b4d0438b16155f34db5bb151db1e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C.  <a href="#a6b4d0438b16155f34db5bb151db1e808">More...</a><br /></td></tr>
<tr class="separator:a6b4d0438b16155f34db5bb151db1e808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615376486e6389f090a77180d31d1023"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a615376486e6389f090a77180d31d1023">qr_rank1_update_c</a> (m, n, q, r, u, v, err)</td></tr>
<tr class="memdesc:a615376486e6389f090a77180d31d1023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1.  <a href="#a615376486e6389f090a77180d31d1023">More...</a><br /></td></tr>
<tr class="separator:a615376486e6389f090a77180d31d1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a84a23794f147236ae80ce54b24081"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a70a84a23794f147236ae80ce54b24081">cholesky_factor_c</a> (n, a, upper, err)</td></tr>
<tr class="memdesc:a70a84a23794f147236ae80ce54b24081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cholesky factorization of a symmetric, positive definite matrix.  <a href="#a70a84a23794f147236ae80ce54b24081">More...</a><br /></td></tr>
<tr class="separator:a70a84a23794f147236ae80ce54b24081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc29e4257189d6ecdecd838b137d79"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad5fc29e4257189d6ecdecd838b137d79">cholesky_rank1_update_c</a> (n, r, u, err)</td></tr>
<tr class="memdesc:ad5fc29e4257189d6ecdecd838b137d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 update to a Cholesky factored matrix (upper triangular).  <a href="#ad5fc29e4257189d6ecdecd838b137d79">More...</a><br /></td></tr>
<tr class="separator:ad5fc29e4257189d6ecdecd838b137d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba4b37b842f37f76c42f554d8131f00"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2ba4b37b842f37f76c42f554d8131f00">cholesky_rank1_downdate_c</a> (n, r, u, err)</td></tr>
<tr class="memdesc:a2ba4b37b842f37f76c42f554d8131f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular).  <a href="#a2ba4b37b842f37f76c42f554d8131f00">More...</a><br /></td></tr>
<tr class="separator:a2ba4b37b842f37f76c42f554d8131f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b99d65f92e5762fbb05ddc707fb715"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a86b99d65f92e5762fbb05ddc707fb715">rz_factor_c</a> (m, n, a, tau, err)</td></tr>
<tr class="memdesc:a86b99d65f92e5762fbb05ddc707fb715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors an upper trapezoidal matrix by means of orthogonal transformations such that A = R * Z = (R 0) * Z. Z is an orthogonal matrix of dimension N-by-N, and R is an M-by-M upper triangular matrix.  <a href="#a86b99d65f92e5762fbb05ddc707fb715">More...</a><br /></td></tr>
<tr class="separator:a86b99d65f92e5762fbb05ddc707fb715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607ab80bd81fbd558796b0ddfd81464"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ab607ab80bd81fbd558796b0ddfd81464">mult_rz_c</a> (trans, m, n, l, a, tau, c, err)</td></tr>
<tr class="memdesc:ab607ab80bd81fbd558796b0ddfd81464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C.  <a href="#ab607ab80bd81fbd558796b0ddfd81464">More...</a><br /></td></tr>
<tr class="separator:ab607ab80bd81fbd558796b0ddfd81464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e5b8578d1128fac969935798c0a97"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a3a7e5b8578d1128fac969935798c0a97">svd_c</a> (m, n, a, s, u, vt, err)</td></tr>
<tr class="memdesc:a3a7e5b8578d1128fac969935798c0a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of a matrix A. The SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal matrix.  <a href="#a3a7e5b8578d1128fac969935798c0a97">More...</a><br /></td></tr>
<tr class="separator:a3a7e5b8578d1128fac969935798c0a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc91f7afbf731b7a9219a31aa067065d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#abc91f7afbf731b7a9219a31aa067065d">solve_tri_mtx_c</a> (upper, trans, nounit, n, nrhs, alpha, a, b)</td></tr>
<tr class="memdesc:abc91f7afbf731b7a9219a31aa067065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves one of the matrix equations: op(A) * X = alpha * B, where A is a triangular matrix.  <a href="#abc91f7afbf731b7a9219a31aa067065d">More...</a><br /></td></tr>
<tr class="separator:abc91f7afbf731b7a9219a31aa067065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36f2bdcc9def21fcd3657bed2f736f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a1d36f2bdcc9def21fcd3657bed2f736f">solve_lu_c</a> (n, nrhs, a, ipvt, b)</td></tr>
<tr class="memdesc:a1d36f2bdcc9def21fcd3657bed2f736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of LU-factored equations.  <a href="#a1d36f2bdcc9def21fcd3657bed2f736f">More...</a><br /></td></tr>
<tr class="separator:a1d36f2bdcc9def21fcd3657bed2f736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afad66bd793711f301bd471c9978165"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2afad66bd793711f301bd471c9978165">solve_qr_c</a> (m, n, nrhs, a, tau, b, err)</td></tr>
<tr class="memdesc:a2afad66bd793711f301bd471c9978165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of M QR-factored equations of N unknowns where M &gt;= N.  <a href="#a2afad66bd793711f301bd471c9978165">More...</a><br /></td></tr>
<tr class="separator:a2afad66bd793711f301bd471c9978165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410c7071c72c513ec53a10374ffb456"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2410c7071c72c513ec53a10374ffb456">solve_qr_pivot_c</a> (m, n, nrhs, a, tau, jpvt, b, err)</td></tr>
<tr class="memdesc:a2410c7071c72c513ec53a10374ffb456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of M QR-factored equations of N unknowns where the QR factorization made use of column pivoting.  <a href="#a2410c7071c72c513ec53a10374ffb456">More...</a><br /></td></tr>
<tr class="separator:a2410c7071c72c513ec53a10374ffb456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a796d25715839cd4fb664bcd65dc59f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2a796d25715839cd4fb664bcd65dc59f">solve_cholesky_c</a> (upper, n, nrhs, a, b)</td></tr>
<tr class="memdesc:a2a796d25715839cd4fb664bcd65dc59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of Cholesky factored equations.  <a href="#a2a796d25715839cd4fb664bcd65dc59f">More...</a><br /></td></tr>
<tr class="separator:a2a796d25715839cd4fb664bcd65dc59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aacb4362b2939ec3bce0a30743ea4f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a12aacb4362b2939ec3bce0a30743ea4f">mtx_inverse_c</a> (n, a, err)</td></tr>
<tr class="memdesc:a12aacb4362b2939ec3bce0a30743ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a square matrix.  <a href="#a12aacb4362b2939ec3bce0a30743ea4f">More...</a><br /></td></tr>
<tr class="separator:a12aacb4362b2939ec3bce0a30743ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf40bd59c6964e37746beebbdeac89b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a2bf40bd59c6964e37746beebbdeac89b">mtx_pinverse_c</a> (m, n, a, ainv, err)</td></tr>
<tr class="memdesc:a2bf40bd59c6964e37746beebbdeac89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the singular value decomposition of the matrix.  <a href="#a2bf40bd59c6964e37746beebbdeac89b">More...</a><br /></td></tr>
<tr class="separator:a2bf40bd59c6964e37746beebbdeac89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2d6deef9e1c13fe9b2ea8288b57b43"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a8e2d6deef9e1c13fe9b2ea8288b57b43">solve_least_squares_c</a> (m, n, nrhs, a, b, err)</td></tr>
<tr class="memdesc:a8e2d6deef9e1c13fe9b2ea8288b57b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the overdetermined or underdetermined system (A*X = B) of M equations of N unknowns using a QR or LQ factorization of the matrix A. Notice, it is assumed that matrix A has full rank.  <a href="#a8e2d6deef9e1c13fe9b2ea8288b57b43">More...</a><br /></td></tr>
<tr class="separator:a8e2d6deef9e1c13fe9b2ea8288b57b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d24b9c212ae24a5ae351b01b10ddfc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a30d24b9c212ae24a5ae351b01b10ddfc">eigen_symm_c</a> (n, vecs, a, vals, err)</td></tr>
<tr class="memdesc:a30d24b9c212ae24a5ae351b01b10ddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues, and optionally the eigenvectors of a real, symmetric matrix.  <a href="#a30d24b9c212ae24a5ae351b01b10ddfc">More...</a><br /></td></tr>
<tr class="separator:a30d24b9c212ae24a5ae351b01b10ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12087a2bc99ab50e7a25d8ba99112c63"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a12087a2bc99ab50e7a25d8ba99112c63">eigen_asymm_c</a> (n, a, vals, vecs, err)</td></tr>
<tr class="memdesc:a12087a2bc99ab50e7a25d8ba99112c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues, and the right eigenvectors of a square matrix.  <a href="#a12087a2bc99ab50e7a25d8ba99112c63">More...</a><br /></td></tr>
<tr class="separator:a12087a2bc99ab50e7a25d8ba99112c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9808a17b4e0e8848c0ca6ed4a3a59af"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ad9808a17b4e0e8848c0ca6ed4a3a59af">eigen_gen_c</a> (n, a, b, alpha, beta, vecs, err)</td></tr>
<tr class="memdesc:ad9808a17b4e0e8848c0ca6ed4a3a59af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues, and optionally the right eigenvectors of a square matrix assuming the structure of the eigenvalue problem is A*X = lambda*B*X.  <a href="#ad9808a17b4e0e8848c0ca6ed4a3a59af">More...</a><br /></td></tr>
<tr class="separator:ad9808a17b4e0e8848c0ca6ed4a3a59af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49418a380de6dd1d6bf3f84d3d9e4281"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a49418a380de6dd1d6bf3f84d3d9e4281">sort_dbl_ind_c</a> (ascend, n, x, ind)</td></tr>
<tr class="memdesc:a49418a380de6dd1d6bf3f84d3d9e4281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an array of double-precision values.  <a href="#a49418a380de6dd1d6bf3f84d3d9e4281">More...</a><br /></td></tr>
<tr class="separator:a49418a380de6dd1d6bf3f84d3d9e4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0852ae5393707d83c4680db3d0402d1b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a0852ae5393707d83c4680db3d0402d1b">sort_cmplx_ind_c</a> (ascend, n, x, ind)</td></tr>
<tr class="memdesc:a0852ae5393707d83c4680db3d0402d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an array of complex values according to their real components.  <a href="#a0852ae5393707d83c4680db3d0402d1b">More...</a><br /></td></tr>
<tr class="separator:a0852ae5393707d83c4680db3d0402d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f56be6e707720d8159f91db6faa935"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#a77f56be6e707720d8159f91db6faa935">sort_eigen_cmplx_c</a> (ascend, n, vals, vecs)</td></tr>
<tr class="memdesc:a77f56be6e707720d8159f91db6faa935"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach.  <a href="#a77f56be6e707720d8159f91db6faa935">More...</a><br /></td></tr>
<tr class="separator:a77f56be6e707720d8159f91db6faa935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e02da095c23d13fe0be9377d1ef8ba"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__c__binding.html#ab3e02da095c23d13fe0be9377d1ef8ba">sort_eigen_dbl_c</a> (ascend, n, vals, vecs)</td></tr>
<tr class="memdesc:ab3e02da095c23d13fe0be9377d1ef8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach.  <a href="#ab3e02da095c23d13fe0be9377d1ef8ba">More...</a><br /></td></tr>
<tr class="separator:ab3e02da095c23d13fe0be9377d1ef8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b><a class="el" href="namespacelinalg__c__binding.html" title="linalg_c_binding ">linalg_c_binding</a></b> </p>
<dl class="section user"><dt>Purpose</dt><dd>Provides a C friendly interface to the LINALG library. </dd></dl>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="a70a84a23794f147236ae80ce54b24081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::cholesky_factor_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Cholesky factorization of a symmetric, positive definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix to factor. On output, the factored matrix is returned in either the upper or lower triangular portion of the matrix, dependent upon the value of <code>upper</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>An optional input that, if specified, provides control over whether the factorization is computed as A = U**T * U (set to true), or as A = L * L**T (set to false). The default value is true such that A = U**T * U. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if <code>a</code> is not positive definite. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00814">814</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2ba4b37b842f37f76c42f554d8131f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::cholesky_rank1_downdate_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not positive definite.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs if <code>r</code> is singular. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00888">888</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad5fc29e4257189d6ecdecd838b137d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::cholesky_rank1_update_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 update to a Cholesky factored matrix (upper triangular). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00849">849</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a30846d79f49024432caa4b8186742810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::cmtx_mult_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(lda,*), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(ldb,*), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the matrix operation: C = alpha * op(A) * op(B) + beta * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transa</td><td>Set to true if op(A) == A**T; else, set to false if op(A) == A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transb</td><td>Set to true if op(B) == B**T; else, set to false if op(B) == B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C, and the number of rows in matrix op(A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C, and the number of columns in matrix op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of columns in matrix op(A), and the number of rows in the matrix op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The M-by-K matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>The leading dimension of matrix A. If <code>transa</code> is true, this value must be at least MAX(1, K); else, if <code>transa</code> is false, this value must be at least MAX(1, M). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The K-by-N matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>The leading dimension of matrix B. If <code>transb</code> is true, this value must be at least MAX(1, N); else, if <code>transb</code> is false, this value must be at least MAX(1, K). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00096">96</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a30d35954c375badb374c863746ae0b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(dp) function linalg_c_binding::det_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix on which to operate. On output the contents are overwritten by the LU factorization of the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the input matrix is not square.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00374">374</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a1e8d75b44685315225b41c91a6b1bb00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::diag_cmtx_mult_left_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(min(m, k)), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(k, n), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A MIN(M,K)-element array containing the diagonal elements of matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The K-by-N matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00240">240</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="abb5d5df3f4370e0fa17e02b5c50ce846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::diag_cmtx_mult_right_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m, k), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(min(k, n)), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of columns in matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The M-by-K matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A MIN(K,N)-element array containing the diagonal elements of matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00265">265</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a52ed3672e434e835eba0b5a90224f076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::diag_mtx_mult_cmplx_left_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(min(m, k)), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(k, n), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A MIN(M,K)-element array containing the diagonal elements of matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The K-by-N matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00188">188</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a9011f36861d28a6a66b322f06354397d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::diag_mtx_mult_cmplx_right_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m, k), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(min(k, n)), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of columns in matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The M-by-K matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A MIN(K,N)-element array containing the diagonal elements of matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00214">214</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a7c321e1758a1b3fb1a0a85f826ec7d68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::diag_mtx_mult_left_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,k)), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(k,n), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matirx operation: C = alpha * A * B + beta * C, where A is a diagonal amtrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A MIN(M,K)-element array containing the diagonal elements of matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The K-by-N matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00138">138</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a5de8fae56b5e00dba7b3cb4c8eee3c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::disg_mtx_mult_right_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m, k), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(k, n)), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comptues the matrix operation: C = alpha * A * B + beta * C, where B is a diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of columns in matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The M-by-K matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A MIN(K,N)-element array containing the diagonal elements of matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00163">163</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a12087a2bc99ab50e7a25d8ba99112c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::eigen_asymm_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n), intent(out)&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the eigenvalues, and the right eigenvectors of a square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix on which to operate. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vals</td><td>An N-element array containing the eigenvalues of the matrix on output. The eigenvalues are not sorted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecs</td><td>An N-by-N matrix containing the right eigenvectors (one per column) on output. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01372">1372</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad9808a17b4e0e8848c0ca6ed4a3a59af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::eigen_gen_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n, n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n, n), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n), intent(out)&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(out)&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the eigenvalues, and optionally the right eigenvectors of a square matrix assuming the structure of the eigenvalue problem is A*X = lambda*B*X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix A. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>On input, the N-by-N matrix B. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha</td><td>An N-element array that, on output, contains the numerator of the eigenvalue ration ALPHA / BETA. Computation of this ratio isn't necessarily as trivial as it seems as it is entirely possible, and likely, that ALPHA / BETA can overflow or underflow. With that said, the values in ALPHA will always be less than and usually comparable with the NORM(A). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">beta</td><td>An N-element array that, on output, contains the denominator used to determine the eigenvalues as ALPHA / BETA. The values in this array will always be less than and usually comparable with the NORM(B). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecs</td><td>An N-by-N matrix containing the right eigenvectors (one per column) on output. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01421">1421</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a30d24b9c212ae24a5ae351b01b10ddfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::eigen_symm_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(out)&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the eigenvalues, and optionally the eigenvectors of a real, symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecs</td><td>Set to true to compute the eigenvectors as well as the eigenvalues; else, set to false to just compute the eigenvalues. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N symmetric matrix on which to operate. On output, and if <code>vecs</code> is set to true, the matrix will contain the eigenvectors (one per column) corresponding to each eigenvalue in <code>vals</code>. If <code>vecs</code> is set to false, the lower triangular portion of the matrix is overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vals</td><td>An N-element array that will contain the eigenvalues sorted into ascending order. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01333">1333</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a8285c85a2b972f436a9b06573ed61a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::form_lu_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the L, U, and P matrices from the output of the lu_factor routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lu</td><td>On input, the N-by-N matrix as output by lu_factor. On output, the N-by-N lower triangular matrix L. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipvt</td><td>The N-element pivot array as output by lu_factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>An N-by-N matrix where the U matrix will be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An N-by-N matrix where the row permutation matrix will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Remarks</dt><dd>This routine allows extraction of the actual "L", "U", and "P" matrices of the decomposition. To use these matrices to solve the system A*X = B, the following approach is used.</dd></dl>
<ol type="1">
<li>First, solve the linear system: L*Y = P*B for Y.</li>
<li>Second, solve the linear system: U*X = Y for X.</li>
</ol>
<p>Notice, as both L and U are triangular in structure, the above equations can be solved by forward and backward substitution.</p>
<dl class="section user"><dt>See Also</dt><dd><ul>
<li><a href="https://en.wikipedia.org/wiki/LU_decomposition">Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/LUDecomposition.html">Wolfram MathWorld</a> </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00521">521</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ae594d5d52674a91481d5513b1bec30ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::form_qr_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(out)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, an M-by-N matrix where the elements below the diagonal contain the elementary reflectors generated from the QR factorization. On and above the diagonal, the matrix contains the matrix R. On output, the elements below the diagonal are zeroed such that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>An M-by-M matrix where the full orthogonal matrix Q will be written. In the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the scalar factor array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00643">643</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2c59585ad7a55fdcf8f08d15fa355970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::form_qr_pivot_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>pvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(out)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, an M-by-N matrix where the elements below the diagonal contain the elementary reflectors generated from the QR factorization. On and above the diagonal, the matrix contains the matrix R. On output, the elements below the diagonal are zeroed such that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvt</td><td>An N-element column pivot array as returned by the QR factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>An M-by-M matrix where the full orthogonal matrix Q will be written. In the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An N-by-N matrix where the pivot matrix will be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the scalar factor array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00692">692</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad56b68663844796fb3d20fb1ee0e75c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::lu_factor_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(min(m,n)), intent(out)&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LU factorization of an M-by-N matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix on which to operate. On output, the LU factored matrix in the form [L\U] where the unit diagonal elements of L are not stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipvt</td><td>An MIN(M, N)-element array used to track row-pivot operations. The array stored pivot information such that row I is interchanged with row IPVT(I). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the pivot array is not sized appropriately.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if <code>a</code> is found to be singular. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00475">475</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a12aacb4362b2939ec3bce0a30743ea4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::mtx_inverse_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of a square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix to invert. On output, the inverted matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01214">1214</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a7cbe605511e1d19ecccdacbf76abc2e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::mtx_mult_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(lda,*), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(ldb,*), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the matrix operation: C = alpha * op(A) * op(B) + beta * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transa</td><td>Set to true if op(A) == A**T; else, set to false if op(A) == A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transb</td><td>Set to true if op(B) == B**T; else, set to false if op(B) == B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in matrix C, and the number of rows in matrix op(A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in matrix C, and the number of columns in matrix op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The number of columns in matrix op(A), and the number of rows in the matrix op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The M-by-K matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>The leading dimension of matrix A. If <code>transa</code> is true, this value must be at least MAX(1, K); else, if <code>transa</code> is false, this value must be at least MAX(1, M). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The K-by-N matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>The leading dimension of matrix B. If <code>transb</code> is true, this value must be at least MAX(1, N); else, if <code>transb</code> is false, this value must be at least MAX(1, K). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar multiplier to matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The M-by-N matrix C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00047">47</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2bf40bd59c6964e37746beebbdeac89b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::mtx_pinverse_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,m), intent(out)&#160;</td>
          <td class="paramname"><em>ainv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the singular value decomposition of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix to invert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix to invert. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to invert. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ainv</td><td>The N-by-M matrix where the pseudo-inverse of <code>a</code> will be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01251">1251</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad079eb8c17d4c0bafb4c7483bab6d614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(i32) function linalg_c_binding::mtx_rank_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix of interest. On output, the contents of the matrix are overwritten. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00341">341</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a6b4d0438b16155f34db5bb151db1e808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::mult_qr_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(inout)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Q**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix <code>c</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix <code>c</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>On input, an M-by-M matrix containing the elementary reflectors output from the QR factorization. Notice, the contents of this matrix are restored on exit. that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M,N)-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the scalar factor array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00737">737</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ab607ab80bd81fbd558796b0ddfd81464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::mult_rz_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a general matrix by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Z**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix <code>c</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix <code>c</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>The number of columns in matrix <code>a</code> containing the meaningful part of the Householder vectors (M &gt;= L &gt;= 0). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-M matrix Z as output by <code>rz_factor</code>. The matrix is used as in-place storage during execution; however, the contents of the matrix are restored on exit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>An M-element array containing the scalar factors of the elementary reflectors found in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Z and the original matrix C. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00969">969</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a6d0c1703806a14d1134f49f54da9804d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::qr_factor_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR factorization of an M-by-N matrix without pivoting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the scalar factor array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00553">553</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a17a1157b047a3e01fbefd9e6752e16ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::qr_factor_pivot_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the QR factorization of an M-by-N matrix with column pivoting such that A * P = Q * R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">jpvt</td><td>On input, an N-element array that if JPVT(I) .ne. 0, the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th column of A is a free column. On output, if JPVT(I) = K, then the I-th column of A * P was the K-th column of A. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the scalar factor array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00598">598</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a615376486e6389f090a77180d31d1023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::qr_rank1_update_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(inout)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>On input, the original M-by-M orthogonal matrix Q. On output, the updated matrix Q1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the M-by-N matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the M-element U update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>On input, the N-element V update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00778">778</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad166279ad4bef86d67195c4854f3f8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::rank1_update_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m), intent(in)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the rank-1 update to matrix A such that: A = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar, X is an M-element array, and N is an N-element array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of elements in <code>x</code>, and the number of rows in matrix <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in <code>y</code>, and the number of columns in matrix <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An M-element array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>An N-element array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to update. On output, the updated M-by-N matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine is based upon the BLAS routine DGER. </dd></dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00294">294</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a86b99d65f92e5762fbb05ddc707fb715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::rz_factor_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factors an upper trapezoidal matrix by means of orthogonal transformations such that A = R * Z = (R 0) * Z. Z is an orthogonal matrix of dimension N-by-N, and R is an M-by-M upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N upper trapezoidal matrix to factor. On output, the leading M-by-M upper triangular part of the matrix contains the upper triangular matrix R, and elements N-L+1 to N of the first M rows of A, with the array <code>tau</code>, represent the orthogonal matrix Z as a product of M elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>An M-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00927">927</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2a796d25715839cd4fb664bcd65dc59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_cholesky_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of Cholesky factored equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>Set to true if the original matrix A was factored such that A = U**T * U; else, set to false if the factorization of A was A = L**T * L. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the original matrix <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The N-by-N Cholesky factored matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>On input, the N-by-NRHS right-hand-side matrix B. On output, the solution matrix X. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01190">1190</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a8e2d6deef9e1c13fe9b2ea8288b57b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_least_squares_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m, n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(max(m,n), nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the overdetermined or underdetermined system (A*X = B) of M equations of N unknowns using a QR or LQ factorization of the matrix A. Notice, it is assumed that matrix A has full rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix A. On output, the matrix is overwritten by the details of its complete orthogonal factorization. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>If M &gt;= N, the M-by-NRHS matrix B. On output, the first N rows contain the N-by-NRHS solution matrix X. If M &lt; N, an N-by-NRHS matrix with the first M rows containing the matrix B. On output, the N-by-NRHS solution matrix X. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01292">1292</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a1d36f2bdcc9def21fcd3657bed2f736f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_lu_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of LU-factored equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the original matrix <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The N-by-N LU factored matrix as output by lu_factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipvt</td><td>The N-element pivot array as output by lu_factor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>On input, the N-by-NRHS right-hand-side matrix. On output, the N-by-NRHS solution matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01079">1079</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2afad66bd793711f301bd471c9978165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_qr_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of M QR-factored equations of N unknowns where M &gt;= N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. Notice, M must be greater than or equal to N. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>On input, the M-by-NRHS right-hand-side matrix. On output, the first N columns are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01112">1112</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a2410c7071c72c513ec53a10374ffb456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_qr_pivot_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(max(m,n),nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of M QR-factored equations of N unknowns where the QR factorization made use of column pivoting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original coefficient matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are altered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jpvt</td><td>An N-element array, as output by qr_factor, used to track the column pivots. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>On input, the MAX(M, N)-by-NRHS matrix where the first M rows contain the right-hand-side matrix B. On output, the first N rows are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01157">1157</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="abc91f7afbf731b7a9219a31aa067065d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::solve_tri_mtx_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>nounit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), intent(in), value&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,nrhs), intent(inout)&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves one of the matrix equations: op(A) * X = alpha * B, where A is a triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>Set to true if A is an upper triangular matrix; else, set to false if A is a lower triangular matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true if op(A) = A**T; else, set to false if op(A) = A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nounit</td><td>Set to true if A is not a unit-diagonal matrix (ones on every diagonal element); else, set to false if A is a unit-diagonal matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The dimension of the triangular matrix <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>The number of right-hand-side vectors (number of columns in matrix <code>b</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar multiplier to B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>N-by-N triangular matrix on which to operate. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>On input, the N-by-NRHS right-hand-side. On output, the N-by-NRHS solution. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01056">1056</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a0852ae5393707d83c4680db3d0402d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::sort_cmplx_ind_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr), intent(in), value&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an array of complex values according to their real components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascend</td><td>Set to true to sort in ascending order; else, false to sort in descending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>On input, the N-element array to sort. On output, the sorted array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>On input, a pointer to an integer array. If NULL, this argument is ignored, and <code>x</code> is sorted as expected. However, if used, on output, the contents of this array are shifted in the same order as that of <code>x</code> as a means of tracking the sorting operation. It is often useful to set this array to an ascending group of values (1, 2, ... n) such that this array tracks the original positions of the sorted array. Such an array can then be used to align other arrays. This array must be the same size as <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01495">1495</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a49418a380de6dd1d6bf3f84d3d9e4281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::sort_dbl_ind_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr), intent(in), value&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an array of double-precision values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascend</td><td>Set to true to sort in ascending order; else, false to sort in descending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>On input, the N-element array to sort. On output, the sorted array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ind</td><td>On input, a pointer to an integer array. If NULL, this argument is ignored, and <code>x</code> is sorted as expected. However, if used, on output, the contents of this array are shifted in the same order as that of <code>x</code> as a means of tracking the sorting operation. It is often useful to set this array to an ascending group of values (1, 2, ... n) such that this array tracks the original positions of the sorted array. Such an array can then be used to align other arrays. This array must be the same size as <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01459">1459</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a77f56be6e707720d8159f91db6faa935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::sort_eigen_cmplx_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascend</td><td>Set to true to sort in ascending order; else, false to sort in descending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of eigenvalues. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vals</td><td>On input, an N-element array containing the eigenvalues. On output, the sorted eigenvalues. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vecs</td><td>On input, an N-by-N matrix containing the eigenvectors associated with <code>vals</code> (one vector per column). On output, the sorted eigenvector matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01527">1527</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ab3e02da095c23d13fe0be9377d1ef8ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::sort_eigen_dbl_c </td>
          <td>(</td>
          <td class="paramtype">logical(c_bool), intent(in), value&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(inout)&#160;</td>
          <td class="paramname"><em>vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascend</td><td>Set to true to sort in ascending order; else, false to sort in descending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of eigenvalues. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vals</td><td>On input, an N-element array containing the eigenvalues. On output, the sorted eigenvalues. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vecs</td><td>On input, an N-by-N matrix containing the eigenvectors associated with <code>vals</code> (one vector per column). On output, the sorted eigenvector matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01550">1550</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a3a7e5b8578d1128fac969935798c0a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::svd_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(min(m,n)), intent(out)&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,m), intent(out)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(errorhandler), intent(inout)&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition of a matrix A. The SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the original matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the original matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. The matrix is overwritten on output. that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>A MIN(M, N)-element array containing the singular values of <code>a</code> sorted in descending order. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>An M-by-M matrix that on output contains the left singular vectors (matrix U in the decomposition: A = U * S * V**T) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>An N-by-N matrix that on output contains the right singular vectors (matrix V**T in the decomposition: A = U * S * V**T). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">err</td><td>The errorhandler object. If no error handling is desired, simply pass NULL, and errors will be dealt with by the default internal error handler. Possible errors that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if the singular value array is not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l01016">1016</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad8585a8b92cfc6f1b2dc10028c5e3a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_c_binding::swap_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(n), intent(inout)&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements either array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>One of the N-element arrays. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>The other N-element array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00399">399</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a359a0b386de6e6e0a8bea2aa5df08fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure real(dp) function linalg_c_binding::trace_c </td>
          <td>(</td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in), value&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(m,n), intent(in)&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the trace of a matrix (the sum of the main diagonal elements). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The matrix on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The trace of <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="linalg__c__binding_8f90_source.html#l00314">314</a> of file <a class="el" href="linalg__c__binding_8f90_source.html">linalg_c_binding.f90</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelinalg__c__binding.html">linalg_c_binding</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
