<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linalg: linalg_factor Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linalg
   &#160;<span id="projectnumber">1.4.3</span>
   </div>
   <div id="projectbrief">A linear algebra library that provides a user-friendly interface to several BLAS and LAPACK routines.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacelinalg__factor.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">linalg_factor Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b><a class="el" href="namespacelinalg__factor.html" title="linalg_factor ">linalg_factor</a></b>  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacelinalg__factor_1_1form__lu.html">form_lu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the L and U matrices from the condensed [L\U] storage format used by the <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a>.  <a href="interfacelinalg__factor_1_1form__lu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacelinalg__factor_1_1form__qr.html">form_qr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.  <a href="interfacelinalg__factor_1_1form__qr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacelinalg__factor_1_1mult__qr.html">mult_qr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Q from a QR factorization.  <a href="interfacelinalg__factor_1_1mult__qr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacelinalg__factor_1_1mult__rz.html">mult_rz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Z from an RZ factorization.  <a href="interfacelinalg__factor_1_1mult__rz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacelinalg__factor_1_1qr__factor.html">qr_factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR factorization of an M-by-N matrix.  <a href="interfacelinalg__factor_1_1qr__factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a3714624ab99aff29de340cb03b40a336"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a> (a, ipvt, err)</td></tr>
<tr class="memdesc:a3714624ab99aff29de340cb03b40a336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LU factorization of an M-by-N matrix.  <a href="#a3714624ab99aff29de340cb03b40a336">More...</a><br /></td></tr>
<tr class="separator:a3714624ab99aff29de340cb03b40a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cc1d3bf1096f1d5670f0fc5d005021"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#ac2cc1d3bf1096f1d5670f0fc5d005021">form_lu_all</a> (lu, ipvt, u, p, err)</td></tr>
<tr class="memdesc:ac2cc1d3bf1096f1d5670f0fc5d005021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the L, U, and P matrices from the output of the <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a> routine.  <a href="#ac2cc1d3bf1096f1d5670f0fc5d005021">More...</a><br /></td></tr>
<tr class="separator:ac2cc1d3bf1096f1d5670f0fc5d005021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879569820095bb3a668feb18b0203fc2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a879569820095bb3a668feb18b0203fc2">form_lu_only</a> (lu, u, err)</td></tr>
<tr class="memdesc:a879569820095bb3a668feb18b0203fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the L, and U matrices from the output of the <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a> routine.  <a href="#a879569820095bb3a668feb18b0203fc2">More...</a><br /></td></tr>
<tr class="separator:a879569820095bb3a668feb18b0203fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8354cee69f1a135aa76087c1cf466437"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a8354cee69f1a135aa76087c1cf466437">qr_factor_no_pivot</a> (a, tau, work, olwork, err)</td></tr>
<tr class="memdesc:a8354cee69f1a135aa76087c1cf466437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR factorization of an M-by-N matrix without pivoting.  <a href="#a8354cee69f1a135aa76087c1cf466437">More...</a><br /></td></tr>
<tr class="separator:a8354cee69f1a135aa76087c1cf466437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3904ef2ef10819f3e97272ea3db7c835"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a3904ef2ef10819f3e97272ea3db7c835">qr_factor_pivot</a> (a, tau, jpvt, work, olwork, err)</td></tr>
<tr class="memdesc:a3904ef2ef10819f3e97272ea3db7c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the QR factorization of an M-by-N matrix with column pivoting such that A * P = Q * R.  <a href="#a3904ef2ef10819f3e97272ea3db7c835">More...</a><br /></td></tr>
<tr class="separator:a3904ef2ef10819f3e97272ea3db7c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b39ee0a10a41749297ea47532256f46"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a0b39ee0a10a41749297ea47532256f46">form_qr_no_pivot</a> (r, tau, q, work, olwork, err)</td></tr>
<tr class="memdesc:a0b39ee0a10a41749297ea47532256f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.  <a href="#a0b39ee0a10a41749297ea47532256f46">More...</a><br /></td></tr>
<tr class="separator:a0b39ee0a10a41749297ea47532256f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc8168f02a2948f384dae8fff08612"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a6efc8168f02a2948f384dae8fff08612">form_qr_pivot</a> (r, tau, pvt, q, p, work, olwork, err)</td></tr>
<tr class="memdesc:a6efc8168f02a2948f384dae8fff08612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.  <a href="#a6efc8168f02a2948f384dae8fff08612">More...</a><br /></td></tr>
<tr class="separator:a6efc8168f02a2948f384dae8fff08612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9f2e6c259d21729ef7eacde53950a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#af1d9f2e6c259d21729ef7eacde53950a">mult_qr_mtx</a> (lside, trans, a, tau, c, work, olwork, err)</td></tr>
<tr class="memdesc:af1d9f2e6c259d21729ef7eacde53950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C, or C = C * op(Q).  <a href="#af1d9f2e6c259d21729ef7eacde53950a">More...</a><br /></td></tr>
<tr class="separator:af1d9f2e6c259d21729ef7eacde53950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ecb97cedb85bb914098a46c7eb349d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#af5ecb97cedb85bb914098a46c7eb349d">mult_qr_vec</a> (trans, a, tau, c, work, olwork, err)</td></tr>
<tr class="memdesc:af5ecb97cedb85bb914098a46c7eb349d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C.  <a href="#af5ecb97cedb85bb914098a46c7eb349d">More...</a><br /></td></tr>
<tr class="separator:af5ecb97cedb85bb914098a46c7eb349d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0af1fa85462f638b170dd2b97afee9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a3a0af1fa85462f638b170dd2b97afee9">qr_rank1_update</a> (q, r, u, v, work, err)</td></tr>
<tr class="memdesc:a3a0af1fa85462f638b170dd2b97afee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1.  <a href="#a3a0af1fa85462f638b170dd2b97afee9">More...</a><br /></td></tr>
<tr class="separator:a3a0af1fa85462f638b170dd2b97afee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d305330e931c62fc215a6de269f849"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a55d305330e931c62fc215a6de269f849">cholesky_factor</a> (a, upper, err)</td></tr>
<tr class="memdesc:a55d305330e931c62fc215a6de269f849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cholesky factorization of a symmetric, positive definite matrix.  <a href="#a55d305330e931c62fc215a6de269f849">More...</a><br /></td></tr>
<tr class="separator:a55d305330e931c62fc215a6de269f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674d54ea841bd6f95bc8a93ba6e6144"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a5674d54ea841bd6f95bc8a93ba6e6144">cholesky_rank1_update</a> (r, u, work, err)</td></tr>
<tr class="memdesc:a5674d54ea841bd6f95bc8a93ba6e6144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 update to a Cholesky factored matrix (upper triangular).  <a href="#a5674d54ea841bd6f95bc8a93ba6e6144">More...</a><br /></td></tr>
<tr class="separator:a5674d54ea841bd6f95bc8a93ba6e6144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95ae27bc625c23901304680105270f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a3c95ae27bc625c23901304680105270f">cholesky_rank1_downdate</a> (r, u, work, err)</td></tr>
<tr class="memdesc:a3c95ae27bc625c23901304680105270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular).  <a href="#a3c95ae27bc625c23901304680105270f">More...</a><br /></td></tr>
<tr class="separator:a3c95ae27bc625c23901304680105270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27cc026c0b8092eed7e79c135847674"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#aa27cc026c0b8092eed7e79c135847674">rz_factor</a> (a, tau, work, olwork, err)</td></tr>
<tr class="memdesc:aa27cc026c0b8092eed7e79c135847674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors an upper trapezoidal matrix by means of orthogonal transformations such that A = R * Z = (R 0) * Z. Z is an orthogonal matrix of dimension N-by-N, and R is an M-by-M upper triangular matrix.  <a href="#aa27cc026c0b8092eed7e79c135847674">More...</a><br /></td></tr>
<tr class="separator:aa27cc026c0b8092eed7e79c135847674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd1af0971a46b569c9eaf7132413d4a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a9dd1af0971a46b569c9eaf7132413d4a">mult_rz_mtx</a> (lside, trans, l, a, tau, c, work, olwork, err)</td></tr>
<tr class="memdesc:a9dd1af0971a46b569c9eaf7132413d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a general matrix by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C, or C = C * op(Z).  <a href="#a9dd1af0971a46b569c9eaf7132413d4a">More...</a><br /></td></tr>
<tr class="separator:a9dd1af0971a46b569c9eaf7132413d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141c1e9171f3a39f9f6567288853459b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a141c1e9171f3a39f9f6567288853459b">mult_rz_vec</a> (trans, l, a, tau, c, work, olwork, err)</td></tr>
<tr class="memdesc:a141c1e9171f3a39f9f6567288853459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C.  <a href="#a141c1e9171f3a39f9f6567288853459b">More...</a><br /></td></tr>
<tr class="separator:a141c1e9171f3a39f9f6567288853459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4743b118b731d2323f27994ab6ff4"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinalg__factor.html#a69c4743b118b731d2323f27994ab6ff4">svd</a> (a, s, u, vt, work, olwork, err)</td></tr>
<tr class="memdesc:a69c4743b118b731d2323f27994ab6ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of a matrix A. The SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal matrix.  <a href="#a69c4743b118b731d2323f27994ab6ff4">More...</a><br /></td></tr>
<tr class="separator:a69c4743b118b731d2323f27994ab6ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b><a class="el" href="namespacelinalg__factor.html" title="linalg_factor ">linalg_factor</a></b> </p>
<dl class="section user"><dt>Purpose</dt><dd>Provides a set of matrix factorization routines. </dd></dl>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a55d305330e931c62fc215a6de269f849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d305330e931c62fc215a6de269f849">&#9670;&nbsp;</a></span>cholesky_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Cholesky factorization of a symmetric, positive definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the N-by-N matrix to factor. On output, the factored matrix is returned in either the upper or lower triangular portion of the matrix, dependent upon the value of <code>upper</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>An optional input that, if specified, provides control over whether the factorization is computed as A = U**T * U (set to true), or as A = L * L**T (set to false). The default value is true such that A = U**T * U. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if <code>a</code> is not square.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if <code>a</code> is not positive definite.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates the solution of a positive-definite system of equations via Cholesky factorization. <div class="fragment"><div class="line"><span class="keyword">program</span> example</div><div class="line">    <span class="keywordtype">use </span>iso_fortran_env, <span class="keywordtype">only</span> : real64, int32</div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__factor.html">linalg_factor</a>, <span class="keywordtype">only</span> : cholesky_factor</div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__solve.html">linalg_solve</a>, <span class="keywordtype">only</span> : <a class="code" href="interfacelinalg__solve_1_1solve__cholesky.html">solve_cholesky</a>, <a class="code" href="interfacelinalg__solve_1_1solve__triangular__system.html">solve_triangular_system</a></div><div class="line">    <span class="keywordtype">implicit none</span></div><div class="line"></div><div class="line">    <span class="comment">! Variables</span></div><div class="line">    <span class="keywordtype">real(real64)</span> :: a(3, 3), b(3), bu(3)</div><div class="line">    <span class="keywordtype">integer(int32)</span> :: i</div><div class="line"></div><div class="line">    <span class="comment">! Build the 3-by-3 positive-definite matrix A.</span></div><div class="line">    <span class="comment">!     | 4   12   -16 |</span></div><div class="line">    <span class="comment">! A = | 12  37   -43 |</span></div><div class="line">    <span class="comment">!     |-16 -43    98 |</span></div><div class="line">    a = reshape([4.0d0, 12.0d0, -16.0d0, 12.0d0, 37.0d0, -43.0d0, -16.0d0, &amp;</div><div class="line">        -43.0d0, 98.0d0], [3, 3])</div><div class="line"></div><div class="line">    <span class="comment">! Build the 3-element array B</span></div><div class="line">    <span class="comment">!     | 5 |</span></div><div class="line">    <span class="comment">! b = | 1 |</span></div><div class="line">    <span class="comment">!     | 3 |</span></div><div class="line">    b = [5.0d0, 1.0d0, 3.0d0]</div><div class="line"></div><div class="line">    <span class="comment">! Make a copy of B for later use - not necessary, but just for example to</span></div><div class="line">    <span class="comment">! illustrate the long or manual method of solving a Cholesky factored system</span></div><div class="line">    bu = b</div><div class="line"></div><div class="line">    <span class="comment">! Compute the Cholesky factorization of A considering only the upper </span></div><div class="line">    <span class="comment">! triangular portion of A (the default configuration).</span></div><div class="line">    <span class="keyword">call </span>cholesky_factor(a)</div><div class="line"></div><div class="line">    <span class="comment">! Compute the solution</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__solve_1_1solve__cholesky.html">solve_cholesky</a>(.true., a, b)</div><div class="line"></div><div class="line">    <span class="comment">! Display the results</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Cholesky Solution: X = &quot;</span></div><div class="line">    print <span class="stringliteral">&#39;(F8.4)&#39;</span>, (b(i), i = 1, <span class="keyword">size</span>(b))</div><div class="line"></div><div class="line">    <span class="comment">! The solution could also be computed manually noting the Cholesky </span></div><div class="line">    <span class="comment">! factorization causes A = U**T * U.  Then U**T * U * X = B.  </span></div><div class="line"></div><div class="line">    <span class="comment">! Step 1 would then be to solve the problem U**T * Y = B, for Y.</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__solve_1_1solve__triangular__system.html">solve_triangular_system</a>(.true., .true., .true., a, bu)</div><div class="line"></div><div class="line">    <span class="comment">! Now, solve the problem U * X = Y, for X</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__solve_1_1solve__triangular__system.html">solve_triangular_system</a>(.true., .false., .true., a, bu)</div><div class="line"></div><div class="line">    <span class="comment">! Display the results</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Cholesky Solution (Manual Approach): X = &quot;</span></div><div class="line">    print <span class="stringliteral">&#39;(F8.4)&#39;</span>, (bu(i), i = 1, <span class="keyword">size</span>(bu))</div><div class="line"><span class="keyword">end program</span></div></div><!-- fragment --> The above program produces the following output. <div class="fragment"><div class="line">Cholesky Solution: X =</div><div class="line"> 239.5833</div><div class="line"> -65.6667</div><div class="line"> 10.3333</div><div class="line">Cholesky Solution (Manual Approach): X =</div><div class="line"> 239.5833</div><div class="line"> -65.6667</div><div class="line"> 10.3333</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DPOTRF. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01631">1631</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a3c95ae27bc625c23901304680105270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c95ae27bc625c23901304680105270f">&#9670;&nbsp;</a></span>cholesky_rank1_downdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::cholesky_rank1_downdate </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional argument that if supplied prevents local memory allocation. If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation cosines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not positive definite.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs if <code>r</code> is singular.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the QRUPDATE routine DCH1DN.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><a href="https://sourceforge.net/projects/qrupdate/">Source</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01817">1817</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a5674d54ea841bd6f95bc8a93ba6e6144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674d54ea841bd6f95bc8a93ba6e6144">&#9670;&nbsp;</a></span>cholesky_rank1_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::cholesky_rank1_update </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 update to a Cholesky factored matrix (upper triangular). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional argument that if supplied prevents local memory allocation. If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation cosines used to transform R to R1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the QRUPDATE routine DCH1UP.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><a href="https://sourceforge.net/projects/qrupdate/">Source</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01723">1723</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="ac2cc1d3bf1096f1d5670f0fc5d005021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cc1d3bf1096f1d5670f0fc5d005021">&#9670;&nbsp;</a></span>form_lu_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::form_lu_all </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the L, U, and P matrices from the output of the <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a> routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lu</td><td>On input, the N-by-N matrix as output by <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a>. On output, the N-by-N lower triangular matrix L. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipvt</td><td>The N-element pivot array as output by <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>An N-by-N matrix where the U matrix will be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An N-by-N matrix where the row permutation matrix will be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Remarks</dt><dd>This routine allows extraction of the actual "L", "U", and "P" matrices of the decomposition. To use these matrices to solve the system A*X = B, the following approach is used.</dd></dl>
<ol type="1">
<li>First, solve the linear system: L*Y = P*B for Y.</li>
<li>Second, solve the linear system: U*X = Y for X.</li>
</ol>
<p>Notice, as both L and U are triangular in structure, the above equations can be solved by forward and backward substitution.</p>
<dl class="section user"><dt>See Also</dt><dd><ul>
<li><a href="https://en.wikipedia.org/wiki/LU_decomposition">Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/LUDecomposition.html">Wolfram MathWorld</a> </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00497">497</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a879569820095bb3a668feb18b0203fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879569820095bb3a668feb18b0203fc2">&#9670;&nbsp;</a></span>form_lu_only()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::form_lu_only </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the L, and U matrices from the output of the <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a> routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lu</td><td>On input, the N-by-N matrix as output by <a class="el" href="namespacelinalg__factor.html#a3714624ab99aff29de340cb03b40a336">lu_factor</a>. On output, the N-by-N lower triangular matrix L. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>An N-by-N matrix where the U matrix will be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00574">574</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a0b39ee0a10a41749297ea47532256f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b39ee0a10a41749297ea47532256f46">&#9670;&nbsp;</a></span>form_qr_no_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::form_qr_no_pivot </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, an M-by-N matrix where the elements below the diagonal contain the elementary reflectors generated from the QR factorization. On and above the diagonal, the matrix contains the matrix R. On output, the elements below the diagonal are zeroed such that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>An M-by-M matrix where the full orthogonal matrix Q will be written. In the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DORGQR. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00881">881</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a6efc8168f02a2948f384dae8fff08612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efc8168f02a2948f384dae8fff08612">&#9670;&nbsp;</a></span>form_qr_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::form_qr_pivot </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>pvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out)&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, an M-by-N matrix where the elements below the diagonal contain the elementary reflectors generated from the QR factorization. On and above the diagonal, the matrix contains the matrix R. On output, the elements below the diagonal are zeroed such that the remaining matrix is simply the M-by-N matrix R. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvt</td><td>An N-element column pivot array as returned by the QR factorization. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>An M-by-M matrix where the full orthogonal matrix Q will be written. In the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>An N-by-N matrix where the pivot matrix will be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DORGQR. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01012">1012</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a3714624ab99aff29de340cb03b40a336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3714624ab99aff29de340cb03b40a336">&#9670;&nbsp;</a></span>lu_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::lu_factor </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LU factorization of an M-by-N matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix on which to operate. On output, the LU factored matrix in the form [L\U] where the unit diagonal elements of L are not stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipvt</td><td>An MIN(M, N)-element array used to track row-pivot operations. The array stored pivot information such that row I is interchanged with row IPVT(I). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if <code>ipvt</code> is not sized appropriately.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if <code>a</code> is found to be singular.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>To solve a system of 3 equations of 3 unknowns using LU factorization, the following code will suffice. <div class="fragment"><div class="line"><span class="keyword">program</span> example</div><div class="line">    <span class="keywordtype">use </span>iso_fortran_env</div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__factor.html">linalg_factor</a>, <span class="keywordtype">only</span> : lu_factor</div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__solve.html">linalg_solve</a>, <span class="keywordtype">only</span> : <a class="code" href="interfacelinalg__solve_1_1solve__lu.html">solve_lu</a></div><div class="line">    <span class="keywordtype">implicit none</span></div><div class="line"></div><div class="line">    <span class="comment">! Local Variables</span></div><div class="line">    <span class="keywordtype">real(real64)</span> :: a(3,3), b(3)</div><div class="line">    <span class="keywordtype">integer(int32)</span> :: i, pvt(3)</div><div class="line"></div><div class="line">    <span class="comment">! Build the 3-by-3 matrix A.</span></div><div class="line">    <span class="comment">!     | 1   2   3 |</span></div><div class="line">    <span class="comment">! A = | 4   5   6 |</span></div><div class="line">    <span class="comment">!     | 7   8   0 |</span></div><div class="line">    a = reshape( &amp;</div><div class="line">        [1.0d0, 4.0d0, 7.0d0, 2.0d0, 5.0d0, 8.0d0, 3.0d0, 6.0d0, 0.0d0], &amp;</div><div class="line">        [3, 3])</div><div class="line"></div><div class="line">    <span class="comment">! Build the right-hand-side vector B.</span></div><div class="line">    <span class="comment">!     | -1 |</span></div><div class="line">    <span class="comment">! b = | -2 |</span></div><div class="line">    <span class="comment">!     | -3 |</span></div><div class="line">    b = [-1.0d0, -2.0d0, -3.0d0]</div><div class="line"></div><div class="line">    <span class="comment">! The solution is:</span></div><div class="line">    <span class="comment">!     |  1/3 |</span></div><div class="line">    <span class="comment">! x = | -2/3 |</span></div><div class="line">    <span class="comment">!     |   0  |</span></div><div class="line"></div><div class="line">    <span class="comment">! Compute the LU factorization</span></div><div class="line">    <span class="keyword">call </span>lu_factor(a, pvt)</div><div class="line"></div><div class="line">    <span class="comment">! Compute the solution.  The results overwrite b.</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__solve_1_1solve__lu.html">solve_lu</a>(a, pvt, b)</div><div class="line"></div><div class="line">    <span class="comment">! Display the results.</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;LU Solution: X = &quot;</span></div><div class="line">    print <span class="stringliteral">&#39;(F8.4)&#39;</span>, (b(i), i = 1, <span class="keyword">size</span>(b))</div><div class="line"><span class="keyword">end program</span></div></div><!-- fragment --> The program generates the following output. <div class="fragment"><div class="line">LU Solution: X =</div><div class="line"> 0.3333</div><div class="line">-0.6667</div><div class="line"> 0.0000</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DGETRF.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><ul>
<li><a href="https://en.wikipedia.org/wiki/LU_decomposition">Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/LUDecomposition.html">Wolfram MathWorld</a> </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00413">413</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="af1d9f2e6c259d21729ef7eacde53950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d9f2e6c259d21729ef7eacde53950a">&#9670;&nbsp;</a></span>mult_qr_mtx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::mult_qr_mtx </td>
          <td>(</td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C, or C = C * op(Q). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lside</td><td>Set to true to apply Q or Q**T from the left; else, set to false to apply Q or Q**T from the right. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Q**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>On input, an LDA-by-K matrix containing the elementary reflectors output from the QR factorization. If <code>lside</code> is set to true, LDA = M, and M &gt;= K &gt;= 0; else, if <code>lside</code> is set to false, LDA = N, and N &gt;= K &gt;= 0. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DORMQR. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01114">1114</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="af5ecb97cedb85bb914098a46c7eb349d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ecb97cedb85bb914098a46c7eb349d">&#9670;&nbsp;</a></span>mult_qr_vec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::mult_qr_vec </td>
          <td>(</td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a vector by the orthogonal matrix Q from a QR factorization such that: C = op(Q) * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Q**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>On input, an M-by-K matrix containing the elementary reflectors output from the QR factorization. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-element vector C. On output, the product of the orthogonal matrix Q and the original vector C. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine is based upon the LAPACK routine DORM2R. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01241">1241</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a9dd1af0971a46b569c9eaf7132413d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd1af0971a46b569c9eaf7132413d4a">&#9670;&nbsp;</a></span>mult_rz_mtx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::mult_rz_mtx </td>
          <td>(</td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in)&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a general matrix by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C, or C = C * op(Z). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lside</td><td>Set to true to apply Z or Z**T from the left; else, set to false to apply Z or Z**T from the right. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Z**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>The number of columns in matrix <code>a</code> containing the meaningful part of the Householder vectors. If <code>lside</code> is true, M &gt;= L &gt;= 0; else, if <code>lside</code> is false, N &gt;= L &gt;= 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input the K-by-LTA matrix Z, where LTA = M if <code>lside</code> is true; else, LTA = N if <code>lside</code> is false. The I-th row must contain the Householder vector in the last k rows. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A K-element array containing the scalar factors of the elementary reflectors, where M &gt;= K &gt;= 0 if <code>lside</code> is true; else, N &gt;= K &gt;= 0 if <code>lside</code> is false. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Z and the original matrix C. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DORMRZ. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l02068">2068</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a141c1e9171f3a39f9f6567288853459b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141c1e9171f3a39f9f6567288853459b">&#9670;&nbsp;</a></span>mult_rz_vec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::mult_rz_vec </td>
          <td>(</td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(in)&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a vector by the orthogonal matrix Z from an RZ factorization such that: C = op(Z) * C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Set to true to apply Z**T; else, set to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>The number of columns in matrix <code>a</code> containing the meaningful part of the Householder vectors. If <code>lside</code> is true, M &gt;= L &gt;= 0; else, if <code>lside</code> is false, N &gt;= L &gt;= 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input the K-by-LTA matrix Z, where LTA = M if <code>lside</code> is true; else, LTA = N if <code>lside</code> is false. The I-th row must contain the Householder vector in the last k rows. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>A K-element array containing the scalar factors of the elementary reflectors, where M &gt;= K &gt;= 0 if <code>lside</code> is true; else, N &gt;= K &gt;= 0 if <code>lside</code> is false. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>On input, the M-element array C. On output, the product of the orthogonal matrix Z and the original array C. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DORMRZ. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l02210">2210</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a8354cee69f1a135aa76087c1cf466437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8354cee69f1a135aa76087c1cf466437">&#9670;&nbsp;</a></span>qr_factor_no_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::qr_factor_no_pivot </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the QR factorization of an M-by-N matrix without pivoting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if <code>tau</code> or <code>work</code> are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>QR factorization without pivoting is best suited to solving an overdetermined system in least-squares terms, or to solve a normally defined system. To solve an underdetermined system, it is recommended to use either LQ factorization, or a column-pivoting based QR factorization.</dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DGEQRF. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00663">663</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a3904ef2ef10819f3e97272ea3db7c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3904ef2ef10819f3e97272ea3db7c835">&#9670;&nbsp;</a></span>qr_factor_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine linalg_factor::qr_factor_pivot </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the QR factorization of an M-by-N matrix with column pivoting such that A * P = Q * R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">jpvt</td><td>On input, an N-element array that if JPVT(I) .ne. 0, the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th column of A is a free column. On output, if JPVT(I) = K, then the I-th column of A * P was the K-th column of A. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DGEQP3. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l00766">766</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a3a0af1fa85462f638b170dd2b97afee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0af1fa85462f638b170dd2b97afee9">&#9670;&nbsp;</a></span>qr_rank1_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::qr_rank1_update </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>On input, the original M-by-K orthogonal matrix Q. On output, the updated matrix Q1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>On input, the M-by-N matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>On input, the M-element U update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>On input, the N-element V update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional argument that if supplied prevents local memory allocation. If provided, the array must have at least 2*K elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Remarks</dt><dd><pre class="fragment"> Notice, K must either be equal to M, or to N.  In the event that K = N,
 only the submatrix Qa is updated.  This is appropriate as the QR
 factorization for an overdetermined system can be written as follows:
  A = Q * R = [Qa, Qb] * [Ra]
                         [0 ]

 Note: Ra is upper triangular of dimension N-by-N.</pre></dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates a rank 1 update to a QR factored system. The results are compared to updating the original matrix, and then performing the factorization. <div class="fragment"><div class="line"><span class="keyword">program</span> example</div><div class="line">    <span class="keywordtype">use </span>iso_fortran_env</div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__factor.html">linalg_factor</a></div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__solve.html">linalg_solve</a></div><div class="line">    <span class="keywordtype">use </span><a class="code" href="namespacelinalg__core.html">linalg_core</a></div><div class="line">    <span class="keywordtype">implicit none</span></div><div class="line"></div><div class="line">    <span class="comment">! Variables</span></div><div class="line">    <span class="keywordtype">real(real64)</span> :: a(3,3), u(3), v(3), r(3,3), tau(3), q(3,3), qu(3,3)</div><div class="line">    <span class="keywordtype">integer(int32)</span> :: i</div><div class="line"></div><div class="line">    <span class="comment">! Build the 3-by-3 matrix A.</span></div><div class="line">    <span class="comment">!     | 1   2   3 |</span></div><div class="line">    <span class="comment">! A = | 4   5   6 |</span></div><div class="line">    <span class="comment">!     | 7   8   0 |</span></div><div class="line">    a = reshape( &amp;</div><div class="line">        [1.0d0, 4.0d0, 7.0d0, 2.0d0, 5.0d0, 8.0d0, 3.0d0, 6.0d0, 0.0d0], &amp;</div><div class="line">        [3, 3])</div><div class="line"></div><div class="line">    <span class="comment">! Build the update vectors</span></div><div class="line">    <span class="comment">!     | 1/2 |      | 1 |</span></div><div class="line">    <span class="comment">! u = | 3/2 |, v = | 5 |</span></div><div class="line">    <span class="comment">!     |  3  |      | 2 |</span></div><div class="line">    u = [0.5d0, 1.5d0, 3.0d0]</div><div class="line">    v = [1.0d0, 5.0d0, 2.0d0]</div><div class="line"></div><div class="line">    <span class="comment">! Compute the QR factorization of the original matrix</span></div><div class="line">    r = a   <span class="comment">! Making a copy as the matrix will be overwritten by qr_factor</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__factor_1_1qr__factor.html">qr_factor</a>(r, tau)</div><div class="line"></div><div class="line">    <span class="comment">! Form Q &amp; R</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__factor_1_1form__qr.html">form_qr</a>(r, tau, q)</div><div class="line"></div><div class="line">    <span class="comment">! Compute the rank 1 update to the original matrix such that: </span></div><div class="line">    <span class="comment">! A = A + u * v**T</span></div><div class="line">    <span class="keyword">call </span>rank1_update(1.0d0, u, v, a)</div><div class="line"></div><div class="line">    <span class="comment">! Compute the rank 1 update to the factorization.  Notice, the contents </span></div><div class="line">    <span class="comment">! of U &amp; V are destroyed as part of this process.</span></div><div class="line">    <span class="keyword">call </span>qr_rank1_update(q, r, u, v)</div><div class="line"></div><div class="line">    <span class="comment">! As comparison, compute the QR factorization of the rank 1 updated matrix</span></div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__factor_1_1qr__factor.html">qr_factor</a>(a, tau)</div><div class="line">    <span class="keyword">call </span><a class="code" href="interfacelinalg__factor_1_1form__qr.html">form_qr</a>(a, tau, qu)</div><div class="line"></div><div class="line">    <span class="comment">! Display the matrices</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Updating the Factored Form:&quot;</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Q = &quot;</span></div><div class="line">    <span class="keywordflow">do</span> i = 1, <span class="keyword">size</span>(q, 1)</div><div class="line">        print *, q(i,:)</div><div class="line"><span class="keywordflow">    end do</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;R = &quot;</span></div><div class="line">    <span class="keywordflow">do</span> i = 1, <span class="keyword">size</span>(r, 1)</div><div class="line">        print *, r(i,:)</div><div class="line"><span class="keywordflow">    end do</span></div><div class="line"></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Updating A Directly:&quot;</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;Q = &quot;</span></div><div class="line">    <span class="keywordflow">do</span> i = 1, <span class="keyword">size</span>(qu, 1)</div><div class="line">        print *, qu(i,:)</div><div class="line"><span class="keywordflow">    end do</span></div><div class="line">    print <span class="stringliteral">&#39;(A)&#39;</span>, <span class="stringliteral">&quot;R = &quot;</span></div><div class="line">    <span class="keywordflow">do</span> i = 1, <span class="keyword">size</span>(a, 1)</div><div class="line">        print *, a(i,:)</div><div class="line"><span class="keywordflow">    end do</span></div><div class="line"><span class="keyword">end program </span></div></div><!-- fragment --> The above program produces the following output. <div class="fragment"><div class="line">Updating the Factored Form:</div><div class="line">Q =</div><div class="line"> -0.13031167282892092       0.98380249683206911      -0.12309149097933236</div><div class="line"> -0.47780946703937632      -0.17109608640557677      -0.86164043685532932</div><div class="line"> -0.86874448552613881       -5.3467527001743037E-002  0.49236596391733078</div><div class="line">R =</div><div class="line"> -11.510864433221338       -26.540144032823541       -10.033998807826904</div><div class="line"> 0.0000000000000000        1.0586570346345126        2.0745400476676279</div><div class="line"> 0.0000000000000000        0.0000000000000000       -5.2929341121113067</div><div class="line">Updating A Directly:</div><div class="line">Q =</div><div class="line"> -0.13031167282892087       0.98380249683206955      -0.12309149097933178</div><div class="line"> -0.47780946703937643      -0.17109608640557616      -0.86164043685532943</div><div class="line"> -0.86874448552613903       -5.3467527001742954E-002  0.49236596391733084</div><div class="line">R =</div><div class="line"> -11.510864433221336       -26.540144032823545       -10.033998807826906</div><div class="line"> 0.0000000000000000        1.0586570346345205        2.0745400476676350</div><div class="line"> 0.0000000000000000        0.0000000000000000       -5.2929341121113058</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the QRUPDATE routine DQR1UP.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><a href="https://sourceforge.net/projects/qrupdate/">Source</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01461">1461</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="aa27cc026c0b8092eed7e79c135847674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27cc026c0b8092eed7e79c135847674">&#9670;&nbsp;</a></span>rz_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::rz_factor </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factors an upper trapezoidal matrix by means of orthogonal transformations such that A = R * Z = (R 0) * Z. Z is an orthogonal matrix of dimension N-by-N, and R is an M-by-M upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N upper trapezoidal matrix to factor. On output, the leading M-by-M upper triangular part of the matrix contains the upper triangular matrix R, and elements N-L+1 to N of the first M rows of A, with the array <code>tau</code>, represent the orthogonal matrix Z as a product of M elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau</td><td>An M-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Further Details</dt><dd><pre class="fragment">  The factorization is obtained by Householder's method.  The kth
  transformation matrix, Z( k ), which is used to introduce zeros into
  the ( m - k + 1 )th row of A, is given in the form

     Z( k ) = ( I     0   ),
              ( 0  T( k ) )

  where

     T( k ) = I - tau*u( k )*u( k )**T,   u( k ) = (   1    ),
                                                   (   0    )
                                                   ( z( k ) )

  tau is a scalar and z( k ) is an l element vector. tau and z( k )
  are chosen to annihilate the elements of the kth row of A2.

  The scalar tau is returned in the kth element of TAU and the vector
  u( k ) in the kth row of A2, such that the elements of z( k ) are
  in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
  the upper triangular part of A1.

  Z is given by

     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).</pre></dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine is based upon the LAPACK routine DTZRZF.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><ul>
<li><a href="http://netlib.org/lapack/lug/node44.html">LAPACK Users Manual</a> </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l01956">1956</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
<a id="a69c4743b118b731d2323f27994ab6ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4743b118b731d2323f27994ab6ff4">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public linalg_factor::svd </td>
          <td>(</td>
          <td class="paramtype">real(dp), dimension(:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out), optional&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:,:), intent(out), optional&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(dp), dimension(:), intent(out), optional, target&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(i32), intent(out), optional&#160;</td>
          <td class="paramname"><em>olwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(errors), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition of a matrix A. The SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>A MIN(M, N)-element array containing the singular values of <code>a</code> sorted in descending order. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>An optional argument, that if supplied, is used to contain the orthogonal matrix U from the decomposition. The matrix U contains the left singular vectors, and can be either M-by-M (all left singular vectors are computed), or M-by-MIN(M,N) (only the first MIN(M, N) left singular vectors are computed). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>An optional argument, that if supplied, is used to contain the transpose of the N-by-N orthogonal matrix V. The matrix V contains the right singular vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>An optional input, that if provided, prevents any local memory allocation. If not provided, the memory required is allocated within. If provided, the length of the array must be at least <code>olwork</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">olwork</td><td>An optional output used to determine workspace size. If supplied, the routine determines the optimal size for <code>work</code>, and returns without performing any actual calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>An optional errors-based object that if provided can be used to retrieve information relating to any errors encountered during execution. If not provided, a default implementation of the errors class is used internally to provide error handling. Possible errors and warning messages that may be encountered are as follows.<ul>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">! Decompose matrix the M-by-N matrix A such that A = U * S * V**T with</span></div><div class="line"><span class="comment">! M &gt;= N.</span></div><div class="line"></div><div class="line"><span class="comment">! Variables</span></div><div class="line"><span class="keywordtype">real(dp)</span>, <span class="keywordtype">dimension(m, n)</span> :: a</div><div class="line"><span class="keywordtype">real(dp)</span>, <span class="keywordtype">dimension(m, m)</span> :: u</div><div class="line"><span class="keywordtype">real(dp)</span>, <span class="keywordtype">dimension(n, n)</span> :: vt</div><div class="line"><span class="keywordtype">real(dp)</span>, <span class="keywordtype">dimension(n)</span> :: s</div><div class="line"></div><div class="line"><span class="comment">! Initialize A...</span></div><div class="line"></div><div class="line"><span class="comment">! Compute the SVD of A. On output, S contains the MIN(M,N) singular</span></div><div class="line"><span class="comment">! values of A in descending order, U contains the left singular vectors</span></div><div class="line"><span class="comment">! (one per column), and VT contains the right singular vectors (one per</span></div><div class="line"><span class="comment">! row).</span></div><div class="line"><span class="keyword">call </span>svd(a, s, u, vt)</div><div class="line"></div><div class="line"><span class="comment">! Note: If M &gt; N, then we can make U M-by-N, and compute the N</span></div><div class="line"><span class="comment">! left singular vectors of A, as there are at most N singular values</span></div><div class="line"><span class="comment">! of A.  Also, if M &lt; N, then there are at most M singular values of A,</span></div><div class="line">! and as such, the length of the array s should be m.</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Notes</dt><dd>This routine utilizes the LAPACK routine DGESVD.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><ul>
<li><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/SingularValueDecomposition.html">Wolfram MathWorld</a> </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="linalg__factor_8f90_source.html#l02369">2369</a> of file <a class="el" href="linalg__factor_8f90_source.html">linalg_factor.f90</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelinalg__factor.html">linalg_factor</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
