var tipuesearch = {"pages":[{"title":" LINALG ","text":"LINALG Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"csr_matrix – LINALG ","text":"type, public :: csr_matrix A sparse matrix stored in compressed sparse row (CSR) format. Contents Variables column_indices row_indices values Type-Bound Procedures extract_diagonal get Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: column_indices An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the column indices of each value. integer(kind=int32), public, allocatable, dimension(:) :: row_indices An M+1 element array containing the indices in V an JA at which the\nrequested row starts. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the non-zero values of the matrix. Type-Bound Procedures procedure, public :: extract_diagonal => csr_extract_diagonal private  subroutine csr_extract_diagonal(a, diag, err) Extracts the diagonal from a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(out), dimension(:) :: diag The diagonal values. class(errors), intent(inout), optional, target :: err The error object to be updated. procedure, public :: get => csr_get_element private  function csr_get_element(this, i, j) result(rst) Retrieves the element at the specified row and column. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: this The CSR matrix object. integer(kind=int32), intent(in) :: i The row index. integer(kind=int32), intent(in) :: j The column index. Return Value real(kind=real64) The value at the specified row and column.","tags":"","loc":"type\\csr_matrix.html"},{"title":"msr_matrix – LINALG ","text":"type, public :: msr_matrix A sparse matrix stored in modified sparse row format. Contents Variables indices m n nnz values Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: indices An NNZ-element array containing the index information. integer(kind=int32), public :: m = 0 The number of rows in the matrix. integer(kind=int32), public :: n = 0 The number of columns in the matrix. integer(kind=int32), public :: nnz = 0 The number of nonzero values in the matrix. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array containing the non-zero values from the\nmatrix.  The first MIN(M,N) elements contain the diagonal.","tags":"","loc":"type\\msr_matrix.html"},{"title":"eigen_solution – LINALG ","text":"type, public :: eigen_solution A container for both eigenvectors and eigenvalues. Contents Variables values vectors Components Type Visibility Attributes Name Initial complex(kind=real64), public, allocatable, dimension(:) :: values An array of eigenvalues. complex(kind=real64), public, allocatable, dimension(:,:) :: vectors A collection of eigenvectors, stored columnwise.","tags":"","loc":"type\\eigen_solution.html"},{"title":"lu_factors – LINALG ","text":"type, public :: lu_factors A container for the results of a LU factorization. Contents Variables L P U Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: L The lower-triangular factorization. real(kind=real64), public, allocatable, dimension(:,:) :: P The pivot tracking matrix. real(kind=real64), public, allocatable, dimension(:,:) :: U The upper-triangular factorization.","tags":"","loc":"type\\lu_factors.html"},{"title":"qr_factors – LINALG ","text":"type, public :: qr_factors A container for the results of a QR factorization of an M-by-N \nmatrix. Contents Variables P Q R Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: P The N-by-N pivot tracking matrix. real(kind=real64), public, allocatable, dimension(:,:) :: Q The M-by-M orthogonal matrix, . real(kind=real64), public, allocatable, dimension(:,:) :: R The M-by-N upper trapezoidal matrix, .","tags":"","loc":"type\\qr_factors.html"},{"title":"svd_factors – LINALG ","text":"type, public :: svd_factors A container for the results of a singular value decomposition of\nan M-by-N matrix. Contents Variables S U Vt Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: S The M-by-N diagonal matrix containing the singular values\non the diagonal. real(kind=real64), public, allocatable, dimension(:,:) :: U The M-by-M orthogonal matrix . real(kind=real64), public, allocatable, dimension(:,:) :: Vt The transpose of the N-by-N right singular vector matrix .","tags":"","loc":"type\\svd_factors.html"},{"title":"caxcpy – LINALG","text":"subroutine caxcpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer :: n complex :: a complex :: x (*) integer :: incx complex :: y (*) integer :: incy Contents Variables i ix iy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy","tags":"","loc":"proc\\caxcpy.html"},{"title":"cch1dn – LINALG","text":"subroutine cch1dn(n, R, ldr, u, rw, info) Arguments Type Intent Optional Attributes Name integer :: n complex :: R (ldr,*) integer :: ldr complex :: u (*) real :: rw (*) integer :: info Contents Variables crho i j rho rr t ui Variables Type Visibility Attributes Name Initial complex, public :: crho integer, public :: i integer, public :: j real, public :: rho complex, public :: rr complex, public :: t complex, public :: ui","tags":"","loc":"proc\\cch1dn.html"},{"title":"cch1up – LINALG","text":"subroutine cch1up(n, R, ldr, u, w) Arguments Type Intent Optional Attributes Name integer :: n complex :: R (ldr,*) integer :: ldr complex :: u (*) real :: w (*) Contents Variables i j rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j complex, public :: rr complex, public :: t complex, public :: ui","tags":"","loc":"proc\\cch1up.html"},{"title":"cchdex – LINALG","text":"subroutine cchdex(n, R, ldr, j, rw) Arguments Type Intent Optional Attributes Name integer :: n complex :: R (ldr,*) integer :: ldr integer :: j real :: rw (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\cchdex.html"},{"title":"cchinx – LINALG","text":"subroutine cchinx(n, R, ldr, j, u, rw, info) Arguments Type Intent Optional Attributes Name integer :: n complex :: R (ldr,*) integer :: ldr integer :: j complex :: u (*) complex :: rw (*) integer :: info Contents Variables i rho t Variables Type Visibility Attributes Name Initial integer, public :: i real, public :: rho complex, public :: t","tags":"","loc":"proc\\cchinx.html"},{"title":"cchshx – LINALG","text":"subroutine cchshx(n, R, ldr, i, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: n complex :: R (ldr,*) integer :: ldr integer :: i integer :: j complex :: w (*) real :: rw (*) Contents Variables info l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: l","tags":"","loc":"proc\\cchshx.html"},{"title":"cgqvec – LINALG","text":"subroutine cgqvec(m, n, Q, ldq, u) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: Q (ldq,*) integer :: ldq complex :: u (*) Contents Variables i info j r Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j real, public :: r","tags":"","loc":"proc\\cgqvec.html"},{"title":"clu1up – LINALG","text":"subroutine clu1up(m, n, L, ldl, R, ldr, u, v) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: L (ldl,*) integer :: ldl complex :: R (ldr,*) integer :: ldr complex :: u (*) complex :: v (*) Contents Variables i info j k ui vi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k complex, public :: ui complex, public :: vi","tags":"","loc":"proc\\clu1up.html"},{"title":"clup1up – LINALG","text":"subroutine clup1up(m, n, L, ldl, R, ldr, p, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: L (ldl,*) integer :: ldl complex :: R (ldr,*) integer :: ldr integer :: p (*) complex :: u (*) complex :: v (*) complex :: w (*) Contents Variables i info itmp j k one tau tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: itmp integer, public :: j integer, public :: k complex, public, parameter :: one = 1e0 real, public, parameter :: tau = 1e-1 complex, public :: tmp","tags":"","loc":"proc\\clup1up.html"},{"title":"cqhqr – LINALG","text":"subroutine cqhqr(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: R (ldr,*) integer :: ldr real :: c (*) complex :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j complex, public :: t","tags":"","loc":"proc\\cqhqr.html"},{"title":"cqr1up – LINALG","text":"subroutine cqr1up(m, n, k, Q, ldq, R, ldr, u, v, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr complex :: u (*) complex :: v (*) complex :: w (*) real :: rw (*) Contents Variables full i info ru ruu Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info real, public :: ru real, public :: ruu","tags":"","loc":"proc\\cqr1up.html"},{"title":"cqrdec – LINALG","text":"subroutine cqrdec(m, n, k, Q, ldq, R, ldr, j, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr integer :: j real :: rw (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\cqrdec.html"},{"title":"cqrder – LINALG","text":"subroutine cqrder(m, n, Q, ldq, R, ldr, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr integer :: j complex :: w (*) real :: rw (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\cqrder.html"},{"title":"cqrinc – LINALG","text":"subroutine cqrinc(m, n, k, Q, ldq, R, ldr, j, x, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr integer :: j complex :: x (*) real :: rw (*) Contents Variables full i info k1 rx Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info integer, public :: k1 real, public :: rx","tags":"","loc":"proc\\cqrinc.html"},{"title":"cqrinr – LINALG","text":"subroutine cqrinr(m, n, Q, ldq, R, ldr, j, x, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr integer :: j complex :: x (*) real :: rw (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\cqrinr.html"},{"title":"cqrot – LINALG","text":"subroutine cqrot(dir, m, n, Q, ldq, c, s) Arguments Type Intent Optional Attributes Name character(len=1) :: dir integer :: m integer :: n complex :: Q (ldq,*) integer :: ldq real :: c (*) complex :: s (*) Contents Variables fwd i info Variables Type Visibility Attributes Name Initial logical, public :: fwd integer, public :: i integer, public :: info","tags":"","loc":"proc\\cqrot.html"},{"title":"cqrqh – LINALG","text":"subroutine cqrqh(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n complex :: R (ldr,*) integer :: ldr real :: c (*) complex :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j complex, public :: t","tags":"","loc":"proc\\cqrqh.html"},{"title":"cqrshc – LINALG","text":"subroutine cqrshc(m, n, k, Q, ldq, R, ldr, i, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k complex :: Q (ldq,*) integer :: ldq complex :: R (ldr,*) integer :: ldr integer :: i integer :: j complex :: w (*) real :: rw (*) Contents Variables info jj kk l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: jj integer, public :: kk integer, public :: l","tags":"","loc":"proc\\cqrshc.html"},{"title":"cqrtv1 – LINALG","text":"subroutine cqrtv1(n, u, w) Arguments Type Intent Optional Attributes Name integer :: n complex :: u (*) real :: w (*) Contents Variables i rr t Variables Type Visibility Attributes Name Initial integer, public :: i complex, public :: rr complex, public :: t","tags":"","loc":"proc\\cqrtv1.html"},{"title":"dch1dn – LINALG","text":"subroutine dch1dn(n, R, ldr, u, w, info) Arguments Type Intent Optional Attributes Name integer :: n double precision :: R (ldr,*) integer :: ldr double precision :: u (*) double precision :: w (*) integer :: info Contents Variables i j rho rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j double precision, public :: rho double precision, public :: rr double precision, public :: t double precision, public :: ui","tags":"","loc":"proc\\dch1dn.html"},{"title":"dch1up – LINALG","text":"subroutine dch1up(n, R, ldr, u, w) Arguments Type Intent Optional Attributes Name integer :: n double precision :: R (ldr,*) integer :: ldr double precision :: u (*) double precision :: w (*) Contents Variables i j rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j double precision, public :: rr double precision, public :: t double precision, public :: ui","tags":"","loc":"proc\\dch1up.html"},{"title":"dchdex – LINALG","text":"subroutine dchdex(n, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: n double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: w (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\dchdex.html"},{"title":"dchinx – LINALG","text":"subroutine dchinx(n, R, ldr, j, u, w, info) Arguments Type Intent Optional Attributes Name integer :: n double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: u (*) double precision :: w (*) integer :: info Contents Variables i rho t Variables Type Visibility Attributes Name Initial integer, public :: i double precision, public :: rho double precision, public :: t","tags":"","loc":"proc\\dchinx.html"},{"title":"dchshx – LINALG","text":"subroutine dchshx(n, R, ldr, i, j, w) Arguments Type Intent Optional Attributes Name integer :: n double precision :: R (ldr,*) integer :: ldr integer :: i integer :: j double precision :: w (*) Contents Variables info l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: l","tags":"","loc":"proc\\dchshx.html"},{"title":"dgqvec – LINALG","text":"subroutine dgqvec(m, n, Q, ldq, u) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: Q (ldq,*) integer :: ldq double precision :: u (*) Contents Variables i info j r Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j double precision, public :: r","tags":"","loc":"proc\\dgqvec.html"},{"title":"dlu1up – LINALG","text":"subroutine dlu1up(m, n, L, ldl, R, ldr, u, v) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: L (ldl,*) integer :: ldl double precision :: R (ldr,*) integer :: ldr double precision :: u (*) double precision :: v (*) Contents Variables i info j k ui vi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k double precision, public :: ui double precision, public :: vi","tags":"","loc":"proc\\dlu1up.html"},{"title":"dlup1up – LINALG","text":"subroutine dlup1up(m, n, L, ldl, R, ldr, p, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: L (ldl,*) integer :: ldl double precision :: R (ldr,*) integer :: ldr integer :: p (*) double precision :: u (*) double precision :: v (*) double precision :: w (*) Contents Variables i info itmp j k one tau tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: itmp integer, public :: j integer, public :: k double precision, public, parameter :: one = 1d0 double precision, public, parameter :: tau = 1d-1 double precision, public :: tmp","tags":"","loc":"proc\\dlup1up.html"},{"title":"dqhqr – LINALG","text":"subroutine dqhqr(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: R (ldr,*) integer :: ldr double precision :: c (*) double precision :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j double precision, public :: t","tags":"","loc":"proc\\dqhqr.html"},{"title":"dqr1up – LINALG","text":"subroutine dqr1up(m, n, k, Q, ldq, R, ldr, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr double precision :: u (*) double precision :: v (*) double precision :: w (*) Contents Variables full i info ru ruu Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info double precision, public :: ru double precision, public :: ruu","tags":"","loc":"proc\\dqr1up.html"},{"title":"dqrdec – LINALG","text":"subroutine dqrdec(m, n, k, Q, ldq, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: w (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\dqrdec.html"},{"title":"dqrder – LINALG","text":"subroutine dqrder(m, n, Q, ldq, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: w (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\dqrder.html"},{"title":"dqrinc – LINALG","text":"subroutine dqrinc(m, n, k, Q, ldq, R, ldr, j, x, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: x (*) double precision :: w (*) Contents Variables full i info k1 rx Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info integer, public :: k1 double precision, public :: rx","tags":"","loc":"proc\\dqrinc.html"},{"title":"dqrinr – LINALG","text":"subroutine dqrinr(m, n, Q, ldq, R, ldr, j, x, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr integer :: j double precision :: x (*) double precision :: w (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\dqrinr.html"},{"title":"dqrot – LINALG","text":"subroutine dqrot(dir, m, n, Q, ldq, c, s) Arguments Type Intent Optional Attributes Name character(len=1) :: dir integer :: m integer :: n double precision :: Q (ldq,*) integer :: ldq double precision :: c (*) double precision :: s (*) Contents Variables fwd i info Variables Type Visibility Attributes Name Initial logical, public :: fwd integer, public :: i integer, public :: info","tags":"","loc":"proc\\dqrot.html"},{"title":"dqrqh – LINALG","text":"subroutine dqrqh(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double precision :: R (ldr,*) integer :: ldr double precision :: c (*) double precision :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j double precision, public :: t","tags":"","loc":"proc\\dqrqh.html"},{"title":"dqrshc – LINALG","text":"subroutine dqrshc(m, n, k, Q, ldq, R, ldr, i, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double precision :: Q (ldq,*) integer :: ldq double precision :: R (ldr,*) integer :: ldr integer :: i integer :: j double precision :: w (*) Contents Variables info jj kk l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: jj integer, public :: kk integer, public :: l","tags":"","loc":"proc\\dqrshc.html"},{"title":"dqrtv1 – LINALG","text":"subroutine dqrtv1(n, u, w) Arguments Type Intent Optional Attributes Name integer :: n double precision :: u (*) double precision :: w (*) Contents Variables i rr t Variables Type Visibility Attributes Name Initial integer, public :: i double precision, public :: rr double precision, public :: t","tags":"","loc":"proc\\dqrtv1.html"},{"title":"sch1dn – LINALG","text":"subroutine sch1dn(n, R, ldr, u, w, info) Arguments Type Intent Optional Attributes Name integer :: n real :: R (ldr,*) integer :: ldr real :: u (*) real :: w (*) integer :: info Contents Variables i j rho rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: rho real, public :: rr real, public :: t real, public :: ui","tags":"","loc":"proc\\sch1dn.html"},{"title":"sch1up – LINALG","text":"subroutine sch1up(n, R, ldr, u, w) Arguments Type Intent Optional Attributes Name integer :: n real :: R (ldr,*) integer :: ldr real :: u (*) real :: w (*) Contents Variables i j rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: rr real, public :: t real, public :: ui","tags":"","loc":"proc\\sch1up.html"},{"title":"schdex – LINALG","text":"subroutine schdex(n, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: n real :: R (ldr,*) integer :: ldr integer :: j real :: w (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\schdex.html"},{"title":"schinx – LINALG","text":"subroutine schinx(n, R, ldr, j, u, w, info) Arguments Type Intent Optional Attributes Name integer :: n real :: R (ldr,*) integer :: ldr integer :: j real :: u (*) real :: w (*) integer :: info Contents Variables i rho t Variables Type Visibility Attributes Name Initial integer, public :: i real, public :: rho real, public :: t","tags":"","loc":"proc\\schinx.html"},{"title":"schshx – LINALG","text":"subroutine schshx(n, R, ldr, i, j, w) Arguments Type Intent Optional Attributes Name integer :: n real :: R (ldr,*) integer :: ldr integer :: i integer :: j real :: w (*) Contents Variables info l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: l","tags":"","loc":"proc\\schshx.html"},{"title":"sgqvec – LINALG","text":"subroutine sgqvec(m, n, Q, ldq, u) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: Q (ldq,*) integer :: ldq real :: u (*) Contents Variables i info j r Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j real, public :: r","tags":"","loc":"proc\\sgqvec.html"},{"title":"slu1up – LINALG","text":"subroutine slu1up(m, n, L, ldl, R, ldr, u, v) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: L (ldl,*) integer :: ldl real :: R (ldr,*) integer :: ldr real :: u (*) real :: v (*) Contents Variables i info j k ui vi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k real, public :: ui real, public :: vi","tags":"","loc":"proc\\slu1up.html"},{"title":"slup1up – LINALG","text":"subroutine slup1up(m, n, L, ldl, R, ldr, p, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: L (ldl,*) integer :: ldl real :: R (ldr,*) integer :: ldr integer :: p (*) real :: u (*) real :: v (*) real :: w (*) Contents Variables i info itmp j k one tau tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: itmp integer, public :: j integer, public :: k real, public, parameter :: one = 1e0 real, public, parameter :: tau = 1e-1 real, public :: tmp","tags":"","loc":"proc\\slup1up.html"},{"title":"sqhqr – LINALG","text":"subroutine sqhqr(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: R (ldr,*) integer :: ldr real :: c (*) real :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j real, public :: t","tags":"","loc":"proc\\sqhqr.html"},{"title":"sqr1up – LINALG","text":"subroutine sqr1up(m, n, k, Q, ldq, R, ldr, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr real :: u (*) real :: v (*) real :: w (*) Contents Variables full i info ru ruu Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info real, public :: ru real, public :: ruu","tags":"","loc":"proc\\sqr1up.html"},{"title":"sqrdec – LINALG","text":"subroutine sqrdec(m, n, k, Q, ldq, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr integer :: j real :: w (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\sqrdec.html"},{"title":"sqrder – LINALG","text":"subroutine sqrder(m, n, Q, ldq, R, ldr, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr integer :: j real :: w (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\sqrder.html"},{"title":"sqrinc – LINALG","text":"subroutine sqrinc(m, n, k, Q, ldq, R, ldr, j, x, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr integer :: j real :: x (*) real :: w (*) Contents Variables full i info k1 rx Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info integer, public :: k1 real, public :: rx","tags":"","loc":"proc\\sqrinc.html"},{"title":"sqrinr – LINALG","text":"subroutine sqrinr(m, n, Q, ldq, R, ldr, j, x, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr integer :: j real :: x (*) real :: w (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\sqrinr.html"},{"title":"sqrot – LINALG","text":"subroutine sqrot(dir, m, n, Q, ldq, c, s) Arguments Type Intent Optional Attributes Name character(len=1) :: dir integer :: m integer :: n real :: Q (ldq,*) integer :: ldq real :: c (*) real :: s (*) Contents Variables fwd i info Variables Type Visibility Attributes Name Initial logical, public :: fwd integer, public :: i integer, public :: info","tags":"","loc":"proc\\sqrot.html"},{"title":"sqrqh – LINALG","text":"subroutine sqrqh(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: R (ldr,*) integer :: ldr real :: c (*) real :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j real, public :: t","tags":"","loc":"proc\\sqrqh.html"},{"title":"sqrshc – LINALG","text":"subroutine sqrshc(m, n, k, Q, ldq, R, ldr, i, j, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k real :: Q (ldq,*) integer :: ldq real :: R (ldr,*) integer :: ldr integer :: i integer :: j real :: w (*) Contents Variables info jj kk l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: jj integer, public :: kk integer, public :: l","tags":"","loc":"proc\\sqrshc.html"},{"title":"sqrtv1 – LINALG","text":"subroutine sqrtv1(n, u, w) Arguments Type Intent Optional Attributes Name integer :: n real :: u (*) real :: w (*) Contents Variables i rr t Variables Type Visibility Attributes Name Initial integer, public :: i real, public :: rr real, public :: t","tags":"","loc":"proc\\sqrtv1.html"},{"title":"zaxcpy – LINALG","text":"subroutine zaxcpy(n, a, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer :: n double complex :: a double complex :: x (*) integer :: incx double complex :: y (*) integer :: incy Contents Variables i ix iy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ix integer, public :: iy","tags":"","loc":"proc\\zaxcpy.html"},{"title":"zch1dn – LINALG","text":"subroutine zch1dn(n, R, ldr, u, rw, info) Arguments Type Intent Optional Attributes Name integer :: n double complex :: R (ldr,*) integer :: ldr double complex :: u (*) double precision :: rw (*) integer :: info Contents Variables crho i j rho rr t ui Variables Type Visibility Attributes Name Initial double complex, public :: crho integer, public :: i integer, public :: j double precision, public :: rho double complex, public :: rr double complex, public :: t double complex, public :: ui","tags":"","loc":"proc\\zch1dn.html"},{"title":"zch1up – LINALG","text":"subroutine zch1up(n, R, ldr, u, w) Arguments Type Intent Optional Attributes Name integer :: n double complex :: R (ldr,*) integer :: ldr double complex :: u (*) double precision :: w (*) Contents Variables i j rr t ui Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j double complex, public :: rr double complex, public :: t double complex, public :: ui","tags":"","loc":"proc\\zch1up.html"},{"title":"zchdex – LINALG","text":"subroutine zchdex(n, R, ldr, j, rw) Arguments Type Intent Optional Attributes Name integer :: n double complex :: R (ldr,*) integer :: ldr integer :: j double precision :: rw (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\zchdex.html"},{"title":"zchinx – LINALG","text":"subroutine zchinx(n, R, ldr, j, u, rw, info) Arguments Type Intent Optional Attributes Name integer :: n double complex :: R (ldr,*) integer :: ldr integer :: j double complex :: u (*) double complex :: rw (*) integer :: info Contents Variables i rho t Variables Type Visibility Attributes Name Initial integer, public :: i double precision, public :: rho double complex, public :: t","tags":"","loc":"proc\\zchinx.html"},{"title":"zchshx – LINALG","text":"subroutine zchshx(n, R, ldr, i, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: n double complex :: R (ldr,*) integer :: ldr integer :: i integer :: j double complex :: w (*) double precision :: rw (*) Contents Variables info l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: l","tags":"","loc":"proc\\zchshx.html"},{"title":"zgqvec – LINALG","text":"subroutine zgqvec(m, n, Q, ldq, u) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: Q (ldq,*) integer :: ldq double complex :: u (*) Contents Variables i info j r Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j double precision, public :: r","tags":"","loc":"proc\\zgqvec.html"},{"title":"zlu1up – LINALG","text":"subroutine zlu1up(m, n, L, ldl, R, ldr, u, v) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: L (ldl,*) integer :: ldl double complex :: R (ldr,*) integer :: ldr double complex :: u (*) double complex :: v (*) Contents Variables i info j k ui vi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: j integer, public :: k double complex, public :: ui double complex, public :: vi","tags":"","loc":"proc\\zlu1up.html"},{"title":"zlup1up – LINALG","text":"subroutine zlup1up(m, n, L, ldl, R, ldr, p, u, v, w) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: L (ldl,*) integer :: ldl double complex :: R (ldr,*) integer :: ldr integer :: p (*) double complex :: u (*) double complex :: v (*) double complex :: w (*) Contents Variables i info itmp j k one tau tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: itmp integer, public :: j integer, public :: k double complex, public, parameter :: one = 1d0 double precision, public, parameter :: tau = 1d-1 double complex, public :: tmp","tags":"","loc":"proc\\zlup1up.html"},{"title":"zqhqr – LINALG","text":"subroutine zqhqr(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: R (ldr,*) integer :: ldr double precision :: c (*) double complex :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j double complex, public :: t","tags":"","loc":"proc\\zqhqr.html"},{"title":"zqr1up – LINALG","text":"subroutine zqr1up(m, n, k, Q, ldq, R, ldr, u, v, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr double complex :: u (*) double complex :: v (*) double complex :: w (*) double precision :: rw (*) Contents Variables full i info j ru ruu Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info integer, public :: j double precision, public :: ru double precision, public :: ruu","tags":"","loc":"proc\\zqr1up.html"},{"title":"zqrdec – LINALG","text":"subroutine zqrdec(m, n, k, Q, ldq, R, ldr, j, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr integer :: j double precision :: rw (*) Contents Variables i info Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info","tags":"","loc":"proc\\zqrdec.html"},{"title":"zqrder – LINALG","text":"subroutine zqrder(m, n, Q, ldq, R, ldr, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr integer :: j double complex :: w (*) double precision :: rw (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\zqrder.html"},{"title":"zqrinc – LINALG","text":"subroutine zqrinc(m, n, k, Q, ldq, R, ldr, j, x, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr integer :: j double complex :: x (*) double precision :: rw (*) Contents Variables full i info k1 rx Variables Type Visibility Attributes Name Initial logical, public :: full integer, public :: i integer, public :: info integer, public :: k1 double precision, public :: rx","tags":"","loc":"proc\\zqrinc.html"},{"title":"zqrinr – LINALG","text":"subroutine zqrinr(m, n, Q, ldq, R, ldr, j, x, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr integer :: j double complex :: x (*) double precision :: rw (*) Contents Variables i info k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: info integer, public :: k","tags":"","loc":"proc\\zqrinr.html"},{"title":"zqrot – LINALG","text":"subroutine zqrot(dir, m, n, Q, ldq, c, s) Arguments Type Intent Optional Attributes Name character(len=1) :: dir integer :: m integer :: n double complex :: Q (ldq,*) integer :: ldq double precision :: c (*) double complex :: s (*) Contents Variables fwd i info Variables Type Visibility Attributes Name Initial logical, public :: fwd integer, public :: i integer, public :: info","tags":"","loc":"proc\\zqrot.html"},{"title":"zqrqh – LINALG","text":"subroutine zqrqh(m, n, R, ldr, c, s) Arguments Type Intent Optional Attributes Name integer :: m integer :: n double complex :: R (ldr,*) integer :: ldr double precision :: c (*) double complex :: s (*) Contents Variables i ii info j t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: info integer, public :: j double complex, public :: t","tags":"","loc":"proc\\zqrqh.html"},{"title":"zqrshc – LINALG","text":"subroutine zqrshc(m, n, k, Q, ldq, R, ldr, i, j, w, rw) Arguments Type Intent Optional Attributes Name integer :: m integer :: n integer :: k double complex :: Q (ldq,*) integer :: ldq double complex :: R (ldr,*) integer :: ldr integer :: i integer :: j double complex :: w (*) double precision :: rw (*) Contents Variables info jj kk l Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: jj integer, public :: kk integer, public :: l","tags":"","loc":"proc\\zqrshc.html"},{"title":"zqrtv1 – LINALG","text":"subroutine zqrtv1(n, u, w) Arguments Type Intent Optional Attributes Name integer :: n double complex :: u (*) double precision :: w (*) Contents Variables i rr t Variables Type Visibility Attributes Name Initial integer, public :: i double complex, public :: rr double complex, public :: t","tags":"","loc":"proc\\zqrtv1.html"},{"title":"amub – LINALG","text":"subroutine amub(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (*) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (*) integer :: nzmax integer :: iw (ncol) integer :: ierr Contents Variables ii j jcol jj jpos k ka kb len scal values Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: jcol integer, public :: jj integer, public :: jpos integer, public :: k integer, public :: ka integer, public :: kb integer, public :: len real(kind=8), public :: scal logical, public :: values","tags":"","loc":"proc\\amub.html"},{"title":"aplb – LINALG","text":"subroutine aplb(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (nrow+1) integer :: nzmax integer :: iw (ncol) integer :: ierr Contents Variables ii j jcol jpos k ka kb len values Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: jcol integer, public :: jpos integer, public :: k integer, public :: ka integer, public :: kb integer, public :: len logical, public :: values","tags":"","loc":"proc\\aplb.html"},{"title":"aplb1 – LINALG","text":"subroutine aplb1(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (nrow+1) integer :: nzmax integer :: ierr Contents Variables i j1 j2 ka kamax kb kbmax kc values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j1 integer, public :: j2 integer, public :: ka integer, public :: kamax integer, public :: kb integer, public :: kbmax integer, public :: kc logical, public :: values","tags":"","loc":"proc\\aplb1.html"},{"title":"aplsb – LINALG","text":"subroutine aplsb(nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: s real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (nrow+1) integer :: nzmax integer :: iw (ncol) integer :: ierr Contents Variables ii j jcol jpos k ka kb len Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: jcol integer, public :: jpos integer, public :: k integer, public :: ka integer, public :: kb integer, public :: len","tags":"","loc":"proc\\aplsb.html"},{"title":"aplsb1 – LINALG","text":"subroutine aplsb1(nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: s real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (nrow+1) integer :: nzmax integer :: ierr Contents Variables i j1 j2 ka kamax kb kbmax kc Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j1 integer, public :: j2 integer, public :: ka integer, public :: kamax integer, public :: kb integer, public :: kbmax integer, public :: kc","tags":"","loc":"proc\\aplsb1.html"},{"title":"apmbt – LINALG","text":"subroutine apmbt(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (ncol+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (*) integer :: nzmax integer :: iw (*) integer :: ierr Contents Variables i ii ipos j jcol jpos k ka len ljob nnza nnzb values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: ipos integer, public :: j integer, public :: jcol integer, public :: jpos integer, public :: k integer, public :: ka integer, public :: len integer, public :: ljob integer, public :: nnza integer, public :: nnzb logical, public :: values","tags":"","loc":"proc\\apmbt.html"},{"title":"aplsbt – LINALG","text":"subroutine aplsbt(nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: s real(kind=8) :: b (*) integer :: jb (*) integer :: ib (ncol+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (*) integer :: nzmax integer :: iw (*) integer :: ierr Contents Variables i ii ipos j jcol jpos k ka len ljob nnza nnzb Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: ipos integer, public :: j integer, public :: jcol integer, public :: jpos integer, public :: k integer, public :: ka integer, public :: len integer, public :: ljob integer, public :: nnza integer, public :: nnzb","tags":"","loc":"proc\\aplsbt.html"},{"title":"diamua – LINALG","text":"subroutine diamua(nrow, job, a, ja, ia, diag, b, jb, ib) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) Contents Variables ii k k1 k2 scal Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: scal","tags":"","loc":"proc\\diamua.html"},{"title":"amudia – LINALG","text":"subroutine amudia(nrow, job, a, ja, ia, diag, b, jb, ib) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) Contents Variables ii k k1 k2 Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: k integer, public :: k1 integer, public :: k2","tags":"","loc":"proc\\amudia.html"},{"title":"aplsca – LINALG","text":"subroutine aplsca(nrow, a, ja, ia, scal, iw) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: scal integer :: iw (*) Contents Variables icount ii j k k1 k2 ko test Variables Type Visibility Attributes Name Initial integer, public :: icount integer, public :: ii integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2 integer, public :: ko logical, public :: test","tags":"","loc":"proc\\aplsca.html"},{"title":"apldia – LINALG","text":"subroutine apldia(nrow, job, a, ja, ia, diag, b, jb, ib, iw) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) integer :: iw (*) Contents Variables icount ii j k k1 k2 ko nnz test Variables Type Visibility Attributes Name Initial integer, public :: icount integer, public :: ii integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2 integer, public :: ko integer, public :: nnz logical, public :: test","tags":"","loc":"proc\\apldia.html"},{"title":"distdot – LINALG","text":"function distdot(n, x, ix, y, iy) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (*) integer :: ix real(kind=8) :: y (*) integer :: iy Return Value doubleprecision Contents","tags":"","loc":"proc\\distdot.html"},{"title":"csrdns – LINALG","text":"subroutine csrdns(nrow, ncol, a, ja, ia, dns, ndns, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: dns (ndns,*) integer :: ndns integer :: ierr Contents Variables i j k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc\\csrdns.html"},{"title":"dnscsr – LINALG","text":"subroutine dnscsr(nrow, ncol, nzmax, dns, ndns, a, ja, ia, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: nzmax real(kind=8) :: dns (ndns,*) integer :: ndns real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: ierr Contents Variables i j next Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: next","tags":"","loc":"proc\\dnscsr.html"},{"title":"coocsr – LINALG","text":"subroutine coocsr(nrow, nnz, a, ir, jc, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: nnz real(kind=8) :: a (*) integer :: ir (*) integer :: jc (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables i iad j k k0 x Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iad integer, public :: j integer, public :: k integer, public :: k0 real(kind=8), public :: x","tags":"","loc":"proc\\coocsr.html"},{"title":"coicsr – LINALG","text":"subroutine coicsr(n, nnz, job, a, ja, ia, iwk) Arguments Type Intent Optional Attributes Name integer :: n integer :: nnz integer :: job real(kind=8) :: a (*) integer :: ja (nnz) integer :: ia (*) integer :: iwk (n+1) Contents Variables i inext init ipos j jnext k t tnext values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: inext integer, public :: init integer, public :: ipos integer, public :: j integer, public :: jnext integer, public :: k real(kind=8), public :: t real(kind=8), public :: tnext logical, public :: values","tags":"","loc":"proc\\coicsr.html"},{"title":"csrcoo – LINALG","text":"subroutine csrcoo(nrow, job, nzmax, a, ja, ia, nnz, ao, ir, jc, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job integer :: nzmax real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: nnz real(kind=8) :: ao (*) integer :: ir (*) integer :: jc (*) integer :: ierr Contents Variables i k k1 k2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: k1 integer, public :: k2","tags":"","loc":"proc\\csrcoo.html"},{"title":"csrssr – LINALG","text":"subroutine csrssr(nrow, a, ja, ia, nzmax, ao, jao, iao, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: nzmax real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) integer :: ierr Contents Variables i k kdiag ko kold t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kdiag integer, public :: ko integer, public :: kold real(kind=8), public :: t","tags":"","loc":"proc\\csrssr.html"},{"title":"ssrcsr – LINALG","text":"subroutine ssrcsr(job, value2, nrow, a, ja, ia, nzmax, ao, jao, iao, indu, iwk, ierr) Arguments Type Intent Optional Attributes Name integer :: job integer :: value2 integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: nzmax real(kind=8) :: ao (nzmax) integer :: jao (nzmax) integer :: iao (nrow+1) integer :: indu (nrow) integer :: iwk (nrow+1) integer :: ierr Contents Variables i ipos j k kfirst klast ko kosav nnz tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ipos integer, public :: j integer, public :: k integer, public :: kfirst integer, public :: klast integer, public :: ko integer, public :: kosav integer, public :: nnz real(kind=8), public :: tmp","tags":"","loc":"proc\\ssrcsr.html"},{"title":"xssrcsr – LINALG","text":"subroutine xssrcsr(nrow, a, ja, ia, nzmax, ao, jao, iao, indu, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: nzmax real(kind=8) :: ao (nzmax) integer :: jao (nzmax) integer :: iao (nrow+1) integer :: indu (nrow+1) integer :: ierr Contents Variables i ipos j k kfirst klast ko kosav lenrow nnz Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ipos integer, public :: j integer, public :: k integer, public :: kfirst integer, public :: klast integer, public :: ko integer, public :: kosav integer, public :: lenrow integer, public :: nnz","tags":"","loc":"proc\\xssrcsr.html"},{"title":"csrell – LINALG","text":"subroutine csrell(nrow, a, ja, ia, maxcol, coef, jcoef, ncoef, ndiag, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: maxcol real(kind=8) :: coef (ncoef,1) integer :: jcoef (ncoef,1) integer :: ncoef integer :: ndiag integer :: ierr Contents Variables i j k k1 k2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2","tags":"","loc":"proc\\csrell.html"},{"title":"ellcsr – LINALG","text":"subroutine ellcsr(nrow, coef, jcoef, ncoef, ndiag, a, ja, ia, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: coef (ncoef,1) integer :: jcoef (ncoef,1) integer :: ncoef integer :: ndiag real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: nzmax integer :: ierr Contents Variables i k kpos Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kpos","tags":"","loc":"proc\\ellcsr.html"},{"title":"csrmsr – LINALG","text":"subroutine csrmsr(n, a, ja, ia, ao, jao, wk, iwk) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: ao (*) integer :: jao (*) real(kind=8) :: wk (n) integer :: iwk (n+1) Contents Variables i icount ii iptr j k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: icount integer, public :: ii integer, public :: iptr integer, public :: j integer, public :: k","tags":"","loc":"proc\\csrmsr.html"},{"title":"msrcsr – LINALG","text":"subroutine msrcsr(n, a, ja, ao, jao, iao, wk, iwk) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (n+1) real(kind=8) :: wk (n) integer :: iwk (n+1) Contents Variables added i idiag ii iptr j k Variables Type Visibility Attributes Name Initial logical, public :: added integer, public :: i integer, public :: idiag integer, public :: ii integer, public :: iptr integer, public :: j integer, public :: k","tags":"","loc":"proc\\msrcsr.html"},{"title":"csrcsc – LINALG","text":"subroutine csrcsc(n, job, ipos, a, ja, ia, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n integer :: job integer :: ipos real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (n+1) Contents","tags":"","loc":"proc\\csrcsc.html"},{"title":"csrcsc2 – LINALG","text":"subroutine csrcsc2(n, n2, job, ipos, a, ja, ia, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n integer :: n2 integer :: job integer :: ipos real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (n2+1) Contents Variables i j k next Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: next","tags":"","loc":"proc\\csrcsc2.html"},{"title":"csrlnk – LINALG","text":"subroutine csrlnk(n, ia, link) Arguments Type Intent Optional Attributes Name integer :: n integer :: ia (n+1) integer :: link (*) Contents Variables i iend istart k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iend integer, public :: istart integer, public :: k","tags":"","loc":"proc\\csrlnk.html"},{"title":"lnkcsr – LINALG","text":"subroutine lnkcsr(n, a, jcol, istart, link, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: jcol (*) integer :: istart (n) integer :: link (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables ipos irow next Variables Type Visibility Attributes Name Initial integer, public :: ipos integer, public :: irow integer, public :: next","tags":"","loc":"proc\\lnkcsr.html"},{"title":"csrdia – LINALG","text":"subroutine csrdia(n, idiag, job, a, ja, ia, ndiag, diag, ioff, ao, jao, iao, ind) Arguments Type Intent Optional Attributes Name integer :: n integer :: idiag integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: ndiag real(kind=8) :: diag (ndiag,idiag) integer :: ioff (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) integer :: ind (*) Contents Variables i idum ii j jmax job1 job2 k ko l n2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idum integer, public :: ii integer, public :: j integer, public :: jmax integer, public :: job1 integer, public :: job2 integer, public :: k integer, public :: ko integer, public :: l integer, public :: n2","tags":"","loc":"proc\\csrdia.html"},{"title":"diacsr – LINALG","text":"subroutine diacsr(n, job, idiag, diag, ndiag, ioff, a, ja, ia) Arguments Type Intent Optional Attributes Name integer :: n integer :: job integer :: idiag real(kind=8) :: diag (ndiag,idiag) integer :: ndiag integer :: ioff (*) real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) Contents Variables i j jj ko t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jj integer, public :: ko real(kind=8), public :: t","tags":"","loc":"proc\\diacsr.html"},{"title":"bsrcsr – LINALG","text":"subroutine bsrcsr(job, n, m, na, a, ja, ia, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: job integer :: n integer :: m integer :: na real(kind=8) :: a (na,*) integer :: ja (*) integer :: ia (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (n+1) Contents Variables i i1 i2 ii ij irow j jstart k krow val Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: ii integer, public :: ij integer, public :: irow integer, public :: j integer, public :: jstart integer, public :: k integer, public :: krow logical, public :: val","tags":"","loc":"proc\\bsrcsr.html"},{"title":"csrbsr – LINALG","text":"subroutine csrbsr(job, nrow, m, na, a, ja, ia, ao, jao, iao, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: job integer :: nrow integer :: m integer :: na real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: ao (na,*) integer :: jao (na) integer :: iao (*) integer :: iw (*) integer :: ierr Contents Variables i ii ij io irow j jpos jr k ko len m2 nr vals Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: ij integer, public :: io integer, public :: irow integer, public :: j integer, public :: jpos integer, public :: jr integer, public :: k integer, public :: ko integer, public :: len integer, public :: m2 integer, public :: nr logical, public :: vals","tags":"","loc":"proc\\csrbsr.html"},{"title":"csrbnd – LINALG","text":"subroutine csrbnd(n, a, ja, ia, job, abd, nabd, lowd, ml, mu, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) integer :: job real(kind=8) :: abd (nabd,n) integer :: nabd integer :: lowd integer :: ml integer :: mu integer :: ierr Contents Variables i ii j k m mdiag Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: k integer, public :: m integer, public :: mdiag","tags":"","loc":"proc\\csrbnd.html"},{"title":"bndcsr – LINALG","text":"subroutine bndcsr(n, abd, nabd, lowd, ml, mu, a, ja, ia, len, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: abd (nabd,*) integer :: nabd integer :: lowd integer :: ml integer :: mu real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) integer :: len integer :: ierr Contents Variables i irow j k0 ko t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: irow integer, public :: j integer, public :: k0 integer, public :: ko real(kind=8), public :: t","tags":"","loc":"proc\\bndcsr.html"},{"title":"csrssk – LINALG","text":"subroutine csrssk(n, imod, a, ja, ia, asky, isky, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: imod real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: asky (nzmax) integer :: isky (n+1) integer :: nzmax integer :: ierr Contents Variables i j k kend ml nnz Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: kend integer, public :: ml integer, public :: nnz","tags":"","loc":"proc\\csrssk.html"},{"title":"sskssr – LINALG","text":"subroutine sskssr(n, imod, asky, isky, ao, jao, iao, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: imod real(kind=8) :: asky (*) integer :: isky (n+1) real(kind=8) :: ao (nzmax) integer :: jao (nzmax) integer :: iao (n+1) integer :: nzmax integer :: ierr Contents Variables i j k kend kstart next Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: kend integer, public :: kstart integer, public :: next","tags":"","loc":"proc\\sskssr.html"},{"title":"csrjad – LINALG","text":"subroutine csrjad(nrow, a, ja, ia, idiag, iperm, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: idiag integer :: iperm (nrow) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (nrow) Contents Variables i ilo j jj k k0 k1 len Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ilo integer, public :: j integer, public :: jj integer, public :: k integer, public :: k0 integer, public :: k1 integer, public :: len","tags":"","loc":"proc\\csrjad.html"},{"title":"jadcsr – LINALG","text":"subroutine jadcsr(nrow, idiag, a, ja, ia, iperm, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: idiag real(kind=8) :: a (*) integer :: ja (*) integer :: ia (idiag+1) integer :: iperm (nrow) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (nrow+1) Contents Variables i j jj k k1 kpos len Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jj integer, public :: k integer, public :: k1 integer, public :: kpos integer, public :: len","tags":"","loc":"proc\\jadcsr.html"},{"title":"dcsort – LINALG","text":"subroutine dcsort(ival, n, icnt, index, ilo, ihi) Arguments Type Intent Optional Attributes Name integer :: ival (n) integer :: n integer :: icnt (ilo:ihi) integer :: index (n) integer :: ilo integer :: ihi Contents Variables i ivalj j Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ivalj integer, public :: j","tags":"","loc":"proc\\dcsort.html"},{"title":"cooell – LINALG","text":"subroutine cooell(job, n, nnz, a, ja, ia, ao, jao, lda, ncmax, nc, ierr) Arguments Type Intent Optional Attributes Name integer :: job integer :: n integer :: nnz real(kind=8) :: a (nnz) integer :: ja (nnz) integer :: ia (nnz) real(kind=8) :: ao (lda,ncmax) integer :: jao (lda,ncmax) integer :: lda integer :: ncmax integer :: nc integer :: ierr Contents Variables copyval i ip j k zero Variables Type Visibility Attributes Name Initial logical, public :: copyval integer, public :: i integer, public :: ip integer, public :: j integer, public :: k real(kind=8), public, parameter :: zero = 0.0D0","tags":"","loc":"proc\\cooell.html"},{"title":"xcooell – LINALG","text":"subroutine xcooell(n, nnz, a, ja, ia, ac, jac, nac, ner, ncmax, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: nnz real(kind=8) :: a (nnz) integer :: ja (nnz) integer :: ia (nnz) real(kind=8) :: ac (nac,ner) integer :: jac (nac,ner) integer :: nac integer :: ner integer :: ncmax integer :: ierr Contents Variables icount ii in inn innz is k Variables Type Visibility Attributes Name Initial integer, public :: icount integer, public :: ii integer, public :: in integer, public :: inn integer, public :: innz integer, public :: is integer, public :: k","tags":"","loc":"proc\\xcooell.html"},{"title":"csruss – LINALG","text":"subroutine csruss(nrow, a, ja, ia, diag, al, jal, ial, au, jau, iau) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (*) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (nrow+1) real(kind=8) :: au (*) integer :: jau (*) integer :: iau (nrow+1) Contents Variables i j k kl ku Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: kl integer, public :: ku","tags":"","loc":"proc\\csruss.html"},{"title":"usscsr – LINALG","text":"subroutine usscsr(nrow, a, ja, ia, diag, al, jal, ial, au, jau, iau) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (*) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (nrow+1) real(kind=8) :: au (*) integer :: jau (*) integer :: iau (nrow+1) Contents Variables i j jak k ka Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jak integer, public :: k integer, public :: ka","tags":"","loc":"proc\\usscsr.html"},{"title":"csrsss – LINALG","text":"subroutine csrsss(nrow, a, ja, ia, sorted, diag, al, jal, ial, au) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) logical :: sorted real(kind=8) :: diag (*) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (nrow+1) real(kind=8) :: au (*) Contents Variables i jak k kl ku Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: jak integer, public :: k integer, public :: kl integer, public :: ku","tags":"","loc":"proc\\csrsss.html"},{"title":"ssscsr – LINALG","text":"subroutine ssscsr(nrow, a, ja, ia, diag, al, jal, ial, au) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (*) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (nrow+1) real(kind=8) :: au (*) Contents Variables i j jak k ka Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jak integer, public :: k integer, public :: ka","tags":"","loc":"proc\\ssscsr.html"},{"title":"csrvbr – LINALG","text":"subroutine csrvbr(n, ia, ja, a, nr, nc, kvstr, kvstc, ib, jb, kb, b, job, iwk, nkmax, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: ia (n+1) integer :: ja (*) real(kind=8) :: a (*) integer :: nr integer :: nc integer :: kvstr (*) integer :: kvstc (*) integer :: ib (*) integer :: jb (nkmax-1) integer :: kb (nkmax) real(kind=8) :: b (nzmax) integer :: job integer :: iwk (*) integer :: nkmax integer :: nzmax integer :: ierr Contents Variables a0 b0 b1 i ii j jj jnew k0 nb ncol neqr numc sorted Variables Type Visibility Attributes Name Initial integer, public :: a0 integer, public :: b0 integer, public :: b1 integer, public :: i integer, public :: ii integer, public :: j integer, public :: jj integer, public :: jnew integer, public :: k0 integer, public :: nb integer, public :: ncol integer, public :: neqr integer, public :: numc logical, public :: sorted","tags":"","loc":"proc\\csrvbr.html"},{"title":"vbrcsr – LINALG","text":"subroutine vbrcsr(ia, ja, a, nr, kvstr, kvstc, ib, jb, kb, b, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: ia (*) integer :: ja (*) real(kind=8) :: a (*) integer :: nr integer :: kvstr (nr+1) integer :: kvstc (*) integer :: ib (nr+1) integer :: jb (*) integer :: kb (*) real(kind=8) :: b (nzmax) integer :: nzmax integer :: ierr Contents Variables a0 b0 i ii j jj neqr numc Variables Type Visibility Attributes Name Initial integer, public :: a0 integer, public :: b0 integer, public :: i integer, public :: ii integer, public :: j integer, public :: jj integer, public :: neqr integer, public :: numc","tags":"","loc":"proc\\vbrcsr.html"},{"title":"csorted – LINALG","text":"subroutine csorted(n, ia, ja, sorted) Arguments Type Intent Optional Attributes Name integer :: n integer :: ia (n+1) integer :: ja (*) logical :: sorted Contents Variables i j Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc\\csorted.html"},{"title":"ilut – LINALG","text":"subroutine ilut(n, a, ja, ia, lfil, droptol, alu, jlu, ju, iwk, w, jw, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) integer :: lfil real(kind=8) :: droptol real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: iwk real(kind=8) :: w (n+1) integer :: jw (2*n) integer :: ierr Contents Variables abs fact i ii j j1 j2 jj jpos jrow ju0 k len lenl lenu s t tnorm Variables Type Visibility Attributes Name Initial real(kind=8), public :: abs real(kind=8), public :: fact integer, public :: i integer, public :: ii integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: jpos integer, public :: jrow integer, public :: ju0 integer, public :: k integer, public :: len integer, public :: lenl integer, public :: lenu real(kind=8), public :: s real(kind=8), public :: t real(kind=8), public :: tnorm","tags":"","loc":"proc\\ilut.html"},{"title":"ilutp – LINALG","text":"subroutine ilutp(n, a, ja, ia, lfil, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) integer :: lfil real(kind=8) :: droptol real(kind=8) :: permtol integer :: mbloc real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: iwk real(kind=8) :: w (n+1) integer :: jw (2*n) integer :: iperm (2*n) integer :: ierr Contents Variables abs fact i icut ii imax j j1 j2 jj jpos jrow ju0 k len lenl lenu s t tmp tnorm xmax xmax0 Variables Type Visibility Attributes Name Initial real(kind=8), public :: abs real(kind=8), public :: fact integer, public :: i integer, public :: icut integer, public :: ii integer, public :: imax integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: jpos integer, public :: jrow integer, public :: ju0 integer, public :: k integer, public :: len integer, public :: lenl integer, public :: lenu real(kind=8), public :: s real(kind=8), public :: t real(kind=8), public :: tmp real(kind=8), public :: tnorm real(kind=8), public :: xmax real(kind=8), public :: xmax0","tags":"","loc":"proc\\ilutp.html"},{"title":"ilud – LINALG","text":"subroutine ilud(n, a, ja, ia, alph, tol, alu, jlu, ju, iwk, w, jw, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: alph real(kind=8) :: tol real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: iwk real(kind=8) :: w (2*n) integer :: jw (2*n) integer :: ierr Contents Variables abs dropsum fact i ii j j1 j2 jj jpos jrow ju0 k len lenl lenu s t tnorm Variables Type Visibility Attributes Name Initial real(kind=8), public :: abs real(kind=8), public :: dropsum real(kind=8), public :: fact integer, public :: i integer, public :: ii integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: jpos integer, public :: jrow integer, public :: ju0 integer, public :: k integer, public :: len integer, public :: lenl integer, public :: lenu real(kind=8), public :: s real(kind=8), public :: t real(kind=8), public :: tnorm","tags":"","loc":"proc\\ilud.html"},{"title":"iludp – LINALG","text":"subroutine iludp(n, a, ja, ia, alph, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: alph real(kind=8) :: droptol real(kind=8) :: permtol integer :: mbloc real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: iwk real(kind=8) :: w (2*n) integer :: jw (2*n) integer :: iperm (2*n) integer :: ierr Contents Variables abs dropsum fact i icut ii imax j j1 j2 jj jpos jrow ju0 k len lenl lenu s t tmp tnorm xmax xmax0 Variables Type Visibility Attributes Name Initial real(kind=8), public :: abs real(kind=8), public :: dropsum real(kind=8), public :: fact integer, public :: i integer, public :: icut integer, public :: ii integer, public :: imax integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: jpos integer, public :: jrow integer, public :: ju0 integer, public :: k integer, public :: len integer, public :: lenl integer, public :: lenu real(kind=8), public :: s real(kind=8), public :: t real(kind=8), public :: tmp real(kind=8), public :: tnorm real(kind=8), public :: xmax real(kind=8), public :: xmax0","tags":"","loc":"proc\\iludp.html"},{"title":"iluk – LINALG","text":"subroutine iluk(n, a, ja, ia, lfil, alu, jlu, ju, levs, iwk, w, jw, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) integer :: lfil real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: levs (*) integer :: iwk real(kind=8) :: w (n) integer :: jw (3*n) integer :: ierr Contents Variables fact i ii j j1 j2 jj jlev jpos jrow ju0 k lenl lenu min n2 s t Variables Type Visibility Attributes Name Initial real(kind=8), public :: fact integer, public :: i integer, public :: ii integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: jlev integer, public :: jpos integer, public :: jrow integer, public :: ju0 integer, public :: k integer, public :: lenl integer, public :: lenu integer, public :: min integer, public :: n2 real(kind=8), public :: s real(kind=8), public :: t","tags":"","loc":"proc\\iluk.html"},{"title":"ilu0 – LINALG","text":"subroutine ilu0(n, a, ja, ia, alu, jlu, ju, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (*) integer :: iw (*) integer :: ierr Contents Variables i ii j jcol jf jj jm jrow js ju0 jw tl Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: jcol integer, public :: jf integer, public :: jj integer, public :: jm integer, public :: jrow integer, public :: js integer, public :: ju0 integer, public :: jw real(kind=8), public :: tl","tags":"","loc":"proc\\ilu0.html"},{"title":"milu0 – LINALG","text":"subroutine milu0(n, a, ja, ia, alu, jlu, ju, iw, ierr) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (*) integer :: iw (*) integer :: ierr Contents Variables i ii j jcol jf jj jm jrow js ju0 jw s tl Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: jcol integer, public :: jf integer, public :: jj integer, public :: jm integer, public :: jrow integer, public :: js integer, public :: ju0 integer, public :: jw real(kind=8), public :: s real(kind=8), public :: tl","tags":"","loc":"proc\\milu0.html"},{"title":"pgmres – LINALG","text":"subroutine pgmres(n, im, rhs, sol, vv, eps, maxits, iout, aa, ja, ia, alu, jlu, ju, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: im real(kind=8) :: rhs (n) real(kind=8) :: sol (n) real(kind=8) :: vv (n,*) real(kind=8) :: eps integer :: maxits integer :: iout real(kind=8) :: aa (*) integer :: ja (*) integer :: ia (n+1) real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (n) integer :: ierr Contents Variables c eps1 epsmac gam hh i i1 ii its j jj k k1 kmax ro rs s t Variables Type Visibility Attributes Name Initial real(kind=8), public :: c (kmax) real(kind=8), public :: eps1 real(kind=8), public :: epsmac real(kind=8), public :: gam real(kind=8), public :: hh (kmax+1,kmax) integer, public :: i integer, public :: i1 integer, public :: ii integer, public :: its integer, public :: j integer, public :: jj integer, public :: k integer, public :: k1 integer, public, parameter :: kmax = 50 real(kind=8), public :: ro real(kind=8), public :: rs (kmax+1) real(kind=8), public :: s (kmax) real(kind=8), public :: t","tags":"","loc":"proc\\pgmres.html"},{"title":"lusol – LINALG","text":"subroutine lusol(n, y, x, alu, jlu, ju) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: y (n) real(kind=8) :: x (n) real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\lusol.html"},{"title":"lutsol – LINALG","text":"subroutine lutsol(n, y, x, alu, jlu, ju) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: y (n) real(kind=8) :: x (n) real(kind=8) :: alu (*) integer :: jlu (*) integer :: ju (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\lutsol.html"},{"title":"qsplit – LINALG","text":"subroutine qsplit(a, ind, n, ncut) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (n) integer :: ind (n) integer :: n integer :: ncut Contents Variables abskey first itmp j last mid tmp Variables Type Visibility Attributes Name Initial real(kind=8), public :: abskey integer, public :: first integer, public :: itmp integer, public :: j integer, public :: last integer, public :: mid real(kind=8), public :: tmp","tags":"","loc":"proc\\qsplit.html"},{"title":"stopbis – LINALG","text":"function stopbis(n, ipar, mvpi, fpar, r, delx, sx) Arguments Type Intent Optional Attributes Name integer :: n integer :: ipar (16) integer :: mvpi real(kind=8) :: fpar (16) real(kind=8) :: r (n) real(kind=8) :: delx (n) real(kind=8) :: sx Return Value logical Contents","tags":"","loc":"proc\\stopbis.html"},{"title":"brkdn – LINALG","text":"function brkdn(alpha, ipar) Arguments Type Intent Optional Attributes Name real(kind=8) :: alpha integer :: ipar (16) Return Value logical Contents Variables beta one zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: beta real(kind=8), public, parameter :: one = 1.0D0 real(kind=8), public, parameter :: zero = 0.0D0","tags":"","loc":"proc\\brkdn.html"},{"title":"cg – LINALG","text":"subroutine cg(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (n,*) Contents Variables alpha i lp rp Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha integer, public :: i logical, public :: lp logical, public :: rp","tags":"","loc":"proc\\cg.html"},{"title":"cgnr – LINALG","text":"subroutine cgnr(n, rhs, sol, ipar, fpar, wk) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: wk (n,*) Contents Variables alpha i lp rp zz zzm1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha integer, public :: i logical, public :: lp logical, public :: rp real(kind=8), public :: zz real(kind=8), public :: zzm1","tags":"","loc":"proc\\cgnr.html"},{"title":"bcg – LINALG","text":"subroutine bcg(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (n,*) Contents Variables alpha i lp one rp Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha integer, public :: i logical, public :: lp real(kind=8), public :: one logical, public :: rp","tags":"","loc":"proc\\bcg.html"},{"title":"bcgstab – LINALG","text":"subroutine bcgstab(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (n,8) Contents Variables alpha beta i lp omega one rho rp Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: beta integer, public :: i logical, public, save :: lp real(kind=8), public :: omega real(kind=8), public :: one real(kind=8), public :: rho logical, public, save :: rp","tags":"","loc":"proc\\bcgstab.html"},{"title":"tfqmr – LINALG","text":"subroutine tfqmr(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (n,*) Contents Variables alpha eta i lp one rho rp sigma tao te theta zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: eta integer, public :: i logical, public :: lp real(kind=8), public :: one real(kind=8), public :: rho logical, public :: rp real(kind=8), public :: sigma real(kind=8), public :: tao real(kind=8), public :: te real(kind=8), public :: theta real(kind=8), public :: zero","tags":"","loc":"proc\\tfqmr.html"},{"title":"fom – LINALG","text":"subroutine fom(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (*) Contents Variables alpha c hes i idx ii k lp m one p2 prs ptr rp s vc vrn vs zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: c integer, public :: hes integer, public :: i integer, public :: idx integer, public :: ii integer, public :: k logical, public :: lp integer, public :: m real(kind=8), public :: one integer, public :: p2 integer, public :: prs integer, public :: ptr logical, public :: rp real(kind=8), public :: s integer, public :: vc integer, public :: vrn integer, public :: vs real(kind=8), public :: zero","tags":"","loc":"proc\\fom.html"},{"title":"gmres – LINALG","text":"subroutine gmres(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (*) Contents Variables alpha c hess i idx ii k lp m one p2 ptr rp s vc vrn vs zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: c integer, public :: hess integer, public :: i integer, public :: idx integer, public :: ii integer, public :: k logical, public :: lp integer, public :: m real(kind=8), public :: one integer, public :: p2 integer, public :: ptr logical, public :: rp real(kind=8), public :: s integer, public :: vc integer, public :: vrn integer, public :: vs real(kind=8), public :: zero","tags":"","loc":"proc\\gmres.html"},{"title":"dqgmres – LINALG","text":"subroutine dqgmres(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (*) Contents Variables alpha beta c deps full i ic ihd ihm ii is iv iw j j0 jp1 k lb lp one psi ptr ptrv ptrw rp s zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: beta real(kind=8), public :: c real(kind=8), public :: deps logical, public :: full integer, public :: i integer, public :: ic integer, public :: ihd integer, public :: ihm integer, public :: ii integer, public :: is integer, public :: iv integer, public :: iw integer, public :: j integer, public :: j0 integer, public :: jp1 integer, public :: k integer, public :: lb logical, public :: lp real(kind=8), public :: one real(kind=8), public :: psi integer, public :: ptr integer, public :: ptrv integer, public :: ptrw logical, public :: rp real(kind=8), public :: s real(kind=8), public :: zero","tags":"","loc":"proc\\dqgmres.html"},{"title":"fgmres – LINALG","text":"subroutine fgmres(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (*) Contents Variables alpha c hess i idx ii iz k lp m one p2 ptr rp s vc vrn vs zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: alpha real(kind=8), public :: c integer, public :: hess integer, public :: i integer, public :: idx integer, public :: ii integer, public :: iz integer, public :: k logical, public :: lp integer, public :: m real(kind=8), public :: one integer, public :: p2 integer, public :: ptr logical, public :: rp real(kind=8), public :: s integer, public :: vc integer, public :: vrn integer, public :: vs real(kind=8), public :: zero","tags":"","loc":"proc\\fgmres.html"},{"title":"dbcg – LINALG","text":"subroutine dbcg(n, rhs, sol, ipar, fpar, w) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: rhs (n) real(kind=8) :: sol (n) integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: w (n,*) Contents Variables beta delta distdot full i i2 indp ip2 j ju k lb lbm1 lp np one perm res rp sqrt ss ss1 t u umm usav x ypiv zero zeta Variables Type Visibility Attributes Name Initial real(kind=8), public :: beta real(kind=8), public :: delta real(kind=8), public :: distdot logical, public :: full integer, public :: i integer, public :: i2 integer, public :: indp integer, public :: ip2 integer, public :: j integer, public :: ju integer, public :: k integer, public :: lb integer, public :: lbm1 logical, public :: lp integer, public :: np real(kind=8), public :: one logical, public :: perm (3) real(kind=8), public :: res logical, public :: rp real(kind=8), public :: sqrt real(kind=8), public :: ss real(kind=8), public :: ss1 real(kind=8), public :: t real(kind=8), public :: u (3) real(kind=8), public :: umm real(kind=8), public :: usav (3) real(kind=8), public :: x real(kind=8), public :: ypiv (3) real(kind=8), public :: zero real(kind=8), public :: zeta","tags":"","loc":"proc\\dbcg.html"},{"title":"implu – LINALG","text":"subroutine implu(np, umm, beta, ypiv, u, permut, full) Arguments Type Intent Optional Attributes Name integer :: np real(kind=8) :: umm real(kind=8) :: beta real(kind=8) :: ypiv (*) real(kind=8) :: u (*) logical :: permut (*) logical :: full Contents Variables k npm1 perm x xpiv Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: npm1 logical, public :: perm real(kind=8), public :: x real(kind=8), public :: xpiv","tags":"","loc":"proc\\implu.html"},{"title":"uppdir – LINALG","text":"subroutine uppdir(n, p, np, lbp, indp, y, u, usav, flops) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: p (n,lbp) integer :: np integer :: lbp integer :: indp real(kind=8) :: y (*) real(kind=8) :: u (*) real(kind=8) :: usav (*) real(kind=8) :: flops Contents Variables j ju k npm1 x zero Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: ju integer, public :: k integer, public :: npm1 real(kind=8), public :: x real(kind=8), public :: zero","tags":"","loc":"proc\\uppdir.html"},{"title":"givens – LINALG","text":"subroutine givens(x, y, c, s) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: y real(kind=8) :: c real(kind=8) :: s Contents Variables one t zero Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: one = 1.0D0 real(kind=8), public :: t real(kind=8), public, parameter :: zero = 0.0D0","tags":"","loc":"proc\\givens.html"},{"title":"tidycg – LINALG","text":"subroutine tidycg(n, ipar, fpar, sol, delx) Arguments Type Intent Optional Attributes Name integer :: n integer :: ipar (16) real(kind=8) :: fpar (16) real(kind=8) :: sol (n) real(kind=8) :: delx (n) Contents Variables i zero Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=8), public :: zero","tags":"","loc":"proc\\tidycg.html"},{"title":"bisinit – LINALG","text":"subroutine bisinit(ipar, fpar, wksize, dsc, lp, rp, wk) Arguments Type Intent Optional Attributes Name integer :: ipar (16) real(kind=8) :: fpar (16) integer :: wksize integer :: dsc logical :: lp logical :: rp real(kind=8) :: wk (*) Contents Variables i one zero Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=8), public :: one real(kind=8), public :: zero","tags":"","loc":"proc\\bisinit.html"},{"title":"mgsro – LINALG","text":"subroutine mgsro(full, lda, n, m, ind, ops, vec, hh, ierr) Arguments Type Intent Optional Attributes Name logical :: full integer :: lda integer :: n integer :: m integer :: ind real(kind=8) :: ops real(kind=8) :: vec (lda,m) real(kind=8) :: hh (m) integer :: ierr Contents Variables fct i k nrm0 nrm1 one reorth thr zero Variables Type Visibility Attributes Name Initial real(kind=8), public :: fct integer, public :: i integer, public :: k real(kind=8), public :: nrm0 real(kind=8), public :: nrm1 real(kind=8), public, parameter :: one = 1.0D0 real(kind=8), public, parameter :: reorth = 0.98D0 real(kind=8), public :: thr real(kind=8), public, parameter :: zero = 0.0D0","tags":"","loc":"proc\\mgsro.html"},{"title":"amux – LINALG","text":"subroutine amux(n, x, y, a, ja, ia) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (*) real(kind=8) :: y (*) real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) Contents Variables i k t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\amux.html"},{"title":"amuxms – LINALG","text":"subroutine amuxms(n, x, y, a, ja) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (*) real(kind=8) :: y (*) real(kind=8) :: a (*) integer :: ja (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\amuxms.html"},{"title":"atmux – LINALG","text":"subroutine atmux(n, x, y, a, ja, ia) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (*) real(kind=8) :: y (*) real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\atmux.html"},{"title":"atmuxr – LINALG","text":"subroutine atmuxr(m, n, x, y, a, ja, ia) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=8) :: x (*) real(kind=8) :: y (*) real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\atmuxr.html"},{"title":"amuxe – LINALG","text":"subroutine amuxe(n, x, y, na, ncol, a, ja) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) integer :: na integer :: ncol real(kind=8) :: a (na,*) integer :: ja (na,*) Contents Variables i j Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc\\amuxe.html"},{"title":"amuxd – LINALG","text":"subroutine amuxd(n, x, y, diag, ndiag, idiag, ioff) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: diag (ndiag,idiag) integer :: ndiag integer :: idiag integer :: ioff (idiag) Contents Variables i1 i2 io j k Variables Type Visibility Attributes Name Initial integer, public :: i1 integer, public :: i2 integer, public :: io integer, public :: j integer, public :: k","tags":"","loc":"proc\\amuxd.html"},{"title":"amuxj – LINALG","text":"subroutine amuxj(n, x, y, jdiag, a, ja, ia) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) integer :: jdiag real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) Contents Variables i ii j k1 len Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: k1 integer, public :: len","tags":"","loc":"proc\\amuxj.html"},{"title":"vbrmv – LINALG","text":"subroutine vbrmv(nr, nc, ia, ja, a, kvstr, kvstc, x, b) Arguments Type Intent Optional Attributes Name integer :: nr integer :: nc integer :: ia (nr+1) integer :: ja (*) real(kind=8) :: a (*) integer :: kvstr (nr+1) integer :: kvstc (*) real(kind=8) :: x (*) real(kind=8) :: b (*) Contents Variables i ii istart istop j jj k n xjj Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: istart integer, public :: istop integer, public :: j integer, public :: jj integer, public :: k integer, public :: n real(kind=8), public :: xjj","tags":"","loc":"proc\\vbrmv.html"},{"title":"lsol – LINALG","text":"subroutine lsol(n, x, y, al, jal, ial) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (n+1) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\lsol.html"},{"title":"ldsol – LINALG","text":"subroutine ldsol(n, x, y, al, jal) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: al (*) integer :: jal (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\ldsol.html"},{"title":"lsolc – LINALG","text":"subroutine lsolc(n, x, y, al, jal, ial) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: al (*) integer :: jal (*) integer :: ial (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\lsolc.html"},{"title":"ldsolc – LINALG","text":"subroutine ldsolc(n, x, y, al, jal) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: al (*) integer :: jal (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\ldsolc.html"},{"title":"ldsoll – LINALG","text":"subroutine ldsoll(n, x, y, al, jal, nlev, lev, ilev) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: al (*) integer :: jal (*) integer :: nlev integer :: lev (n) integer :: ilev (nlev+1) Contents Variables i ii jrow k t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: jrow integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\ldsoll.html"},{"title":"usol – LINALG","text":"subroutine usol(n, x, y, au, jau, iau) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: au (*) integer :: jau (*) integer :: iau (n+1) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\usol.html"},{"title":"udsol – LINALG","text":"subroutine udsol(n, x, y, au, jau) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: au (*) integer :: jau (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\udsol.html"},{"title":"usolc – LINALG","text":"subroutine usolc(n, x, y, au, jau, iau) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (*) real(kind=8) :: y (*) real(kind=8) :: au (*) integer :: jau (*) integer :: iau (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\usolc.html"},{"title":"udsolc – LINALG","text":"subroutine udsolc(n, x, y, au, jau) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: y (n) real(kind=8) :: au (*) integer :: jau (*) Contents Variables j k t Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k real(kind=8), public :: t","tags":"","loc":"proc\\udsolc.html"},{"title":"getelm – LINALG","text":"function getelm(i, j, a, ja, ia, iadd, sorted) Arguments Type Intent Optional Attributes Name integer :: i integer :: j double precision :: a (*) integer :: ja (*) integer :: ia (*) integer :: iadd logical :: sorted Return Value doubleprecision Contents Variables ibeg iend imid k Variables Type Visibility Attributes Name Initial integer, public :: ibeg integer, public :: iend integer, public :: imid integer, public :: k","tags":"","loc":"proc\\getelm.html"},{"title":"submat – LINALG","text":"subroutine submat(job, i1, i2, j1, j2, a, ja, ia, nr, nc, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: job integer :: i1 integer :: i2 integer :: j1 integer :: j2 real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: nr integer :: nc real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables i ii j k k1 k2 klen Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2 integer, public :: klen","tags":"","loc":"proc\\submat.html"},{"title":"filter – LINALG","text":"subroutine filter(n, job, drptol, a, ja, ia, b, jb, ib, len, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: job real(kind=8) :: drptol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (*) integer :: len integer :: ierr Contents Variables index k k1 k2 loctol norm row Variables Type Visibility Attributes Name Initial integer, public :: index integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: loctol real(kind=8), public :: norm integer, public :: row","tags":"","loc":"proc\\filter.html"},{"title":"filterm – LINALG","text":"subroutine filterm(n, job, drop, a, ja, b, jb, len, ierr) Arguments Type Intent Optional Attributes Name integer :: n integer :: job real(kind=8) :: drop real(kind=8) :: a (*) integer :: ja (*) real(kind=8) :: b (*) integer :: jb (*) integer :: len integer :: ierr Contents Variables index k k1 k2 loctol norm row Variables Type Visibility Attributes Name Initial integer, public :: index integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: loctol real(kind=8), public :: norm integer, public :: row","tags":"","loc":"proc\\filterm.html"},{"title":"csort – LINALG","text":"subroutine csort(n, a, ja, ia, values) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (n+1) logical :: values Contents Variables i j k rj row Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k real(kind=8), public :: rj integer, public :: row","tags":"","loc":"proc\\csort.html"},{"title":"clncsr – LINALG","text":"subroutine clncsr(job, value2, nrow, a, ja, ia, indu, iwk) Arguments Type Intent Optional Attributes Name integer :: job integer :: value2 integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: indu (nrow) integer :: iwk (nrow+1) Contents Variables i ipos j k kfirst klast ko tmp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ipos integer, public :: j integer, public :: k integer, public :: kfirst integer, public :: klast integer, public :: ko real(kind=8), public :: tmp","tags":"","loc":"proc\\clncsr.html"},{"title":"copmat – LINALG","text":"subroutine copmat(nrow, a, ja, ia, ao, jao, iao, ipos, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) integer :: ipos integer :: job Contents Variables i k kst Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kst","tags":"","loc":"proc\\copmat.html"},{"title":"msrcop – LINALG","text":"subroutine msrcop(nrow, a, ja, ao, jao, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: job Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\msrcop.html"},{"title":"getdia – LINALG","text":"subroutine getdia(nrow, ncol, job, a, ja, ia, len, diag, idiag, ioff) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: job real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: len real(kind=8) :: diag (*) integer :: idiag (*) integer :: ioff Contents Variables i iend istart k kdiag ko kold max Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iend integer, public :: istart integer, public :: k integer, public :: kdiag integer, public :: ko integer, public :: kold integer, public :: max","tags":"","loc":"proc\\getdia.html"},{"title":"transp – LINALG","text":"subroutine transp(nrow, ncol, a, ja, ia, iwk, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) integer :: iwk (*) integer :: ierr Contents Variables i inext init j jcol k l nnz t t1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: inext integer, public :: init integer, public :: j integer, public :: jcol integer, public :: k integer, public :: l integer, public :: nnz real(kind=8), public :: t real(kind=8), public :: t1","tags":"","loc":"proc\\transp.html"},{"title":"getl – LINALG","text":"subroutine getl(n, a, ja, ia, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables i k kdiag ko kold t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kdiag integer, public :: ko integer, public :: kold real(kind=8), public :: t","tags":"","loc":"proc\\getl.html"},{"title":"getu – LINALG","text":"subroutine getu(n, a, ja, ia, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables i k kdiag kfirst ko t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kdiag integer, public :: kfirst integer, public :: ko real(kind=8), public :: t","tags":"","loc":"proc\\getu.html"},{"title":"levels – LINALG","text":"subroutine levels(n, jal, ial, nlev, lev, ilev, levnum) Arguments Type Intent Optional Attributes Name integer :: n integer :: jal (*) integer :: ial (*) integer :: nlev integer :: lev (*) integer :: ilev (*) integer :: levnum (*) Contents Variables i j levi Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: levi","tags":"","loc":"proc\\levels.html"},{"title":"amask – LINALG","text":"subroutine amask(nrow, ncol, a, ja, ia, jmask, imask, c, jc, ic, iw, nzmax, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) integer :: jmask (*) integer :: imask (nrow+1) real(kind=8) :: c (*) integer :: jc (*) integer :: ic (nrow+1) logical :: iw (ncol) integer :: nzmax integer :: ierr Contents Variables ii j k k1 k2 len Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2 integer, public :: len","tags":"","loc":"proc\\amask.html"},{"title":"rperm – LINALG","text":"subroutine rperm(nrow, a, ja, ia, ao, jao, iao, perm, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (nrow+1) integer :: perm (nrow) integer :: job Contents Variables i ii j k ko values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: j integer, public :: k integer, public :: ko logical, public :: values","tags":"","loc":"proc\\rperm.html"},{"title":"cperm – LINALG","text":"subroutine cperm(nrow, a, ja, ia, ao, jao, iao, perm, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (nrow+1) integer :: perm (*) integer :: job Contents Variables i k nnz Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: nnz","tags":"","loc":"proc\\cperm.html"},{"title":"dperm – LINALG","text":"subroutine dperm(nrow, a, ja, ia, ao, jao, iao, perm, qperm, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (nrow+1) integer :: perm (nrow) integer :: qperm (*) integer :: job Contents Variables locjob mod Variables Type Visibility Attributes Name Initial integer, public :: locjob integer, public :: mod","tags":"","loc":"proc\\dperm.html"},{"title":"dperm1 – LINALG","text":"subroutine dperm1(i1, i2, a, ja, ia, b, jb, ib, perm, ipos, job) Arguments Type Intent Optional Attributes Name integer :: i1 integer :: i2 real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (*) integer :: perm (*) integer :: ipos integer :: job Contents Variables i irow k ko values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: irow integer, public :: k integer, public :: ko logical, public :: values","tags":"","loc":"proc\\dperm1.html"},{"title":"dperm2 – LINALG","text":"subroutine dperm2(i1, i2, a, ja, ia, b, jb, ib, cperm, rperm, istart, ipos, job) Arguments Type Intent Optional Attributes Name integer :: i1 integer :: i2 real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (*) integer :: cperm (*) integer :: rperm (*) integer :: istart integer :: ipos integer :: job Contents Variables i irow k ko values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: irow integer, public :: k integer, public :: ko logical, public :: values","tags":"","loc":"proc\\dperm2.html"},{"title":"dmperm – LINALG","text":"subroutine dmperm(nrow, a, ja, ao, jao, perm, job) Arguments Type Intent Optional Attributes Name integer :: nrow real(kind=8) :: a (*) integer :: ja (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: perm (nrow) integer :: job Contents Variables j n1 n2 Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: n1 integer, public :: n2","tags":"","loc":"proc\\dmperm.html"},{"title":"dvperm – LINALG","text":"subroutine dvperm(n, x, perm) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) integer :: perm (n) Contents Variables ii init j k next tmp tmp1 Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: init integer, public :: j integer, public :: k integer, public :: next real(kind=8), public :: tmp real(kind=8), public :: tmp1","tags":"","loc":"proc\\dvperm.html"},{"title":"ivperm – LINALG","text":"subroutine ivperm(n, ix, perm) Arguments Type Intent Optional Attributes Name integer :: n integer :: ix (n) integer :: perm (n) Contents Variables ii init j k next tmp tmp1 Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: init integer, public :: j integer, public :: k integer, public :: next integer, public :: tmp integer, public :: tmp1","tags":"","loc":"proc\\ivperm.html"},{"title":"retmx – LINALG","text":"subroutine retmx(n, a, ja, ia, dd) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: dd (*) Contents Variables i k k1 k2 t t1 t2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: t real(kind=8), public :: t1 real(kind=8), public :: t2","tags":"","loc":"proc\\retmx.html"},{"title":"diapos – LINALG","text":"subroutine diapos(n, ja, ia, idiag) Arguments Type Intent Optional Attributes Name integer :: n integer :: ja (*) integer :: ia (n+1) integer :: idiag (n) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\diapos.html"},{"title":"dscaldg – LINALG","text":"subroutine dscaldg(n, a, ja, ia, diag, job) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: diag (*) integer :: job Contents Variables i j k k1 k2 t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: t","tags":"","loc":"proc\\dscaldg.html"},{"title":"extbdg – LINALG","text":"subroutine extbdg(n, a, ja, ia, bdiag, nblk, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: bdiag (*) integer :: nblk real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) Contents Variables i j j1 j2 jj k kb ko l ltr m Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: j1 integer, public :: j2 integer, public :: jj integer, public :: k integer, public :: kb integer, public :: ko integer, public :: l integer, public :: ltr integer, public :: m","tags":"","loc":"proc\\extbdg.html"},{"title":"getbwd – LINALG","text":"subroutine getbwd(n, ja, ia, ml, mu) Arguments Type Intent Optional Attributes Name integer :: n integer :: ja (*) integer :: ia (n+1) integer :: ml integer :: mu Contents Variables i k ldist Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: ldist","tags":"","loc":"proc\\getbwd.html"},{"title":"blkfnd – LINALG","text":"subroutine blkfnd(nrow, ja, ia, nblk) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ja (*) integer :: ia (nrow+1) integer :: nblk Contents Variables i i1 i2 iblk imsg irow jf jfirst jl jlast jrow len len0 minlen Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: i2 integer, public :: iblk integer, public :: imsg integer, public :: irow integer, public :: jf integer, public :: jfirst integer, public :: jl integer, public :: jlast integer, public :: jrow integer, public :: len integer, public :: len0 integer, public :: minlen","tags":"","loc":"proc\\blkfnd.html"},{"title":"blkchk – LINALG","text":"subroutine blkchk(nrow, ja, ia, nblk, imsg) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ja (*) integer :: ia (nrow+1) integer :: nblk integer :: imsg Contents Variables i i1 ii irow j j2 jstart k len lena nr Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i1 integer, public :: ii integer, public :: irow integer, public :: j integer, public :: j2 integer, public :: jstart integer, public :: k integer, public :: len integer, public :: lena integer, public :: nr","tags":"","loc":"proc\\blkchk.html"},{"title":"infdia – LINALG","text":"subroutine infdia(n, ja, ia, ind, idiag) Arguments Type Intent Optional Attributes Name integer :: n integer :: ja (*) integer :: ia (*) integer :: ind (*) integer :: idiag Contents Variables i j k n2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: n2","tags":"","loc":"proc\\infdia.html"},{"title":"amubdg – LINALG","text":"subroutine amubdg(nrow, ncol, ncolb, ja, ia, jb, ib, ndegr, nnz, iw) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: ncolb integer :: ja (*) integer :: ia (nrow+1) integer :: jb (*) integer :: ib (ncol+1) integer :: ndegr (nrow) integer :: nnz integer :: iw (ncolb) Contents Variables ii j jc jr k last ldg Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: jc integer, public :: jr integer, public :: k integer, public :: last integer, public :: ldg","tags":"","loc":"proc\\amubdg.html"},{"title":"aplbdg – LINALG","text":"subroutine aplbdg(nrow, ncol, ja, ia, jb, ib, ndegr, nnz, iw) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: ncol integer :: ja (*) integer :: ia (nrow+1) integer :: jb (*) integer :: ib (nrow+1) integer :: ndegr (nrow) integer :: nnz integer :: iw (ncol) Contents Variables ii j jc jr k last ldg Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: jc integer, public :: jr integer, public :: k integer, public :: last integer, public :: ldg","tags":"","loc":"proc\\aplbdg.html"},{"title":"rnrms – LINALG","text":"subroutine rnrms(nrow, nrm, a, ia, diag) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: nrm real(kind=8) :: a (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) Contents Variables ii k k1 k2 scal Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: k integer, public :: k1 integer, public :: k2 real(kind=8), public :: scal","tags":"","loc":"proc\\rnrms.html"},{"title":"cnrms – LINALG","text":"subroutine cnrms(nrow, nrm, a, ja, ia, diag) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: nrm real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) Contents Variables ii j k k1 k2 Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: k integer, public :: k1 integer, public :: k2","tags":"","loc":"proc\\cnrms.html"},{"title":"roscal – LINALG","text":"subroutine roscal(nrow, job, nrm, a, ja, ia, diag, b, jb, ib, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job integer :: nrm real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) integer :: ierr Contents Variables j Variables Type Visibility Attributes Name Initial integer, public :: j","tags":"","loc":"proc\\roscal.html"},{"title":"coscal – LINALG","text":"subroutine coscal(nrow, job, nrm, a, ja, ia, diag, b, jb, ib, ierr) Arguments Type Intent Optional Attributes Name integer :: nrow integer :: job integer :: nrm real(kind=8) :: a (*) integer :: ja (*) integer :: ia (nrow+1) real(kind=8) :: diag (nrow) real(kind=8) :: b (*) integer :: jb (*) integer :: ib (nrow+1) integer :: ierr Contents Variables j Variables Type Visibility Attributes Name Initial integer, public :: j","tags":"","loc":"proc\\coscal.html"},{"title":"addblk – LINALG","text":"subroutine addblk(nrowa, ncola, a, ja, ia, ipos, jpos, job, nrowb, ncolb, b, jb, ib, nrowc, ncolc, c, jc, ic, nzmx, ierr) Arguments Type Intent Optional Attributes Name integer :: nrowa integer :: ncola real(kind=8) :: a (1:*) integer :: ja (1:*) integer :: ia (1:*) integer :: ipos integer :: jpos integer :: job integer :: nrowb integer :: ncolb real(kind=8) :: b (1:*) integer :: jb (1:*) integer :: ib (1:*) integer :: nrowc integer :: ncolc real(kind=8) :: c (1:*) integer :: jc (1:*) integer :: ic (1:*) integer :: nzmx integer :: ierr Contents Variables i j1 j2 ka kamax kb kbmax kc values Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j1 integer, public :: j2 integer, public :: ka integer, public :: kamax integer, public :: kb integer, public :: kbmax integer, public :: kc logical, public :: values","tags":"","loc":"proc\\addblk.html"},{"title":"get1up – LINALG","text":"subroutine get1up(n, ja, ia, ju) Arguments Type Intent Optional Attributes Name integer :: n integer :: ja (*) integer :: ia (*) integer :: ju (*) Contents Variables i k Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc\\get1up.html"},{"title":"xtrows – LINALG","text":"subroutine xtrows(i1, i2, a, ja, ia, ao, jao, iao, iperm, job) Arguments Type Intent Optional Attributes Name integer :: i1 integer :: i2 real(kind=8) :: a (*) integer :: ja (*) integer :: ia (*) real(kind=8) :: ao (*) integer :: jao (*) integer :: iao (*) integer :: iperm (*) integer :: job Contents Variables ii j k ko values Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: j integer, public :: k integer, public :: ko logical, public :: values","tags":"","loc":"proc\\xtrows.html"},{"title":"csrkvstr – LINALG","text":"subroutine csrkvstr(n, ia, ja, nr, kvstr) Arguments Type Intent Optional Attributes Name integer :: n integer :: ia (n+1) integer :: ja (*) integer :: nr integer :: kvstr (*) Contents Variables i j jdiff Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jdiff","tags":"","loc":"proc\\csrkvstr.html"},{"title":"csrkvstc – LINALG","text":"subroutine csrkvstc(n, ia, ja, nc, kvstc, iwk) Arguments Type Intent Optional Attributes Name integer :: n integer :: ia (n+1) integer :: ja (*) integer :: nc integer :: kvstc (*) integer :: iwk (*) Contents Variables i j k ncol Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: ncol","tags":"","loc":"proc\\csrkvstc.html"},{"title":"kvstmerge – LINALG","text":"subroutine kvstmerge(nr, kvstr, nc, kvstc, n, kvst) Arguments Type Intent Optional Attributes Name integer :: nr integer :: kvstr (nr+1) integer :: nc integer :: kvstc (nc+1) integer :: n integer :: kvst (*) Contents Variables i j Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc\\kvstmerge.html"},{"title":"DDOT – LINALG","text":"interface public pure function DDOT(n, dx, incx, dy, incy) result(rst) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: dx (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: dy (*) integer(kind=int32), intent(in) :: incy Return Value real(kind=real64)","tags":"","loc":"interface\\ddot.html"},{"title":"DGBMV – LINALG","text":"interface public pure subroutine DGBMV(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: kl integer(kind=int32), intent(in) :: ku real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy","tags":"","loc":"interface\\dgbmv.html"},{"title":"DGEMM – LINALG","text":"interface public pure subroutine DGEMM(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc","tags":"","loc":"interface\\dgemm.html"},{"title":"DGEMV – LINALG","text":"interface public pure subroutine DGEMV(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy","tags":"","loc":"interface\\dgemv.html"},{"title":"DSCAL – LINALG","text":"interface public pure subroutine DSCAL(n, da, dx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: da real(kind=real64), intent(inout) :: dx (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"interface\\dscal.html"},{"title":"DSWAP – LINALG","text":"interface public pure subroutine DSWAP(n, dx, incx, dy, incy) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: dx (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(inout) :: dy (*) integer(kind=int32), intent(in) :: incy","tags":"","loc":"interface\\dswap.html"},{"title":"DTRSM – LINALG","text":"interface public pure subroutine DTRSM(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb","tags":"","loc":"interface\\dtrsm.html"},{"title":"DTRSV – LINALG","text":"interface public pure subroutine DTRSV(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: x (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"interface\\dtrsv.html"},{"title":"ZDSCAL – LINALG","text":"interface public pure subroutine ZDSCAL(n, da, zx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: da complex(kind=real64), intent(inout) :: zx (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"interface\\zdscal.html"},{"title":"ZGBMV – LINALG","text":"interface public pure subroutine ZGBMV(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: kl integer(kind=int32), intent(in) :: ku complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy","tags":"","loc":"interface\\zgbmv.html"},{"title":"ZGEMM – LINALG","text":"interface public pure subroutine ZGEMM(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc","tags":"","loc":"interface\\zgemm.html"},{"title":"ZGEMV – LINALG","text":"interface public pure subroutine ZGEMV(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy","tags":"","loc":"interface\\zgemv.html"},{"title":"ZSCAL – LINALG","text":"interface public pure subroutine ZSCAL(n, za, zx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(inout) :: zx (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"interface\\zscal.html"},{"title":"ZTRSM – LINALG","text":"interface public pure subroutine ZTRSM(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb","tags":"","loc":"interface\\ztrsm.html"},{"title":"ZTRSV – LINALG","text":"interface public pure subroutine ZTRSV(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"interface\\ztrsv.html"},{"title":"DGEEV – LINALG","text":"interface public pure subroutine DGEEV(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: wr (*) real(kind=real64), intent(out) :: wi (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgeev.html"},{"title":"DGELQF – LINALG","text":"interface public pure subroutine DGELQF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgelqf.html"},{"title":"DGELS – LINALG","text":"interface public pure subroutine DGELS(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgels.html"},{"title":"DGELSS – LINALG","text":"interface public pure subroutine DGELSS(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgelss.html"},{"title":"DGELSY – LINALG","text":"interface public pure subroutine DGELSY(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgelsy.html"},{"title":"DGEQP3 – LINALG","text":"interface public pure subroutine DGEQP3(m, n, a, lda, jpvt, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgeqp3.html"},{"title":"DGEQRF – LINALG","text":"interface public pure subroutine DGEQRF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgeqrf.html"},{"title":"DGESV – LINALG","text":"interface public pure subroutine DGESV(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgesv.html"},{"title":"DGESVD – LINALG","text":"interface public pure subroutine DGESVD(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(out) :: u (ldu,*) integer(kind=int32), intent(in) :: ldu real(kind=real64), intent(out) :: vt (ldvt,*) integer(kind=int32), intent(in) :: ldvt real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgesvd.html"},{"title":"DGETRF – LINALG","text":"interface public pure subroutine DGETRF(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgetrf.html"},{"title":"DGETRI – LINALG","text":"interface public pure subroutine DGETRI(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgetri.html"},{"title":"DGETRS – LINALG","text":"interface public pure subroutine DGETRS(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dgetrs.html"},{"title":"DGGEV – LINALG","text":"interface public pure subroutine DGGEV(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: alphar (*) real(kind=real64), intent(out) :: alphai (*) real(kind=real64), intent(out) :: beta (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dggev.html"},{"title":"DGGEV3 – LINALG","text":"interface public pure subroutine DGGEV3(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: alphar (*) real(kind=real64), intent(out) :: alphai (*) real(kind=real64), intent(out) :: beta (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dggev3.html"},{"title":"DLAIC1 – LINALG","text":"interface public pure subroutine DLAIC1(job, j, x, sest, w, gamma, sestpr, s, c) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: j real(kind=real64), intent(in) :: x (j) real(kind=real64), intent(in) :: sest real(kind=real64), intent(in) :: w (j) real(kind=real64), intent(in) :: gamma real(kind=real64), intent(out) :: sestpr real(kind=real64), intent(out) :: s real(kind=real64), intent(out) :: c","tags":"","loc":"interface\\dlaic1.html"},{"title":"DLAMCH – LINALG","text":"interface public pure function DLAMCH(cmach) result(x) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real64)","tags":"","loc":"interface\\dlamch.html"},{"title":"DLASET – LINALG","text":"interface public pure subroutine DLASET(uplo, m, n, alpha, beta, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: beta real(kind=real64), intent(out) :: a (lda,*) integer(kind=int32), intent(in) :: lda","tags":"","loc":"interface\\dlaset.html"},{"title":"DLASRT – LINALG","text":"interface public pure subroutine DLASRT(id, n, d, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: id integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: d (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dlasrt.html"},{"title":"DORGLQ – LINALG","text":"interface public pure subroutine DORGLQ(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dorglq.html"},{"title":"DORGQR – LINALG","text":"interface public pure subroutine DORGQR(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dorgqr.html"},{"title":"DORMLQ – LINALG","text":"interface public pure subroutine DORMLQ(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dormlq.html"},{"title":"DORMQR – LINALG","text":"interface public pure subroutine DORMQR(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dormqr.html"},{"title":"DORMRZ – LINALG","text":"interface public pure subroutine DORMRZ(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k integer(kind=int32), intent(in) :: l real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dormrz.html"},{"title":"DPOTRF – LINALG","text":"interface public pure subroutine DPOTRF(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dpotrf.html"},{"title":"DPOTRS – LINALG","text":"interface public pure subroutine DPOTRS(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dpotrs.html"},{"title":"DSYEV – LINALG","text":"interface public pure subroutine DSYEV(jobz, uplo, n, a, lda, w, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: w (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dsyev.html"},{"title":"DTZRZF – LINALG","text":"interface public pure subroutine DTZRZF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dtzrzf.html"},{"title":"ZGEEV – LINALG","text":"interface public pure subroutine ZGEEV(jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: w (*) complex(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl complex(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgeev.html"},{"title":"ZGELQF – LINALG","text":"interface public pure subroutine ZGELQF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgelqf.html"},{"title":"ZGELS – LINALG","text":"interface public pure subroutine ZGELS(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgels.html"},{"title":"ZGELSS – LINALG","text":"interface public pure subroutine ZGELSS(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgelss.html"},{"title":"ZGELSY – LINALG","text":"interface public pure subroutine ZGELSY(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgelsy.html"},{"title":"ZGEQP3 – LINALG","text":"interface public pure subroutine ZGEQP3(m, n, a, lda, jpvt, tau, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(inout) :: jpvt (*) complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgeqp3.html"},{"title":"ZGEQRF – LINALG","text":"interface public pure subroutine ZGEQRF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgeqrf.html"},{"title":"ZGESVD – LINALG","text":"interface public pure subroutine ZGESVD(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: s (*) complex(kind=real64), intent(out) :: u (ldu,*) integer(kind=int32), intent(in) :: ldu complex(kind=real64), intent(out) :: vt (ldvt,*) integer(kind=int32), intent(in) :: ldvt complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgesvd.html"},{"title":"ZGETRF – LINALG","text":"interface public pure subroutine ZGETRF(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgetrf.html"},{"title":"ZGETRI – LINALG","text":"interface public pure subroutine ZGETRI(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgetri.html"},{"title":"ZGETRS – LINALG","text":"interface public pure subroutine ZGETRS(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zgetrs.html"},{"title":"ZLAIC1 – LINALG","text":"interface public pure subroutine ZLAIC1(job, j, x, sest, w, gamma, sestpr, s, c) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: j complex(kind=real64), intent(in) :: x (j) real(kind=real64), intent(in) :: sest complex(kind=real64), intent(in) :: w (j) complex(kind=real64), intent(in) :: gamma real(kind=real64), intent(out) :: sestpr complex(kind=real64), intent(out) :: s complex(kind=real64), intent(out) :: c","tags":"","loc":"interface\\zlaic1.html"},{"title":"ZPOTRF – LINALG","text":"interface public pure subroutine ZPOTRF(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zpotrf.html"},{"title":"ZPOTRS – LINALG","text":"interface public pure subroutine ZPOTRS(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zpotrs.html"},{"title":"ZTZRZF – LINALG","text":"interface public pure subroutine ZTZRZF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\ztzrzf.html"},{"title":"ZUNGLQ – LINALG","text":"interface public pure subroutine ZUNGLQ(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zunglq.html"},{"title":"ZUNGQR – LINALG","text":"interface public pure subroutine ZUNGQR(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zungqr.html"},{"title":"ZUNMLQ – LINALG","text":"interface public pure subroutine ZUNMLQ(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zunmlq.html"},{"title":"ZUNMQR – LINALG","text":"interface public pure subroutine ZUNMQR(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zunmqr.html"},{"title":"zunmrz – LINALG","text":"interface public pure subroutine zunmrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k integer(kind=int32), intent(in) :: l complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zunmrz.html"},{"title":"band_diag_mtx_mult – LINALG","text":"public interface band_diag_mtx_mult An interface to the banded diagonal matrix multiplication routines. Contents Module Procedures band_diag_mtx_mult_dbl band_diag_mtx_mult_cmplx Module Procedures private  subroutine band_diag_mtx_mult_dbl(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. real(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_diag_mtx_mult_cmplx(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. complex(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_diag_mtx_mult.html"},{"title":"band_mtx_mult – LINALG","text":"public interface band_mtx_mult An interface to the banded matrix multiplication routines. Contents Module Procedures band_mtx_vec_mult_dbl band_mtx_vec_mult_cmplx Module Procedures private  subroutine band_mtx_vec_mult_dbl(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation or where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating whether to perform the operation (FALSE) or (TRUE). integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. real(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_mtx_vec_mult_cmplx(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: trans An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. complex(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_mtx_mult.html"},{"title":"band_mtx_to_full_mtx – LINALG","text":"public interface band_mtx_to_full_mtx An interface to the banded matrix to full matrix conversion routines. Contents Module Procedures band_to_full_mtx_dbl band_to_full_mtx_cmplx Module Procedures private  subroutine band_to_full_mtx_dbl(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_to_full_mtx_cmplx(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. complex(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_mtx_to_full_mtx.html"},{"title":"banded_to_dense – LINALG","text":"public interface banded_to_dense An interface to the banded to dense matrix conversion routines. Contents Module Procedures banded_to_dense_dbl banded_to_dense_cmplx Module Procedures private  subroutine banded_to_dense_dbl(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. real(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine banded_to_dense_cmplx(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. complex(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\banded_to_dense.html"},{"title":"dense_to_banded – LINALG","text":"public interface dense_to_banded An interface to the dense to banded matrix conversion routines. Contents Module Procedures dense_to_banded_dbl dense_to_banded_cmplx Module Procedures private  subroutine dense_to_banded_dbl(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine dense_to_banded_cmplx(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\dense_to_banded.html"},{"title":"det – LINALG","text":"public interface det An interface to the determinant routines. Contents Module Procedures det_dbl det_cmplx Module Procedures private  function det_dbl(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value real(kind=real64) The determinant of the matrix. private  function det_cmplx(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value complex(kind=real64) The determinant of the matrix.","tags":"","loc":"interface\\det.html"},{"title":"diag_mtx_mult – LINALG","text":"public interface diag_mtx_mult An interface to the diagonal matrix multiplication routines. Contents Module Procedures diag_mtx_mult_mtx diag_mtx_mult_mtx2 diag_mtx_mult_mtx3 diag_mtx_mult_mtx4 diag_mtx_mult_mtx_cmplx diag_mtx_mult_mtx2_cmplx diag_mtx_mult_mtx_mix diag_mtx_mult_mtx2_mix diag_mtx_sparse_mult Module Procedures private  subroutine diag_mtx_mult_mtx(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx3(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx4(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_cmplx(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_cmplx(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_mix(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_mix(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_sparse_mult(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix and is a sparse matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in), dimension(:) :: a class( csr_matrix ), intent(inout) :: b class(errors), intent(inout), optional, target :: err","tags":"","loc":"interface\\diag_mtx_mult.html"},{"title":"extract_diagonal – LINALG","text":"public interface extract_diagonal An interface to the diagonal extraction routines. Contents Module Procedures extract_diagonal_dbl extract_diagonal_cmplx extract_diagonal_csr Module Procedures private  subroutine extract_diagonal_dbl(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_cmplx(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. complex(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_csr(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\extract_diagonal.html"},{"title":"mtx_mult – LINALG","text":"public interface mtx_mult An interface to the matrix multiplication routines. Contents Module Procedures mtx_mult_mtx mtx_mult_vec cmtx_mult_mtx cmtx_mult_vec Module Procedures private  subroutine mtx_mult_mtx(transa, transb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: transa A logical flag indicating if the matrix should be transposed. logical, intent(in) :: transb A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine mtx_mult_vec(trans, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:) :: b The vector in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the vector . real(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_mtx(opa, opb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_vec(opa, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:) :: b The vector in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the vector . complex(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\mtx_mult.html"},{"title":"mtx_rank – LINALG","text":"public interface mtx_rank An interface to the matrix rank routines. Contents Module Procedures mtx_rank_dbl mtx_rank_cmplx Module Procedures private  function mtx_rank_dbl(a, tol, work, olwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value integer(kind=int32) The rank of the matrix. private  function mtx_rank_cmplx(a, tol, work, olwork, rwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any\nlocal memory allocation for real-valued workspace arrays.  If not \nprovided, the memory required is allocated within.  If provided, the\nlength of the array must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The rank of the matrix. Return Value integer(kind=int32) The rank of the matrix.","tags":"","loc":"interface\\mtx_rank.html"},{"title":"rank1_update – LINALG","text":"public interface rank1_update An interface to the rank-1 update routines. Contents Module Procedures rank1_update_dbl rank1_update_cmplx Module Procedures private  subroutine rank1_update_dbl(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . real(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. real(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. real(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine rank1_update_cmplx(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . complex(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. complex(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\rank1_update.html"},{"title":"recip_mult_array – LINALG","text":"public interface recip_mult_array An interface to the reciprocal multiplication routines. Contents Module Procedures recip_mult_array_dbl Module Procedures private  subroutine recip_mult_array_dbl(a, x) Computes the product of a scalar and a vector, where the scalar is \nthe reciprocal of the scalar A. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar A, which is the reciprocal of the scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: x On input, the vector to multiply.  On output, the product of the\nvector and the scalar reciprocal.","tags":"","loc":"interface\\recip_mult_array.html"},{"title":"swap – LINALG","text":"public interface swap An interface to the swap routines. Contents Module Procedures swap_dbl swap_cmplx Module Procedures private  subroutine swap_dbl(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the \nfirst array are copied to the second array. real(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the \nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine swap_cmplx(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the\nfirst array are copied to the second array. complex(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the\nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\swap.html"},{"title":"trace – LINALG","text":"public interface trace An interface to the trace routines. Contents Module Procedures trace_dbl trace_cmplx Module Procedures private pure function trace_dbl(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value real(kind=real64) The trace of the matrix. private pure function trace_cmplx(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value complex(kind=real64) The trace of the matrix.","tags":"","loc":"interface\\trace.html"},{"title":"tri_mtx_mult – LINALG","text":"public interface tri_mtx_mult An interface to the triangular matrix multiplication routines. Contents Module Procedures tri_mtx_mult_dbl tri_mtx_mult_cmplx Module Procedures private  subroutine tri_mtx_mult_dbl(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular \n(TRUE) or lower triangular (FALSE). real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine tri_mtx_mult_cmplx(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular\n(TRUE) or lower triangular (FALSE). complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\tri_mtx_mult.html"},{"title":"cholesky_factor – LINALG","text":"public interface cholesky_factor Contents Module Procedures cholesky_factor_dbl cholesky_factor_cmplx Module Procedures private  subroutine cholesky_factor_dbl(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine cholesky_factor_cmplx(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\cholesky_factor.html"},{"title":"cholesky_rank1_downdate – LINALG","text":"public interface cholesky_rank1_downdate Contents Module Procedures cholesky_rank1_downdate_dbl cholesky_rank1_downdate_cmplx Module Procedures private  subroutine cholesky_rank1_downdate_dbl(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_downdate_cmplx(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\cholesky_rank1_downdate.html"},{"title":"cholesky_rank1_update – LINALG","text":"public interface cholesky_rank1_update Contents Module Procedures cholesky_rank1_update_dbl cholesky_rank1_update_cmplx Module Procedures private  subroutine cholesky_rank1_update_dbl(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_update_cmplx(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\cholesky_rank1_update.html"},{"title":"solve_cholesky – LINALG","text":"public interface solve_cholesky Contents Module Procedures solve_cholesky_mtx solve_cholesky_mtx_cmplx solve_cholesky_vec solve_cholesky_vec_cmplx Module Procedures private  subroutine solve_cholesky_mtx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_mtx_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\solve_cholesky.html"},{"title":"la_band_diag_mtx_mult – LINALG","text":"public  function la_band_diag_mtx_mult(left, m, n, kl, ku, alpha, a, lda, b) result(flag) bind(C, name = \"la_band_diag_mtx_mult\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: left integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: b (*) Return Value integer(kind=c_int) Contents Variables err ma nb Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: nb","tags":"","loc":"proc\\la_band_diag_mtx_mult.html"},{"title":"la_band_diag_mtx_mult_cmplx – LINALG","text":"public  function la_band_diag_mtx_mult_cmplx(left, m, n, kl, ku, alpha, a, lda, b) result(flag) bind(C, name = \"la_band_diag_mtx_mult_cmplx\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: left integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: b (*) Return Value integer(kind=c_int) Contents Variables err ma nb Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: nb","tags":"","loc":"proc\\la_band_diag_mtx_mult_cmplx.html"},{"title":"la_band_mtx_vec_mult – LINALG","text":"public  function la_band_mtx_vec_mult(trans, m, n, kl, ku, alpha, a, lda, x, beta, y) result(flag) bind(C, name = \"la_band_mtx_vec_mult\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: x (*) real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: y (*) Return Value integer(kind=c_int) Contents Variables err ma nx ny Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: nx integer(kind=c_int), public :: ny","tags":"","loc":"proc\\la_band_mtx_vec_mult.html"},{"title":"la_band_mtx_vec_mult_cmplx – LINALG","text":"public  function la_band_mtx_vec_mult_cmplx(trans, m, n, kl, ku, alpha, a, lda, x, beta, y) result(flag) bind(C, name = \"la_band_mtx_vec_mult_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: x (*) complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: y (*) Return Value integer(kind=c_int) Contents Variables err ma nx ny Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: nx integer(kind=c_int), public :: ny","tags":"","loc":"proc\\la_band_mtx_vec_mult_cmplx.html"},{"title":"la_band_to_full_mtx – LINALG","text":"public  function la_band_to_full_mtx(m, n, kl, ku, b, ldb, f, ldf) result(flag) bind(C, name = \"la_band_to_full_mtx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(out) :: f (ldf,*) integer(kind=c_int), intent(in), value :: ldf Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_band_to_full_mtx.html"},{"title":"la_band_to_full_mtx_cmplx – LINALG","text":"public  function la_band_to_full_mtx_cmplx(m, n, kl, ku, b, ldb, f, ldf) result(flag) bind(C, name = \"la_band_to_full_mtx_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(out) :: f (ldf,*) integer(kind=c_int), intent(in), value :: ldf Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_band_to_full_mtx_cmplx.html"},{"title":"la_cholesky_factor – LINALG","text":"public  function la_cholesky_factor(upper, n, a, lda) result(flag) bind(C, name = \"la_cholesky_factor\")) @brief Computes the Cholesky factorization of a symmetric, positive\ndefinite matrix. @param[in] upper Set to true to compute the upper triangular factoriztion\n A = U T * U; else, set to false to compute the lower triangular\n factorzation A = L * L T.\n@param[in] n The dimension of matrix A.\n@param[in,out] a On input, the N-by-N matrix to factor.  On output, the\n factored matrix is returned in either the upper or lower triangular\n portion of the matrix, dependent upon the value of @p upper.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_MATRIX_FORMAT_ERROR: Occurs if @p a is not positive definite. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_factor.html"},{"title":"la_cholesky_factor_cmplx – LINALG","text":"public  function la_cholesky_factor_cmplx(upper, n, a, lda) result(flag) bind(C, name = \"la_cholesky_factor_cmplx\")) @brief Computes the Cholesky factorization of a symmetric, positive\ndefinite matrix. @param[in] upper Set to true to compute the upper triangular factoriztion\n A = U H * U; else, set to false to compute the lower triangular\n factorzation A = L * L H.\n@param[in] n The dimension of matrix A.\n@param[in,out] a On input, the N-by-N matrix to factor.  On output, the\n factored matrix is returned in either the upper or lower triangular\n portion of the matrix, dependent upon the value of @p upper.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_MATRIX_FORMAT_ERROR: Occurs if @p a is not positive definite. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_factor_cmplx.html"},{"title":"la_cholesky_rank1_downdate – LINALG","text":"public  function la_cholesky_rank1_downdate(n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_downdate\")) @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper\ntriangular). @param[in] n The dimension of the matrix.\n@param[in,out] r On input, the N-by-N upper triangular matrix R.  On\n output, the updated matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the N-element update vector U.  On output,\n the rotation sines used to transform R to R1. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not\n     positive definite. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_rank1_downdate.html"},{"title":"la_cholesky_rank1_downdate_cmplx – LINALG","text":"public  function la_cholesky_rank1_downdate_cmplx(n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_downdate_cmplx\")) @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper\ntriangular). @param[in] n The dimension of the matrix.\n@param[in,out] r On input, the N-by-N upper triangular matrix R.  On\n output, the updated matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the N-element update vector U.  On output,\n the rotation sines used to transform R to R1. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not\n     positive definite. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_rank1_downdate_cmplx.html"},{"title":"la_cholesky_rank1_update – LINALG","text":"public  function la_cholesky_rank1_update(n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_update\")) @brief Computes the rank 1 update to a Cholesky factored matrix (upper\ntriangular). @param[in] n The dimension of the matrix.\n@param[in,out] r On input, the N-by-N upper triangular matrix R.  On\n output, the updated matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the N-element update vector U.  On output,\n the rotation sines used to transform R to R1. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_rank1_update.html"},{"title":"la_cholesky_rank1_update_cmplx – LINALG","text":"public  function la_cholesky_rank1_update_cmplx(n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_update_cmplx\")) @brief Computes the rank 1 update to a Cholesky factored matrix (upper\ntriangular). @param[in] n The dimension of the matrix.\n@param[in,out] r On input, the N-by-N upper triangular matrix R.  On\n output, the updated matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the N-element update vector U.  On output,\n the rotation sines used to transform R to R1. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_cholesky_rank1_update_cmplx.html"},{"title":"la_det – LINALG","text":"public  function la_det(n, a, lda, d) result(flag) bind(C, name=\"la_det\")) @brief Computes the determinant of a square matrix. @param n The dimension of the matrix.\n@param a The N-by-N matrix.  The matrix is overwritten on output.\n@param lda The leading dimension of the matrix.\n@param[out] d The determinant of @p a. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized\n     appropriately.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: d Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_det.html"},{"title":"la_det_cmplx – LINALG","text":"public  function la_det_cmplx(n, a, lda, d) result(flag) bind(C, name=\"la_det_cmplx\")) @brief Computes the determinant of a square matrix. @param n The dimension of the matrix.\n@param a The N-by-N matrix.  The matrix is overwritten on output.\n@param lda The leading dimension of the matrix.\n@param[out] d The determinant of @p a. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized\n     appropriately.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: d Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_det_cmplx.html"},{"title":"la_diag_mtx_mult – LINALG","text":"public  function la_diag_mtx_mult(lside, transb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_diag_mtx_mult\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. @param lside Set to true to apply matrix A from the left; else, set\n to false to apply matrix A from the left.\n@param trans Set to true if op(B) == B**T; else, set to false if\n op(B) == B.\n@param m The number of rows in the matrix C.\n@param n The number of columns in the matrix C.\n@param k The inner dimension of the matrix product A * op(B).\n@param alpha A scalar multiplier.\n@param a A P-element array containing the diagonal elements of matrix A\n where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k)\n if @p lside is false.\n@param b The LDB-by-TDB matrix B where (LDB = leading dimension of B,\n and TDB = trailing dimension of B):\n - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k\n - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n\n - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m\n - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k\n@param ldb The leading dimension of matrix B.\n@param beta A scalar multiplier.\n@param c The @p m by @p n matrix C.\n@param ldc The leading dimension of matrix C. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not\n     correct.\n - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are\n     incorrect. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: transb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (*) real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ls ncols nrows p tb Variables Type Visibility Attributes Name Initial type(errors), public :: err logical, public :: ls integer(kind=c_int), public :: ncols integer(kind=c_int), public :: nrows integer(kind=c_int), public :: p logical, public :: tb","tags":"","loc":"proc\\la_diag_mtx_mult.html"},{"title":"la_diag_mtx_mult_cmplx – LINALG","text":"public  function la_diag_mtx_mult_cmplx(lside, opb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_diag_mtx_mult_cmplx\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. @param lside Set to true to apply matrix A from the left; else, set\n to false to apply matrix A from the left.\n@param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B,\n set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose\n of B, otherwise, set to NO_OPERATION to compute op(B) as B.\n@param m The number of rows in the matrix C.\n@param n The number of columns in the matrix C.\n@param k The inner dimension of the matrix product A * op(B).\n@param alpha A scalar multiplier.\n@param a A P-element array containing the diagonal elements of matrix A\n where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k)\n if @p lside is false.\n@param b The LDB-by-TDB matrix B where (LDB = leading dimension of B,\n and TDB = trailing dimension of B):\n - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k\n - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n\n - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m\n - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k\n@param ldb The leading dimension of matrix B.\n@param beta A scalar multiplier.\n@param c The @p m by @p n matrix C.\n@param ldc The leading dimension of matrix C. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not\n     correct.\n - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are\n     incorrect. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (*) complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ls ncols nrows p tb Variables Type Visibility Attributes Name Initial type(errors), public :: err logical, public :: ls integer(kind=c_int), public :: ncols integer(kind=c_int), public :: nrows integer(kind=c_int), public :: p logical, public :: tb","tags":"","loc":"proc\\la_diag_mtx_mult_cmplx.html"},{"title":"la_diag_mtx_mult_mixed – LINALG","text":"public  function la_diag_mtx_mult_mixed(lside, opb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name = \"la_diag_mtx_mult_mixed\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. @param lside Set to true to apply matrix A from the left; else, set\n to false to apply matrix A from the left.\n@param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B,\n set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose\n of B, otherwise, set to NO_OPERATION to compute op(B) as B.\n@param m The number of rows in the matrix C.\n@param n The number of columns in the matrix C.\n@param k The inner dimension of the matrix product A * op(B).\n@param alpha A scalar multiplier.\n@param a A P-element array containing the diagonal elements of matrix A\n where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k)\n if @p lside is false.\n@param b The LDB-by-TDB matrix B where (LDB = leading dimension of B,\n and TDB = trailing dimension of B):\n - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k\n - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n\n - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m\n - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k\n@param ldb The leading dimension of matrix B.\n@param beta A scalar multiplier.\n@param c The @p m by @p n matrix C.\n@param ldc The leading dimension of matrix C. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not\n     correct.\n - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are\n     incorrect. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (*) complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ls ncols nrows p tb Variables Type Visibility Attributes Name Initial type(errors), public :: err logical, public :: ls integer(kind=c_int), public :: ncols integer(kind=c_int), public :: nrows integer(kind=c_int), public :: p logical, public :: tb","tags":"","loc":"proc\\la_diag_mtx_mult_mixed.html"},{"title":"la_eigen_asymm – LINALG","text":"public  function la_eigen_asymm(vecs, n, a, lda, vals, v, ldv) result(flag) bind(C, name = \"la_eigen_asymm\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix. @param[in] vecs Set to true to compute the eigenvectors as well as the\n eigenvalues; else, set to false to just compute the eigenvalues.\n@param[in] n The dimension of the matrix.\n@param[in,out] a On input, the N-by-N matrix on which to operate.  On\n output, the contents of this matrix are overwritten.\n@param[in] lda The leading dimension of matrix A.\n@param[out] vals An N-element array containing the eigenvalues of the\n matrix.  The eigenvalues are not sorted.\n@param[out] v An N-by-N matrix where the right eigenvectors will be\n written (one per column). @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: vals (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_eigen_asymm.html"},{"title":"la_eigen_cmplx – LINALG","text":"public  function la_eigen_cmplx(vecs, n, a, lda, vals, v, ldv) result(flag) bind(C, name = \"la_eigen_cmplx\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix. @param[in] vecs Set to true to compute the eigenvectors as well as the\n eigenvalues; else, set to false to just compute the eigenvalues.\n@param[in] n The dimension of the matrix.\n@param[in,out] a On input, the N-by-N matrix on which to operate.  On\n output, the contents of this matrix are overwritten.\n@param[in] lda The leading dimension of matrix A.\n@param[out] vals An N-element array containing the eigenvalues of the\n matrix.  The eigenvalues are not sorted.\n@param[out] v An N-by-N matrix where the right eigenvectors will be\n written (one per column). @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: vals (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_eigen_cmplx.html"},{"title":"la_eigen_gen – LINALG","text":"public  function la_eigen_gen(vecs, n, a, lda, b, ldb, alpha, beta, v, ldv) result(flag) bind(C, name = \"la_eigen_gen\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix assuming the structure of the eigenvalue problem is\nA X = lambda B*X. @param[in] vecs Set to true to compute the eigenvectors as well as the\n eigenvalues; else, set to false to just compute the eigenvalues.\n@param[in] n The dimension of the matrix.\n@param[in,out] a On input, the N-by-N matrix A.  On output, the contents\n of this matrix are overwritten.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b On input, the N-by-N matrix B.  On output, the contents\n of this matrix are overwritten.\n@param[in] ldb The leading dimension of matrix B.\n@param[out] alpha An N-element array that, if @p beta is not supplied,\n contains the eigenvalues.  If @p beta is supplied however, the\n eigenvalues must be computed as ALPHA / BETA.  This however, is not as\n trivial as it seems as it is entirely possible, and likely, that\n ALPHA / BETA can overflow or underflow.  With that said, the values in\n ALPHA will always be less than and usually comparable with the NORM(A).\n@param[out] beta An optional N-element array that if provided forces\n @p alpha to return the numerator, and this array contains the\n denominator used to determine the eigenvalues as ALPHA / BETA.  If used,\n the values in this array will always be less than and usually comparable\n with the NORM(B).\n@param[out] v An N-by-N matrix where the right eigenvectors will be\n written (one per column). @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(out) :: alpha (*) real(kind=c_double), intent(out) :: beta (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_eigen_gen.html"},{"title":"la_eigen_symm – LINALG","text":"public  function la_eigen_symm(vecs, n, a, lda, vals) result(flag) bind(C, name = \"la_eigen_symm\")) @brief Computes the eigenvalues, and optionally the eigenvectors of a\nreal, symmetric matrix. @param[in] vecs Set to true to compute the eigenvectors as well as the\n eigenvalues; else, set to false to just compute the eigenvalues.\n@param[in] n The dimension of the matrix.\n@param[in,out] a On input, the N-by-N symmetric matrix on which to\n operate.  On output, and if @p vecs is set to true, the matrix will\n contain the eigenvectors (one per column) corresponding to each\n eigenvalue in @p vals.  If @p vecs is set to false, the lower triangular\n portion of the matrix is overwritten.\n@param[in] lda The leading dimension of matrix A.\n@param[out] vals An N-element array that will contain the eigenvalues\n sorted into ascending order. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: vals (*) Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_eigen_symm.html"},{"title":"la_form_lq – LINALG","text":"public  function la_form_lq(m, n, l, ldl, tau, q, ldq) result(flag) bind(C, name = \"la_form_lq\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: l (ldl,*) integer(kind=c_int), intent(in), value :: ldl real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_form_lq.html"},{"title":"la_form_lq_cmplx – LINALG","text":"public  function la_form_lq_cmplx(m, n, l, ldl, tau, q, ldq) result(flag) bind(C, name = \"la_form_lq_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: l (ldl,*) integer(kind=c_int), intent(in), value :: ldl complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_form_lq_cmplx.html"},{"title":"la_form_lu – LINALG","text":"public  function la_form_lu(n, a, lda, ipvt, u, ldu, p, ldp) result(flag) bind(C, name = \"la_form_lu\")) @brief Extracts the L, U, and P matrices from the LU factorization\noutput from la_lu_factor. @param n The dimension of the input matrix.\n@param[in,out] a On input, the N-by-N matrix as output by\n @ref la_lu_factor.  On output, the N-by-N lower triangular matrix L.\n@param lda The leading dimension of @p a.\n@param ipvt The N-element pivot array as output by\n @ref la_lu_factor.\n@param[out] u An N-by-N matrix where the U matrix will be written.\n@param ldu The leading dimension of @p u.\n@param[out] p An N-by-N matrix where the row permutation matrix will be\n written.\n@param ldp The leading dimension of @p p. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldp is not \n     correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) real(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_form_lu.html"},{"title":"la_form_lu_cmplx – LINALG","text":"public  function la_form_lu_cmplx(n, a, lda, ipvt, u, ldu, p, ldp) result(flag) bind(C, name = \"la_form_lu_cmplx\")) @brief Extracts the L, U, and P matrices from the LU factorization\noutput from la_lu_factor. @param n The dimension of the input matrix.\n@param[in,out] a On input, the N-by-N matrix as output by\n @ref la_lu_factor.  On output, the N-by-N lower triangular matrix L.\n@param lda The leading dimension of @p a.\n@param ipvt The N-element pivot array as output by\n @ref la_lu_factor.\n@param[out] u An N-by-N matrix where the U matrix will be written.\n@param ldu The leading dimension of @p u.\n@param[out] p An N-by-N matrix where the row permutation matrix will be\n written.\n@param ldp The leading dimension of @p p. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldp is not \n     correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) complex(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_form_lu_cmplx.html"},{"title":"la_form_qr – LINALG","text":"public  function la_form_qr(fullq, m, n, r, ldr, tau, q, ldq) result(flag) bind(C, name = \"la_form_qr\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm. @param[in] fullq Set to true to always return the full Q matrix; else,\n set to false, and in the event that M > N, Q may be supplied as M-by-N,\n and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the\n factorization can be written as Q * R = [Q1, Q2] * [R1; 0].\n@param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] r On input, the M-by-N factored matrix as returned by the\n QR factorization routine.  On output, the upper triangular matrix R.\n@param[in] ldr The leading dimension of matrix R.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n each elementary reflector defined in @p r.\n@param[out] q An M-by-M matrix where the full Q matrix will be written.\n In the event that @p fullq is set to false, and M > N, this matrix need\n only by M-by-N.\n@param[in] ldq The leading dimension of matrix Q. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) Contents Variables err mn nq Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn integer(kind=c_int), public :: nq","tags":"","loc":"proc\\la_form_qr.html"},{"title":"la_form_qr_cmplx – LINALG","text":"public  function la_form_qr_cmplx(fullq, m, n, r, ldr, tau, q, ldq) result(flag) bind(C, name = \"la_form_qr_cmplx\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm. @param[in] fullq Set to true to always return the full Q matrix; else,\n set to false, and in the event that M > N, Q may be supplied as M-by-N,\n and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the\n factorization can be written as Q * R = [Q1, Q2] * [R1; 0].\n@param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] r On input, the M-by-N factored matrix as returned by the\n QR factorization routine.  On output, the upper triangular matrix R.\n@param[in] ldr The leading dimension of matrix R.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n each elementary reflector defined in @p r.\n@param[out] q An M-by-M matrix where the full Q matrix will be written.\n In the event that @p fullq is set to false, and M > N, this matrix need\n only by M-by-N.\n@param[in] ldq The leading dimension of matrix Q. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) Contents Variables err mn nq Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn integer(kind=c_int), public :: nq","tags":"","loc":"proc\\la_form_qr_cmplx.html"},{"title":"la_form_qr_cmplx_pvt – LINALG","text":"public  function la_form_qr_cmplx_pvt(fullq, m, n, r, ldr, tau, pvt, q, ldq, p, ldp) result(flag) bind(C, name = \"la_form_qr_cmplx_pvt\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm.  This\nroutine also inflates the pivot array into an N-by-N matrix P such\nthat A * P = Q * R. @param[in] fullq Set to true to always return the full Q matrix; else,\n set to false, and in the event that M > N, Q may be supplied as M-by-N,\n and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the\n factorization can be written as Q * R = [Q1, Q2] * [R1; 0].\n@param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] r On input, the M-by-N factored matrix as returned by the\n QR factorization routine.  On output, the upper triangular matrix R.\n@param[in] ldr The leading dimension of matrix R.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n each elementary reflector defined in @p r.\n@param[in] pvt An N-element array containing the pivot information from\n the QR factorization.\n@param[out] q An M-by-M matrix where the full Q matrix will be written.\n In the event that @p fullq is set to false, and M > N, this matrix need\n only by M-by-N.\n@param[in] ldq The leading dimension of matrix Q.\n@param[out] p An N-by-N matrix where the pivot matrix P will be written.\n@param[in] ldp The leading dimension of matrix P. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: pvt (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq complex(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) Contents Variables err mn nq Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn integer(kind=c_int), public :: nq","tags":"","loc":"proc\\la_form_qr_cmplx_pvt.html"},{"title":"la_form_qr_pvt – LINALG","text":"public  function la_form_qr_pvt(fullq, m, n, r, ldr, tau, pvt, q, ldq, p, ldp) result(flag) bind(C, name = \"la_form_qr_pvt\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm.  This\nroutine also inflates the pivot array into an N-by-N matrix P such\nthat A * P = Q * R. @param[in] fullq Set to true to always return the full Q matrix; else,\n set to false, and in the event that M > N, Q may be supplied as M-by-N,\n and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the\n factorization can be written as Q * R = [Q1, Q2] * [R1; 0].\n@param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] r On input, the M-by-N factored matrix as returned by the\n QR factorization routine.  On output, the upper triangular matrix R.\n@param[in] ldr The leading dimension of matrix R.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n each elementary reflector defined in @p r.\n@param[in] pvt An N-element array containing the pivot information from\n the QR factorization.\n@param[out] q An M-by-M matrix where the full Q matrix will be written.\n In the event that @p fullq is set to false, and M > N, this matrix need\n only by M-by-N.\n@param[in] ldq The leading dimension of matrix Q.\n@param[out] p An N-by-N matrix where the pivot matrix P will be written.\n@param[in] ldp The leading dimension of matrix P. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: pvt (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) Contents Variables err mn nq Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn integer(kind=c_int), public :: nq","tags":"","loc":"proc\\la_form_qr_pvt.html"},{"title":"la_inverse – LINALG","text":"public  function la_inverse(n, a, lda) result(flag) bind(C, name = \"la_inverse\")) @brief Computes the inverse of a square matrix. @param[in] n The dimension of matrix A.\n@param[in,out] a On input, the N-by-N matrix to invert.  On output, the\n inverted matrix.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_inverse.html"},{"title":"la_inverse_cmplx – LINALG","text":"public  function la_inverse_cmplx(n, a, lda) result(flag) bind(C, name = \"la_inverse_cmplx\")) @brief Computes the inverse of a square matrix. @param[in] n The dimension of matrix A.\n@param[in,out] a On input, the N-by-N matrix to invert.  On output, the\n inverted matrix.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_inverse_cmplx.html"},{"title":"la_lq_factor – LINALG","text":"public  function la_lq_factor(m, n, a, lda, tau) result(flag) bind(C, name = \"la_lq_factor\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_lq_factor.html"},{"title":"la_lq_factor_cmplx – LINALG","text":"public  function la_lq_factor_cmplx(m, n, a, lda, tau) result(flag) bind(C, name = \"la_lq_factor_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_lq_factor_cmplx.html"},{"title":"la_lu_factor – LINALG","text":"public  function la_lu_factor(m, n, a, lda, ipvt) result(flag) bind(C, name = \"la_lu_factor\")) @brief Computes the LU factorization of an M-by-N matrix. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix on which to operate.  On\noutput, the LU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored.\n@param lda The leading dimension of matrix A.\n@param[out] ipvt An MIN(M, N)-element array used to track row-pivot\n operations.  The array stored pivot information such that row I is\n interchanged with row IPVT(I). @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if @p a is found to be\n     singular. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: ipvt (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_lu_factor.html"},{"title":"la_lu_factor_cmplx – LINALG","text":"public  function la_lu_factor_cmplx(m, n, a, lda, ipvt) result(flag) bind(C, name = \"la_lu_factor_cmplx\")) @brief Computes the LU factorization of an M-by-N matrix. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix on which to operate.  On\noutput, the LU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored.\n@param lda The leading dimension of matrix A.\n@param[out] ipvt An MIN(M, N)-element array used to track row-pivot\n operations.  The array stored pivot information such that row I is\n interchanged with row IPVT(I). @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if @p a is found to be\n     singular. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: ipvt (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_lu_factor_cmplx.html"},{"title":"la_mtx_mult – LINALG","text":"public  function la_mtx_mult(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_mtx_mult\")) @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. @param transa Set to true to compute op(A) as the transpose of A; else,\n set to false to compute op(A) as A.\n@param transb Set to true to compute op(B) as the transpose of B; else,\n set to false to compute op(B) as B.\n@param m The number of rows in @p c.\n@param n The number of columns in @p c.\n@param k The interior dimension of the product @p a and @p b.\n@param alpha A scalar multiplier.\n@param a If @p transa is true, this matrix must be @p k by @p m; else,\n if @p transa is false, this matrix must be @p m by @p k.\n@param lda The leading dimension of matrix @p a.\n@param b If @p transb is true, this matrix must be @p n by @p k; else,\n if @p transb is false, this matrix must be @p k by @p n.\n@param ldb The leading dimension of matrix @p b.\n@param beta A scalar multiplier.\n@param c The @p m by @p n matrix C.\n@param ldc The leading dimension of matrix @p c. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldb, or @p ldc are not\n     correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: transa logical(kind=c_bool), intent(in), value :: transb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables nrowa nrowb ta tb Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: nrowa integer(kind=c_int), public :: nrowb character(len=1), public :: ta character(len=1), public :: tb","tags":"","loc":"proc\\la_mtx_mult.html"},{"title":"la_mtx_mult_cmplx – LINALG","text":"public  function la_mtx_mult_cmplx(opa, opb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_mtx_mult_cmplx\")) @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. @param opa Set to LA_TRANSPOSE to compute op(A) as a direct transpose of A,\n set to  LA_HERMITIAN_TRANSPOSE to compute op(A) as the Hermitian transpose\n of A, otherwise, set to NO_OPERATION to compute op(A) as A.\n@param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B,\n set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose\n of B, otherwise, set to NO_OPERATION to compute op(B) as B.\n@param mThe number of rows in @p c.\n@param n The number of columns in @p c.\n@param k The interior dimension of the product @p a and @p b.\n@param alpha A scalar multiplier.\n@param a If @p opa is LA_TRANSPOSE or  LA_HERMITIAN_TRANSPOSE, this matrix must\n be @p k by @p m; else, this matrix must be @p m by @p k.\n@param lda The leading dimension of matrix @p a.\n@param b If @p opb is LA_TRANSPOSE or  LA_HERMITIAN_TRANSPOSE, this matrix must\n be @p n by @p k; else, this matrix must be @p k by @p n.\n@param ldb The leading dimension of matrix @p b.\n@param beta A scalar multiplier.\n@param c The @p m by @p n matrix C.\n@param ldc The leading dimension of matrix @p c. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldb, or @p ldc are not\n     correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: opa integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables nrowa nrowb ta tb Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: nrowa integer(kind=c_int), public :: nrowb character(len=1), public :: ta character(len=1), public :: tb","tags":"","loc":"proc\\la_mtx_mult_cmplx.html"},{"title":"la_mult_lq – LINALG","text":"public  function la_mult_lq(lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_lq\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_mult_lq.html"},{"title":"la_mult_lq_cmplx – LINALG","text":"public  function la_mult_lq_cmplx(lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_lq_cmplx\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_mult_lq_cmplx.html"},{"title":"la_mult_qr – LINALG","text":"public  function la_mult_qr(lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_qr\")) @brief Multiplies a general matrix by the orthogonal matrix Q from a QR\nfactorization such that: C = op(Q) * C, or C = C * op(Q). @param[in] lside Set to true to apply Q or Q T from the left; else, set\n to false to apply Q or Q T from the right.\n@param[in] trans Set to true to apply Q**T; else, set to false.\n@param[in] m The number of rows in matrix C.\n@param[in] n The number of columns in matrix C.\n@param[in] k The number of elementary reflectors whose product defines \n the matrix Q.\n@param[in] a On input, an LDA-by-K matrix containing the elementary\n reflectors output from the QR factorization.  If @p lside is set to\n true, LDA = M, and M >= K >= 0; else, if @p lside is set to false,\n LDA = N, and N >= K >= 0.  Notice, the contents of this matrix are\n restored on exit.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A K-element array containing the scalar factors of each\n elementary reflector defined in @p a.\n@param[in,out] c On input, the M-by-N matrix C.  On output, the product\n of the orthogonal matrix Q and the original matrix C.\n@param[in] ldc THe leading dimension of matrix C. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ma na Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: na","tags":"","loc":"proc\\la_mult_qr.html"},{"title":"la_mult_qr_cmplx – LINALG","text":"public  function la_mult_qr_cmplx(lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_qr_cmplx\")) @brief Multiplies a general matrix by the orthogonal matrix Q from a QR\nfactorization such that: C = op(Q) * C, or C = C * op(Q). @param[in] lside Set to true to apply Q or Q H from the left; else, set\n to false to apply Q or Q H from the right.\n@param[in] trans Set to true to apply Q**H; else, set to false.\n@param[in] m The number of rows in matrix C.\n@param[in] n The number of columns in matrix C.\n@param[in] k The number of elementary reflectors whose product defines \n the matrix Q.\n@param[in] a On input, an LDA-by-K matrix containing the elementary\n reflectors output from the QR factorization.  If @p lside is set to\n true, LDA = M, and M >= K >= 0; else, if @p lside is set to false,\n LDA = N, and N >= K >= 0.  Notice, the contents of this matrix are\n restored on exit.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A K-element array containing the scalar factors of each\n elementary reflector defined in @p a.\n@param[in,out] c On input, the M-by-N matrix C.  On output, the product\n of the orthogonal matrix Q and the original matrix C.\n@param[in] ldc THe leading dimension of matrix C. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) Contents Variables err ma na Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma integer(kind=c_int), public :: na","tags":"","loc":"proc\\la_mult_qr_cmplx.html"},{"title":"la_pinverse – LINALG","text":"public  function la_pinverse(m, n, a, lda, ainv, ldai) result(flag) bind(C, name = \"la_pinverse\")) @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by\nmeans of singular value decomposition. @param[in] m The number of rows in the matrix.\n@parma[in] n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix to invert.  The matrix is\n overwritten on output.\n@param[in] lda The leading dimension of matrix A.\n@param[out] ainv The N-by-M matrix where the pseudo-inverse of @p a\n will be written.\n@param[in] ldai The leading dimension of matrix AINV. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldai is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: ainv (ldai,*) integer(kind=c_int), intent(in), value :: ldai Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_pinverse.html"},{"title":"la_pinverse_cmplx – LINALG","text":"public  function la_pinverse_cmplx(m, n, a, lda, ainv, ldai) result(flag) bind(C, name = \"la_pinverse_cmplx\")) @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by\nmeans of singular value decomposition. @param[in] m The number of rows in the matrix.\n@parma[in] n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix to invert.  The matrix is\n overwritten on output.\n@param[in] lda The leading dimension of matrix A.\n@param[out] ainv The N-by-M matrix where the pseudo-inverse of @p a\n will be written.\n@param[in] ldai The leading dimension of matrix AINV. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldai is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: ainv (ldai,*) integer(kind=c_int), intent(in), value :: ldai Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_pinverse_cmplx.html"},{"title":"la_qr_factor – LINALG","text":"public  function la_qr_factor(m, n, a, lda, tau) result(flag) bind(C, name = \"la_qr_factor\")) @brief Computes the QR factorization of an M-by-N matrix without\npivoting. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a  On input, the M-by-N matrix to factor.  On output, the\n elements on and above the diagonal contain the MIN(M, N)-by-N upper\n trapezoidal matrix R (R is upper triangular if M >= N).  The elements\n below the diagonal, along with the array @p tau, represent the\n orthogonal matrix Q as a product of elementary reflectors.\n@param lda The leading dimension of matrix A.\n@param[out] tau A MIN(M, N)-element array used to store the scalar\n factors of the elementary reflectors. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_factor.html"},{"title":"la_qr_factor_cmplx – LINALG","text":"public  function la_qr_factor_cmplx(m, n, a, lda, tau) result(flag) bind(C, name = \"la_qr_factor_cmplx\")) @brief Computes the QR factorization of an M-by-N matrix without\npivoting. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a  On input, the M-by-N matrix to factor.  On output, the\n elements on and above the diagonal contain the MIN(M, N)-by-N upper\n trapezoidal matrix R (R is upper triangular if M >= N).  The elements\n below the diagonal, along with the array @p tau, represent the\n orthogonal matrix Q as a product of elementary reflectors.\n@param lda The leading dimension of matrix A.\n@param[out] tau A MIN(M, N)-element array used to store the scalar\n factors of the elementary reflectors. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_factor_cmplx.html"},{"title":"la_qr_factor_cmplx_pvt – LINALG","text":"public  function la_qr_factor_cmplx_pvt(m, n, a, lda, tau, jpvt) result(flag) bind(C, name = \"la_qr_factor_cmplx_pvt\")) @brief Computes the QR factorization of an M-by-N matrix with column\npivoting. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a  On input, the M-by-N matrix to factor.  On output, the\n elements on and above the diagonal contain the MIN(M, N)-by-N upper\n trapezoidal matrix R (R is upper triangular if M >= N).  The elements\n below the diagonal, along with the array @p tau, represent the\n orthogonal matrix Q as a product of elementary reflectors.\n@param lda The leading dimension of matrix A.\n@param[out] tau A MIN(M, N)-element array used to store the scalar\n factors of the elementary reflectors.\n@param[in,out] jpvt On input, an N-element array that if JPVT(I) .ne. 0,\n the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0,\n the I-th column of A is a free column.  On output, if JPVT(I) = K, then\n the I-th column of A * P was the K-th column of A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) integer(kind=c_int), intent(inout) :: jpvt (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_factor_cmplx_pvt.html"},{"title":"la_qr_factor_pvt – LINALG","text":"public  function la_qr_factor_pvt(m, n, a, lda, tau, jpvt) result(flag) bind(C, name = \"la_qr_factor_pvt\")) @brief Computes the QR factorization of an M-by-N matrix with column\npivoting. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param[in,out] a  On input, the M-by-N matrix to factor.  On output, the\n elements on and above the diagonal contain the MIN(M, N)-by-N upper\n trapezoidal matrix R (R is upper triangular if M >= N).  The elements\n below the diagonal, along with the array @p tau, represent the\n orthogonal matrix Q as a product of elementary reflectors.\n@param lda The leading dimension of matrix A.\n@param[out] tau A MIN(M, N)-element array used to store the scalar\n factors of the elementary reflectors.\n@param[in,out] jpvt On input, an N-element array that if JPVT(I) .ne. 0,\n the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0,\n the I-th column of A is a free column.  On output, if JPVT(I) = K, then\n the I-th column of A * P was the K-th column of A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) integer(kind=c_int), intent(inout) :: jpvt (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_factor_pvt.html"},{"title":"la_qr_rank1_update – LINALG","text":"public  function la_qr_rank1_update(m, n, q, ldq, r, ldr, u, v) result(flag) bind(C, name = \"la_qr_rank1_update\")) @brief Computes the rank 1 update to an M-by-N QR factored matrix A\n(M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. @param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] q On input, the original M-by-K orthogonal matrix Q.  On\n output, the updated matrix Q1.\n@param[in] ldq The leading dimension of matrix Q.\n@param[in,out] r On input, the M-by-N matrix R.  On output, the updated\n matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the M-element U update vector.  On output,\n the original content of the array is overwritten.\n@param[in,out] v On input, the N-element V update vector.  On output,\n the original content of the array is overwritten. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldq or @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) real(kind=c_double), intent(inout) :: v (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_rank1_update.html"},{"title":"la_qr_rank1_update_cmplx – LINALG","text":"public  function la_qr_rank1_update_cmplx(m, n, q, ldq, r, ldr, u, v) result(flag) bind(C, name = \"la_qr_rank1_update_cmplx\")) @brief Computes the rank 1 update to an M-by-N QR factored matrix A\n(M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. @param[in] m The number of rows in R.\n@param[in] n The number of columns in R.\n@param[in,out] q On input, the original M-by-K orthogonal matrix Q.  On\n output, the updated matrix Q1.\n@param[in] ldq The leading dimension of matrix Q.\n@param[in,out] r On input, the M-by-N matrix R.  On output, the updated\n matrix R1.\n@param[in] ldr The leading dimension of matrix R.\n@param[in,out] u On input, the M-element U update vector.  On output,\n the original content of the array is overwritten.\n@param[in,out] v On input, the N-element V update vector.  On output,\n the original content of the array is overwritten. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldq or @p ldr is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory \n     available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) complex(kind=c_double), intent(inout) :: v (*) Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_qr_rank1_update_cmplx.html"},{"title":"la_rank – LINALG","text":"public  function la_rank(m, n, a, lda, rnk) result(flag) bind(C, name=\"la_rank\")) @brief Computes the rank of a matrix. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param a The M-by-N matrix.  The matrix is overwritten as part of this\n operation.\n@param lda The leading dimension of matrix A.\n@param[out] rnk The rank of @p a. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process\n     could not converge to a zero value. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: rnk Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_rank.html"},{"title":"la_rank1_update – LINALG","text":"public  function la_rank1_update(m, n, alpha, x, y, a, lda) result(flag) bind(C, name = \"la_rank1_update\")) @brief Performs the rank-1 update to matrix A such that:\nA = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar,\nX is an M-element array, and N is an N-element array. @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in] alpha The scalar multiplier.\n@param[in] x An M-element array.\n@param[in] y An N-element array.\n@param[in,out] a On input, the M-by-N matrix to update.  On output, the\n updated M-by-N matrix.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: x (*) real(kind=c_double), intent(in) :: y (*) real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_rank1_update.html"},{"title":"la_rank1_update_cmplx – LINALG","text":"public  function la_rank1_update_cmplx(m, n, alpha, x, y, a, lda) result(flag) bind(C, name = \"la_rank1_update_cmplx\")) @brief Performs the rank-1 update to matrix A such that:\nA = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar,\nX is an M-element array, and N is an N-element array. @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in] alpha The scalar multiplier.\n@param[in] x An M-element array.\n@param[in] y An N-element array.\n@param[in,out] a On input, the M-by-N matrix to update.  On output, the\n updated M-by-N matrix.\n@param[in] lda The leading dimension of matrix A. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: x (*) complex(kind=c_double), intent(in) :: y (*) complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_rank1_update_cmplx.html"},{"title":"la_rank_cmplx – LINALG","text":"public  function la_rank_cmplx(m, n, a, lda, rnk) result(flag) bind(C, name=\"la_rank_cmplx\")) @brief Computes the rank of a matrix. @param m The number of rows in the matrix.\n@param n The number of columns in the matrix.\n@param a The M-by-N matrix.  The matrix is overwritten as part of this\n operation.\n@param lda The leading dimension of matrix A.\n@param[out] rnk The rank of @p a. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process\n     could not converge to a zero value. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: rnk Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_rank_cmplx.html"},{"title":"la_solve_cholesky – LINALG","text":"public  function la_solve_cholesky(upper, m, n, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_cholesky\")) @brief Solves a system of Cholesky factored equations. @param[in] upper Set to true if the original matrix A was factored such\n that A = U T * U; else, set to false if the factorization of A was\n A = L T * L.\n@param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] a The M-by-M Cholesky factored matrix.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b On input, the M-by-N right-hand-side matrix B.  On\n output, the M-by-N solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_solve_cholesky.html"},{"title":"la_solve_cholesky_cmplx – LINALG","text":"public  function la_solve_cholesky_cmplx(upper, m, n, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_cholesky_cmplx\")) @brief Solves a system of Cholesky factored equations. @param[in] upper Set to true if the original matrix A was factored such\n that A = U T * U; else, set to false if the factorization of A was\n A = L T * L.\n@param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] a The M-by-M Cholesky factored matrix.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b On input, the M-by-N right-hand-side matrix B.  On\n output, the M-by-N solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_solve_cholesky_cmplx.html"},{"title":"la_solve_least_squares – LINALG","text":"public  function la_solve_least_squares(m, n, k, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_least_squares\")) @brief Solves the overdetermined or underdetermined system (A*X = B) of\nM equations of N unknowns using a QR or LQ factorization of the matrix A.\nNotice, it is assumed that matrix A has full rank. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N matrix A.  On output, if M >= N,\n the QR factorization of A in the form as output by qr_factor; else,\n if M < N, the LQ factorization of A.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b If M >= N, the M-by-NRHS matrix B.  On output, the first\n N rows contain the N-by-NRHS solution matrix X.  If M < N, an\n N-by-NRHS matrix with the first M rows containing the matrix B.  On\n output, the N-by-NRHS solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_INVALID_OPERATION_ERROR: Occurs if @p a is not of full rank. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err maxmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: maxmn","tags":"","loc":"proc\\la_solve_least_squares.html"},{"title":"la_solve_least_squares_cmplx – LINALG","text":"public  function la_solve_least_squares_cmplx(m, n, k, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_least_squares_cmplx\")) @brief Solves the overdetermined or underdetermined system (A*X = B) of\nM equations of N unknowns using a QR or LQ factorization of the matrix A.\nNotice, it is assumed that matrix A has full rank. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N matrix A.  On output, if M >= N,\n the QR factorization of A in the form as output by qr_factor; else,\n if M < N, the LQ factorization of A.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b If M >= N, the M-by-NRHS matrix B.  On output, the first\n N rows contain the N-by-NRHS solution matrix X.  If M < N, an\n N-by-NRHS matrix with the first M rows containing the matrix B.  On\n output, the N-by-NRHS solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_INVALID_OPERATION_ERROR: Occurs if @p a is not of full rank. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err maxmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: maxmn","tags":"","loc":"proc\\la_solve_least_squares_cmplx.html"},{"title":"la_solve_lq – LINALG","text":"public  function la_solve_lq(m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_lq\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_solve_lq.html"},{"title":"la_solve_lq_cmplx – LINALG","text":"public  function la_solve_lq_cmplx(m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_lq_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_solve_lq_cmplx.html"},{"title":"la_solve_lu – LINALG","text":"public  function la_solve_lu(m, n, a, lda, ipvt, b, ldb) result(flag) bind(C, name = \"la_solve_lu\")) @brief Solves a system of LU-factored equations. @param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] a The M-by-M LU factored matrix.\n@param[in] lda The leading dimension of matrix A.\n@param[in] ipvt The M-element pivot array from the LU factorization.\n@param[in,out] b On input, the M-by-N right-hand-side.  On output, the\n M-by-N solution.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_solve_lu.html"},{"title":"la_solve_lu_cmplx – LINALG","text":"public  function la_solve_lu_cmplx(m, n, a, lda, ipvt, b, ldb) result(flag) bind(C, name = \"la_solve_lu_cmplx\")) @brief Solves a system of LU-factored equations. @param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] a The M-by-M LU factored matrix.\n@param[in] lda The leading dimension of matrix A.\n@param[in] ipvt The M-element pivot array from the LU factorization.\n@param[in,out] b On input, the M-by-N right-hand-side.  On output, the\n M-by-N solution.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_solve_lu_cmplx.html"},{"title":"la_solve_qr – LINALG","text":"public  function la_solve_qr(m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_qr\")) @brief Solves a system of M QR-factored equations of N unknowns where\nM >= N. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N QR factored matrix as returned by\n qr_factor.  On output, the contents of this matrix are restored.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n the elementary reflectors as returned by qr_factor.\n@param[in,out] b On input, the M-by-K right-hand-side matrix.  On output,\n the first N rows are overwritten by the solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct, or\n     if @p m is less than @p n.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err minmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: minmn","tags":"","loc":"proc\\la_solve_qr.html"},{"title":"la_solve_qr_cmplx – LINALG","text":"public  function la_solve_qr_cmplx(m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_qr_cmplx\")) @brief Solves a system of M QR-factored equations of N unknowns where\nM >= N. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N QR factored matrix as returned by\n qr_factor.  On output, the contents of this matrix are restored.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n the elementary reflectors as returned by qr_factor.\n@param[in,out] b On input, the M-by-K right-hand-side matrix.  On output,\n the first N rows are overwritten by the solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct, or\n     if @p m is less than @p n.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err minmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: minmn","tags":"","loc":"proc\\la_solve_qr_cmplx.html"},{"title":"la_solve_qr_cmplx_pvt – LINALG","text":"public  function la_solve_qr_cmplx_pvt(m, n, k, a, lda, tau, jpvt, b, ldb) result(flag) bind(C, name = \"la_solve_qr_cmplx_pvt\")) @brief Solves a system of M QR-factored equations of N unknowns. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N QR factored matrix as returned by\n qr_factor.  On output, the contents of this matrix are restored.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n the elementary reflectors as returned by qr_factor.\n@param[in] jpvt The N-element array that was used to track the column\n pivoting operations in the QR factorization.\n@param[in,out] b On input, the M-by-K right-hand-side matrix.  On output,\n the first N rows are overwritten by the solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: jpvt (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err maxmn minmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: maxmn integer(kind=c_int), public :: minmn","tags":"","loc":"proc\\la_solve_qr_cmplx_pvt.html"},{"title":"la_solve_qr_pvt – LINALG","text":"public  function la_solve_qr_pvt(m, n, k, a, lda, tau, jpvt, b, ldb) result(flag) bind(C, name = \"la_solve_qr_pvt\")) @brief Solves a system of M QR-factored equations of N unknowns. @param[in] m The number of equations (rows in matrix A).\n@param[in] n The number of unknowns (columns in matrix A).\n@param[in] k The number of columns in the right-hand-side matrix.\n@param[in,out] a On input, the M-by-N QR factored matrix as returned by\n qr_factor.  On output, the contents of this matrix are restored.\n@param[in] lda The leading dimension of matrix A.\n@param[in] tau A MIN(M, N)-element array containing the scalar factors of\n the elementary reflectors as returned by qr_factor.\n@param[in] jpvt The N-element array that was used to track the column\n pivoting operations in the QR factorization.\n@param[in,out] b On input, the M-by-K right-hand-side matrix.  On output,\n the first N rows are overwritten by the solution matrix X.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: jpvt (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err maxmn minmn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: maxmn integer(kind=c_int), public :: minmn","tags":"","loc":"proc\\la_solve_qr_pvt.html"},{"title":"la_solve_tri_mtx – LINALG","text":"public  function la_solve_tri_mtx(lside, upper, trans, nounit, m, n, alpha, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_tri_mtx\")) @brief Solves one of the matrix equations: op(A) * X = alpha * B, or\nX * op(A) = alpha * B, where A is a triangular matrix. @param[in] lside Set to true to solve op(A) * X = alpha * B; else, set to\n false to solve X * op(A) = alpha * B.\n@param[in] upper Set to true if A is an upper triangular matrix; else,\n set to false if A is a lower triangular matrix.\n@param[in] trans Set to true if op(A) = A**T; else, set to false if\n op(A) = A.\n@param[in] nounit Set to true if A is not a unit-diagonal matrix (ones on\n every diagonal element); else, set to false if A is a unit-diagonal\n matrix.\n@param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] alpha The scalar multiplier to B.\n@param[in] a If @p lside is true, the M-by-M triangular matrix on which\n to operate; else, if @p lside is false, the N-by-N triangular matrix on\n which to operate.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b On input, the M-by-N right-hand-side.  On output, the\n M-by-N solution.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: upper logical(kind=c_bool), intent(in), value :: trans logical(kind=c_bool), intent(in), value :: nounit integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_solve_tri_mtx.html"},{"title":"la_solve_tri_mtx_cmplx – LINALG","text":"public  function la_solve_tri_mtx_cmplx(lside, upper, trans, nounit, m, n, alpha, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_tri_mtx_cmplx\")) @brief Solves one of the matrix equations: op(A) * X = alpha * B, or\nX * op(A) = alpha * B, where A is a triangular matrix. @param[in] lside Set to true to solve op(A) * X = alpha * B; else, set to\n false to solve X * op(A) = alpha * B.\n@param[in] upper Set to true if A is an upper triangular matrix; else,\n set to false if A is a lower triangular matrix.\n@param[in] trans Set to true if op(A) = A**H; else, set to false if\n op(A) = A.\n@param[in] nounit Set to true if A is not a unit-diagonal matrix (ones on\n every diagonal element); else, set to false if A is a unit-diagonal\n matrix.\n@param[in] m The number of rows in matrix B.\n@param[in] n The number of columns in matrix B.\n@param[in] alpha The scalar multiplier to B.\n@param[in] a If @p lside is true, the M-by-M triangular matrix on which\n to operate; else, if @p lside is false, the N-by-N triangular matrix on\n which to operate.\n@param[in] lda The leading dimension of matrix A.\n@param[in,out] b On input, the M-by-N right-hand-side.  On output, the\n M-by-N solution.\n@param[in] ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: upper logical(kind=c_bool), intent(in), value :: trans logical(kind=c_bool), intent(in), value :: nounit integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents Variables err ma Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: ma","tags":"","loc":"proc\\la_solve_tri_mtx_cmplx.html"},{"title":"la_sort_eigen – LINALG","text":"public  function la_sort_eigen(ascend, n, vals, vecs, ldv) result(flag) bind(C, name = \"la_sort_eigen\")) @brief A sorting routine specifically tailored for sorting of eigenvalues\nand their associated eigenvectors using a quick-sort approach. @param[in] ascend\n@param[in] n The number of eigenvalues.\n@param[in,out] vals On input, an N-element array containing the\n eigenvalues.  On output, the sorted eigenvalues.\n@param[in,out] vecs On input, an N-by-N matrix containing the\n eigenvectors associated with @p vals (one vector per column).  On\n output, the sorted eigenvector matrix.\n@param[in] ldv The leading dimension of @p vecs. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldv is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: ascend integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: vals (*) real(kind=c_double), intent(inout) :: vecs (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_sort_eigen.html"},{"title":"la_sort_eigen_cmplx – LINALG","text":"public  function la_sort_eigen_cmplx(ascend, n, vals, vecs, ldv) result(flag) bind(C, name = \"la_sort_eigen_cmplx\")) @brief A sorting routine specifically tailored for sorting of eigenvalues\nand their associated eigenvectors using a quick-sort approach. @param[in] ascend\n@param[in] n The number of eigenvalues.\n@param[in,out] vals On input, an N-element array containing the\n eigenvalues.  On output, the sorted eigenvalues.\n@param[in,out] vecs On input, an N-by-N matrix containing the\n eigenvectors associated with @p vals (one vector per column).  On\n output, the sorted eigenvector matrix.\n@param[in] ldv The leading dimension of @p vecs. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p ldv is not correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: ascend integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: vals (*) complex(kind=c_double), intent(inout) :: vecs (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err Variables Type Visibility Attributes Name Initial type(errors), public :: err","tags":"","loc":"proc\\la_sort_eigen_cmplx.html"},{"title":"la_svd – LINALG","text":"public  function la_svd(m, n, a, lda, s, u, ldu, vt, ldv) result(flag) bind(C, name = \"la_svd\")) @brief Computes the singular value decomposition of a matrix A.  The\n SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal\n matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal\n matrix. @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix to factor.  The matrix is\n overwritten on output.\n@param[in] lda The leading dimension of matrix A.\n@param[out] s A MIN(M, N)-element array containing the singular values\n of @p a sorted in descending order.\n@param[out] u An M-by-M matrix where the orthogonal U matrix will be\n written.\n@param[in] ldu The leading dimension of matrix U.\n@param[out] vt An N-by-N matrix where the transpose of the right \n singular vector matrix V.\n@param[in] ldv The leading dimension of matrix V. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldv is not \n     correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process\n     could not converge to a zero value. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: s (*) real(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: vt (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_svd.html"},{"title":"la_svd_cmplx – LINALG","text":"public  function la_svd_cmplx(m, n, a, lda, s, u, ldu, vt, ldv) result(flag) bind(C, name = \"la_svd_cmplx\")) @brief Computes the singular value decomposition of a matrix A.  The\n SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal\n matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal\n matrix. @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in,out] a On input, the M-by-N matrix to factor.  The matrix is\n overwritten on output.\n@param[in] lda The leading dimension of matrix A.\n@param[out] s A MIN(M, N)-element array containing the singular values\n of @p a sorted in descending order.\n@param[out] u An M-by-M matrix where the orthogonal U matrix will be\n written.\n@param[in] ldu The leading dimension of matrix U.\n@param[out] vt An N-by-N matrix where the transpose of the right \n singular vector matrix V.\n@param[in] ldv The leading dimension of matrix V. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldv is not \n     correct.\n - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and\n     there is insufficient memory available.\n - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process\n     could not converge to a zero value. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: s (*) complex(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu complex(kind=c_double), intent(out) :: vt (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) Contents Variables err mn Variables Type Visibility Attributes Name Initial type(errors), public :: err integer(kind=c_int), public :: mn","tags":"","loc":"proc\\la_svd_cmplx.html"},{"title":"la_trace – LINALG","text":"public  function la_trace(m, n, a, lda, rst) result(flag) bind(C, name = \"la_trace\")) @brief Computes the trace of a matrix (the sum of the main diagonal\nelements). @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in] a The M-by-N matrix on which to operate.\n@param[in] lda The leading dimension of the matrix.\n@param[out] rst The results of the operation. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: rst Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_trace.html"},{"title":"la_trace_cmplx – LINALG","text":"public  function la_trace_cmplx(m, n, a, lda, rst) result(flag) bind(C, name = \"la_trace_cmplx\")) @brief Computes the trace of a matrix (the sum of the main diagonal\nelements). @param[in] m The number of rows in the matrix.\n@param[in] n The number of columns in the matrix.\n@param[in] a The M-by-N matrix on which to operate.\n@param[in] lda The leading dimension of the matrix.\n@param[out] rst The results of the operation. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: rst Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_trace_cmplx.html"},{"title":"la_tri_mtx_mult – LINALG","text":"public  function la_tri_mtx_mult(upper, alpha, n, a, lda, beta, b, ldb) result(flag) bind(C, name = \"la_tri_mtx_mult\")) @brief Computes the triangular matrix operation:\nB = alpha * A T * A + beta * B, or B = alpha * A * A T + beta * B,\nwhere A is a triangular matrix. @param upper Set to true if matrix A is upper triangular, and\n B = alpha * A T * A + beta * B is to be calculated; else, set to false\n if A is lower triangular, and B = alpha * A * A T + beta * B is to\n be computed.\n@param alpha A scalar multiplier.\n@param n The dimension of the matrix.\n@param a The @p n by @p n triangular matrix A.  Notice, if @p upper is\n true, only the upper triangular portion of this matrix is referenced;\n else, if @p upper is false, only the lower triangular portion of this\n matrix is referenced.\n@param lda The leading dimension of matrix A.\n@param beta A scalar multiplier.\n@param b On input, the @p n by @p n matrix B.  On output, the @p n by\n @p n resulting matrix.\n@param ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldb are not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper real(kind=c_double), intent(in), value :: alpha integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_tri_mtx_mult.html"},{"title":"la_tri_mtx_mult_cmplx – LINALG","text":"public  function la_tri_mtx_mult_cmplx(upper, alpha, n, a, lda, beta, b, ldb) result(flag) bind(C, name = \"la_tri_mtx_mult_cmplx\")) @brief Computes the triangular matrix operation:\nB = alpha * A T * A + beta * B, or B = alpha * A * A T + beta * B,\nwhere A is a triangular matrix. @param upper Set to true if matrix A is upper triangular, and\n B = alpha * A T * A + beta * B is to be calculated; else, set to false\n if A is lower triangular, and B = alpha * A * A T + beta * B is to\n be computed.\n@param alpha A scalar multiplier.\n@param n The dimension of the matrix.\n@param a The @p n by @p n triangular matrix A.  Notice, if @p upper is\n true, only the upper triangular portion of this matrix is referenced;\n else, if @p upper is false, only the lower triangular portion of this\n matrix is referenced.\n@param lda The leading dimension of matrix A.\n@param beta A scalar multiplier.\n@param b On input, the @p n by @p n matrix B.  On output, the @p n by\n @p n resulting matrix.\n@param ldb The leading dimension of matrix B. @return An error code.  The following codes are possible.\n - LA_NO_ERROR: No error occurred.  Successful operation.\n - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldb are not correct. Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper complex(kind=c_double), intent(in), value :: alpha integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) Contents","tags":"","loc":"proc\\la_tri_mtx_mult_cmplx.html"},{"title":"eigen – LINALG","text":"public interface eigen An interface to the eigenvalue and eigenvector routines. Contents Module Procedures eigen_symm eigen_asymm eigen_gen eigen_cmplx Module Procedures private  subroutine eigen_symm(vecs, a, vals, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is a symmetric matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: vecs Set to true to compute the eigenvectors as well as the eigenvalues; \nelse, set to false to just compute the eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N symmetric matrix on which to operate.  On \noutput, and if vecs is set to true, the matrix will contain the \neigenvectors (one per column) corresponding to each eigenvalue in \nvals.  If vecs is set to false, the lower triangular portion of the \nmatrix is overwritten. real(kind=real64), intent(out), dimension(:) :: vals An N-element array that will contain the eigenvalues sorted into \nascending order. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_asymm(a, vals, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_gen(a, b, alpha, beta, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, by solving\nthe eigenvalue problem: . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: alpha An N-element array that, if beta is not supplied, contains the \neigenvalues.  If beta is supplied however, the eigenvalues must be \ncomputed as .  This however, is not as\ntrivial as it seems as it is entirely possible, and likely, that can overflow or underflow.  With that said, the \nvalues in will always be less than and usually comparable \nwith the NORM( ). real(kind=real64), intent(out), optional, dimension(:) :: beta An optional N-element array that if provided forces alpha to return \nthe numerator, and this array contains the denominator used to \ndetermine the eigenvalues as .  If used,\nthe values in this array will always be less than and usually \ncomparable with the NORM( ). complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_cmplx(a, vals, vecs, work, olwork, rwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 2 * N. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\eigen.html"},{"title":"report_array_size_error – LINALG","text":"public  subroutine report_array_size_error(fcn, err, name, expected, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expected The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_inner_matrix_dimension_error – LINALG","text":"public  subroutine report_inner_matrix_dimension_error(fcn, err, name1, name2, expected, actual) Reports an inner matrix dimension error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name1 The name of the first matrix. character(len=*), intent(in) :: name2 The name of the second matrix. integer(kind=int32), intent(in) :: expected The expected inner dimension. integer(kind=int32), intent(in) :: actual The actual inner dimension. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_inner_matrix_dimension_error.html"},{"title":"report_matrix_size_error – LINALG","text":"public  subroutine report_matrix_size_error(fcn, err, name, expectedRows, expectedCols, actualRows, actualCols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedRows The expected number of rows in the matrix. integer(kind=int32), intent(in) :: expectedCols The expected number of columns in the matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – LINALG","text":"public  subroutine report_memory_error(fcn, err, flag) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: flag The error flag. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_singular_matrix_warning – LINALG","text":"public  subroutine report_singular_matrix_warning(fcn, err, row) Reports a singular matrix error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: row The row index where the singularity issue was first encountered. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_singular_matrix_warning.html"},{"title":"report_square_matrix_error – LINALG","text":"public  subroutine report_square_matrix_error(fcn, err, name, expectedSize, actualRows, actualCols) Reports an error where a square matrix was expected but a non-square \nmatrix was provided. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedSize The expected size of the square matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_square_matrix_error.html"},{"title":"mtx_inverse – LINALG","text":"public interface mtx_inverse Contents Module Procedures mtx_inverse_dbl mtx_inverse_cmplx Module Procedures private  subroutine mtx_inverse_dbl(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_inverse_cmplx(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mtx_inverse.html"},{"title":"mtx_pinverse – LINALG","text":"public interface mtx_pinverse Contents Module Procedures mtx_pinverse_dbl mtx_pinverse_cmplx Module Procedures private  subroutine mtx_pinverse_dbl(a, ainv, tol, work, olwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. real(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_pinverse_cmplx(a, ainv, tol, work, olwork, rwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. complex(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mtx_pinverse.html"},{"title":"solve_least_squares – LINALG","text":"public interface solve_least_squares Contents Module Procedures solve_least_squares_mtx solve_least_squares_mtx_cmplx solve_least_squares_vec solve_least_squares_vec_cmplx Module Procedures private  subroutine solve_least_squares_mtx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares.html"},{"title":"solve_least_squares_full – LINALG","text":"public interface solve_least_squares_full Contents Module Procedures solve_least_squares_mtx_pvt solve_least_squares_mtx_pvt_cmplx solve_least_squares_vec_pvt solve_least_squares_vec_pvt_cmplx Module Procedures private  subroutine solve_least_squares_mtx_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares_full.html"},{"title":"solve_least_squares_svd – LINALG","text":"public interface solve_least_squares_svd Contents Module Procedures solve_least_squares_mtx_svd solve_least_squares_mtx_svd_cmplx solve_least_squares_vec_svd solve_least_squares_vec_svd_cmplx Module Procedures private  subroutine solve_least_squares_mtx_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares_svd.html"},{"title":"form_lq – LINALG","text":"public interface form_lq Contents Module Procedures form_lq_no_pivot form_lq_no_pivot_cmplx Module Procedures private  subroutine form_lq_no_pivot(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lq_no_pivot_cmplx(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_lq.html"},{"title":"lq_factor – LINALG","text":"public interface lq_factor Contents Module Procedures lq_factor_no_pivot lq_factor_no_pivot_cmplx Module Procedures private  subroutine lq_factor_no_pivot(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine lq_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\lq_factor.html"},{"title":"mult_lq – LINALG","text":"public interface mult_lq Contents Module Procedures mult_lq_mtx mult_lq_mtx_cmplx mult_lq_vec mult_lq_vec_cmplx Module Procedures private  subroutine mult_lq_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_lq.html"},{"title":"solve_lq – LINALG","text":"public interface solve_lq Contents Module Procedures solve_lq_mtx solve_lq_mtx_cmplx solve_lq_vec solve_lq_vec_cmplx Module Procedures private  subroutine solve_lq_mtx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_lq.html"},{"title":"form_lu – LINALG","text":"public interface form_lu Contents Module Procedures form_lu_all form_lu_all_cmplx form_lu_only form_lu_only_cmplx Module Procedures private  subroutine form_lu_all(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_all_cmplx(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only_cmplx(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_lu.html"},{"title":"lu_factor – LINALG","text":"public interface lu_factor Contents Module Procedures lu_factor_dbl lu_factor_cmplx csr_lu_factor Module Procedures private  subroutine lu_factor_dbl(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine lu_factor_cmplx(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine csr_lu_factor(a, lu, ju, droptol, err) Factors a matrix using an LU decomposition. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix to factor. type( msr_matrix ), intent(out) :: lu The LU matrix. integer(kind=int32), intent(out), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\lu_factor.html"},{"title":"solve_lu – LINALG","text":"public interface solve_lu Contents Module Procedures solve_lu_mtx solve_lu_mtx_cmplx solve_lu_vec solve_lu_vec_cmplx csr_lu_solve Module Procedures private  subroutine solve_lu_mtx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_mtx_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine csr_lu_solve(lu, ju, b, x, err) Solves a linear system using an LU decomposition. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: lu The LU matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_lu.html"},{"title":"form_qr – LINALG","text":"public interface form_qr Contents Module Procedures form_qr_no_pivot form_qr_no_pivot_cmplx form_qr_pivot form_qr_pivot_cmplx Module Procedures private  subroutine form_qr_no_pivot(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_no_pivot_cmplx(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot_cmplx(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_qr.html"},{"title":"mult_qr – LINALG","text":"public interface mult_qr Contents Module Procedures mult_qr_mtx mult_qr_mtx_cmplx mult_qr_vec mult_qr_vec_cmplx Module Procedures private  subroutine mult_qr_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_qr.html"},{"title":"qr_factor – LINALG","text":"public interface qr_factor Contents Module Procedures qr_factor_no_pivot qr_factor_no_pivot_cmplx qr_factor_pivot qr_factor_pivot_cmplx Module Procedures private  subroutine qr_factor_no_pivot(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot(a, tau, jpvt, work, olwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot_cmplx(a, tau, jpvt, work, olwork, rwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local allocate of \nreal-valued memory.  If not provided, the memory required is \nallocated within.  If provided, the length of the array must be at\nleast 2*N. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\qr_factor.html"},{"title":"qr_rank1_update – LINALG","text":"public interface qr_rank1_update Contents Module Procedures qr_rank1_update_dbl qr_rank1_update_cmplx Module Procedures private  subroutine qr_rank1_update_dbl(q, r, u, v, work, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . real(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least 2 K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_rank1_update_cmplx(q, r, u, v, work, rwork, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\qr_rank1_update.html"},{"title":"solve_qr – LINALG","text":"public interface solve_qr Contents Module Procedures solve_qr_no_pivot_mtx solve_qr_no_pivot_mtx_cmplx solve_qr_no_pivot_vec solve_qr_no_pivot_vec_cmplx solve_qr_pivot_mtx solve_qr_pivot_mtx_cmplx solve_qr_pivot_vec solve_qr_pivot_vec_cmplx Module Procedures private  subroutine solve_qr_no_pivot_mtx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_vec(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_vec_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_qr.html"},{"title":"mult_rz – LINALG","text":"public interface mult_rz Contents Module Procedures mult_rz_mtx mult_rz_mtx_cmplx mult_rz_vec mult_rz_vec_cmplx Module Procedures private  subroutine mult_rz_mtx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_mtx_cmplx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. real(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec_cmplx(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. complex(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_rz.html"},{"title":"rz_factor – LINALG","text":"public interface rz_factor Contents Module Procedures rz_factor_dbl rz_factor_cmplx Module Procedures private  subroutine rz_factor_dbl(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine rz_factor_cmplx(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\rz_factor.html"},{"title":"sort – LINALG","text":"public interface sort An interface to the sorting routines. Contents Module Procedures sort_dbl_array sort_dbl_array_ind sort_cmplx_array sort_cmplx_array_ind sort_eigen_cmplx sort_eigen_dbl sort_int32_array sort_int32_array_ind Module Procedures private  subroutine sort_dbl_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_dbl_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_cmplx_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_cmplx_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_cmplx(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. complex(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_dbl(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_int32_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_int32_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\sort.html"},{"title":"banded_to_csr – LINALG","text":"public  function banded_to_csr(m, ml, mu, a, err) result(rst) Converts a banded matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the banded matrix. integer(kind=int32), intent(in) :: ml The number of lower diagonals in the banded matrix. integer(kind=int32), intent(in) :: mu The number of upper diagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Contents","tags":"","loc":"proc\\banded_to_csr.html"},{"title":"create_csr_matrix – LINALG","text":"public  function create_csr_matrix(m, n, rows, cols, vals, err) result(rst) Creates a CSR matrix from the input data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in), dimension(:) :: rows The row indices. integer(kind=int32), intent(in), dimension(:) :: cols The column indices. real(kind=real64), intent(in), dimension(:) :: vals The values. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Contents","tags":"","loc":"proc\\create_csr_matrix.html"},{"title":"create_empty_csr_matrix – LINALG","text":"public  function create_empty_csr_matrix(m, n, nnz, err) result(rst) Creates an empty CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero values in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The empty CSR matrix. Contents","tags":"","loc":"proc\\create_empty_csr_matrix.html"},{"title":"create_empty_msr_matrix – LINALG","text":"public  function create_empty_msr_matrix(m, n, nnz, err) result(rst) Creates an empty MSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero elements in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. Contents","tags":"","loc":"proc\\create_empty_msr_matrix.html"},{"title":"csr_to_msr – LINALG","text":"public  function csr_to_msr(a, err) result(rst) Converts a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. Contents","tags":"","loc":"proc\\csr_to_msr.html"},{"title":"dense_to_csr – LINALG","text":"public  function dense_to_csr(a, err) result(rst) Converts a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Contents","tags":"","loc":"proc\\dense_to_csr.html"},{"title":"dense_to_msr – LINALG","text":"public  function dense_to_msr(a, err) result(rst) Converts a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. Contents","tags":"","loc":"proc\\dense_to_msr.html"},{"title":"diag_to_csr – LINALG","text":"public  function diag_to_csr(a, err) result(rst) Converts a diagonal matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Contents","tags":"","loc":"proc\\diag_to_csr.html"},{"title":"msr_to_csr – LINALG","text":"public  function msr_to_csr(a, err) result(rst) Converts an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Contents","tags":"","loc":"proc\\msr_to_csr.html"},{"title":"csr_to_dense – LINALG","text":"public  subroutine csr_to_dense(a, x, err) Converts a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Contents","tags":"","loc":"proc\\csr_to_dense.html"},{"title":"msr_to_dense – LINALG","text":"public  subroutine msr_to_dense(a, x, err) Converts an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Contents","tags":"","loc":"proc\\msr_to_dense.html"},{"title":"assignment(=) – LINALG","text":"public interface assignment(=) Contents Module Procedures csr_assign_to_dense dense_assign_to_csr msr_assign_to_dense dense_assign_to_msr csr_assign_to_msr msr_assign_to_csr Module Procedures private  subroutine csr_assign_to_dense(dense, sparse) Assigns the values of a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( csr_matrix ), intent(in) :: sparse The CSR matrix. private  subroutine dense_assign_to_csr(sparse, dense) Assigns the values of a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: sparse The CSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine msr_assign_to_dense(dense, msr) Assigns an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. private  subroutine dense_assign_to_msr(msr, dense) Assigns a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine csr_assign_to_msr(msr, csr) Assigns a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. class( csr_matrix ), intent(in) :: csr The CSR matrix. private  subroutine msr_assign_to_csr(csr, msr) Assigns an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: csr The CSR matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix.","tags":"","loc":"interface\\assignment(=).html"},{"title":"matmul – LINALG","text":"public interface matmul Contents Module Procedures csr_mtx_mtx_mult csr_mtx_vec_mult Module Procedures private  function csr_mtx_mtx_mult(a, b) result(rst) Multiplies two CSR matrices together. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_vec_mult(a, b) result(rst) Multiplies a CSR matrix by a vector. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in), dimension(:) :: b The vector. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector.","tags":"","loc":"interface\\matmul.html"},{"title":"nonzero_count – LINALG","text":"public interface nonzero_count Contents Module Procedures nonzero_count_csr nonzero_count_msr Module Procedures private pure function nonzero_count_csr(x) result(rst) Returns the number of non-zero values in the matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. Return Value integer(kind=int32) The number of non-zero values in the matrix. private pure function nonzero_count_msr(x) result(rst) Returns the number of non-zero elements in an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. Return Value integer(kind=int32) The number of non-zero elements.","tags":"","loc":"interface\\nonzero_count.html"},{"title":"operator(*) – LINALG","text":"public interface operator(*) Contents Module Procedures csr_mtx_mult_scalar_1 csr_mtx_mult_scalar_2 Module Procedures private  function csr_mtx_mult_scalar_1(a, b) result(rst) Multiplies a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_mult_scalar_2(a, b) result(rst) Multiplies a scalar by a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar. class( csr_matrix ), intent(in) :: b The CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"operator(+) – LINALG","text":"public interface operator(+) Contents Module Procedures csr_mtx_add Module Procedures private  function csr_mtx_add(a, b) result(rst) Adds two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(+).html"},{"title":"operator(-) – LINALG","text":"public interface operator(-) Contents Module Procedures csr_mtx_sub Module Procedures private  function csr_mtx_sub(a, b) result(rst) Subtracts two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(-).html"},{"title":"operator(/) – LINALG","text":"public interface operator(/) Contents Module Procedures csr_mtx_divide_scalar_1 Module Procedures private  function csr_mtx_divide_scalar_1(a, b) result(rst) Divides a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix )","tags":"","loc":"interface\\operator(SLASH).html"},{"title":"pgmres_solver – LINALG","text":"public interface pgmres_solver Contents Module Procedures csr_pgmres_solver Module Procedures private  subroutine csr_pgmres_solver(a, lu, ju, b, x, im, tol, maxits, iout, err) Solves a linear system using the PGMRES method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. class( msr_matrix ), intent(in) :: lu The LU factored matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(inout), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. integer(kind=int32), intent(in), optional :: im The Krylov subspace size. real(kind=real64), intent(in), optional :: tol The convergence tolerance. integer(kind=int32), intent(in), optional :: maxits The maximum number of iterations. integer(kind=int32), intent(in), optional :: iout The output level. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\pgmres_solver.html"},{"title":"size – LINALG","text":"public interface size Contents Module Procedures csr_size msr_size Module Procedures private pure function csr_size(x, dim) result(rst) Returns the size of the matrix along the specified dimension. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the matrix along the specified dimension. private pure function msr_size(x, dim) result(rst) Returns the size of the specified dimension of an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the specified dimension.","tags":"","loc":"interface\\size.html"},{"title":"sparse_direct_solve – LINALG","text":"public interface sparse_direct_solve Contents Module Procedures csr_solve_sparse_direct Module Procedures private  subroutine csr_solve_sparse_direct(a, b, x, droptol, err) Solves a linear system using a direct method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\sparse_direct_solve.html"},{"title":"transpose – LINALG","text":"public interface transpose Contents Module Procedures csr_transpose Module Procedures private  function csr_transpose(a) result(rst) Transposes a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. Return Value type( csr_matrix ) The transposed CSR matrix.","tags":"","loc":"interface\\transpose.html"},{"title":"svd – LINALG","text":"public interface svd Contents Module Procedures svd_dbl svd_cmplx Module Procedures private  subroutine svd_dbl(a, s, u, vt, work, olwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. real(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). real(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \ntranspose of the N-by-N orthogonal matrix .  The matrix contains the right singular vectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine svd_cmplx(a, s, u, vt, work, olwork, rwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. complex(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). complex(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \nconjugate transpose of the N-by-N orthogonal matrix .  The \nmatrix contains the right singular vectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\svd.html"},{"title":"solve_triangular_system – LINALG","text":"public interface solve_triangular_system Contents Module Procedures solve_tri_mtx solve_tri_mtx_cmplx solve_tri_vec solve_tri_vec_cmplx Module Procedures private  subroutine solve_tri_mtx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in) :: alpha The scalar multiplier . real(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_mtx_cmplx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in) :: alpha The scalar multiplier . complex(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . real(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec_cmplx(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . complex(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_triangular_system.html"},{"title":"cholesky_factor – LINALG","text":"public pure function cholesky_factor(a, upper) result(rst) Computes the Cholesky factorization of a positive-definite matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to factor. logical, intent(in), optional :: upper An optional parameter to specifiy if the upper factorization should be computed (true); else, false for the lower\nfactorization .  The default is to compute the upper\nfactorization. Return Value real(kind=real64), allocatable, dimension(:,:) The factored matrix, either or . Contents","tags":"","loc":"proc\\cholesky_factor.html"},{"title":"identity – LINALG","text":"public pure function identity(n) result(rst) Constructs an N-by-N identity matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The size of the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. Contents","tags":"","loc":"proc\\identity.html"},{"title":"inverse – LINALG","text":"public pure function inverse(a) result(rst) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N matrix to invert. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-N inverted matrix. Contents","tags":"","loc":"proc\\inverse.html"},{"title":"lu_factor – LINALG","text":"public pure function lu_factor(a) result(rst) Uses linalg_lu Computes the LU factorization of a square matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N matrix to factor. Return Value type( lu_factors ) The factored form of the matrix. Contents","tags":"","loc":"proc\\lu_factor.html"},{"title":"pinverse – LINALG","text":"public pure function pinverse(a) result(rst) Computes the Moore-Penrose pseudoinverse of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to invert. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-M inverted matrix. Contents","tags":"","loc":"proc\\pinverse.html"},{"title":"qr_factor – LINALG","text":"public pure function qr_factor(a, pivot) result(rst) Computes the QR factorization of an M-by-N matrix such that either (no pivoting), or (with pivoting). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to factor. logical, intent(in), optional :: pivot An optional parameter used to specifiy if pivoting should be used\n(true); else, false if no pivoting is used.  The default is false\nsuch that no pivoting is performed. Return Value type( qr_factors ) The factored form of the matrix. Contents","tags":"","loc":"proc\\qr_factor.html"},{"title":"svd – LINALG","text":"public pure function svd(a) result(rst) Computes the singular value decomposition of an M-by-N matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to factor. Return Value type( svd_factors ) The factored form of the matrix. Contents","tags":"","loc":"proc\\svd.html"},{"title":"swap_arrays – LINALG","text":"public pure subroutine swap_arrays(x, y) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x The first array. real(kind=real64), intent(inout), dimension(:) :: y The second array. Contents","tags":"","loc":"proc\\swap_arrays.html"},{"title":"eigen – LINALG","text":"public interface eigen Contents Module Procedures eigen_1 eigen_2 Module Procedures private pure function eigen_1(a, right) result(rst) Solves the eigenvalue problem where \nmatrix is is square, but not necessarily symmetric.  Optionally,\nthe left eigenvalue problem can be solved such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix . logical, intent(in), optional :: right An optional parameter specifying if the right eigenvalue solution\nshould be computed (true), or the left eigenvalue solution should be\ncomputed (false).  The default is true such that the right eigenvalue\nproblem is solved. Return Value type( eigen_solution ) The solution. private pure function eigen_2(a, b, right) result(rst) Solves the eigenvalue problem where and are both N-by-N matrices.  Optionally, the left\neigenvalue problem can be solved such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix . real(kind=real64), intent(in), dimension(:,:) :: b The matrix . logical, intent(in), optional :: right An optional parameter specifying if the right eigenvalue solution\nshould be computed (true), or the left eigenvalue solution should be\ncomputed (false).  The default is true such that the right eigenvalue\nproblem is solved. Return Value type( eigen_solution ) The solution.","tags":"","loc":"interface\\eigen~2.html"},{"title":"solve_least_squares – LINALG","text":"public interface solve_least_squares Contents Module Procedures solve_least_squares_mtx solve_least_squares_vec Module Procedures private pure function solve_least_squares_mtx(a, b) result(rst) Solves the least squares problem by minimizing using\na complete orthogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:,:) :: b The M-by-NRHS matrix . Return Value real(kind=real64), allocatable, dimension(:,:) The resulting N-by-NRHS matrix . private pure function solve_least_squares_vec(a, b) result(rst) Solves the least squares problem by minimizing using\na complete orthogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: b The M-element array . Return Value real(kind=real64), allocatable, dimension(:) The resulting N-element array .","tags":"","loc":"interface\\solve_least_squares~2.html"},{"title":"solve_linear_system – LINALG","text":"public interface solve_linear_system Contents Module Procedures solve_linear_system_mtx solve_linear_system_vec Module Procedures private pure function solve_linear_system_mtx(a, b) result(rst) Solves the M-by-N linear system for . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:,:) :: b The M-by-NRHS matrix . Return Value real(kind=real64), allocatable, dimension(:,:) The resulting N-by-NRHS matrix . private pure function solve_linear_system_vec(a, b) result(rst) Solves the M-by-N linear system for . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: b The M-element array . Return Value real(kind=real64), allocatable, dimension(:) The resulting N-element array .","tags":"","loc":"interface\\solve_linear_system.html"},{"title":"solve_triangular_system – LINALG","text":"public interface solve_triangular_system Contents Module Procedures solve_triangular_system_mtx solve_triangular_system_vec Module Procedures private pure function solve_triangular_system_mtx(a, b, upper) result(rst) Solves a triangular system of the form where is a\ntriangular matrix, either upper or lower, for equation . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix. real(kind=real64), intent(in), dimension(:,:) :: b The N-by-NRHS matrix. logical, intent(in), optional :: upper An optional argument specifying if the matrix is upper \ntriangular (true), or lower triangular (false).  The default \nassumption is that is an upper triangular matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-NRHS solution matrix, . private pure function solve_triangular_system_vec(a, b, upper) result(rst) Solves a triangular system of the form where is a\ntriangular matrix, either upper or lower, for equation . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix. real(kind=real64), intent(in), dimension(:) :: b The N-element array. logical, intent(in), optional :: upper An optional argument specifying if the matrix is upper \ntriangular (true), or lower triangular (false).  The default \nassumption is that is an upper triangular matrix. Return Value real(kind=real64), allocatable, dimension(:) The N-element solution array, .","tags":"","loc":"interface\\solve_triangular_system~2.html"},{"title":"DCH1DN – LINALG","text":"interface public pure subroutine DCH1DN(n, r, ldr, u, w, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\dch1dn.html"},{"title":"DCH1UP – LINALG","text":"interface public pure subroutine DCH1UP(n, r, ldr, u, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*)","tags":"","loc":"interface\\dch1up.html"},{"title":"DQR1UP – LINALG","text":"interface public pure subroutine DQR1UP(m, n, k, q, ldq, r, ldr, u, v, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: q (ldq,*) integer(kind=int32), intent(in) :: ldq real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(inout) :: v (*) real(kind=real64), intent(out) :: w (*)","tags":"","loc":"interface\\dqr1up.html"},{"title":"ZCH1DN – LINALG","text":"interface public pure subroutine ZCH1DN(n, r, ldr, u, rw, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: rw (*) integer(kind=int32), intent(out) :: info","tags":"","loc":"interface\\zch1dn.html"},{"title":"ZCH1UP – LINALG","text":"interface public pure subroutine ZCH1UP(n, r, ldr, u, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*)","tags":"","loc":"interface\\zch1up.html"},{"title":"ZQR1UP – LINALG","text":"interface public pure subroutine ZQR1UP(m, n, k, q, ldq, r, ldr, u, v, w, rw) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: q (ldq,*) integer(kind=int32), intent(in) :: ldq complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) complex(kind=real64), intent(inout) :: v (*) complex(kind=real64), intent(out) :: w (*) real(kind=real64), intent(out) :: rw (*)","tags":"","loc":"interface\\zqr1up.html"},{"title":"amub – LINALG","text":"interface public pure subroutine amub(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (*) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (*) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr Description @brief Computes the matrix product: C = A * B. @param[in] nrow The row dimension of matrices A & C.\n@param[in] ncol The column dimension of matrices B & C.\n@param[in] job Set to 0 to compute only the structure (JC & IC);\n else, set to any non-zero value.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix C.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX.","tags":"","loc":"interface\\amub.html"},{"title":"aplb – LINALG","text":"interface public pure subroutine aplb(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (nrow+1) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (nrow+1) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr Description @brief Computes the matrix sum: C = A + B, where the matrices are\ngiven in CSR format. @param[in] nrow The number of rows in the matrices.\n@param[in] ncol The number of columns in the matrices.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix A.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX.","tags":"","loc":"interface\\aplb.html"},{"title":"aplsb – LINALG","text":"interface public pure subroutine aplsb(nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, iw, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: s real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (nrow+1) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (nrow+1) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr Description @brief Computes the matrix sum: C = A + s * B, where the matrices\nare given in CSR format. @param[in] nrow The number of rows in the matrices.\n@param[in] ncol The number of columns in the matrices.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] s The scalar multiplier.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix A.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX.","tags":"","loc":"interface\\aplsb.html"},{"title":"bndcsr – LINALG","text":"interface public pure subroutine bndcsr(n, abd, nabd, lowd, ml, mu, a, ja, ia, len, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: abd (nabd,*) integer(kind=int32), intent(in) :: nabd integer(kind=int32), intent(in) :: lowd integer(kind=int32), intent(in) :: ml integer(kind=int32), intent(in) :: mu real(kind=real64), intent(out) :: a (*) integer(kind=int32), intent(out) :: ja (*) integer(kind=int32), intent(out) :: ia (n+1) integer(kind=int32), intent(in) :: len integer(kind=int32), intent(out) :: ierr Description @brief Converts the LINPACK, BLAS, LAPACK banded matrix format into\na CSR format. @param[in] n The row dimension of the matrix.\n@param[in] abd The banded matrix.\n@param[in] nabd The leading dimension of @p abd.\n@param[in] lowd The row index where the lowest diagonal (leftmost) of\n A is located.  LINPACK uses LOWD = 2 * ML + MU + 1.\n@param[in] ml The bandwidth of the strict lower part of A.\n@param[in] mu The bandwidth of the strict upper part of A.\n@param[out] a The non-zero elements of matrix A.\n@param[out] ja The column indices of matrix A.\n@param[out] ia The index in A where the requested row starts.\n@param[in] len The length of @p a and @p ja.\n@param[out] ierr Error message output.\n * 0: Normal return.\n * -1: Invalid @p lowd value.\n * Positive Valued: Not enough storage in @p a and @p ja.","tags":"","loc":"interface\\bndcsr.html"},{"title":"clncsr – LINALG","text":"interface public pure subroutine clncsr(job, value2, nrow, a, ja, ia, indu, iwk) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: value2 integer(kind=int32), intent(in) :: nrow real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (*) integer(kind=int32), intent(inout) :: indu (*) integer(kind=int32), intent(inout) :: iwk (*) Description @breif Cleans up a CSR matrix. @param[in] job The job to perform.\n - 0: Nothing is done\n - 1: Eliminate duplicate entries and zero entries.\n - 2: Eliminate duplicate entries and perform partial ordering.\n - 3: Eliminate duplicate entries and sort the entries in increasing\n     order of column indices.\n@param[in] value2 0 if the matrix is pattern only (A is not touched),\n or 1 if the matrix has values.\n@param[in] nrow The number of rows in the matrix.\n@param[in,out] a The non-zero values.\n@param[in,out] ja An array of column indices of the elements in A.\n@param[in,out] ia An array of pointers to the rows.\n@param[out] indu An NROW array containing pointers to the beginning \n of the upper triangular portion if job > 1.\n@param[out] iwk An NROW+1 element workspace array.","tags":"","loc":"interface\\clncsr.html"},{"title":"coocsr – LINALG","text":"interface public pure subroutine coocsr(nrow, nnz, a, ir, jc, ao, jao, iao) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: nnz real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(inout) :: ir (*) integer(kind=int32), intent(in) :: jc (*) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) integer(kind=int32), intent(out) :: iao (*) Description @brief Converte a matrix stored in coordinate format to CSR format. @param[in] nrow The number of rows in the matrix.\n@param[in] nnz The number of non-zero elements in the matrix.\n@param[in] a An NNZ-element array containing the non-zero elements\n of the matrix.\n@param[in,out] ir An NNZ-element array containing the row indices of\n each non-zero element.\n@param[in] jc An NNZ-element array containing the column indices of\n each non-zero element.\n@param[out] ao The non-zero elements of matrix A.\n@param[out] jao The column indices of matrix A.\n@param[out] iao The index in A where the requested row starts.","tags":"","loc":"interface\\coocsr.html"},{"title":"csort – LINALG","text":"interface public pure subroutine csort(n, a, ja, ia, values) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(in) :: ia (*) logical, intent(in) :: values Description @brief Sorces the elements of a CSR matrix in increasing order of \ntheir column indices within each row. @param[in] n The number of rows in the matrix.\n@param[in,out] a The non-zero values.\n@param[in,out] ja An array of column indices of the elements in A.\n@param[in] ia An array of pointers to the rows.\n@param[in] values Idicates whether A must also be permuted.  If\n false, A can be a dummy array.","tags":"","loc":"interface\\csort.html"},{"title":"csrcsc2 – LINALG","text":"interface public pure subroutine csrcsc2(n, n2, job, ipos, a, ja, ia, a0, ja0, ia0) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: n2 integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: ipos real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(out) :: a0 (*) integer(kind=int32), intent(out) :: ja0 (*) integer(kind=int32), intent(out) :: ia0 (n2+1) Description @brief Converts a CSR matrix into a CSC matrix (transposition). @param[in] n The number of rows in the CSR matrix.\n@param[in] n2 The number of columns in the CSC matrix.\n@param[in] job Fill the values (job == 1) or only the pattern \n (job /= 1).\n@param[in] ipos Starting position of A0 in JA0.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[out] a0 The non-zero elements of the transposed array.\n@param[out] ja0 The size NNZ array containing the column indices.\n@param[out] ia0 The N+1 size array containing the column starts.","tags":"","loc":"interface\\csrcsc2.html"},{"title":"csrmsr – LINALG","text":"interface public pure subroutine csrmsr(n, a, ja, ia, ao, jao, wk, iwk) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) real(kind=real64), intent(out) :: wk (n) integer(kind=int32), intent(out) :: iwk (n+1) Description @brief Converts a CSR matrix to an MSR matrix. @param[in] n The row dimension of the matrix.\n@param[in,out] a The non-zero elements of matrix A.\n@param[in,out] ja The column indices of matrix A.\n@param[in,out] ia The index in A where the requested row starts.\n@param[out] ao An NNZ-element array containing the non-zero elements\n for the MSR matrix.\n@param[out] jao An NNZ-element index tracking array for the MSR\n matrix.\n@param[out] wk An N-element workspace array.\n@param[out] iwk An N+1 element workspace array.","tags":"","loc":"interface\\csrmsr.html"},{"title":"getdia – LINALG","text":"interface public pure subroutine getdia(nrow, ncol, job, a, ja, ia, len, diag, idiag, ioff) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (*) integer(kind=int32), intent(out) :: len real(kind=real64), intent(out) :: diag (*) integer(kind=int32), intent(out) :: idiag (*) integer(kind=int32), intent(in) :: ioff Description @brief Extracts the diagonal from a matrix. @param[in] nrow The number of rows.\n@param[in] ncol The number of columns.\n@param[in] job Set to 0 to not alter @p a, @p ja, and @p ia; else,\nset to a non-zero value to perform this as an in-place operation.\n@param[out] len The number of non-zero elements found in @p diag.\n@param[out] idiag An array of length @p len containing the original\n positions in the original arrays @p a and @p ja of the diagonal\n elements collected in diagl.\n@param[in] ioff The offset of the wanted diagonal.","tags":"","loc":"interface\\getdia.html"},{"title":"getelm – LINALG","text":"interface public  function getelm(i, j, a, ja, ia, iadd, sorted) result(rst) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (*) integer(kind=int32), intent(out) :: iadd logical, intent(in) :: sorted Return Value real(kind=real64) Description @brief Gets element A(i,j) of matrix A for any pair (i,j). @param[in] i The row index.\n@param[in] j The column index.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[out] iadd The address of element A(i,j) in arrays A & JA, if \n found; else, zero if not found.\n@param[in] sorted Indicates whether the matrix is known to be sorted. @return The requested value.","tags":"","loc":"interface\\getelm.html"},{"title":"ilud – LINALG","text":"interface public pure subroutine ilud(n, a, ja, ia, alph, tol, alu, jlu, ju, iwk, w, jw, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(in) :: alph real(kind=real64), intent(in) :: tol real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (2*n) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: ierr Description @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format with standard dropping strategy. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alph The diagonal compensation parameter.  If ALPH = 0,\n the process is approximately equivalent to ILU with threshold; else,\n if ALPH = 1, the process is approximately equivalent to MILU with\n threshold.\n@param[in] tol The threshold parameter for dropping small terms in\n the factorization.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: Insufficient storage for the LU factors.\n * -3: Zero-valued row encountered.","tags":"","loc":"interface\\ilud.html"},{"title":"iludp – LINALG","text":"interface public pure subroutine iludp(n, a, ja, ia, alph, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) real(kind=real64), intent(in) :: alph real(kind=real64), intent(in) :: droptol real(kind=real64), intent(in) :: permtol integer(kind=int32), intent(in) :: mbloc real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (2*n) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: iperm (2*n) integer(kind=int32), intent(out) :: ierr Description @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format with standard dropping strategy. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alph The diagonal compensation parameter.  If ALPH = 0,\n the process is approximately equivalent to ILU with threshold; else,\n if ALPH = 1, the process is approximately equivalent to MILU with\n threshold.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[in] permtol A tolerance ratio used to determine whether or\n not to permute two columns.  At step I, columns I and J are \n permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values\n are typically between 0.1 to 0.01.\n@param[in] mbloc If desired, permuting can be done only within the\n diagonal blocks of size MBLOC.  Useful for PDE problems with many\n degrees of freedom.  If this feature is not required, simply set\n MBLOC equal to N.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: Insufficient storage for the LU factors.\n * -3: Zero-valued row encountered.","tags":"","loc":"interface\\iludp.html"},{"title":"ilut – LINALG","text":"interface public pure subroutine ilut(n, a, ja, ia, lfil, droptol, alu, jlu, ju, iwk, w, jw, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) integer(kind=int32), intent(in) :: lfil real(kind=real64), intent(in) :: droptol real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (n+1) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: ierr Description @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format using a dual truncation mechanism. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] lfil The fill-in parameter.  Each row of L and each row\n of U will have a maximum of @p lfil elements, excluding the \n diagonal element.  @p lfil must be greater than or equal to zero.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: The matrix L overflows the output array.\n * -3: The matrix U overflows the output array.\n * -4: Illegal value for @P lfil.\n * -5: Zero-valued row encountered.","tags":"","loc":"interface\\ilut.html"},{"title":"ilutp – LINALG","text":"interface public pure subroutine ilutp(n, a, ja, ia, lfil, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) integer(kind=int32), intent(in) :: lfil real(kind=real64), intent(in) :: droptol real(kind=real64), intent(in) :: permtol integer(kind=int32), intent(in) :: mbloc real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (n+1) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: iperm (2*n) integer(kind=int32), intent(out) :: ierr Description @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format using a dual truncation mechanism and pivoting. @param[in] n The row dimension of the matrix.\n@param[in,out] a The non-zero elements of matrix A.  On output, the\n columns are permuted.\n@param[in,out] ja The column indices of matrix A.  On output, the\n columns are permuted.\n@param[in,out] ia The index in A where the requested row starts.  On \n output, the columns are permuted.\n@param[in] lfil The fill-in parameter.  Each row of L and each row\n of U will have a maximum of @p lfil elements, excluding the \n diagonal element.  @p lfil must be greater than or equal to zero.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[in] permtol A tolerance ratio used to determine whether or\n not to permute two columns.  At step I, columns I and J are \n permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values\n are typically between 0.1 to 0.01.\n@param[in] mbloc If desired, permuting can be done only within the\n diagonal blocks of size MBLOC.  Useful for PDE problems with many\n degrees of freedom.  If this feature is not required, simply set\n MBLOC equal to N.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2 N element workspace array.\n@param[out] iperm A 2 N element array containing the permutation\n arrays.  IPERM(1:N) contains the old numbers of unknowns, and \n IPERM(N+1:) contains the new unknowns.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: The matrix L overflows the output array.\n * -3: The matrix U overflows the output array.\n * -4: Illegal value for @P lfil.\n * -5: Zero-valued row encountered. @par Remarks\nTo avoid permuting the solution vector arrays for each LU-solve, the\nmatrix A is permuted on return.  Similarly for the U matrix.  To\npermute the matrix back to its original state, use the following\ncode.\n@code{.f90}\ndo k = ia(1), ia(n+1) - 1\n ja(k) = iperm(ja(k))\nend do\n@endcode","tags":"","loc":"interface\\ilutp.html"},{"title":"lusol – LINALG","text":"interface public pure subroutine lusol(n, y, x, alu, jlu, ju) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: y (n) real(kind=real64), intent(out) :: x (n) real(kind=real64), intent(in) :: alu (*) integer(kind=int32), intent(in) :: jlu (*) integer(kind=int32), intent(in) :: ju (*) Description @brief Solves the LU-factored system (LU) x = y. @param[in] n The dimension of the system.\n@param[in] y The N-element right-hand-side vector.\n@param[out] x The N-element solution vector.\n@param[in] alu The LU-factored matrix.\n@param[in] jlu The LU-factored matrix.\n@param[in] ju The LU-factored matrix.","tags":"","loc":"interface\\lusol.html"},{"title":"msrcsr – LINALG","text":"interface public pure subroutine msrcsr(n, a, ja, ao, jao, iao, wk, iwk) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) integer(kind=int32), intent(out) :: iao (n+1) real(kind=real64), intent(out) :: wk (n) integer(kind=int32), intent(out) :: iwk (n+1) Description @brief Converts and MSR matrix to a CSR matrix. @param[in] n The row dimension of the matrix.\n@param[in] a An NNZ-element array containing the non-zero elements\n for the MSR matrix.\n@param[in] ja An NNZ-element index tracking array for the MSR\n matrix.\n@param[out] ao The non-zero elements of matrix A.\n@param[out] jao The column indices of matrix A.\n@param[out] iao The index in A where the requested row starts.\n@param[out] wk An N-element workspace array.\n@param[out] iwk An N+1 element workspace array.","tags":"","loc":"interface\\msrcsr.html"},{"title":"pgmres – LINALG","text":"interface public pure subroutine pgmres(n, im, rhs, sol, vv, eps, maxits, iout, aa, ja, ia, alu, jlu, ju, ierr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: im real(kind=real64), intent(inout) :: rhs (n) real(kind=real64), intent(inout) :: sol (n) real(kind=real64), intent(out) :: vv (n,*) real(kind=real64), intent(in) :: eps integer(kind=int32), intent(in) :: maxits integer(kind=int32), intent(in) :: iout real(kind=real64), intent(in) :: aa (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(in) :: alu (*) integer(kind=int32), intent(in) :: jlu (*) integer(kind=int32), intent(in) :: ju (n) integer(kind=int32), intent(out) :: ierr Description @brief An ILUT preconditioned GMRES algorithm.  This routine utilizes\nthe L and U matrices generated by the ILUT routine to precondition\nthe GMRES algorithm.  The stopping criteria utilized is based simply \non reducing the residual norm to the requested tolerance. @param[in] n The row dimension of the matrix.\n@param[in] im The size of the Krylov subspace.  This value should\n not exceed 50.\n@param[in,out] rhs The N-element right-hand-side vector.  On output,\n the contents of this array are overwritten.\n@param[in,out] sol On input, the N-element solution estimate.  On\n output, the computed solution.\n@param[out] vv An N-by-IM+1 workspace matrix.\n@param[in] eps The convergence tolerance against which the norm of\n the residual is checked.\n@param[in] maxits The maximum number of iterations to allow.\n@param[in] iout The device output number for printing intermediate\n results.  Set to a value less than or equal to zero to suppress\n printing.\n@param[in] aa The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alu The LU-factored matrix from ILUT.\n@param[in] jlu The LU-factored matrix from ILUT.\n@param[in] ju The LU-factored matrix from ILUT.\n@param[out] ierr Error flag:\n * 0: Successful return\n * 1: Convergence not achieved.\n * -1: The initial guess seems to be the exact solution.","tags":"","loc":"interface\\pgmres.html"},{"title":"blas – LINALG","text":"@brief A module providing explicit interfaces to BLAS routines. Contents Interfaces DDOT DGBMV DGEMM DGEMV DSCAL DSWAP DTRSM DTRSV ZDSCAL ZGBMV ZGEMM ZGEMV ZSCAL ZTRSM ZTRSV Interfaces interface public pure function DDOT(n, dx, incx, dy, incy) result(rst) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: dx (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: dy (*) integer(kind=int32), intent(in) :: incy Return Value real(kind=real64) interface public pure subroutine DGBMV(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: kl integer(kind=int32), intent(in) :: ku real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy interface public pure subroutine DGEMM(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc interface public pure subroutine DGEMV(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(in) :: beta real(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy interface public pure subroutine DSCAL(n, da, dx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: da real(kind=real64), intent(inout) :: dx (*) integer(kind=int32), intent(in) :: incx interface public pure subroutine DSWAP(n, dx, incx, dy, incy) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: dx (*) integer(kind=int32), intent(in) :: incx real(kind=real64), intent(inout) :: dy (*) integer(kind=int32), intent(in) :: incy interface public pure subroutine DTRSM(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb interface public pure subroutine DTRSV(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: x (*) integer(kind=int32), intent(in) :: incx interface public pure subroutine ZDSCAL(n, da, zx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: da complex(kind=real64), intent(inout) :: zx (*) integer(kind=int32), intent(in) :: incx interface public pure subroutine ZGBMV(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: kl integer(kind=int32), intent(in) :: ku complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy interface public pure subroutine ZGEMM(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc interface public pure subroutine ZGEMV(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: x (*) integer(kind=int32), intent(in) :: incx complex(kind=real64), intent(in) :: beta complex(kind=real64), intent(inout) :: y (*) integer(kind=int32), intent(in) :: incy interface public pure subroutine ZSCAL(n, za, zx, incx) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: za complex(kind=real64), intent(inout) :: zx (*) integer(kind=int32), intent(in) :: incx interface public pure subroutine ZTRSM(side, uplo, transa, diag, m, n, alpha, a, lda, b, ldb) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: uplo character(len=1), intent(in) :: transa character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: alpha complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb interface public pure subroutine ZTRSV(uplo, trans, diag, n, a, lda, x, incx) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo character(len=1), intent(in) :: trans character(len=1), intent(in) :: diag integer(kind=int32), intent(in) :: n complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: x (*) integer(kind=int32), intent(in) :: incx","tags":"","loc":"module\\blas.html"},{"title":"lapack – LINALG","text":"Contents Interfaces DGEEV DGELQF DGELS DGELSS DGELSY DGEQP3 DGEQRF DGESV DGESVD DGETRF DGETRI DGETRS DGGEV DGGEV3 DLAIC1 DLAMCH DLASET DLASRT DORGLQ DORGQR DORMLQ DORMQR DORMRZ DPOTRF DPOTRS DSYEV DTZRZF ZGEEV ZGELQF ZGELS ZGELSS ZGELSY ZGEQP3 ZGEQRF ZGESVD ZGETRF ZGETRI ZGETRS ZLAIC1 ZPOTRF ZPOTRS ZTZRZF ZUNGLQ ZUNGQR ZUNMLQ ZUNMQR zunmrz Interfaces interface public pure subroutine DGEEV(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: wr (*) real(kind=real64), intent(out) :: wi (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGELQF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGELS(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGELSS(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGELSY(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGEQP3(m, n, a, lda, jpvt, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGEQRF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGESV(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info interface public pure subroutine DGESVD(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(out) :: u (ldu,*) integer(kind=int32), intent(in) :: ldu real(kind=real64), intent(out) :: vt (ldvt,*) integer(kind=int32), intent(in) :: ldvt real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGETRF(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) integer(kind=int32), intent(out) :: info interface public pure subroutine DGETRI(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGETRS(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info interface public pure subroutine DGGEV(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: alphar (*) real(kind=real64), intent(out) :: alphai (*) real(kind=real64), intent(out) :: beta (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DGGEV3(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: alphar (*) real(kind=real64), intent(out) :: alphai (*) real(kind=real64), intent(out) :: beta (*) real(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl real(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DLAIC1(job, j, x, sest, w, gamma, sestpr, s, c) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: j real(kind=real64), intent(in) :: x (j) real(kind=real64), intent(in) :: sest real(kind=real64), intent(in) :: w (j) real(kind=real64), intent(in) :: gamma real(kind=real64), intent(out) :: sestpr real(kind=real64), intent(out) :: s real(kind=real64), intent(out) :: c interface public pure function DLAMCH(cmach) result(x) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: cmach Return Value real(kind=real64) interface public pure subroutine DLASET(uplo, m, n, alpha, beta, a, lda) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in) :: beta real(kind=real64), intent(out) :: a (lda,*) integer(kind=int32), intent(in) :: lda interface public pure subroutine DLASRT(id, n, d, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: id integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: d (*) integer(kind=int32), intent(out) :: info interface public pure subroutine DORGLQ(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DORGQR(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DORMLQ(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DORMQR(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DORMRZ(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k integer(kind=int32), intent(in) :: l real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(in) :: tau (*) real(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DPOTRF(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: info interface public pure subroutine DPOTRS(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs real(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info interface public pure subroutine DSYEV(jobz, uplo, n, a, lda, w, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: w (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine DTZRZF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: tau (*) real(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZGEEV(jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobvl character(len=1), intent(in) :: jobvr integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: w (*) complex(kind=real64), intent(out) :: vl (ldvl,*) integer(kind=int32), intent(in) :: ldvl complex(kind=real64), intent(out) :: vr (ldvr,*) integer(kind=int32), intent(in) :: ldvr complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGELQF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZGELS(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZGELSS(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb real(kind=real64), intent(out) :: s (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGELSY(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(inout) :: jpvt (*) real(kind=real64), intent(in) :: rcond integer(kind=int32), intent(out) :: rank complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGEQP3(m, n, a, lda, jpvt, tau, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(inout) :: jpvt (*) complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGEQRF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZGESVD(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobu character(len=1), intent(in) :: jobvt integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda real(kind=real64), intent(out) :: s (*) complex(kind=real64), intent(out) :: u (ldu,*) integer(kind=int32), intent(in) :: ldu complex(kind=real64), intent(out) :: vt (ldvt,*) integer(kind=int32), intent(in) :: ldvt complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork real(kind=real64), intent(out) :: rwork (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGETRF(m, n, a, lda, ipiv, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: ipiv (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZGETRI(n, a, lda, ipiv, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZGETRS(trans, n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(in) :: ipiv (*) complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info interface public pure subroutine ZLAIC1(job, j, x, sest, w, gamma, sestpr, s, c) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: j complex(kind=real64), intent(in) :: x (j) real(kind=real64), intent(in) :: sest complex(kind=real64), intent(in) :: w (j) complex(kind=real64), intent(in) :: gamma real(kind=real64), intent(out) :: sestpr complex(kind=real64), intent(out) :: s complex(kind=real64), intent(out) :: c interface public pure subroutine ZPOTRF(uplo, n, a, lda, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda integer(kind=int32), intent(out) :: info interface public pure subroutine ZPOTRS(uplo, n, nrhs, a, lda, b, ldb, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: uplo integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: nrhs complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(inout) :: b (ldb,*) integer(kind=int32), intent(in) :: ldb integer(kind=int32), intent(out) :: info interface public pure subroutine ZTZRZF(m, n, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(out) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZUNGLQ(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZUNGQR(m, n, k, a, lda, tau, work, lwork, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZUNMLQ(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine ZUNMQR(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info interface public pure subroutine zunmrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: side character(len=1), intent(in) :: trans integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k integer(kind=int32), intent(in) :: l complex(kind=real64), intent(in) :: a (lda,*) integer(kind=int32), intent(in) :: lda complex(kind=real64), intent(in) :: tau (*) complex(kind=real64), intent(inout) :: c (ldc,*) integer(kind=int32), intent(in) :: ldc complex(kind=real64), intent(out) :: work (*) integer(kind=int32), intent(in) :: lwork integer(kind=int32), intent(out) :: info","tags":"","loc":"module\\lapack.html"},{"title":"linalg – LINALG","text":"Uses linalg_lu linalg_lq linalg_rz linalg_sorting linalg_qr linalg_sparse linalg_basic linalg_tri linalg_cholesky linalg_svd linalg_eigen linalg_inverse linalg_least_squares Contents None","tags":"","loc":"module\\linalg.html"},{"title":"linalg_basic – LINALG","text":"Uses linalg_errors ferror lapack iso_fortran_env linalg_sparse blas Contents Variables LA_HERMITIAN_TRANSPOSE LA_NO_OPERATION LA_TRANSPOSE Interfaces band_diag_mtx_mult band_mtx_mult band_mtx_to_full_mtx banded_to_dense dense_to_banded det diag_mtx_mult extract_diagonal mtx_mult mtx_rank rank1_update recip_mult_array swap trace tri_mtx_mult Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: LA_HERMITIAN_TRANSPOSE = 2 Defines a Hermitian transpose operation for a complex-valued matrix. integer(kind=int32), public, parameter :: LA_NO_OPERATION = 0 Defines no operation should be performed on the matrix. integer(kind=int32), public, parameter :: LA_TRANSPOSE = 1 Defines a transpose operation. Interfaces public        interface band_diag_mtx_mult An interface to the banded diagonal matrix multiplication routines. private  subroutine band_diag_mtx_mult_dbl(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. real(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_diag_mtx_mult_cmplx(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. complex(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface band_mtx_mult An interface to the banded matrix multiplication routines. private  subroutine band_mtx_vec_mult_dbl(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation or where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating whether to perform the operation (FALSE) or (TRUE). integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. real(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_mtx_vec_mult_cmplx(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: trans An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. complex(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface band_mtx_to_full_mtx An interface to the banded matrix to full matrix conversion routines. private  subroutine band_to_full_mtx_dbl(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_to_full_mtx_cmplx(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. complex(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface banded_to_dense An interface to the banded to dense matrix conversion routines. private  subroutine banded_to_dense_dbl(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. real(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine banded_to_dense_cmplx(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. complex(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface dense_to_banded An interface to the dense to banded matrix conversion routines. private  subroutine dense_to_banded_dbl(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine dense_to_banded_cmplx(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface det An interface to the determinant routines. private  function det_dbl(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value real(kind=real64) The determinant of the matrix. private  function det_cmplx(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value complex(kind=real64) The determinant of the matrix. public        interface diag_mtx_mult An interface to the diagonal matrix multiplication routines. private  subroutine diag_mtx_mult_mtx(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx3(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx4(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_cmplx(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_cmplx(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_mix(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_mix(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_sparse_mult(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix and is a sparse matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in), dimension(:) :: a class( csr_matrix ), intent(inout) :: b class(errors), intent(inout), optional, target :: err public        interface extract_diagonal An interface to the diagonal extraction routines. private  subroutine extract_diagonal_dbl(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_cmplx(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. complex(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_csr(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface mtx_mult An interface to the matrix multiplication routines. private  subroutine mtx_mult_mtx(transa, transb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: transa A logical flag indicating if the matrix should be transposed. logical, intent(in) :: transb A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine mtx_mult_vec(trans, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:) :: b The vector in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the vector . real(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_mtx(opa, opb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_vec(opa, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:) :: b The vector in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the vector . complex(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface mtx_rank An interface to the matrix rank routines. private  function mtx_rank_dbl(a, tol, work, olwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value integer(kind=int32) The rank of the matrix. private  function mtx_rank_cmplx(a, tol, work, olwork, rwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any\nlocal memory allocation for real-valued workspace arrays.  If not \nprovided, the memory required is allocated within.  If provided, the\nlength of the array must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The rank of the matrix. Return Value integer(kind=int32) The rank of the matrix. public        interface rank1_update An interface to the rank-1 update routines. private  subroutine rank1_update_dbl(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . real(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. real(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. real(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine rank1_update_cmplx(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . complex(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. complex(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface recip_mult_array An interface to the reciprocal multiplication routines. private  subroutine recip_mult_array_dbl(a, x) Computes the product of a scalar and a vector, where the scalar is \nthe reciprocal of the scalar A. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar A, which is the reciprocal of the scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: x On input, the vector to multiply.  On output, the product of the\nvector and the scalar reciprocal. public        interface swap An interface to the swap routines. private  subroutine swap_dbl(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the \nfirst array are copied to the second array. real(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the \nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine swap_cmplx(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the\nfirst array are copied to the second array. complex(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the\nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface trace An interface to the trace routines. private pure function trace_dbl(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value real(kind=real64) The trace of the matrix. private pure function trace_cmplx(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value complex(kind=real64) The trace of the matrix. public        interface tri_mtx_mult An interface to the triangular matrix multiplication routines. private  subroutine tri_mtx_mult_dbl(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular \n(TRUE) or lower triangular (FALSE). real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine tri_mtx_mult_cmplx(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular\n(TRUE) or lower triangular (FALSE). complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_basic.html"},{"title":"linalg_cholesky – LINALG","text":"Uses iso_fortran_env lapack qrupdate linalg_errors Contents Interfaces cholesky_factor cholesky_rank1_downdate cholesky_rank1_update solve_cholesky Interfaces public        interface cholesky_factor private  subroutine cholesky_factor_dbl(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine cholesky_factor_cmplx(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface cholesky_rank1_downdate private  subroutine cholesky_rank1_downdate_dbl(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_downdate_cmplx(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface cholesky_rank1_update private  subroutine cholesky_rank1_update_dbl(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_update_cmplx(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface solve_cholesky private  subroutine solve_cholesky_mtx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_mtx_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_cholesky.html"},{"title":"linalg_c_api – LINALG","text":"@brief Provides a C-friendly API to the LINALG library.  Notice, all C-API \nLINALG routines begin with the prefix \"la_\". Uses ferror linalg iso_c_binding linalg_errors Contents Functions la_band_diag_mtx_mult la_band_diag_mtx_mult_cmplx la_band_mtx_vec_mult la_band_mtx_vec_mult_cmplx la_band_to_full_mtx la_band_to_full_mtx_cmplx la_cholesky_factor la_cholesky_factor_cmplx la_cholesky_rank1_downdate la_cholesky_rank1_downdate_cmplx la_cholesky_rank1_update la_cholesky_rank1_update_cmplx la_det la_det_cmplx la_diag_mtx_mult la_diag_mtx_mult_cmplx la_diag_mtx_mult_mixed la_eigen_asymm la_eigen_cmplx la_eigen_gen la_eigen_symm la_form_lq la_form_lq_cmplx la_form_lu la_form_lu_cmplx la_form_qr la_form_qr_cmplx la_form_qr_cmplx_pvt la_form_qr_pvt la_inverse la_inverse_cmplx la_lq_factor la_lq_factor_cmplx la_lu_factor la_lu_factor_cmplx la_mtx_mult la_mtx_mult_cmplx la_mult_lq la_mult_lq_cmplx la_mult_qr la_mult_qr_cmplx la_pinverse la_pinverse_cmplx la_qr_factor la_qr_factor_cmplx la_qr_factor_cmplx_pvt la_qr_factor_pvt la_qr_rank1_update la_qr_rank1_update_cmplx la_rank la_rank1_update la_rank1_update_cmplx la_rank_cmplx la_solve_cholesky la_solve_cholesky_cmplx la_solve_least_squares la_solve_least_squares_cmplx la_solve_lq la_solve_lq_cmplx la_solve_lu la_solve_lu_cmplx la_solve_qr la_solve_qr_cmplx la_solve_qr_cmplx_pvt la_solve_qr_pvt la_solve_tri_mtx la_solve_tri_mtx_cmplx la_sort_eigen la_sort_eigen_cmplx la_svd la_svd_cmplx la_trace la_trace_cmplx la_tri_mtx_mult la_tri_mtx_mult_cmplx Functions public  function la_band_diag_mtx_mult (left, m, n, kl, ku, alpha, a, lda, b) result(flag) bind(C, name = \"la_band_diag_mtx_mult\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: left integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: b (*) Return Value integer(kind=c_int) public  function la_band_diag_mtx_mult_cmplx (left, m, n, kl, ku, alpha, a, lda, b) result(flag) bind(C, name = \"la_band_diag_mtx_mult_cmplx\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: left integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: b (*) Return Value integer(kind=c_int) public  function la_band_mtx_vec_mult (trans, m, n, kl, ku, alpha, a, lda, x, beta, y) result(flag) bind(C, name = \"la_band_mtx_vec_mult\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: x (*) real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: y (*) Return Value integer(kind=c_int) public  function la_band_mtx_vec_mult_cmplx (trans, m, n, kl, ku, alpha, a, lda, x, beta, y) result(flag) bind(C, name = \"la_band_mtx_vec_mult_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: x (*) complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: y (*) Return Value integer(kind=c_int) public  function la_band_to_full_mtx (m, n, kl, ku, b, ldb, f, ldf) result(flag) bind(C, name = \"la_band_to_full_mtx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(out) :: f (ldf,*) integer(kind=c_int), intent(in), value :: ldf Return Value integer(kind=c_int) public  function la_band_to_full_mtx_cmplx (m, n, kl, ku, b, ldb, f, ldf) result(flag) bind(C, name = \"la_band_to_full_mtx_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: kl integer(kind=c_int), intent(in), value :: ku complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(out) :: f (ldf,*) integer(kind=c_int), intent(in), value :: ldf Return Value integer(kind=c_int) public  function la_cholesky_factor (upper, n, a, lda) result(flag) bind(C, name = \"la_cholesky_factor\")) @brief Computes the Cholesky factorization of a symmetric, positive\ndefinite matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_cholesky_factor_cmplx (upper, n, a, lda) result(flag) bind(C, name = \"la_cholesky_factor_cmplx\")) @brief Computes the Cholesky factorization of a symmetric, positive\ndefinite matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_cholesky_rank1_downdate (n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_downdate\")) @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper\ntriangular). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) public  function la_cholesky_rank1_downdate_cmplx (n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_downdate_cmplx\")) @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper\ntriangular). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) public  function la_cholesky_rank1_update (n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_update\")) @brief Computes the rank 1 update to a Cholesky factored matrix (upper\ntriangular). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) public  function la_cholesky_rank1_update_cmplx (n, r, ldr, u) result(flag) bind(C, name = \"la_cholesky_rank1_update_cmplx\")) @brief Computes the rank 1 update to a Cholesky factored matrix (upper\ntriangular). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) Return Value integer(kind=c_int) public  function la_det (n, a, lda, d) result(flag) bind(C, name=\"la_det\")) @brief Computes the determinant of a square matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: d Return Value integer(kind=c_int) public  function la_det_cmplx (n, a, lda, d) result(flag) bind(C, name=\"la_det_cmplx\")) @brief Computes the determinant of a square matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: d Return Value integer(kind=c_int) public  function la_diag_mtx_mult (lside, transb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_diag_mtx_mult\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: transb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (*) real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_diag_mtx_mult_cmplx (lside, opb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_diag_mtx_mult_cmplx\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (*) complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_diag_mtx_mult_mixed (lside, opb, m, n, k, alpha, a, b, ldb, beta, c, ldc) result(flag) bind(C, name = \"la_diag_mtx_mult_mixed\")) @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C,\nor C = alpha * op(B) * A + beta * C. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (*) complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_eigen_asymm (vecs, n, a, lda, vals, v, ldv) result(flag) bind(C, name = \"la_eigen_asymm\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: vals (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_eigen_cmplx (vecs, n, a, lda, vals, v, ldv) result(flag) bind(C, name = \"la_eigen_cmplx\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: vals (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_eigen_gen (vecs, n, a, lda, b, ldb, alpha, beta, v, ldv) result(flag) bind(C, name = \"la_eigen_gen\")) @brief Computes the eigenvalues, and optionally the right eigenvectors of\na square matrix assuming the structure of the eigenvalue problem is\nA X = lambda B*X. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(out) :: alpha (*) real(kind=c_double), intent(out) :: beta (*) complex(kind=c_double), intent(out) :: v (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_eigen_symm (vecs, n, a, lda, vals) result(flag) bind(C, name = \"la_eigen_symm\")) @brief Computes the eigenvalues, and optionally the eigenvectors of a\nreal, symmetric matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: vecs integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: vals (*) Return Value integer(kind=c_int) public  function la_form_lq (m, n, l, ldl, tau, q, ldq) result(flag) bind(C, name = \"la_form_lq\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: l (ldl,*) integer(kind=c_int), intent(in), value :: ldl real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) public  function la_form_lq_cmplx (m, n, l, ldl, tau, q, ldq) result(flag) bind(C, name = \"la_form_lq_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: l (ldl,*) integer(kind=c_int), intent(in), value :: ldl complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) public  function la_form_lu (n, a, lda, ipvt, u, ldu, p, ldp) result(flag) bind(C, name = \"la_form_lu\")) @brief Extracts the L, U, and P matrices from the LU factorization\noutput from la_lu_factor. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) real(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) public  function la_form_lu_cmplx (n, a, lda, ipvt, u, ldu, p, ldp) result(flag) bind(C, name = \"la_form_lu_cmplx\")) @brief Extracts the L, U, and P matrices from the LU factorization\noutput from la_lu_factor. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) complex(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) public  function la_form_qr (fullq, m, n, r, ldr, tau, q, ldq) result(flag) bind(C, name = \"la_form_qr\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) public  function la_form_qr_cmplx (fullq, m, n, r, ldr, tau, q, ldq) result(flag) bind(C, name = \"la_form_qr_cmplx\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq Return Value integer(kind=c_int) public  function la_form_qr_cmplx_pvt (fullq, m, n, r, ldr, tau, pvt, q, ldq, p, ldp) result(flag) bind(C, name = \"la_form_qr_cmplx_pvt\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm.  This\nroutine also inflates the pivot array into an N-by-N matrix P such\nthat A * P = Q * R. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: pvt (*) complex(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq complex(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) public  function la_form_qr_pvt (fullq, m, n, r, ldr, tau, pvt, q, ldq, p, ldp) result(flag) bind(C, name = \"la_form_qr_pvt\")) @brief Forms the full M-by-M orthogonal matrix Q from the elementary\nreflectors returned by the base QR factorization algorithm.  This\nroutine also inflates the pivot array into an N-by-N matrix P such\nthat A * P = Q * R. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: fullq integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: pvt (*) real(kind=c_double), intent(out) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq real(kind=c_double), intent(out) :: p (ldp,*) integer(kind=c_int), intent(in), value :: ldp Return Value integer(kind=c_int) public  function la_inverse (n, a, lda) result(flag) bind(C, name = \"la_inverse\")) @brief Computes the inverse of a square matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_inverse_cmplx (n, a, lda) result(flag) bind(C, name = \"la_inverse_cmplx\")) @brief Computes the inverse of a square matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_lq_factor (m, n, a, lda, tau) result(flag) bind(C, name = \"la_lq_factor\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) public  function la_lq_factor_cmplx (m, n, a, lda, tau) result(flag) bind(C, name = \"la_lq_factor_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) public  function la_lu_factor (m, n, a, lda, ipvt) result(flag) bind(C, name = \"la_lu_factor\")) @brief Computes the LU factorization of an M-by-N matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: ipvt (*) Return Value integer(kind=c_int) public  function la_lu_factor_cmplx (m, n, a, lda, ipvt) result(flag) bind(C, name = \"la_lu_factor_cmplx\")) @brief Computes the LU factorization of an M-by-N matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: ipvt (*) Return Value integer(kind=c_int) public  function la_mtx_mult (transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_mtx_mult\")) @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: transa logical(kind=c_bool), intent(in), value :: transb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_mtx_mult_cmplx (opa, opb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) result(flag) bind(C, name=\"la_mtx_mult_cmplx\")) @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: opa integer(kind=c_int), intent(in), value :: opb integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_mult_lq (lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_lq\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_mult_lq_cmplx (lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_lq_cmplx\")) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_mult_qr (lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_qr\")) @brief Multiplies a general matrix by the orthogonal matrix Q from a QR\nfactorization such that: C = op(Q) * C, or C = C * op(Q). Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_mult_qr_cmplx (lside, trans, m, n, k, a, lda, tau, c, ldc) result(flag) bind(C, name = \"la_mult_qr_cmplx\")) @brief Multiplies a general matrix by the orthogonal matrix Q from a QR\nfactorization such that: C = op(Q) * C, or C = C * op(Q). Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: trans integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: c (ldc,*) integer(kind=c_int), intent(in), value :: ldc Return Value integer(kind=c_int) public  function la_pinverse (m, n, a, lda, ainv, ldai) result(flag) bind(C, name = \"la_pinverse\")) @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by\nmeans of singular value decomposition. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: ainv (ldai,*) integer(kind=c_int), intent(in), value :: ldai Return Value integer(kind=c_int) public  function la_pinverse_cmplx (m, n, a, lda, ainv, ldai) result(flag) bind(C, name = \"la_pinverse_cmplx\")) @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by\nmeans of singular value decomposition. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: ainv (ldai,*) integer(kind=c_int), intent(in), value :: ldai Return Value integer(kind=c_int) public  function la_qr_factor (m, n, a, lda, tau) result(flag) bind(C, name = \"la_qr_factor\")) @brief Computes the QR factorization of an M-by-N matrix without\npivoting. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) public  function la_qr_factor_cmplx (m, n, a, lda, tau) result(flag) bind(C, name = \"la_qr_factor_cmplx\")) @brief Computes the QR factorization of an M-by-N matrix without\npivoting. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) Return Value integer(kind=c_int) public  function la_qr_factor_cmplx_pvt (m, n, a, lda, tau, jpvt) result(flag) bind(C, name = \"la_qr_factor_cmplx_pvt\")) @brief Computes the QR factorization of an M-by-N matrix with column\npivoting. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: tau (*) integer(kind=c_int), intent(inout) :: jpvt (*) Return Value integer(kind=c_int) public  function la_qr_factor_pvt (m, n, a, lda, tau, jpvt) result(flag) bind(C, name = \"la_qr_factor_pvt\")) @brief Computes the QR factorization of an M-by-N matrix with column\npivoting. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: tau (*) integer(kind=c_int), intent(inout) :: jpvt (*) Return Value integer(kind=c_int) public  function la_qr_rank1_update (m, n, q, ldq, r, ldr, u, v) result(flag) bind(C, name = \"la_qr_rank1_update\")) @brief Computes the rank 1 update to an M-by-N QR factored matrix A\n(M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq real(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr real(kind=c_double), intent(inout) :: u (*) real(kind=c_double), intent(inout) :: v (*) Return Value integer(kind=c_int) public  function la_qr_rank1_update_cmplx (m, n, q, ldq, r, ldr, u, v) result(flag) bind(C, name = \"la_qr_rank1_update_cmplx\")) @brief Computes the rank 1 update to an M-by-N QR factored matrix A\n(M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: q (ldq,*) integer(kind=c_int), intent(in), value :: ldq complex(kind=c_double), intent(inout) :: r (ldr,*) integer(kind=c_int), intent(in), value :: ldr complex(kind=c_double), intent(inout) :: u (*) complex(kind=c_double), intent(inout) :: v (*) Return Value integer(kind=c_int) public  function la_rank (m, n, a, lda, rnk) result(flag) bind(C, name=\"la_rank\")) @brief Computes the rank of a matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: rnk Return Value integer(kind=c_int) public  function la_rank1_update (m, n, alpha, x, y, a, lda) result(flag) bind(C, name = \"la_rank1_update\")) @brief Performs the rank-1 update to matrix A such that:\nA = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar,\nX is an M-element array, and N is an N-element array. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: x (*) real(kind=c_double), intent(in) :: y (*) real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_rank1_update_cmplx (m, n, alpha, x, y, a, lda) result(flag) bind(C, name = \"la_rank1_update_cmplx\")) @brief Performs the rank-1 update to matrix A such that:\nA = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar,\nX is an M-element array, and N is an N-element array. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: x (*) complex(kind=c_double), intent(in) :: y (*) complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda Return Value integer(kind=c_int) public  function la_rank_cmplx (m, n, a, lda, rnk) result(flag) bind(C, name=\"la_rank_cmplx\")) @brief Computes the rank of a matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(out) :: rnk Return Value integer(kind=c_int) public  function la_solve_cholesky (upper, m, n, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_cholesky\")) @brief Solves a system of Cholesky factored equations. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_cholesky_cmplx (upper, m, n, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_cholesky_cmplx\")) @brief Solves a system of Cholesky factored equations. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_least_squares (m, n, k, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_least_squares\")) @brief Solves the overdetermined or underdetermined system (A*X = B) of\nM equations of N unknowns using a QR or LQ factorization of the matrix A.\nNotice, it is assumed that matrix A has full rank. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_least_squares_cmplx (m, n, k, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_least_squares_cmplx\")) @brief Solves the overdetermined or underdetermined system (A*X = B) of\nM equations of N unknowns using a QR or LQ factorization of the matrix A.\nNotice, it is assumed that matrix A has full rank. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_lq (m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_lq\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_lq_cmplx (m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_lq_cmplx\")) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_lu (m, n, a, lda, ipvt, b, ldb) result(flag) bind(C, name = \"la_solve_lu\")) @brief Solves a system of LU-factored equations. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_lu_cmplx (m, n, a, lda, ipvt, b, ldb) result(flag) bind(C, name = \"la_solve_lu_cmplx\")) @brief Solves a system of LU-factored equations. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda integer(kind=c_int), intent(in) :: ipvt (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_qr (m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_qr\")) @brief Solves a system of M QR-factored equations of N unknowns where\nM >= N. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_qr_cmplx (m, n, k, a, lda, tau, b, ldb) result(flag) bind(C, name = \"la_solve_qr_cmplx\")) @brief Solves a system of M QR-factored equations of N unknowns where\nM >= N. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_qr_cmplx_pvt (m, n, k, a, lda, tau, jpvt, b, ldb) result(flag) bind(C, name = \"la_solve_qr_cmplx_pvt\")) @brief Solves a system of M QR-factored equations of N unknowns. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: jpvt (*) complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_qr_pvt (m, n, k, a, lda, tau, jpvt, b, ldb) result(flag) bind(C, name = \"la_solve_qr_pvt\")) @brief Solves a system of M QR-factored equations of N unknowns. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n integer(kind=c_int), intent(in), value :: k real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in) :: tau (*) integer(kind=c_int), intent(in) :: jpvt (*) real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_tri_mtx (lside, upper, trans, nounit, m, n, alpha, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_tri_mtx\")) @brief Solves one of the matrix equations: op(A) * X = alpha * B, or\nX * op(A) = alpha * B, where A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: upper logical(kind=c_bool), intent(in), value :: trans logical(kind=c_bool), intent(in), value :: nounit integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in), value :: alpha real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_solve_tri_mtx_cmplx (lside, upper, trans, nounit, m, n, alpha, a, lda, b, ldb) result(flag) bind(C, name = \"la_solve_tri_mtx_cmplx\")) @brief Solves one of the matrix equations: op(A) * X = alpha * B, or\nX * op(A) = alpha * B, where A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: lside logical(kind=c_bool), intent(in), value :: upper logical(kind=c_bool), intent(in), value :: trans logical(kind=c_bool), intent(in), value :: nounit integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in), value :: alpha complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_sort_eigen (ascend, n, vals, vecs, ldv) result(flag) bind(C, name = \"la_sort_eigen\")) @brief A sorting routine specifically tailored for sorting of eigenvalues\nand their associated eigenvectors using a quick-sort approach. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: ascend integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: vals (*) real(kind=c_double), intent(inout) :: vecs (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_sort_eigen_cmplx (ascend, n, vals, vecs, ldv) result(flag) bind(C, name = \"la_sort_eigen_cmplx\")) @brief A sorting routine specifically tailored for sorting of eigenvalues\nand their associated eigenvectors using a quick-sort approach. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: ascend integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: vals (*) complex(kind=c_double), intent(inout) :: vecs (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_svd (m, n, a, lda, s, u, ldu, vt, ldv) result(flag) bind(C, name = \"la_svd\")) @brief Computes the singular value decomposition of a matrix A.  The\n SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal\n matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal\n matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: s (*) real(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu real(kind=c_double), intent(out) :: vt (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_svd_cmplx (m, n, a, lda, s, u, ldu, vt, ldv) result(flag) bind(C, name = \"la_svd_cmplx\")) @brief Computes the singular value decomposition of a matrix A.  The\n SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal\n matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal\n matrix. Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(inout) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: s (*) complex(kind=c_double), intent(out) :: u (ldu,*) integer(kind=c_int), intent(in), value :: ldu complex(kind=c_double), intent(out) :: vt (ldv,*) integer(kind=c_int), intent(in), value :: ldv Return Value integer(kind=c_int) public  function la_trace (m, n, a, lda, rst) result(flag) bind(C, name = \"la_trace\")) @brief Computes the trace of a matrix (the sum of the main diagonal\nelements). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(out) :: rst Return Value integer(kind=c_int) public  function la_trace_cmplx (m, n, a, lda, rst) result(flag) bind(C, name = \"la_trace_cmplx\")) @brief Computes the trace of a matrix (the sum of the main diagonal\nelements). Read more… Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: m integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(out) :: rst Return Value integer(kind=c_int) public  function la_tri_mtx_mult (upper, alpha, n, a, lda, beta, b, ldb) result(flag) bind(C, name = \"la_tri_mtx_mult\")) @brief Computes the triangular matrix operation:\nB = alpha * A T * A + beta * B, or B = alpha * A * A T + beta * B,\nwhere A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper real(kind=c_double), intent(in), value :: alpha integer(kind=c_int), intent(in), value :: n real(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda real(kind=c_double), intent(in), value :: beta real(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int) public  function la_tri_mtx_mult_cmplx (upper, alpha, n, a, lda, beta, b, ldb) result(flag) bind(C, name = \"la_tri_mtx_mult_cmplx\")) @brief Computes the triangular matrix operation:\nB = alpha * A T * A + beta * B, or B = alpha * A * A T + beta * B,\nwhere A is a triangular matrix. Read more… Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in), value :: upper complex(kind=c_double), intent(in), value :: alpha integer(kind=c_int), intent(in), value :: n complex(kind=c_double), intent(in) :: a (lda,*) integer(kind=c_int), intent(in), value :: lda complex(kind=c_double), intent(in), value :: beta complex(kind=c_double), intent(inout) :: b (ldb,*) integer(kind=c_int), intent(in), value :: ldb Return Value integer(kind=c_int)","tags":"","loc":"module\\linalg_c_api.html"},{"title":"linalg_eigen – LINALG","text":"Uses ferror iso_fortran_env lapack linalg_errors Contents Interfaces eigen Interfaces public        interface eigen An interface to the eigenvalue and eigenvector routines. private  subroutine eigen_symm(vecs, a, vals, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is a symmetric matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: vecs Set to true to compute the eigenvectors as well as the eigenvalues; \nelse, set to false to just compute the eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N symmetric matrix on which to operate.  On \noutput, and if vecs is set to true, the matrix will contain the \neigenvectors (one per column) corresponding to each eigenvalue in \nvals.  If vecs is set to false, the lower triangular portion of the \nmatrix is overwritten. real(kind=real64), intent(out), dimension(:) :: vals An N-element array that will contain the eigenvalues sorted into \nascending order. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_asymm(a, vals, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_gen(a, b, alpha, beta, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, by solving\nthe eigenvalue problem: . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: alpha An N-element array that, if beta is not supplied, contains the \neigenvalues.  If beta is supplied however, the eigenvalues must be \ncomputed as .  This however, is not as\ntrivial as it seems as it is entirely possible, and likely, that can overflow or underflow.  With that said, the \nvalues in will always be less than and usually comparable \nwith the NORM( ). real(kind=real64), intent(out), optional, dimension(:) :: beta An optional N-element array that if provided forces alpha to return \nthe numerator, and this array contains the denominator used to \ndetermine the eigenvalues as .  If used,\nthe values in this array will always be less than and usually \ncomparable with the NORM( ). complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_cmplx(a, vals, vecs, work, olwork, rwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 2 * N. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_eigen.html"},{"title":"linalg_errors – LINALG","text":"Uses ferror iso_fortran_env Contents Variables LA_ARRAY_SIZE_ERROR LA_CONVERGENCE_ERROR LA_INVALID_INPUT_ERROR LA_INVALID_OPERATION_ERROR LA_MATRIX_FORMAT_ERROR LA_NO_ERROR LA_OUT_OF_MEMORY_ERROR LA_SINGULAR_MATRIX_ERROR Subroutines report_array_size_error report_inner_matrix_dimension_error report_matrix_size_error report_memory_error report_singular_matrix_warning report_square_matrix_error Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: LA_ARRAY_SIZE_ERROR = 102 An error flag denoting an improperly sized array. integer(kind=int32), public, parameter :: LA_CONVERGENCE_ERROR = 106 An error flag denoting a convergence failure. integer(kind=int32), public, parameter :: LA_INVALID_INPUT_ERROR = 101 An error flag denoting an invalid input. integer(kind=int32), public, parameter :: LA_INVALID_OPERATION_ERROR = 107 An error resulting from an invalid operation. integer(kind=int32), public, parameter :: LA_MATRIX_FORMAT_ERROR = 104 An error flag denoting an issue with the matrix format. integer(kind=int32), public, parameter :: LA_NO_ERROR = 0 An flag denoting no error condition. integer(kind=int32), public, parameter :: LA_OUT_OF_MEMORY_ERROR = 105 An error flag denoting that there is insufficient memory available. integer(kind=int32), public, parameter :: LA_SINGULAR_MATRIX_ERROR = 103 An error flag denoting a singular matrix. Subroutines public  subroutine report_array_size_error (fcn, err, name, expected, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expected The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. public  subroutine report_inner_matrix_dimension_error (fcn, err, name1, name2, expected, actual) Reports an inner matrix dimension error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name1 The name of the first matrix. character(len=*), intent(in) :: name2 The name of the second matrix. integer(kind=int32), intent(in) :: expected The expected inner dimension. integer(kind=int32), intent(in) :: actual The actual inner dimension. public  subroutine report_matrix_size_error (fcn, err, name, expectedRows, expectedCols, actualRows, actualCols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedRows The expected number of rows in the matrix. integer(kind=int32), intent(in) :: expectedCols The expected number of columns in the matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. public  subroutine report_memory_error (fcn, err, flag) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: flag The error flag. public  subroutine report_singular_matrix_warning (fcn, err, row) Reports a singular matrix error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: row The row index where the singularity issue was first encountered. public  subroutine report_square_matrix_error (fcn, err, name, expectedSize, actualRows, actualCols) Reports an error where a square matrix was expected but a non-square \nmatrix was provided. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedSize The expected size of the square matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix.","tags":"","loc":"module\\linalg_errors.html"},{"title":"linalg_inverse – LINALG","text":"Uses iso_fortran_env lapack linalg_errors blas Contents Interfaces mtx_inverse mtx_pinverse Interfaces public        interface mtx_inverse private  subroutine mtx_inverse_dbl(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_inverse_cmplx(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mtx_pinverse private  subroutine mtx_pinverse_dbl(a, ainv, tol, work, olwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. real(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_pinverse_cmplx(a, ainv, tol, work, olwork, rwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. complex(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_inverse.html"},{"title":"linalg_least_squares – LINALG","text":"Uses iso_fortran_env lapack linalg_errors Contents Interfaces solve_least_squares solve_least_squares_full solve_least_squares_svd Interfaces public        interface solve_least_squares private  subroutine solve_least_squares_mtx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_least_squares_full private  subroutine solve_least_squares_mtx_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_least_squares_svd private  subroutine solve_least_squares_mtx_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_least_squares.html"},{"title":"linalg_lq – LINALG","text":"Uses iso_fortran_env lapack linalg_tri linalg_errors Contents Interfaces form_lq lq_factor mult_lq solve_lq Interfaces public        interface form_lq private  subroutine form_lq_no_pivot(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lq_no_pivot_cmplx(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface lq_factor private  subroutine lq_factor_no_pivot(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine lq_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mult_lq private  subroutine mult_lq_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_lq private  subroutine solve_lq_mtx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_lq.html"},{"title":"linalg_lu – LINALG","text":"Uses linalg_errors ferror lapack sparskit iso_fortran_env linalg_sparse linalg_basic Contents Interfaces form_lu lu_factor solve_lu Interfaces public        interface form_lu private  subroutine form_lu_all(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_all_cmplx(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only_cmplx(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface lu_factor private  subroutine lu_factor_dbl(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine lu_factor_cmplx(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine csr_lu_factor(a, lu, ju, droptol, err) Factors a matrix using an LU decomposition. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix to factor. type( msr_matrix ), intent(out) :: lu The LU matrix. integer(kind=int32), intent(out), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_lu private  subroutine solve_lu_mtx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_mtx_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine csr_lu_solve(lu, ju, b, x, err) Solves a linear system using an LU decomposition. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: lu The LU matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_lu.html"},{"title":"linalg_qr – LINALG","text":"Uses linalg_errors linalg_rz ferror lapack iso_fortran_env linalg_tri qrupdate blas Contents Interfaces form_qr mult_qr qr_factor qr_rank1_update solve_qr Interfaces public        interface form_qr private  subroutine form_qr_no_pivot(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_no_pivot_cmplx(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot_cmplx(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mult_qr private  subroutine mult_qr_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface qr_factor private  subroutine qr_factor_no_pivot(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot(a, tau, jpvt, work, olwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot_cmplx(a, tau, jpvt, work, olwork, rwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local allocate of \nreal-valued memory.  If not provided, the memory required is \nallocated within.  If provided, the length of the array must be at\nleast 2*N. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface qr_rank1_update private  subroutine qr_rank1_update_dbl(q, r, u, v, work, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . real(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least 2 K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_rank1_update_cmplx(q, r, u, v, work, rwork, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_qr private  subroutine solve_qr_no_pivot_mtx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_vec(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_vec_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_qr.html"},{"title":"linalg_rz – LINALG","text":"Uses ferror iso_fortran_env lapack linalg_errors Contents Interfaces mult_rz rz_factor Interfaces public        interface mult_rz private  subroutine mult_rz_mtx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_mtx_cmplx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. real(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec_cmplx(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. complex(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface rz_factor private  subroutine rz_factor_dbl(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine rz_factor_cmplx(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_rz.html"},{"title":"linalg_sorting – LINALG","text":"Uses ferror iso_fortran_env lapack linalg_errors Contents Interfaces sort Interfaces public        interface sort An interface to the sorting routines. private  subroutine sort_dbl_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_dbl_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_cmplx_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_cmplx_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_cmplx(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. complex(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_dbl(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_int32_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_int32_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_sorting.html"},{"title":"linalg_sparse – LINALG","text":"Uses linalg_errors ferror sparskit iso_fortran_env blas Contents Interfaces assignment(=) matmul nonzero_count operator(*) operator(+) operator(-) operator(/) pgmres_solver size sparse_direct_solve transpose Derived Types csr_matrix msr_matrix Functions banded_to_csr create_csr_matrix create_empty_csr_matrix create_empty_msr_matrix csr_to_msr dense_to_csr dense_to_msr diag_to_csr msr_to_csr Subroutines csr_to_dense msr_to_dense Interfaces public        interface assignment(=) private  subroutine csr_assign_to_dense(dense, sparse) Assigns the values of a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( csr_matrix ), intent(in) :: sparse The CSR matrix. private  subroutine dense_assign_to_csr(sparse, dense) Assigns the values of a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: sparse The CSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine msr_assign_to_dense(dense, msr) Assigns an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. private  subroutine dense_assign_to_msr(msr, dense) Assigns a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine csr_assign_to_msr(msr, csr) Assigns a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. class( csr_matrix ), intent(in) :: csr The CSR matrix. private  subroutine msr_assign_to_csr(csr, msr) Assigns an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: csr The CSR matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. public        interface matmul private  function csr_mtx_mtx_mult(a, b) result(rst) Multiplies two CSR matrices together. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_vec_mult(a, b) result(rst) Multiplies a CSR matrix by a vector. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in), dimension(:) :: b The vector. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. public        interface nonzero_count private pure function nonzero_count_csr(x) result(rst) Returns the number of non-zero values in the matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. Return Value integer(kind=int32) The number of non-zero values in the matrix. private pure function nonzero_count_msr(x) result(rst) Returns the number of non-zero elements in an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. Return Value integer(kind=int32) The number of non-zero elements. public        interface operator(*) private  function csr_mtx_mult_scalar_1(a, b) result(rst) Multiplies a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_mult_scalar_2(a, b) result(rst) Multiplies a scalar by a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar. class( csr_matrix ), intent(in) :: b The CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(+) private  function csr_mtx_add(a, b) result(rst) Adds two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(-) private  function csr_mtx_sub(a, b) result(rst) Subtracts two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(/) private  function csr_mtx_divide_scalar_1(a, b) result(rst) Divides a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) public        interface pgmres_solver private  subroutine csr_pgmres_solver(a, lu, ju, b, x, im, tol, maxits, iout, err) Solves a linear system using the PGMRES method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. class( msr_matrix ), intent(in) :: lu The LU factored matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(inout), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. integer(kind=int32), intent(in), optional :: im The Krylov subspace size. real(kind=real64), intent(in), optional :: tol The convergence tolerance. integer(kind=int32), intent(in), optional :: maxits The maximum number of iterations. integer(kind=int32), intent(in), optional :: iout The output level. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface size private pure function csr_size(x, dim) result(rst) Returns the size of the matrix along the specified dimension. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the matrix along the specified dimension. private pure function msr_size(x, dim) result(rst) Returns the size of the specified dimension of an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the specified dimension. public        interface sparse_direct_solve private  subroutine csr_solve_sparse_direct(a, b, x, droptol, err) Solves a linear system using a direct method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface transpose private  function csr_transpose(a) result(rst) Transposes a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. Return Value type( csr_matrix ) The transposed CSR matrix. Derived Types type, public :: csr_matrix A sparse matrix stored in compressed sparse row (CSR) format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: column_indices An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the column indices of each value. integer(kind=int32), public, allocatable, dimension(:) :: row_indices An M+1 element array containing the indices in V an JA at which the\nrequested row starts. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the non-zero values of the matrix. Type-Bound Procedures procedure\n                    ,                  public\n                  :: extract_diagonal =>\n                    csr_extract_diagonal Subroutine procedure\n                    ,                  public\n                  :: get =>\n                    csr_get_element Function type, public :: msr_matrix A sparse matrix stored in modified sparse row format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: indices An NNZ-element array containing the index information. integer(kind=int32), public :: m = 0 The number of rows in the matrix. integer(kind=int32), public :: n = 0 The number of columns in the matrix. integer(kind=int32), public :: nnz = 0 The number of nonzero values in the matrix. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array containing the non-zero values from the\nmatrix.  The first MIN(M,N) elements contain the diagonal. Functions public  function banded_to_csr (m, ml, mu, a, err) result(rst) Converts a banded matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the banded matrix. integer(kind=int32), intent(in) :: ml The number of lower diagonals in the banded matrix. integer(kind=int32), intent(in) :: mu The number of upper diagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function create_csr_matrix (m, n, rows, cols, vals, err) result(rst) Creates a CSR matrix from the input data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in), dimension(:) :: rows The row indices. integer(kind=int32), intent(in), dimension(:) :: cols The column indices. real(kind=real64), intent(in), dimension(:) :: vals The values. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function create_empty_csr_matrix (m, n, nnz, err) result(rst) Creates an empty CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero values in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The empty CSR matrix. public  function create_empty_msr_matrix (m, n, nnz, err) result(rst) Creates an empty MSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero elements in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function csr_to_msr (a, err) result(rst) Converts a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function dense_to_csr (a, err) result(rst) Converts a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function dense_to_msr (a, err) result(rst) Converts a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function diag_to_csr (a, err) result(rst) Converts a diagonal matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function msr_to_csr (a, err) result(rst) Converts an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Subroutines public  subroutine csr_to_dense (a, x, err) Converts a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. public  subroutine msr_to_dense (a, x, err) Converts an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_sparse.html"},{"title":"linalg_svd – LINALG","text":"Uses iso_fortran_env lapack linalg_errors Contents Interfaces svd Interfaces public        interface svd private  subroutine svd_dbl(a, s, u, vt, work, olwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. real(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). real(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \ntranspose of the N-by-N orthogonal matrix .  The matrix contains the right singular vectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine svd_cmplx(a, s, u, vt, work, olwork, rwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. complex(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). complex(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \nconjugate transpose of the N-by-N orthogonal matrix .  The \nmatrix contains the right singular vectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_svd.html"},{"title":"linalg_tri – LINALG","text":"Uses iso_fortran_env linalg_errors blas Contents Interfaces solve_triangular_system Interfaces public        interface solve_triangular_system private  subroutine solve_tri_mtx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in) :: alpha The scalar multiplier . real(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_mtx_cmplx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in) :: alpha The scalar multiplier . complex(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . real(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec_cmplx(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . complex(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_tri.html"},{"title":"linear_algebra – LINALG","text":"This module contains pure functions for basic linear algebra operations. Uses lapack iso_fortran_env ieee_arithmetic blas Contents Interfaces eigen solve_least_squares solve_linear_system solve_triangular_system Derived Types eigen_solution lu_factors qr_factors svd_factors Functions cholesky_factor identity inverse lu_factor pinverse qr_factor svd Subroutines swap_arrays Interfaces public        interface eigen private pure function eigen_1(a, right) result(rst) Solves the eigenvalue problem where \nmatrix is is square, but not necessarily symmetric.  Optionally,\nthe left eigenvalue problem can be solved such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix . logical, intent(in), optional :: right An optional parameter specifying if the right eigenvalue solution\nshould be computed (true), or the left eigenvalue solution should be\ncomputed (false).  The default is true such that the right eigenvalue\nproblem is solved. Return Value type( eigen_solution ) The solution. private pure function eigen_2(a, b, right) result(rst) Solves the eigenvalue problem where and are both N-by-N matrices.  Optionally, the left\neigenvalue problem can be solved such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix . real(kind=real64), intent(in), dimension(:,:) :: b The matrix . logical, intent(in), optional :: right An optional parameter specifying if the right eigenvalue solution\nshould be computed (true), or the left eigenvalue solution should be\ncomputed (false).  The default is true such that the right eigenvalue\nproblem is solved. Return Value type( eigen_solution ) The solution. public        interface solve_least_squares private pure function solve_least_squares_mtx(a, b) result(rst) Solves the least squares problem by minimizing using\na complete orthogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:,:) :: b The M-by-NRHS matrix . Return Value real(kind=real64), allocatable, dimension(:,:) The resulting N-by-NRHS matrix . private pure function solve_least_squares_vec(a, b) result(rst) Solves the least squares problem by minimizing using\na complete orthogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: b The M-element array . Return Value real(kind=real64), allocatable, dimension(:) The resulting N-element array . public        interface solve_linear_system private pure function solve_linear_system_mtx(a, b) result(rst) Solves the M-by-N linear system for . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:,:) :: b The M-by-NRHS matrix . Return Value real(kind=real64), allocatable, dimension(:,:) The resulting N-by-NRHS matrix . private pure function solve_linear_system_vec(a, b) result(rst) Solves the M-by-N linear system for . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: b The M-element array . Return Value real(kind=real64), allocatable, dimension(:) The resulting N-element array . public        interface solve_triangular_system private pure function solve_triangular_system_mtx(a, b, upper) result(rst) Solves a triangular system of the form where is a\ntriangular matrix, either upper or lower, for equation . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix. real(kind=real64), intent(in), dimension(:,:) :: b The N-by-NRHS matrix. logical, intent(in), optional :: upper An optional argument specifying if the matrix is upper \ntriangular (true), or lower triangular (false).  The default \nassumption is that is an upper triangular matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-NRHS solution matrix, . private pure function solve_triangular_system_vec(a, b, upper) result(rst) Solves a triangular system of the form where is a\ntriangular matrix, either upper or lower, for equation . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix. real(kind=real64), intent(in), dimension(:) :: b The N-element array. logical, intent(in), optional :: upper An optional argument specifying if the matrix is upper \ntriangular (true), or lower triangular (false).  The default \nassumption is that is an upper triangular matrix. Return Value real(kind=real64), allocatable, dimension(:) The N-element solution array, . Derived Types type, public :: eigen_solution A container for both eigenvectors and eigenvalues. Components Type Visibility Attributes Name Initial complex(kind=real64), public, allocatable, dimension(:) :: values An array of eigenvalues. complex(kind=real64), public, allocatable, dimension(:,:) :: vectors A collection of eigenvectors, stored columnwise. type, public :: lu_factors A container for the results of a LU factorization. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: L The lower-triangular factorization. real(kind=real64), public, allocatable, dimension(:,:) :: P The pivot tracking matrix. real(kind=real64), public, allocatable, dimension(:,:) :: U The upper-triangular factorization. type, public :: qr_factors A container for the results of a QR factorization of an M-by-N \nmatrix. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: P The N-by-N pivot tracking matrix. real(kind=real64), public, allocatable, dimension(:,:) :: Q The M-by-M orthogonal matrix, . real(kind=real64), public, allocatable, dimension(:,:) :: R The M-by-N upper trapezoidal matrix, . type, public :: svd_factors A container for the results of a singular value decomposition of\nan M-by-N matrix. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: S The M-by-N diagonal matrix containing the singular values\non the diagonal. real(kind=real64), public, allocatable, dimension(:,:) :: U The M-by-M orthogonal matrix . real(kind=real64), public, allocatable, dimension(:,:) :: Vt The transpose of the N-by-N right singular vector matrix . Functions public pure function cholesky_factor (a, upper) result(rst) Computes the Cholesky factorization of a positive-definite matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to factor. logical, intent(in), optional :: upper An optional parameter to specifiy if the upper factorization should be computed (true); else, false for the lower\nfactorization .  The default is to compute the upper\nfactorization. Return Value real(kind=real64), allocatable, dimension(:,:) The factored matrix, either or . public pure function identity (n) result(rst) Constructs an N-by-N identity matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n The size of the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. public pure function inverse (a) result(rst) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N matrix to invert. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-N inverted matrix. public pure function lu_factor (a) result(rst) Computes the LU factorization of a square matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N matrix to factor. Return Value type( lu_factors ) The factored form of the matrix. public pure function pinverse (a) result(rst) Computes the Moore-Penrose pseudoinverse of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to invert. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-M inverted matrix. public pure function qr_factor (a, pivot) result(rst) Computes the QR factorization of an M-by-N matrix such that either (no pivoting), or (with pivoting). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to factor. logical, intent(in), optional :: pivot An optional parameter used to specifiy if pivoting should be used\n(true); else, false if no pivoting is used.  The default is false\nsuch that no pivoting is performed. Return Value type( qr_factors ) The factored form of the matrix. public pure function svd (a) result(rst) Computes the singular value decomposition of an M-by-N matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix to factor. Return Value type( svd_factors ) The factored form of the matrix. Subroutines public pure subroutine swap_arrays (x, y) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x The first array. real(kind=real64), intent(inout), dimension(:) :: y The second array.","tags":"","loc":"module\\linear_algebra.html"},{"title":"qrupdate – LINALG","text":"@brief A module providing explicit interfaces for the QRUPDATE library. Contents Interfaces DCH1DN DCH1UP DQR1UP ZCH1DN ZCH1UP ZQR1UP Interfaces interface public pure subroutine DCH1DN(n, r, ldr, u, w, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*) integer(kind=int32), intent(out) :: info interface public pure subroutine DCH1UP(n, r, ldr, u, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*) interface public pure subroutine DQR1UP(m, n, k, q, ldq, r, ldr, u, v, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k real(kind=real64), intent(inout) :: q (ldq,*) integer(kind=int32), intent(in) :: ldq real(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr real(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(inout) :: v (*) real(kind=real64), intent(out) :: w (*) interface public pure subroutine ZCH1DN(n, r, ldr, u, rw, info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: rw (*) integer(kind=int32), intent(out) :: info interface public pure subroutine ZCH1UP(n, r, ldr, u, w) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) real(kind=real64), intent(out) :: w (*) interface public pure subroutine ZQR1UP(m, n, k, q, ldq, r, ldr, u, v, w, rw) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: k complex(kind=real64), intent(inout) :: q (ldq,*) integer(kind=int32), intent(in) :: ldq complex(kind=real64), intent(inout) :: r (ldr,*) integer(kind=int32), intent(in) :: ldr complex(kind=real64), intent(inout) :: u (*) complex(kind=real64), intent(inout) :: v (*) complex(kind=real64), intent(out) :: w (*) real(kind=real64), intent(out) :: rw (*)","tags":"","loc":"module\\qrupdate.html"},{"title":"sparskit – LINALG","text":"@brief An interface to the SPARSKIT library available at \nhttps://www-users.cse.umn.edu/~saad/software/SPARSKIT/. Contents Interfaces amub aplb aplsb bndcsr clncsr coocsr csort csrcsc2 csrmsr getdia getelm ilud iludp ilut ilutp lusol msrcsr pgmres Interfaces interface public pure subroutine amub(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) @brief Computes the matrix product: C = A * B. @param[in] nrow The row dimension of matrices A & C.\n@param[in] ncol The column dimension of matrices B & C.\n@param[in] job Set to 0 to compute only the structure (JC & IC);\n else, set to any non-zero value.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix C.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (*) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (*) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr interface public pure subroutine aplb(nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr) @brief Computes the matrix sum: C = A + B, where the matrices are\ngiven in CSR format. @param[in] nrow The number of rows in the matrices.\n@param[in] ncol The number of columns in the matrices.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix A.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (nrow+1) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (nrow+1) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr interface public pure subroutine aplsb(nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, iw, ierr) @brief Computes the matrix sum: C = A + s * B, where the matrices\nare given in CSR format. @param[in] nrow The number of rows in the matrices.\n@param[in] ncol The number of columns in the matrices.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] s The scalar multiplier.\n@param[in] b The non-zero elements of matrix B.\n@param[in] jb The column indices of matrix B.\n@param[in] ib The index in B where the requested row starts.\n@param[out] c The non-zero elements of matrix C.\n@param[out] jc The column indices of matrix C.\n@param[out] ic The index in C where the requested row starts.\n@param[in] nzmax The length of arrays C & JC.  The routine will stop\n if the results matrix C has a number of elements that exceeds NZMAX.\n@param[out] iw A workspace array with a length equal to the number of\n of columns in matrix A.\n@param[out] ierr An error message indicator.\n * 0: Normal return\n * .gt. 0: Routine failed in row I with IERR = I because the number\n    of elements in C exceeds NZMAX. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (nrow+1) real(kind=real64), intent(in) :: s real(kind=real64), intent(in) :: b (*) integer(kind=int32), intent(in) :: jb (*) integer(kind=int32), intent(in) :: ib (nrow+1) real(kind=real64), intent(out) :: c (*) integer(kind=int32), intent(out) :: jc (*) integer(kind=int32), intent(out) :: ic (nrow+1) integer(kind=int32), intent(in) :: nzmax integer(kind=int32), intent(out) :: iw (ncol) integer(kind=int32), intent(out) :: ierr interface public pure subroutine bndcsr(n, abd, nabd, lowd, ml, mu, a, ja, ia, len, ierr) @brief Converts the LINPACK, BLAS, LAPACK banded matrix format into\na CSR format. @param[in] n The row dimension of the matrix.\n@param[in] abd The banded matrix.\n@param[in] nabd The leading dimension of @p abd.\n@param[in] lowd The row index where the lowest diagonal (leftmost) of\n A is located.  LINPACK uses LOWD = 2 * ML + MU + 1.\n@param[in] ml The bandwidth of the strict lower part of A.\n@param[in] mu The bandwidth of the strict upper part of A.\n@param[out] a The non-zero elements of matrix A.\n@param[out] ja The column indices of matrix A.\n@param[out] ia The index in A where the requested row starts.\n@param[in] len The length of @p a and @p ja.\n@param[out] ierr Error message output.\n * 0: Normal return.\n * -1: Invalid @p lowd value.\n * Positive Valued: Not enough storage in @p a and @p ja. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: abd (nabd,*) integer(kind=int32), intent(in) :: nabd integer(kind=int32), intent(in) :: lowd integer(kind=int32), intent(in) :: ml integer(kind=int32), intent(in) :: mu real(kind=real64), intent(out) :: a (*) integer(kind=int32), intent(out) :: ja (*) integer(kind=int32), intent(out) :: ia (n+1) integer(kind=int32), intent(in) :: len integer(kind=int32), intent(out) :: ierr interface public pure subroutine clncsr(job, value2, nrow, a, ja, ia, indu, iwk) @breif Cleans up a CSR matrix. @param[in] job The job to perform.\n - 0: Nothing is done\n - 1: Eliminate duplicate entries and zero entries.\n - 2: Eliminate duplicate entries and perform partial ordering.\n - 3: Eliminate duplicate entries and sort the entries in increasing\n     order of column indices.\n@param[in] value2 0 if the matrix is pattern only (A is not touched),\n or 1 if the matrix has values.\n@param[in] nrow The number of rows in the matrix.\n@param[in,out] a The non-zero values.\n@param[in,out] ja An array of column indices of the elements in A.\n@param[in,out] ia An array of pointers to the rows.\n@param[out] indu An NROW array containing pointers to the beginning \n of the upper triangular portion if job > 1.\n@param[out] iwk An NROW+1 element workspace array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: value2 integer(kind=int32), intent(in) :: nrow real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (*) integer(kind=int32), intent(inout) :: indu (*) integer(kind=int32), intent(inout) :: iwk (*) interface public pure subroutine coocsr(nrow, nnz, a, ir, jc, ao, jao, iao) @brief Converte a matrix stored in coordinate format to CSR format. @param[in] nrow The number of rows in the matrix.\n@param[in] nnz The number of non-zero elements in the matrix.\n@param[in] a An NNZ-element array containing the non-zero elements\n of the matrix.\n@param[in,out] ir An NNZ-element array containing the row indices of\n each non-zero element.\n@param[in] jc An NNZ-element array containing the column indices of\n each non-zero element.\n@param[out] ao The non-zero elements of matrix A.\n@param[out] jao The column indices of matrix A.\n@param[out] iao The index in A where the requested row starts. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: nnz real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(inout) :: ir (*) integer(kind=int32), intent(in) :: jc (*) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) integer(kind=int32), intent(out) :: iao (*) interface public pure subroutine csort(n, a, ja, ia, values) @brief Sorces the elements of a CSR matrix in increasing order of \ntheir column indices within each row. @param[in] n The number of rows in the matrix.\n@param[in,out] a The non-zero values.\n@param[in,out] ja An array of column indices of the elements in A.\n@param[in] ia An array of pointers to the rows.\n@param[in] values Idicates whether A must also be permuted.  If\n false, A can be a dummy array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(in) :: ia (*) logical, intent(in) :: values interface public pure subroutine csrcsc2(n, n2, job, ipos, a, ja, ia, a0, ja0, ia0) @brief Converts a CSR matrix into a CSC matrix (transposition). @param[in] n The number of rows in the CSR matrix.\n@param[in] n2 The number of columns in the CSC matrix.\n@param[in] job Fill the values (job == 1) or only the pattern \n (job /= 1).\n@param[in] ipos Starting position of A0 in JA0.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[out] a0 The non-zero elements of the transposed array.\n@param[out] ja0 The size NNZ array containing the column indices.\n@param[out] ia0 The N+1 size array containing the column starts. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: n2 integer(kind=int32), intent(in) :: job integer(kind=int32), intent(in) :: ipos real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(out) :: a0 (*) integer(kind=int32), intent(out) :: ja0 (*) integer(kind=int32), intent(out) :: ia0 (n2+1) interface public pure subroutine csrmsr(n, a, ja, ia, ao, jao, wk, iwk) @brief Converts a CSR matrix to an MSR matrix. @param[in] n The row dimension of the matrix.\n@param[in,out] a The non-zero elements of matrix A.\n@param[in,out] ja The column indices of matrix A.\n@param[in,out] ia The index in A where the requested row starts.\n@param[out] ao An NNZ-element array containing the non-zero elements\n for the MSR matrix.\n@param[out] jao An NNZ-element index tracking array for the MSR\n matrix.\n@param[out] wk An N-element workspace array.\n@param[out] iwk An N+1 element workspace array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) real(kind=real64), intent(out) :: wk (n) integer(kind=int32), intent(out) :: iwk (n+1) interface public pure subroutine getdia(nrow, ncol, job, a, ja, ia, len, diag, idiag, ioff) @brief Extracts the diagonal from a matrix. @param[in] nrow The number of rows.\n@param[in] ncol The number of columns.\n@param[in] job Set to 0 to not alter @p a, @p ja, and @p ia; else,\nset to a non-zero value to perform this as an in-place operation.\n@param[out] len The number of non-zero elements found in @p diag.\n@param[out] idiag An array of length @p len containing the original\n positions in the original arrays @p a and @p ja of the diagonal\n elements collected in diagl.\n@param[in] ioff The offset of the wanted diagonal. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nrow integer(kind=int32), intent(in) :: ncol integer(kind=int32), intent(in) :: job real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (*) integer(kind=int32), intent(out) :: len real(kind=real64), intent(out) :: diag (*) integer(kind=int32), intent(out) :: idiag (*) integer(kind=int32), intent(in) :: ioff interface public  function getelm(i, j, a, ja, ia, iadd, sorted) result(rst) @brief Gets element A(i,j) of matrix A for any pair (i,j). @param[in] i The row index.\n@param[in] j The column index.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[out] iadd The address of element A(i,j) in arrays A & JA, if \n found; else, zero if not found.\n@param[in] sorted Indicates whether the matrix is known to be sorted. @return The requested value. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (*) integer(kind=int32), intent(out) :: iadd logical, intent(in) :: sorted Return Value real(kind=real64) interface public pure subroutine ilud(n, a, ja, ia, alph, tol, alu, jlu, ju, iwk, w, jw, ierr) @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format with standard dropping strategy. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alph The diagonal compensation parameter.  If ALPH = 0,\n the process is approximately equivalent to ILU with threshold; else,\n if ALPH = 1, the process is approximately equivalent to MILU with\n threshold.\n@param[in] tol The threshold parameter for dropping small terms in\n the factorization.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: Insufficient storage for the LU factors.\n * -3: Zero-valued row encountered. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(in) :: alph real(kind=real64), intent(in) :: tol real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (2*n) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: ierr interface public pure subroutine iludp(n, a, ja, ia, alph, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format with standard dropping strategy. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alph The diagonal compensation parameter.  If ALPH = 0,\n the process is approximately equivalent to ILU with threshold; else,\n if ALPH = 1, the process is approximately equivalent to MILU with\n threshold.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[in] permtol A tolerance ratio used to determine whether or\n not to permute two columns.  At step I, columns I and J are \n permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values\n are typically between 0.1 to 0.01.\n@param[in] mbloc If desired, permuting can be done only within the\n diagonal blocks of size MBLOC.  Useful for PDE problems with many\n degrees of freedom.  If this feature is not required, simply set\n MBLOC equal to N.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: Insufficient storage for the LU factors.\n * -3: Zero-valued row encountered. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) real(kind=real64), intent(in) :: alph real(kind=real64), intent(in) :: droptol real(kind=real64), intent(in) :: permtol integer(kind=int32), intent(in) :: mbloc real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (2*n) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: iperm (2*n) integer(kind=int32), intent(out) :: ierr interface public pure subroutine ilut(n, a, ja, ia, lfil, droptol, alu, jlu, ju, iwk, w, jw, ierr) @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format using a dual truncation mechanism. @param[in] n The row dimension of the matrix.\n@param[in] a The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] lfil The fill-in parameter.  Each row of L and each row\n of U will have a maximum of @p lfil elements, excluding the \n diagonal element.  @p lfil must be greater than or equal to zero.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2*N element workspace array.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: The matrix L overflows the output array.\n * -3: The matrix U overflows the output array.\n * -4: Illegal value for @P lfil.\n * -5: Zero-valued row encountered. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) integer(kind=int32), intent(in) :: lfil real(kind=real64), intent(in) :: droptol real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (n+1) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: ierr interface public pure subroutine ilutp(n, a, ja, ia, lfil, droptol, permtol, mbloc, alu, jlu, ju, iwk, w, jw, iperm, ierr) @brief Computes the incomplete LU factorization of a sparse matrix\nin CSR format using a dual truncation mechanism and pivoting. @param[in] n The row dimension of the matrix.\n@param[in,out] a The non-zero elements of matrix A.  On output, the\n columns are permuted.\n@param[in,out] ja The column indices of matrix A.  On output, the\n columns are permuted.\n@param[in,out] ia The index in A where the requested row starts.  On \n output, the columns are permuted.\n@param[in] lfil The fill-in parameter.  Each row of L and each row\n of U will have a maximum of @p lfil elements, excluding the \n diagonal element.  @p lfil must be greater than or equal to zero.\n@param[in] droptol The threshold for dropping small terms in the\n factorization.\n@param[in] permtol A tolerance ratio used to determine whether or\n not to permute two columns.  At step I, columns I and J are \n permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values\n are typically between 0.1 to 0.01.\n@param[in] mbloc If desired, permuting can be done only within the\n diagonal blocks of size MBLOC.  Useful for PDE problems with many\n degrees of freedom.  If this feature is not required, simply set\n MBLOC equal to N.\n@param[out] alu The factored matrix stored in Modified Sparse Row\n (MSR) format containing the L and U factors together.  The diagonal,\n stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU\n matrix contains the i-th row of L, excluding the diagonal entry,\n followed by the i-th row of U.\n@param[out] jlu The column indices for the factored matrix.\n@param[out] ju An N-element array containing the pointers to the\n beginning of each row of U in the factored matrix.\n@param[in] iwk The lengths of @p alu and @p jlu.\n@param[out] w An N+1 element workspace array.\n@param[out] jw A 2 N element workspace array.\n@param[out] iperm A 2 N element array containing the permutation\n arrays.  IPERM(1:N) contains the old numbers of unknowns, and \n IPERM(N+1:) contains the new unknowns.\n@param[out] ierr Error flag:\n * 0: Successful return\n * .gt. 0: Zero pivot encountered at step number IERR.\n * -1: Input matrix is incorrect.  The elimination process generated\n     a row in L or U whose length is greater than N.\n * -2: The matrix L overflows the output array.\n * -3: The matrix U overflows the output array.\n * -4: Illegal value for @P lfil.\n * -5: Zero-valued row encountered. @par Remarks\nTo avoid permuting the solution vector arrays for each LU-solve, the\nmatrix A is permuted on return.  Similarly for the U matrix.  To\npermute the matrix back to its original state, use the following\ncode.\n@code{.f90}\ndo k = ia(1), ia(n+1) - 1\n ja(k) = iperm(ja(k))\nend do\n@endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(inout) :: a (*) integer(kind=int32), intent(inout) :: ja (*) integer(kind=int32), intent(inout) :: ia (n+1) integer(kind=int32), intent(in) :: lfil real(kind=real64), intent(in) :: droptol real(kind=real64), intent(in) :: permtol integer(kind=int32), intent(in) :: mbloc real(kind=real64), intent(out) :: alu (*) integer(kind=int32), intent(out) :: jlu (*) integer(kind=int32), intent(out) :: ju (n) integer(kind=int32), intent(in) :: iwk real(kind=real64), intent(out) :: w (n+1) integer(kind=int32), intent(out) :: jw (2*n) integer(kind=int32), intent(out) :: iperm (2*n) integer(kind=int32), intent(out) :: ierr interface public pure subroutine lusol(n, y, x, alu, jlu, ju) @brief Solves the LU-factored system (LU) x = y. @param[in] n The dimension of the system.\n@param[in] y The N-element right-hand-side vector.\n@param[out] x The N-element solution vector.\n@param[in] alu The LU-factored matrix.\n@param[in] jlu The LU-factored matrix.\n@param[in] ju The LU-factored matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: y (n) real(kind=real64), intent(out) :: x (n) real(kind=real64), intent(in) :: alu (*) integer(kind=int32), intent(in) :: jlu (*) integer(kind=int32), intent(in) :: ju (*) interface public pure subroutine msrcsr(n, a, ja, ao, jao, iao, wk, iwk) @brief Converts and MSR matrix to a CSR matrix. @param[in] n The row dimension of the matrix.\n@param[in] a An NNZ-element array containing the non-zero elements\n for the MSR matrix.\n@param[in] ja An NNZ-element index tracking array for the MSR\n matrix.\n@param[out] ao The non-zero elements of matrix A.\n@param[out] jao The column indices of matrix A.\n@param[out] iao The index in A where the requested row starts.\n@param[out] wk An N-element workspace array.\n@param[out] iwk An N+1 element workspace array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n real(kind=real64), intent(in) :: a (*) integer(kind=int32), intent(in) :: ja (*) real(kind=real64), intent(out) :: ao (*) integer(kind=int32), intent(out) :: jao (*) integer(kind=int32), intent(out) :: iao (n+1) real(kind=real64), intent(out) :: wk (n) integer(kind=int32), intent(out) :: iwk (n+1) interface public pure subroutine pgmres(n, im, rhs, sol, vv, eps, maxits, iout, aa, ja, ia, alu, jlu, ju, ierr) @brief An ILUT preconditioned GMRES algorithm.  This routine utilizes\nthe L and U matrices generated by the ILUT routine to precondition\nthe GMRES algorithm.  The stopping criteria utilized is based simply \non reducing the residual norm to the requested tolerance. @param[in] n The row dimension of the matrix.\n@param[in] im The size of the Krylov subspace.  This value should\n not exceed 50.\n@param[in,out] rhs The N-element right-hand-side vector.  On output,\n the contents of this array are overwritten.\n@param[in,out] sol On input, the N-element solution estimate.  On\n output, the computed solution.\n@param[out] vv An N-by-IM+1 workspace matrix.\n@param[in] eps The convergence tolerance against which the norm of\n the residual is checked.\n@param[in] maxits The maximum number of iterations to allow.\n@param[in] iout The device output number for printing intermediate\n results.  Set to a value less than or equal to zero to suppress\n printing.\n@param[in] aa The non-zero elements of matrix A.\n@param[in] ja The column indices of matrix A.\n@param[in] ia The index in A where the requested row starts.\n@param[in] alu The LU-factored matrix from ILUT.\n@param[in] jlu The LU-factored matrix from ILUT.\n@param[in] ju The LU-factored matrix from ILUT.\n@param[out] ierr Error flag:\n * 0: Successful return\n * 1: Convergence not achieved.\n * -1: The initial guess seems to be the exact solution. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: n integer(kind=int32), intent(in) :: im real(kind=real64), intent(inout) :: rhs (n) real(kind=real64), intent(inout) :: sol (n) real(kind=real64), intent(out) :: vv (n,*) real(kind=real64), intent(in) :: eps integer(kind=int32), intent(in) :: maxits integer(kind=int32), intent(in) :: iout real(kind=real64), intent(in) :: aa (*) integer(kind=int32), intent(in) :: ja (*) integer(kind=int32), intent(in) :: ia (n+1) real(kind=real64), intent(in) :: alu (*) integer(kind=int32), intent(in) :: jlu (*) integer(kind=int32), intent(in) :: ju (n) integer(kind=int32), intent(out) :: ierr","tags":"","loc":"module\\sparskit.html"},{"title":"blas.f90 – LINALG","text":"Contents Modules blas Source Code blas.f90 Source Code !> @brief A module providing explicit interfaces to BLAS routines. module blas implicit none interface pure subroutine DGEMM ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , & c , ldc ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: transa , transb integer ( int32 ), intent ( in ) :: m , n , k , lda , ldb , ldc real ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( inout ) :: c ( ldc , * ) end subroutine pure subroutine DGEMV ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , lda , incx , incy real ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), x ( * ) real ( real64 ), intent ( inout ) :: y ( * ) end subroutine pure subroutine ZGEMM ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , & c , ldc ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: transa , transb integer ( int32 ), intent ( in ) :: m , n , k , lda , ldb , ldc complex ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), b ( ldb , * ) complex ( real64 ), intent ( inout ) :: c ( ldc , * ) end subroutine pure subroutine ZGEMV ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , lda , incx , incy complex ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), x ( * ) complex ( real64 ), intent ( inout ) :: y ( * ) end subroutine pure subroutine DTRSM ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , uplo , transa , diag integer ( int32 ), intent ( in ) :: m , n , lda , ldb real ( real64 ), intent ( in ) :: alpha , a ( lda , * ) real ( real64 ), intent ( inout ) :: b ( ldb , * ) end subroutine pure subroutine ZTRSM ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , uplo , transa , diag integer ( int32 ), intent ( in ) :: m , n , lda , ldb complex ( real64 ), intent ( in ) :: alpha , a ( lda , * ) complex ( real64 ), intent ( inout ) :: b ( ldb , * ) end subroutine pure subroutine DTRSV ( uplo , trans , diag , n , a , lda , x , incx ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo , trans , diag integer ( int32 ), intent ( in ) :: n , lda , incx real ( real64 ), intent ( in ) :: a ( lda , * ) real ( real64 ), intent ( inout ) :: x ( * ) end subroutine pure subroutine ZTRSV ( uplo , trans , diag , n , a , lda , x , incx ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo , trans , diag integer ( int32 ), intent ( in ) :: n , lda , incx complex ( real64 ), intent ( in ) :: a ( lda , * ) complex ( real64 ), intent ( inout ) :: x ( * ) end subroutine pure subroutine DSCAL ( n , da , dx , incx ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , incx real ( real64 ), intent ( in ) :: da real ( real64 ), intent ( inout ) :: dx ( * ) end subroutine pure subroutine ZSCAL ( n , za , zx , incx ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , incx complex ( real64 ), intent ( in ) :: za complex ( real64 ), intent ( inout ) :: zx ( * ) end subroutine pure subroutine ZDSCAL ( n , da , zx , incx ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , incx real ( real64 ), intent ( in ) :: da complex ( real64 ), intent ( inout ) :: zx ( * ) end subroutine pure subroutine DGBMV ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , & incy ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , kl , ku , lda , incx , incy real ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), x ( * ) real ( real64 ), intent ( inout ) :: y ( * ) end subroutine pure subroutine ZGBMV ( trans , m , n , kl , ku , alpha , a , lda , x , incx , beta , y , & incy ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , kl , ku , lda , incx , incy complex ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), x ( * ) complex ( real64 ), intent ( inout ) :: y ( * ) end subroutine pure function DDOT ( n , dx , incx , dy , incy ) result ( rst ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , incx , incy real ( real64 ), intent ( in ) :: dx ( * ), dy ( * ) real ( real64 ) :: rst end function pure subroutine DSWAP ( n , dx , incx , dy , incy ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , incx , incy real ( real64 ), intent ( inout ) :: dx ( * ), dy ( * ) end subroutine end interface end module","tags":"","loc":"sourcefile\\blas.f90.html"},{"title":"lapack.f90 – LINALG","text":"Contents Modules lapack Source Code lapack.f90 Source Code module lapack implicit none interface pure function DLAMCH ( cmach ) result ( x ) use iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function pure subroutine DGESVD ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , & work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobu , jobvt integer ( int32 ), intent ( in ) :: m , n , lda , ldu , ldvt , lwork integer ( int32 ), intent ( out ) :: info real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: s ( * ), u ( ldu , * ), vt ( ldvt , * ), work ( * ) end subroutine pure subroutine ZGESVD ( jobu , jobvt , m , n , a , lda , s , u , ldu , vt , ldvt , & work , lwork , rwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobu , jobvt integer ( int32 ), intent ( in ) :: m , n , lda , ldu , ldvt , lwork integer ( int32 ), intent ( out ) :: info complex ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: s ( * ), rwork ( * ) complex ( real64 ), intent ( out ) :: u ( ldu , * ), vt ( ldvt , * ), work ( * ) end subroutine pure subroutine DGETRF ( m , n , a , lda , ipiv , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda real ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( out ) :: ipiv ( * ), info end subroutine pure subroutine ZGETRF ( m , n , a , lda , ipiv , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda complex ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( out ) :: ipiv ( * ), info end subroutine pure subroutine DSYEV ( jobz , uplo , n , a , lda , w , work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobz , uplo integer ( int32 ), intent ( in ) :: n , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: w ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGEEV ( jobvl , jobvr , n , a , lda , wr , wi , vl , ldvl , vr , ldvr , & work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobvl , jobvr integer ( int32 ), intent ( in ) :: n , lda , ldvl , ldvr , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: wr ( * ), wi ( * ), vl ( ldvl , * ), vr ( ldvr , * ), & work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGGEV ( jobvl , jobvr , n , a , lda , b , ldb , alphar , alphai , & beta , vl , ldvl , vr , ldvr , work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobvl , jobvr integer ( int32 ), intent ( in ) :: n , lda , ldb , ldvl , ldvr , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( out ) :: alphar ( * ), alphai ( * ), beta ( * ), & vl ( ldvl , * ), vr ( ldvr , * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGEEV ( jobvl , jobvr , n , a , lda , w , vl , ldvl , vr , ldvr , work , & lwork , rwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobvl , jobvr integer ( int32 ), intent ( in ) :: n , lda , ldvl , ldvr , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( out ) :: w ( * ), vl ( ldvl , * ), vr ( ldvr , * ), & work ( * ) real ( real64 ), intent ( out ) :: rwork ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DLASET ( uplo , m , n , alpha , beta , a , lda ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: m , n , lda real ( real64 ), intent ( in ) :: alpha , beta real ( real64 ), intent ( out ) :: a ( lda , * ) end subroutine pure subroutine DGEQRF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGEQRF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGEQP3 ( m , n , a , lda , jpvt , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( inout ) :: jpvt ( * ) real ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGEQP3 ( m , n , a , lda , jpvt , tau , work , lwork , rwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( inout ) :: jpvt ( * ) complex ( real64 ), intent ( out ) :: tau ( * ), work ( * ) real ( real64 ), intent ( out ) :: rwork ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DORGQR ( m , n , k , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( in ) :: tau ( * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZUNGQR ( m , n , k , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( in ) :: tau ( * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DORMQR ( side , trans , m , n , k , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , lda , ldc , lwork real ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) real ( real64 ), intent ( inout ) :: c ( ldc , * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZUNMQR ( side , trans , m , n , k , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , lda , ldc , lwork complex ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) complex ( real64 ), intent ( inout ) :: c ( ldc , * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DPOTRF ( uplo , n , a , lda , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: n , lda real ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZPOTRF ( uplo , n , a , lda , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: n , lda complex ( real64 ), intent ( inout ) :: a ( lda , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DTZRZF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZTZRZF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DORMRZ ( side , trans , m , n , k , l , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , l , lda , ldc , lwork real ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) real ( real64 ), intent ( inout ) :: c ( ldc , * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine zunmrz ( side , trans , m , n , k , l , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , l , lda , ldc , lwork complex ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) complex ( real64 ), intent ( inout ) :: c ( ldc , * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGELQF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGELQF ( m , n , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( out ) :: tau ( * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DORGLQ ( m , n , k , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , lda , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( in ) :: tau ( * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZUNGLQ ( m , n , k , a , lda , tau , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , lda , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( in ) :: tau ( * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DORMLQ ( side , trans , m , n , k , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , lda , ldc , lwork real ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) real ( real64 ), intent ( inout ) :: c ( ldc , * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZUNMLQ ( side , trans , m , n , k , a , lda , tau , c , ldc , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: side , trans integer ( int32 ), intent ( in ) :: m , n , k , lda , ldc , lwork complex ( real64 ), intent ( in ) :: a ( lda , * ), tau ( * ) complex ( real64 ), intent ( inout ) :: c ( ldc , * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGETRS ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb real ( real64 ), intent ( in ) :: a ( lda , * ) integer ( int32 ), intent ( in ) :: ipiv ( * ) real ( real64 ), intent ( inout ) :: b ( ldb , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGETRS ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb complex ( real64 ), intent ( in ) :: a ( lda , * ) integer ( int32 ), intent ( in ) :: ipiv ( * ) complex ( real64 ), intent ( inout ) :: b ( ldb , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DLAIC1 ( job , j , x , sest , w , gamma , sestpr , s , c ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: job , j real ( real64 ), intent ( in ) :: x ( j ), w ( j ), sest , gamma real ( real64 ), intent ( out ) :: sestpr , s , c end subroutine pure subroutine ZLAIC1 ( job , j , x , sest , w , gamma , sestpr , s , c ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: job , j complex ( real64 ), intent ( in ) :: x ( j ), w ( j ), gamma real ( real64 ), intent ( in ) :: sest real ( real64 ), intent ( out ) :: sestpr complex ( real64 ), intent ( out ) :: s , c end subroutine pure subroutine DPOTRS ( uplo , n , nrhs , a , lda , b , ldb , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb real ( real64 ), intent ( in ) :: a ( lda , * ) real ( real64 ), intent ( inout ) :: b ( ldb , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZPOTRS ( uplo , n , nrhs , a , lda , b , ldb , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb complex ( real64 ), intent ( in ) :: a ( lda , * ) complex ( real64 ), intent ( inout ) :: b ( ldb , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGETRI ( n , a , lda , ipiv , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , lda , lwork , ipiv ( * ) real ( real64 ), intent ( inout ) :: a ( lda , * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGETRI ( n , a , lda , ipiv , work , lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , lda , lwork , ipiv ( * ) complex ( real64 ), intent ( inout ) :: a ( lda , * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGELS ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZGELS ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: trans integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) complex ( real64 ), intent ( out ) :: work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGELSY ( m , n , nrhs , a , lda , b , ldb , jpvt , rcond , rank , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( int32 ), intent ( inout ) :: jpvt ( * ) real ( real64 ), intent ( in ) :: rcond integer ( int32 ), intent ( out ) :: rank , info real ( real64 ), intent ( out ) :: work ( * ) end subroutine pure subroutine ZGELSY ( m , n , nrhs , a , lda , b , ldb , jpvt , rcond , rank , work , & lwork , rwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( int32 ), intent ( inout ) :: jpvt ( * ) real ( real64 ), intent ( in ) :: rcond integer ( int32 ), intent ( out ) :: rank , info complex ( real64 ), intent ( out ) :: work ( * ) real ( real64 ), intent ( out ) :: rwork ( * ) end subroutine pure subroutine DGELSS ( m , n , nrhs , a , lda , b , ldb , s , rcond , rank , work , & lwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( out ) :: s ( * ) real ( real64 ), intent ( in ) :: rcond integer ( int32 ), intent ( out ) :: rank , info real ( real64 ), intent ( out ) :: work ( * ) end subroutine pure subroutine ZGELSS ( m , n , nrhs , a , lda , b , ldb , s , rcond , rank , work , & lwork , rwork , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , nrhs , lda , ldb , lwork complex ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( out ) :: s ( * ) real ( real64 ), intent ( in ) :: rcond integer ( int32 ), intent ( out ) :: rank , info complex ( real64 ), intent ( out ) :: work ( * ) real ( real64 ), intent ( out ) :: rwork ( * ) end subroutine pure subroutine DLASRT ( id , n , d , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: id integer ( int32 ), intent ( in ) :: n real ( real64 ), intent ( inout ) :: d ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGESV ( n , nrhs , a , lda , ipiv , b , ldb , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , nrhs , lda , ldb integer ( int32 ), intent ( out ) :: ipiv ( * ) real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine DGGEV3 ( jobvl , jobvr , n , a , lda , b , ldb , alphar , alphai , & beta , vl , ldvl , vr , ldvr , work , lwork , info ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: jobvl , jobvr integer ( int32 ), intent ( in ) :: n , lda , ldb , ldvl , ldvr , lwork real ( real64 ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( real64 ), intent ( out ) :: alphar ( * ), alphai ( * ), beta ( * ), & vl ( ldvl , * ), vr ( ldvr , * ), work ( * ) integer ( int32 ), intent ( out ) :: info end subroutine end interface end module","tags":"","loc":"sourcefile\\lapack.f90.html"},{"title":"linalg.f90 – LINALG","text":"Contents Modules linalg Source Code linalg.f90 Source Code ! linalg.f90 module linalg use linalg_sparse use linalg_basic use linalg_sorting use linalg_eigen use linalg_lu use linalg_rz use linalg_qr use linalg_tri use linalg_cholesky use linalg_lq use linalg_svd use linalg_inverse use linalg_least_squares implicit none private ! LINALG_BASIC.F90 public :: LA_NO_OPERATION public :: LA_TRANSPOSE public :: LA_HERMITIAN_TRANSPOSE public :: mtx_mult public :: rank1_update public :: diag_mtx_mult public :: trace public :: mtx_rank public :: det public :: swap public :: recip_mult_array public :: tri_mtx_mult public :: band_mtx_mult public :: band_mtx_to_full_mtx public :: band_diag_mtx_mult public :: banded_to_dense public :: dense_to_banded public :: extract_diagonal ! LINALG_SPARSE.F90 public :: csr_matrix public :: msr_matrix public :: size public :: create_empty_csr_matrix public :: create_empty_msr_matrix public :: nonzero_count public :: dense_to_csr public :: diag_to_csr public :: banded_to_csr public :: csr_to_dense public :: csr_to_msr public :: msr_to_csr public :: dense_to_msr public :: msr_to_dense public :: create_csr_matrix public :: matmul public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) public :: operator ( / ) public :: assignment ( = ) public :: transpose public :: sparse_direct_solve public :: pgmres_solver ! LINALG_SORTING.F90 public :: sort ! LINALG_EIGEN.F90 public :: eigen ! LINALG_LU.F90 public :: lu_factor public :: form_lu public :: solve_lu ! LINALG_RZ.F90 public :: rz_factor public :: mult_rz ! LINALG_QR.F90 public :: qr_factor public :: form_qr public :: mult_qr public :: qr_rank1_update public :: solve_qr ! LINALG_TRI.F90 public :: solve_triangular_system ! LINALG_CHOLESKY.F90 public :: cholesky_factor public :: cholesky_rank1_update public :: cholesky_rank1_downdate public :: solve_cholesky ! LINALG_LQ.F90 public :: lq_factor public :: form_lq public :: mult_lq public :: solve_lq ! LINALG_SVD.F90 public :: svd ! LINALG_INVERSE.F90 public :: mtx_inverse public :: mtx_pinverse ! LINALG_LEAST_SQUARES.F90 public :: solve_least_squares public :: solve_least_squares_full public :: solve_least_squares_svd end module","tags":"","loc":"sourcefile\\linalg.f90.html"},{"title":"linalg_basic.f90 – LINALG","text":"Contents Modules linalg_basic Source Code linalg_basic.f90 Source Code ! linalg_basic.f90 module linalg_basic use iso_fortran_env , only : int32 , real64 use blas use lapack use linalg_sparse use linalg_errors use ferror implicit none private public :: LA_NO_OPERATION public :: LA_TRANSPOSE public :: LA_HERMITIAN_TRANSPOSE public :: mtx_mult public :: rank1_update public :: diag_mtx_mult public :: trace public :: mtx_rank public :: det public :: swap public :: recip_mult_array public :: tri_mtx_mult public :: band_mtx_mult public :: band_mtx_to_full_mtx public :: band_diag_mtx_mult public :: banded_to_dense public :: dense_to_banded public :: extract_diagonal integer ( int32 ), parameter :: LA_NO_OPERATION = 0 !! Defines no operation should be performed on the matrix. integer ( int32 ), parameter :: LA_TRANSPOSE = 1 !! Defines a transpose operation. integer ( int32 ), parameter :: LA_HERMITIAN_TRANSPOSE = 2 !! Defines a Hermitian transpose operation for a complex-valued matrix. interface mtx_mult !! An interface to the matrix multiplication routines. module procedure :: mtx_mult_mtx module procedure :: mtx_mult_vec module procedure :: cmtx_mult_mtx module procedure :: cmtx_mult_vec end interface interface rank1_update !! An interface to the rank-1 update routines. module procedure :: rank1_update_dbl module procedure :: rank1_update_cmplx end interface interface diag_mtx_mult !! An interface to the diagonal matrix multiplication routines. module procedure :: diag_mtx_mult_mtx module procedure :: diag_mtx_mult_mtx2 module procedure :: diag_mtx_mult_mtx3 module procedure :: diag_mtx_mult_mtx4 module procedure :: diag_mtx_mult_mtx_cmplx module procedure :: diag_mtx_mult_mtx2_cmplx module procedure :: diag_mtx_mult_mtx_mix module procedure :: diag_mtx_mult_mtx2_mix module procedure :: diag_mtx_sparse_mult end interface interface trace !! An interface to the trace routines. module procedure :: trace_dbl module procedure :: trace_cmplx end interface interface mtx_rank !! An interface to the matrix rank routines. module procedure :: mtx_rank_dbl module procedure :: mtx_rank_cmplx end interface interface det !! An interface to the determinant routines. module procedure :: det_dbl module procedure :: det_cmplx end interface interface swap !! An interface to the swap routines. module procedure :: swap_dbl module procedure :: swap_cmplx end interface interface recip_mult_array !! An interface to the reciprocal multiplication routines. module procedure :: recip_mult_array_dbl end interface interface tri_mtx_mult !! An interface to the triangular matrix multiplication routines. module procedure :: tri_mtx_mult_dbl module procedure :: tri_mtx_mult_cmplx end interface interface band_mtx_mult !! An interface to the banded matrix multiplication routines. module procedure :: band_mtx_vec_mult_dbl module procedure :: band_mtx_vec_mult_cmplx end interface interface band_mtx_to_full_mtx !! An interface to the banded matrix to full matrix conversion routines. module procedure :: band_to_full_mtx_dbl module procedure :: band_to_full_mtx_cmplx end interface interface band_diag_mtx_mult !! An interface to the banded diagonal matrix multiplication routines. module procedure :: band_diag_mtx_mult_dbl module procedure :: band_diag_mtx_mult_cmplx end interface interface banded_to_dense !! An interface to the banded to dense matrix conversion routines. module procedure :: banded_to_dense_dbl module procedure :: banded_to_dense_cmplx end interface interface dense_to_banded !! An interface to the dense to banded matrix conversion routines. module procedure :: dense_to_banded_dbl module procedure :: dense_to_banded_cmplx end interface interface extract_diagonal !! An interface to the diagonal extraction routines. module procedure :: extract_diagonal_dbl module procedure :: extract_diagonal_cmplx module procedure :: extract_diagonal_csr end interface contains ! ****************************************************************************** ! MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine mtx_mult_mtx ( transa , transb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A B + \\beta C . logical , intent ( in ) :: transa !! A logical flag indicating if the matrix A should be transposed. logical , intent ( in ) :: transb !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: ta , tb integer ( int32 ) :: m , n , k , lda , ldb , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) if ( transa ) then ! K = # of columns in op(A) (# of rows in op(B)) k = size ( a , 1 ) ta = 'T' lda = k else k = size ( a , 2 ) ta = 'N' lda = m end if if ( transb ) then tb = 'T' ldb = n else tb = 'N' ldb = k end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( transa ) then if ( size ( a , 2 ) /= m ) flag = 4 else if ( size ( a , 1 ) /= m ) flag = 4 end if if ( transb ) then if ( size ( b , 2 ) /= k . or . size ( b , 1 ) /= n ) flag = 5 else if ( size ( b , 1 ) /= k . or . size ( b , 2 ) /= n ) flag = 5 end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"mtx_mult_mtx\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call DGEMM call DGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , m ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_mult_vec ( trans , alpha , a , b , beta , c , err ) !! Performs the matrix-vector operation C = \\alpha A B + \\beta C . logical , intent ( in ) :: trans !! A logical flag indicating if the matrix A should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the vector C. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. real ( real64 ), intent ( in ), dimension (:) :: b !! The vector B in the operation. real ( real64 ), intent ( inout ), dimension (:) :: c !! The vector C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: t integer ( int32 ) :: m , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) t = 'N' if ( trans ) t = 'T' if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( trans ) then if ( size ( b ) /= m ) then flag = 4 else if ( size ( c ) /= n ) then flag = 6 end if else if ( size ( b ) /= n ) then flag = 4 else if ( size ( c ) /= m ) then flag = 6 end if end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"mtx_mult_vec\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call DGEMV call DGEMV ( t , m , n , alpha , a , m , b , 1 , beta , c , 1 ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! !                           COMPLEX VALUED VERSIONS                            ! ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! subroutine cmtx_mult_mtx ( opa , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A B + \\beta C . integer ( int32 ), intent ( in ) :: opa !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: ta , tb integer ( int32 ) :: m , n , k , lda , ldb , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) if ( opa == LA_TRANSPOSE ) then ! K = # of columns in op(A) (# of rows in op(B)) k = size ( a , 1 ) ta = 'T' lda = k else if ( opa == LA_HERMITIAN_TRANSPOSE ) then k = size ( a , 1 ) ta = 'C' lda = k else k = size ( a , 2 ) ta = 'N' lda = m end if if ( opb == LA_TRANSPOSE ) then tb = 'T' ldb = n else if ( opb == LA_HERMITIAN_TRANSPOSE ) then tb = 'C' ldb = n else tb = 'N' ldb = k end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( opa == LA_TRANSPOSE . or . opa == LA_HERMITIAN_TRANSPOSE ) then if ( size ( a , 2 ) /= m ) flag = 4 else if ( size ( a , 1 ) /= m ) flag = 4 end if if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then if ( size ( b , 2 ) /= k . or . size ( b , 1 ) /= n ) flag = 5 else if ( size ( b , 1 ) /= k . or . size ( b , 2 ) /= n ) flag = 5 end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"cmtx_mult_mtx\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call ZGEMM call ZGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , m ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine cmtx_mult_vec ( opa , alpha , a , b , beta , c , err ) !! Performs the matrix-vector operation C = \\alpha A B + \\beta C . integer ( int32 ), intent ( in ) :: opa !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the vector C. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:) :: b !! The vector B in the operation. complex ( real64 ), intent ( inout ), dimension (:) :: c !! The vector C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: t integer ( int32 ) :: m , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( opa == LA_TRANSPOSE ) then t = 'T' else if ( opa == LA_HERMITIAN_TRANSPOSE ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( opa == LA_TRANSPOSE . or . opa == LA_HERMITIAN_TRANSPOSE ) then if ( size ( b ) /= m ) then flag = 4 else if ( size ( c ) /= n ) then flag = 6 end if else if ( size ( b ) /= n ) then flag = 4 else if ( size ( c ) /= m ) then flag = 6 end if end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"cmtx_mult_vec\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call ZGEMV call ZGEMV ( t , m , n , alpha , a , m , b , 1 , beta , c , 1 ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ****************************************************************************** ! RANK 1 UPDATE ! ------------------------------------------------------------------------------ subroutine rank1_update_dbl ( alpha , x , y , a , err ) !! Performs a rank-1 update of a matrix of the form A = \\alpha x y&#94;T + A. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the outer product of x and y. real ( real64 ), intent ( in ), dimension (:) :: x !! The vector x in the outer product. real ( real64 ), intent ( in ), dimension (:) :: y !! The vector y in the outer product. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix A to update. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , m , n real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( x ) n = size ( y ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= m . or . size ( a , 2 ) /= n ) then ! ERROR: Matrix dimension array call report_matrix_size_error ( \"rank1_update_dbl\" , errmgr , \"A\" , m , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Process do j = 1 , n if ( y ( j ) /= zero ) then temp = alpha * y ( j ) a (:, j ) = a (:, j ) + temp * x end if end do end subroutine ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! !                           COMPLEX VALUED VERSIONS                            ! ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! subroutine rank1_update_cmplx ( alpha , x , y , a , err ) !! Performs a rank-1 update of a matrix of the form A = \\alpha x y&#94;H + A. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the outer product of x and y. complex ( real64 ), intent ( in ), dimension (:) :: x !! The vector x in the outer product. complex ( real64 ), intent ( in ), dimension (:) :: y !! The vector y in the outer product. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix A to update. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , m , n complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( x ) n = size ( y ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= m . or . size ( a , 2 ) /= n ) then ! ERROR: Matrix dimension array call report_matrix_size_error ( \"rank1_update_cmplx\" , errmgr , \"A\" , m , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Process do j = 1 , n if ( y ( j ) /= zero ) then temp = alpha * conjg ( y ( j )) a (:, j ) = a (:, j ) + temp * x end if end do end subroutine ! ****************************************************************************** ! DIAGONAL MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx ( lside , trans , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. logical , intent ( in ) :: trans !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( trans ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( trans ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2 ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , k real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx3 ( lside , trans , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha B A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. logical , intent ( in ) :: trans !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( trans ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx3\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( trans ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx4 ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx4\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx_cmplx ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2_cmplx ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2_cmplx\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx_mix ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx_mix\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2_mix ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2_cmplx\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_sparse_mult ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix and B is a sparse matrix. logical , intent ( in ) :: lside real ( real64 ), intent ( in ) :: alpha real ( real64 ), intent ( in ), dimension (:) :: a class ( csr_matrix ), intent ( inout ) :: b class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: ii , k , k1 , k2 , nrow real ( real64 ) :: scal class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization nrow = size ( b , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then if ( size ( a ) /= nrow ) then call report_inner_matrix_dimension_error ( \"diag_mtx_sparse_mult\" , & errmgr , \"a\" , \"b\" , nrow , size ( a )) return end if else if ( size ( a ) /= size ( b , 2 )) then call report_inner_matrix_dimension_error ( \"diag_mtx_sparse_mult\" , & errmgr , \"a\" , \"b\" , size ( b , 2 ), size ( a )) return end if end if ! Process if ( lside ) then ! Compute B = DIAG * B do ii = 1 , nrow k1 = b % row_indices ( ii ) k2 = b % row_indices ( ii + 1 ) - 1 if ( alpha == 1.0d0 ) then scal = a ( ii ) else scal = alpha * a ( ii ) end if do k = k1 , k2 b % values ( k ) = b % values ( k ) * scal end do end do else ! Compute B = B * DIAG do ii = 1 , nrow k1 = b % row_indices ( ii ) k2 = b % row_indices ( ii + 1 ) - 1 if ( alpha == 1.0d0 ) then do k = k1 , k2 b % values ( k ) = b % values ( k ) * a ( b % column_indices ( k )) end do else do k = k1 , k2 b % values ( k ) = alpha * b % values ( k ) * a ( b % column_indices ( k )) end do end if end do end if end subroutine ! ****************************************************************************** ! BASIC OPERATION ROUTINES ! ------------------------------------------------------------------------------ pure function trace_dbl ( x ) result ( y ) !! Computes the trace of a matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix. real ( real64 ) :: y !! The trace of the matrix. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn ! Initialization y = zero m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) ! Process do i = 1 , mn y = y + x ( i , i ) end do end function ! ------------------------------------------------------------------------------ pure function trace_cmplx ( x ) result ( y ) !! Computes the trace of a matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix. complex ( real64 ) :: y !! The trace of the matrix. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn ! Initialization y = zero m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) ! Process do i = 1 , mn y = y + x ( i , i ) end do end function ! ------------------------------------------------------------------------------ function mtx_rank_dbl ( a , tol , work , olwork , err ) result ( rnk ) !! Computes the rank of a matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default !! tolerance on singular values such that singular values less than !! this tolerance are treated as zero.  The default tolerance is: !! MAX(M, N) * EPS * MAX(S).  If the supplied value is less than the !! smallest value that causes an overflow if inverted, the tolerance !! reverts back to its default value, and the operation continues; !! however, a warning message is issued. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local !! memory allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork.  If not provided, the memory required is allocated within. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size. If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. integer ( int32 ) :: rnk !! The rank of the matrix. ! Local Variables integer ( int32 ) :: i , m , n , mn , istat , lwork , flag real ( real64 ), pointer , dimension (:) :: wptr , s , w real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ) :: t , tref , smlnum real ( real64 ), dimension ( 1 ) :: dummy , temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) smlnum = DLAMCH ( 's' ) rnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Workspace Query !call svd(a, a(1:mn,1), olwork = lwork) call DGESVD ( 'N' , 'N' , m , n , a , m , dummy , dummy , m , dummy , n , temp , & - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"mtx_rank\" , & \"Incorrectly sized input array WORK, argument 5.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_rank\" , errmgr , flag ) return end if wptr => wrk end if s => wptr ( 1 : mn ) w => wptr ( mn + 1 : lwork ) ! Compute the singular values of A call DGESVD ( 'N' , 'N' , m , n , a , m , s , dummy , m , dummy , n , w , & lwork - mn , flag ) if ( flag > 0 ) then allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) flag , \" superdiagonals could not \" // & \"converge to zero as part of the QR iteration process.\" call errmgr % report_warning ( \"mtx_rank\" , errmsg , LA_CONVERGENCE_ERROR ) end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if if ( t < smlnum ) then ! ! The supplied tolerance is too small, simply fall back to the ! ! default, but issue a warning to the user ! t = tref ! call report_warning(\"mtx_rank\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Count the singular values that are larger than the tolerance value do i = 1 , mn if ( s ( i ) < t ) exit rnk = rnk + 1 end do ! Formatting 100 format ( I0 , A ) end function ! ------------------------------------------------------------------------------ function mtx_rank_cmplx ( a , tol , work , olwork , rwork , err ) result ( rnk ) !! Computes the rank of a matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default !! tolerance on singular values such that singular values less than !! this tolerance are treated as zero.  The default tolerance is: !! MAX(M, N) * EPS * MAX(S).  If the supplied value is less than the !! smallest value that causes an overflow if inverted, the tolerance !! reverts back to its default value, and the operation continues; !! however, a warning message is issued. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local !! memory allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork.  If not provided, the memory required is allocated within. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size. If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any !! local memory allocation for real-valued workspace arrays.  If not !! provided, the memory required is allocated within.  If provided, the !! length of the array must be at least 6 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The rank of the matrix. integer ( int32 ) :: rnk !! The rank of the matrix. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Local Variables integer ( int32 ) :: i , m , n , mn , istat , lwork , flag , lrwork real ( real64 ), pointer , dimension (:) :: s , rwptr , rw real ( real64 ), allocatable , target , dimension (:) :: rwrk complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), pointer , dimension (:) :: wptr real ( real64 ) :: t , tref , smlnum real ( real64 ), dimension ( 1 ) :: dummy complex ( real64 ), dimension ( 1 ) :: cdummy , temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 6 * mn smlnum = DLAMCH ( 's' ) rnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Workspace Query call ZGESVD ( 'N' , 'N' , m , n , a , m , dummy , cdummy , m , cdummy , n , temp , & - 1 , dummy , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"mtx_rank_cmplx\" , & \"Incorrectly sized input array WORK, argument 5.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_rank_cmplx\" , errmgr , flag ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then ! ERROR: RWORK not sized correctly call errmgr % report_error ( \"mtx_rank_cmplx\" , & \"Incorrectly sized input array RWORK.\" , & LA_ARRAY_SIZE_ERROR ) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then end if rwptr => rwrk end if s => rwptr ( 1 : mn ) rw => rwptr ( mn + 1 : lrwork ) ! Compute the singular values of A call ZGESVD ( 'N' , 'N' , m , n , a , m , s , cdummy , m , cdummy , n , wptr , & lwork - mn , rw , flag ) if ( flag > 0 ) then allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) flag , \" superdiagonals could not \" // & \"converge to zero as part of the QR iteration process.\" call errmgr % report_warning ( \"mtx_rank_cmplx\" , errmsg , LA_CONVERGENCE_ERROR ) end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if if ( t < smlnum ) then ! ! The supplied tolerance is too small, simply fall back to the ! ! default, but issue a warning to the user ! t = tref ! call report_warning(\"mtx_rank\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Count the singular values that are larger than the tolerance value do i = 1 , mn if ( s ( i ) < t ) exit rnk = rnk + 1 end do ! Formatting 100 format ( I0 , A ) end function ! ------------------------------------------------------------------------------ function det_dbl ( a , iwork , err ) result ( x ) !! Computes the determinant of a matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the matrix on which to operate.  On output, the LU factored !! matrix in the form [L\\\\U] where L is unit lower triangular and U is !! upper triangular.  The unit diagonal elements of L are not stored. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I).  If not supplied, this array is allocated within. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. real ( real64 ) :: x !! The determinant of the matrix. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 real ( real64 ), parameter :: p1 = 1.0d-1 ! Local Variables integer ( int32 ) :: i , ep , n , istat , flag integer ( int32 ), pointer , dimension (:) :: ipvt integer ( int32 ), allocatable , target , dimension (:) :: iwrk real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) x = zero if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"det\" , errmgr , \"a\" , n , size ( a , 1 ), & size ( a , 2 )) return end if ! Local Memory Allocation if ( present ( iwork )) then if ( size ( iwork ) < n ) then call report_array_size_error ( \"det\" , errmgr , \"iwork\" , n , n ) return end if ipvt => iwork ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then ! ERROR: Out of memory call report_memory_error ( \"det\" , errmgr , flag ) return end if ipvt => iwrk end if ! Compute the LU factorization of A call DGETRF ( n , n , a , n , ipvt , flag ) if ( flag > 0 ) then ! A singular matrix has a determinant of zero x = zero return end if ! Compute the product of the diagonal of A temp = one ep = 0 do i = 1 , n if ( ipvt ( i ) /= i ) temp = - temp temp = a ( i , i ) * temp if ( temp == zero ) then x = zero exit end if do while ( abs ( temp ) < one ) temp = ten * temp ep = ep - 1 end do do while ( abs ( temp ) > ten ) temp = p1 * temp ep = ep + 1 end do end do x = temp * ten ** ep end function ! ------------------------------------------------------------------------------ function det_cmplx ( a , iwork , err ) result ( x ) !! Computes the determinant of a matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the matrix on which to operate.  On output, the LU factored !! matrix in the form [L\\\\U] where L is unit lower triangular and U is !! upper triangular.  The unit diagonal elements of L are not stored. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I).  If not supplied, this array is allocated within. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. complex ( real64 ) :: x !! The determinant of the matrix. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) complex ( real64 ), parameter :: ten = ( 1.0d1 , 0.0d0 ) complex ( real64 ), parameter :: p1 = ( 1.0d-1 , 0.0d0 ) real ( real64 ), parameter :: real_one = 1.0d0 real ( real64 ), parameter :: real_ten = 1.0d1 ! Local Variables integer ( int32 ) :: i , ep , n , istat , flag integer ( int32 ), pointer , dimension (:) :: ipvt integer ( int32 ), allocatable , target , dimension (:) :: iwrk complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) x = zero if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"det_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Local Memory Allocation if ( present ( iwork )) then if ( size ( iwork ) < n ) then call report_array_size_error ( \"det_cmplx\" , errmgr , \"iwork\" , n , n ) end if ipvt => iwork ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"det_cmplx\" , errmgr , flag ) end if ipvt => iwrk end if ! Compute the LU factorization of A call ZGETRF ( n , n , a , n , ipvt , flag ) if ( flag > 0 ) then ! A singular matrix has a determinant of zero x = zero return end if ! Compute the product of the diagonal of A temp = one ep = 0 do i = 1 , n if ( ipvt ( i ) /= i ) temp = - temp temp = a ( i , i ) * temp if ( temp == zero ) then x = zero exit end if do while ( abs ( temp ) < real_one ) temp = ten * temp ep = ep - 1 end do do while ( abs ( temp ) > real_ten ) temp = p1 * temp ep = ep + 1 end do end do x = temp * ten ** ep end function ! ****************************************************************************** ! ARRAY SWAPPING ROUTINE ! ------------------------------------------------------------------------------ subroutine swap_dbl ( x , y , err ) !! Swaps the contents of two arrays. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the first array to swap.  On output, the contents of the !! first array are copied to the second array. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the second array to swap.  On output, the contents of the !! second array are copied to the first array. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then call report_array_size_error ( \"swap_dbl\" , errmgr , \"y\" , n , n ) return end if ! Process do i = 1 , n temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp end do end subroutine ! ------------------------------------------------------------------------------ subroutine swap_cmplx ( x , y , err ) !! Swaps the contents of two arrays. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the first array to swap.  On output, the contents of the !! first array are copied to the second array. complex ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the second array to swap.  On output, the contents of the !! second array are copied to the first array. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , n complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then call report_array_size_error ( \"swap_cmplx\" , errmgr , \"y\" , n , n ) return end if ! Process do i = 1 , n temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp end do end subroutine ! ****************************************************************************** ! ARRAY MULTIPLICIATION ROUTINES ! ------------------------------------------------------------------------------ subroutine recip_mult_array_dbl ( a , x ) !! Computes the product of a scalar and a vector, where the scalar is !! the reciprocal of the scalar A. real ( real64 ), intent ( in ) :: a !! The scalar A, which is the reciprocal of the scalar to multiply by. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the vector to multiply.  On output, the product of the !! vector and the scalar reciprocal. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: twotho = 2.0d3 ! Local Variables logical :: done real ( real64 ) :: bignum , cden , cden1 , cnum , cnum1 , mul , smlnum ! Initialization smlnum = DLAMCH ( 's' ) bignum = one / smlnum if ( log10 ( bignum ) > twotho ) then smlnum = sqrt ( smlnum ) bignum = sqrt ( bignum ) end if ! Initialize the denominator to A, and the numerator to ONE cden = a cnum = one ! Process do cden1 = cden * smlnum cnum1 = cnum / bignum if ( abs ( cden1 ) > abs ( cnum ) . and . cnum /= zero ) then mul = smlnum done = . false . cden = cden1 else if ( abs ( cnum1 ) > abs ( cden )) then mul = bignum done = . false . cnum = cnum1 else mul = cnum / cden done = . true . end if ! Scale the vector X by MUL x = mul * x ! Exit if done if ( done ) exit end do end subroutine ! ****************************************************************************** ! TRIANGULAR MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine tri_mtx_mult_dbl ( upper , alpha , a , beta , b , err ) !! Performs the matrix operation B = \\alpha A&#94;T A + \\beta B or !! B = \\alpha A A&#94;T + \\beta B where A is a triangular matrix. logical , intent ( in ) :: upper !! A logical flag indicating whether the matrix A is upper triangular !! (TRUE) or lower triangular (FALSE). real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The triangular matrix A to multiply by. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the matrix B to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , k , n , d1 , d2 real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) d1 = n d2 = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then d2 = size ( a , 2 ) call report_square_matrix_error ( \"tri_mtx_mult_dbl\" , errmgr , \"a\" , n , & n , size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then d1 = size ( b , 1 ) d2 = size ( b , 2 ) call report_matrix_size_error ( \"tri_mtx_mult_dbl\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Process if ( upper ) then ! Form: B = alpha * A**T * A + beta * B if ( beta == zero ) then do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if else ! Form: B = alpha * A * A**T + beta * B if ( beta == zero ) then do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if end if end subroutine ! ------------------------------------------------------------------------------ subroutine tri_mtx_mult_cmplx ( upper , alpha , a , beta , b , err ) !! Performs the matrix operation B = \\alpha A&#94;T A + \\beta B or !! B = \\alpha A A&#94;T + \\beta B where A is a triangular matrix. logical , intent ( in ) :: upper !! A logical flag indicating whether the matrix A is upper triangular !! (TRUE) or lower triangular (FALSE). complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The triangular matrix A to multiply by. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the matrix B to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , k , n , d1 , d2 complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) d1 = n d2 = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then d2 = size ( a , 2 ) call report_square_matrix_error ( \"tri_mtx_mult_cmplx\" , errmgr , \"a\" , n , & n , size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then d1 = size ( b , 1 ) d2 = size ( b , 2 ) call report_matrix_size_error ( \"tri_mtx_mult_cmplx\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Process if ( upper ) then ! Form: B = alpha * A**T * A + beta * B if ( beta == zero ) then do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if else ! Form: B = alpha * A * A**T + beta * B if ( beta == zero ) then do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if end if end subroutine ! ****************************************************************************** ! BANDED MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine band_mtx_vec_mult_dbl ( trans , kl , ku , alpha , a , x , beta , & y , err ) !! Performs the matrix operation y = \\alpha A x + \\beta y or !! y = \\alpha A&#94;T A + \\beta y where A is a banded matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: trans !! A logical flag indicating whether to perform the operation !! y = \\alpha A x + \\beta y (FALSE) or y = \\alpha A&#94;T x + \\beta y !! (TRUE). integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix A. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix A. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix A to multiply by. real ( real64 ), intent ( in ), dimension (:) :: x !! The vector x to multiply by. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the vector y to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( trans ) then m = size ( x ) n = size ( y ) else m = size ( y ) n = size ( x ) end if ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( a , 1 ) /= kl + ku + 1 ) go to 30 if ( size ( a , 2 ) /= n ) go to 30 ! Process if ( trans ) then call DGBMV ( \"T\" , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) else call DGBMV ( \"N\" , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The size of matrix A is not compatible with the other vectors.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_mtx_vec_mult_cmplx ( trans , kl , ku , alpha , a , x , & beta , y , err ) !! Performs the matrix operation y = \\alpha op(A) x + \\beta y  where !! A is a banded matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: trans !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix A. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix A. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix A to multiply by. complex ( real64 ), intent ( in ), dimension (:) :: x !! The vector x to multiply by. complex ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the vector y to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: op logical :: trns integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( trans == LA_TRANSPOSE ) then op = \"T\" trns = . true . else if ( trans == LA_HERMITIAN_TRANSPOSE ) then op = \"C\" trns = . true . else op = \"N\" trns = . false . end if if ( trns ) then m = size ( x ) n = size ( y ) else m = size ( y ) n = size ( x ) end if ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( a , 1 ) /= kl + ku + 1 ) go to 30 if ( size ( a , 2 ) /= n ) go to 30 ! Process call ZGBMV ( op , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The size of matrix A is not compatible with the other vectors.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_to_full_mtx_dbl ( kl , ku , b , f , err ) !! Converts a banded matrix to a full matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The banded matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: f !! The full matrix to store the result in. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , j , k , m , n , i1 , i2 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( f , 1 ) n = size ( f , 2 ) ! Input Check if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( b , 2 ) /= n ) go to 30 if ( size ( b , 1 ) /= kl + ku + 1 ) go to 40 ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) do i = 1 , i1 - 1 f ( i , j ) = zero end do do i = i1 , i2 f ( i , j ) = b ( k + i , j ) end do do i = i2 + 1 , m f ( i , j ) = zero end do end do ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of columns in the banded matrix does not match \" // & \"the number of columns in the full matrix.\" , & LA_ARRAY_SIZE_ERROR ) return 40 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of rows in the banded matrix does not align with \" // & \"the number of sub and super-diagonals specified.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_to_full_mtx_cmplx ( kl , ku , b , f , err ) !! Converts a banded matrix to a full matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The banded matrix to convert. complex ( real64 ), intent ( out ), dimension (:,:) :: f !! The full matrix to store the result in. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , j , k , m , n , i1 , i2 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( f , 1 ) n = size ( f , 2 ) ! Input Check if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( b , 2 ) /= n ) go to 30 if ( size ( b , 1 ) /= kl + ku + 1 ) go to 40 ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) do i = 1 , i1 - 1 f ( i , j ) = zero end do do i = i1 , i2 f ( i , j ) = b ( k + i , j ) end do do i = i2 + 1 , m f ( i , j ) = zero end do end do ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of columns in the banded matrix does not match \" // & \"the number of columns in the full matrix.\" , & LA_ARRAY_SIZE_ERROR ) return 40 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of rows in the banded matrix does not align with \" // & \"the number of sub and super-diagonals specified.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_diag_mtx_mult_dbl ( left , m , kl , ku , alpha , a , b , err ) !! Performs the matrix operation A = \\alpha A B or A = \\alpha B A !! where A is a banded matrix and B is a diagonal matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: left !! A logical flag indicating whether to perform the operation !! A = \\alpha A B (TRUE) or A = \\alpha B A (FALSE). integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix A. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The banded matrix to multiply. real ( real64 ), intent ( in ), dimension (:) :: b !! The diagonal matrix to multiply by. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , i1 , i2 , j , k , n real ( real64 ) :: temp ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( left ) then if ( size ( b ) /= n ) go to 30 else if ( size ( b ) < m ) go to 30 end if ! Process if ( left ) then ! Compute A = A * B do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) + k i2 = min ( m , j + kl ) + k if ( alpha == one ) then temp = b ( j ) else temp = alpha * b ( j ) end if do i = i1 , i2 a ( i , j ) = a ( i , j ) * temp end do end do else ! Compute A = B * A do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) if ( alpha == 1.0d0 ) then do i = i1 , i2 a ( i + k , j ) = a ( i + k , j ) * b ( i ) end do else do i = i1 , i2 a ( i + k , j ) = alpha * a ( i + k , j ) * b ( i ) end do end if end do end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! B is not sized correctly 30 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"Inner matrix dimensions do not agree.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_diag_mtx_mult_cmplx ( left , m , kl , ku , alpha , a , b , err ) !! Performs the matrix operation A = \\alpha A B or A = \\alpha B A !! where A is a banded matrix and B is a diagonal matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: left !! A logical flag indicating whether to perform the operation !! A = \\alpha A B (TRUE) or A = \\alpha B A (FALSE). integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix A. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The banded matrix to multiply. complex ( real64 ), intent ( in ), dimension (:) :: b !! The diagonal matrix to multiply by. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , i1 , i2 , j , k , n complex ( real64 ) :: temp ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( left ) then if ( size ( b ) /= n ) go to 30 else if ( size ( b ) < m ) go to 30 end if ! Process if ( left ) then ! Compute A = A * B do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) + k i2 = min ( m , j + kl ) + k if ( alpha == one ) then temp = b ( j ) else temp = alpha * b ( j ) end if do i = i1 , i2 a ( i , j ) = a ( i , j ) * temp end do end do else ! Compute A = B * A do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) if ( alpha == 1.0d0 ) then do i = i1 , i2 a ( i + k , j ) = a ( i + k , j ) * b ( i ) end do else do i = i1 , i2 a ( i + k , j ) = alpha * a ( i + k , j ) * b ( i ) end do end if end do end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! B is not sized correctly 30 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"Inner matrix dimensions do not agree.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine banded_to_dense_dbl ( m , kl , ku , a , x , err ) !! Converts a banded matrix to a dense matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: m !! The M-by-N dense matrix. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The (KL+KU+1)-by-N banded matrix. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The M-by-N dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , k , n , i1 , i2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( a , 1 ) /= kl + ku + 1 ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , \"The size of \" // & \"the input matrix does not match the specified bandwidth.\" , & LA_MATRIX_FORMAT_ERROR ) return end if if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) x (: i1 - 1 , j ) = zero do i = i1 , i2 x ( i , j ) = a ( k + i , j ) end do x ( i2 + 1 :, j ) = zero end do end subroutine ! ------------------------------------------------------------------------------ subroutine banded_to_dense_cmplx ( m , kl , ku , a , x , err ) !! Converts a banded matrix to a dense matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: m !! The M-by-N dense matrix. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The (KL+KU+1)-by-N banded matrix. complex ( real64 ), intent ( out ), dimension (:,:) :: x !! The M-by-N dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , k , n , i1 , i2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( a , 1 ) /= kl + ku + 1 ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , \"The size of \" // & \"the input matrix does not match the specified bandwidth.\" , & LA_MATRIX_FORMAT_ERROR ) return end if if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) x (: i1 - 1 , j ) = zero do i = i1 , i2 x ( i , j ) = a ( k + i , j ) end do x ( i2 + 1 :, j ) = zero end do end subroutine ! ------------------------------------------------------------------------------ subroutine dense_to_banded_dbl ( a , kl , ku , x , err ) !! Converts a banded matrix stored in dense format to a compressed form. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix to convert. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The (KL+KU+1)-by-N banded matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , j , k , m , n , mm , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mm = kl + ku + 1 ! Input Check if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"dense_to_banded_dbl\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( x , 1 ) /= mm . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"dense_to_banded_dbl\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) x ( k + i , j ) = a ( i , j ) end do end do end subroutine ! ------------------------------------------------------------------------------ subroutine dense_to_banded_cmplx ( a , kl , ku , x , err ) !! Converts a banded matrix stored in dense format to a compressed form. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix to convert. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. complex ( real64 ), intent ( out ), dimension (:,:) :: x !! The (KL+KU+1)-by-N banded matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , j , k , m , n , mm , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mm = kl + ku + 1 ! Input Check if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"dense_to_banded_cmplx\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( x , 1 ) /= mm . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"dense_to_banded_cmplx\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) x ( k + i , j ) = a ( i , j ) end do end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_dbl ( a , diag , err ) !! Extracts the diagonal of a matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_dbl\" , errmgr , \"diag\" , & mn , size ( diag )) return end if ! Process do i = 1 , mn diag ( i ) = a ( i , i ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_cmplx ( a , diag , err ) !! Extracts the diagonal of a matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix. complex ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_cmplx\" , errmgr , & \"diag\" , mn , size ( diag )) return end if ! Process do i = 1 , mn diag ( i ) = a ( i , i ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_csr ( a , diag , err ) !! Extracts the diagonal of a matrix. class ( csr_matrix ), intent ( in ) :: a !! The M-by-N matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_cmplx\" , errmgr , & \"diag\" , mn , size ( diag )) return end if ! Process call a % extract_diagonal ( diag , errmgr ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_basic.f90.html"},{"title":"linalg_cholesky.f90 – LINALG","text":"Contents Modules linalg_cholesky Source Code linalg_cholesky.f90 Source Code module linalg_cholesky use iso_fortran_env , only : int32 , real64 use linalg_errors use lapack use qrupdate implicit none private public :: cholesky_factor public :: cholesky_rank1_update public :: cholesky_rank1_downdate public :: solve_cholesky interface cholesky_factor module procedure :: cholesky_factor_dbl module procedure :: cholesky_factor_cmplx end interface interface cholesky_rank1_update module procedure :: cholesky_rank1_update_dbl module procedure :: cholesky_rank1_update_cmplx end interface interface cholesky_rank1_downdate module procedure :: cholesky_rank1_downdate_dbl module procedure :: cholesky_rank1_downdate_cmplx end interface interface solve_cholesky module procedure :: solve_cholesky_mtx module procedure :: solve_cholesky_mtx_cmplx module procedure :: solve_cholesky_vec module procedure :: solve_cholesky_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine cholesky_factor_dbl ( a , upper , err ) !! Computes the Cholesky factorization of a symmetric, positive definite !! matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to factor.  On output, the factored !! matrix is returned in either the upper or lower triangular portion !! of the matrix, dependent upon the value of upper. logical , intent ( in ), optional :: upper !! An optional input that, if specified, provides control over whether !! the factorization is computed as A = U&#94;T U (set to true), or !! as A = L L&#94;T (set to false).  The default is true such that !! A = U&#94;T U. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo integer ( int32 ) :: i , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if else uplo = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_factor\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Process call DPOTRF ( uplo , n , a , n , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"cholesky_factor\" , & \"The matrix is not positive-definite.\" , LA_MATRIX_FORMAT_ERROR ) return end if ! Zero out the non-used upper or lower diagonal if ( uplo == 'U' ) then ! Zero out the lower do i = 1 , n - 1 a ( i + 1 : n , i ) = zero end do else ! Zero out the upper do i = 2 , n a ( 1 : i - 1 , i ) = zero end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_factor_cmplx ( a , upper , err ) !! Computes the Cholesky factorization of a symmetric, positive definite !! matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to factor.  On output, the factored !! matrix is returned in either the upper or lower triangular portion !! of the matrix, dependent upon the value of upper. logical , intent ( in ), optional :: upper !! An optional input that, if specified, provides control over whether !! the factorization is computed as A = U&#94;H U (set to true), or !! as A = L L&#94;H (set to false).  The default is true such that !! A = U&#94;H U. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables character :: uplo integer ( int32 ) :: i , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if else uplo = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_factor_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Process call ZPOTRF ( uplo , n , a , n , flag ) if ( flag > 0 ) then ! ERROR: Matrix is not positive definite call errmgr % report_error ( \"cholesky_factor_cmplx\" , & \"The matrix is not positive-definite.\" , LA_MATRIX_FORMAT_ERROR ) end if ! Zero out the non-used upper or lower diagonal if ( uplo == 'U' ) then ! Zero out the lower do i = 1 , n - 1 a ( i + 1 : n , i ) = zero end do else ! Zero out the upper do i = 2 , n a ( 1 : i - 1 , i ) = zero end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_update_dbl ( r , u , work , err ) !! Computes the rank 1 update to a Cholesky factored matrix A = R&#94;T R !! such that A_1 = A + \\vec{u} \\vec{u}&#94;T. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_update_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DCH1UP ( n , r , n , u , wptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_update_cmplx ( r , u , work , err ) !! Computes the rank 1 update to a Cholesky factored matrix A = R&#94;H R !! such that A_1 = A + \\vec{u} \\vec{u}&#94;H. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_update_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZCH1UP ( n , r , n , u , wptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_downdate_dbl ( r , u , work , err ) !! Computes the rank 1 downdate to a Cholesky factored matrix A = R&#94;T R !! such that A_1 = A - \\vec{u} \\vec{u}&#94;T.  This operation only works if !! the new matrix A_1 is positive definite. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_downdate_dbl\" , & errmgr , \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_downdate_dbl\" , errmgr , & \"u\" , n , size ( u )) end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_downdate_dbl\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_downdate_dbl\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DCH1DN ( n , r , n , u , wptr , flag ) if ( flag == 1 ) then ! ERROR: The matrix is not positive definite call errmgr % report_error ( \"cholesky_rank1_downdate\" , & \"The downdated matrix is not positive definite.\" , & LA_MATRIX_FORMAT_ERROR ) else if ( flag == 2 ) then ! ERROR: The matrix is singular call errmgr % report_error ( \"cholesky_rank1_downdate\" , & \"The input matrix is singular.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_downdate_cmplx ( r , u , work , err ) !! Computes the rank 1 downdate to a Cholesky factored matrix A = R&#94;H R !! such that A_1 = A - \\vec{u} \\vec{u}&#94;H.  This operation only works if !! the new matrix A_1 is positive definite. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_downdate_cmplx\" , & errmgr , \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_downdate_cmplx\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_downdate_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_downdate_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZCH1DN ( n , r , n , u , wptr , flag ) if ( flag == 1 ) then ! ERROR: The matrix is not positive definite call errmgr % report_error ( \"cholesky_rank1_downdate_cmplx\" , & \"The downdated matrix is not positive definite.\" , & LA_MATRIX_FORMAT_ERROR ) else if ( flag == 2 ) then ! ERROR: The matrix is singular call errmgr % report_error ( \"cholesky_rank1_downdate_cmplx\" , & \"The input matrix is singular.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_mtx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations A X = R&#94;T R X = B or !! A X = L L&#94;T X = B. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;T R; else, set !! to false if A is factored such that A = L L&#94;T. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS matrix B.  On output, the resulting !! N-by-NRHS matrix X. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_mtx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_cholesky_mtx\" , errmgr , \"b\" , & n , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Process call DPOTRS ( uplo , n , nrhs , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_mtx_cmplx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations A X = R&#94;H R X = B or !! A X = L L&#94;H X = B. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;H R; else, set !! to false if A is factored such that A = L L&#94;H. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS matrix B.  On output, the resulting !! N-by-NRHS matrix X. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_mtx_cmplx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_cholesky_mtx_cmplx\" , errmgr , \"b\" , & n , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Process call ZPOTRS ( uplo , n , nrhs , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_vec ( upper , a , b , err ) !! Solves the system of Cholesky factored equations !! A \\vec{x} = R&#94;T R \\vec{x} = \\vec{b} or !! A \\vec{x} = L L&#94;T \\vec{x} = \\vec{b}. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;T R; else, set !! to false if A is factored such that A = L L&#94;T. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the N-element vector \\vec{b}.  On output, the resulting !! N-element vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_vec\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_cholesky_vec\" , errmgr , \"b\" , & n , size ( b )) return end if ! Process call DPOTRS ( uplo , n , 1 , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_vec_cmplx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations !! A \\vec{x} = R&#94;H R \\vec{x} = \\vec{b} or !! A \\vec{x} = L L&#94;H \\vec{x} = \\vec{b}. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;H R; else, set !! to false if A is factored such that A = L L&#94;H. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the N-element vector \\vec{b}.  On output, the resulting !! N-element vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_vec_cmplx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_cholesky_vec_cmplx\" , errmgr , \"b\" , & n , size ( b )) return end if ! Process call ZPOTRS ( uplo , n , 1 , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_cholesky.f90.html"},{"title":"linalg_c_api.f90 – LINALG","text":"Contents Modules linalg_c_api Source Code linalg_c_api.f90 Source Code ! linalg_c_api.f90 !> @brief Provides a C-friendly API to the LINALG library.  Notice, all C-API !! LINALG routines begin with the prefix \"la_\". module linalg_c_api use iso_c_binding use linalg use ferror use linalg_errors implicit none contains ! ------------------------------------------------------------------------------ !> @brief Performs the rank-1 update to matrix A such that: !! A = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar, !! X is an M-element array, and N is an N-element array. !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in] alpha The scalar multiplier. !! @param[in] x An M-element array. !! @param[in] y An N-element array. !! @param[in,out] a On input, the M-by-N matrix to update.  On output, the !!  updated M-by-N matrix. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. function la_rank1_update ( m , n , alpha , x , y , a , lda ) & bind ( C , name = \"la_rank1_update\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( in ), value :: alpha real ( c_double ), intent ( in ) :: x ( * ), y ( * ) real ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Initialization flag = LA_NO_ERROR ! Input Checking if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call rank1_update ( alpha , x ( 1 : m ), y ( 1 : n ), a ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Performs the rank-1 update to matrix A such that: !! A = alpha * X * Y**T + A, where A is an M-by-N matrix, alpha is a scalar, !! X is an M-element array, and N is an N-element array. !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in] alpha The scalar multiplier. !! @param[in] x An M-element array. !! @param[in] y An N-element array. !! @param[in,out] a On input, the M-by-N matrix to update.  On output, the !!  updated M-by-N matrix. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. function la_rank1_update_cmplx ( m , n , alpha , x , y , a , lda ) & bind ( C , name = \"la_rank1_update_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( in ), value :: alpha complex ( c_double ), intent ( in ) :: x ( * ), y ( * ) complex ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Initialization flag = LA_NO_ERROR ! Input Checking if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call rank1_update ( alpha , x ( 1 : m ), y ( 1 : n ), a ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the trace of a matrix (the sum of the main diagonal !! elements). !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in] a The M-by-N matrix on which to operate. !! @param[in] lda The leading dimension of the matrix. !! @param[out] rst The results of the operation. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. function la_trace ( m , n , a , lda , rst ) bind ( C , name = \"la_trace\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: rst integer ( c_int ) :: flag ! Initialization flag = LA_NO_ERROR ! Input Checking if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process rst = trace ( a ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the trace of a matrix (the sum of the main diagonal !! elements). !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in] a The M-by-N matrix on which to operate. !! @param[in] lda The leading dimension of the matrix. !! @param[out] rst The results of the operation. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. function la_trace_cmplx ( m , n , a , lda , rst ) & bind ( C , name = \"la_trace_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: rst integer ( c_int ) :: flag ! Initialization flag = LA_NO_ERROR ! Input Checking if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process rst = trace ( a ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. !! !! @param transa Set to true to compute op(A) as the transpose of A; else, !!  set to false to compute op(A) as A. !! @param transb Set to true to compute op(B) as the transpose of B; else, !!  set to false to compute op(B) as B. !! @param m The number of rows in @p c. !! @param n The number of columns in @p c. !! @param k The interior dimension of the product @p a and @p b. !! @param alpha A scalar multiplier. !! @param a If @p transa is true, this matrix must be @p k by @p m; else, !!  if @p transa is false, this matrix must be @p m by @p k. !! @param lda The leading dimension of matrix @p a. !! @param b If @p transb is true, this matrix must be @p n by @p k; else, !!  if @p transb is false, this matrix must be @p k by @p n. !! @param ldb The leading dimension of matrix @p b. !! @param beta A scalar multiplier. !! @param c The @p m by @p n matrix C. !! @param ldc The leading dimension of matrix @p c. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldb, or @p ldc are not !!      correct. function la_mtx_mult ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & beta , c , ldc ) bind ( C , name = \"la_mtx_mult\" ) result ( flag ) ! Arugments logical ( c_bool ), intent ( in ), value :: transa , transb integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb , ldc real ( c_double ), intent ( in ), value :: alpha , beta real ( c_double ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) real ( c_double ), intent ( inout ) :: c ( ldc , * ) integer ( c_int ) :: flag ! Local Variables character :: ta , tb integer ( c_int ) :: nrowa , nrowb ! Initialization flag = LA_NO_ERROR ta = \"N\" if ( transa ) ta = \"T\" tb = \"N\" if ( transb ) tb = \"T\" if ( transa ) then nrowa = k else nrowa = m end if if ( transb ) then nrowb = n else nrowb = k end if ! Input Checking if ( lda < nrowa . or . ldb < nrowb . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Call DGEMM directly call DGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) end function ! ------------------------------------------------------------------------------ !> @brief Computes the matrix operation C = alpha * op(A) * op(B) + beta * C. !! !! @param opa Set to LA_TRANSPOSE to compute op(A) as a direct transpose of A, !!  set to  LA_HERMITIAN_TRANSPOSE to compute op(A) as the Hermitian transpose !!  of A, otherwise, set to NO_OPERATION to compute op(A) as A. !! @param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B, !!  set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose !!  of B, otherwise, set to NO_OPERATION to compute op(B) as B. !! @param mThe number of rows in @p c. !! @param n The number of columns in @p c. !! @param k The interior dimension of the product @p a and @p b. !! @param alpha A scalar multiplier. !! @param a If @p opa is LA_TRANSPOSE or  LA_HERMITIAN_TRANSPOSE, this matrix must !!  be @p k by @p m; else, this matrix must be @p m by @p k. !! @param lda The leading dimension of matrix @p a. !! @param b If @p opb is LA_TRANSPOSE or  LA_HERMITIAN_TRANSPOSE, this matrix must !!  be @p n by @p k; else, this matrix must be @p k by @p n. !! @param ldb The leading dimension of matrix @p b. !! @param beta A scalar multiplier. !! @param c The @p m by @p n matrix C. !! @param ldc The leading dimension of matrix @p c. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldb, or @p ldc are not !!      correct. function la_mtx_mult_cmplx ( opa , opb , m , n , k , alpha , a , lda , b , ldb , & beta , c , ldc ) bind ( C , name = \"la_mtx_mult_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: opa , opb , m , n , k , lda , ldb , ldc complex ( c_double ), intent ( in ), value :: alpha , beta complex ( c_double ), intent ( in ) :: a ( lda , * ), b ( ldb , * ) complex ( c_double ), intent ( inout ) :: c ( ldc , * ) integer ( c_int ) :: flag ! Local Variables character :: ta , tb integer ( c_int ) :: nrowa , nrowb ! Initialization flag = LA_NO_ERROR if ( opa == LA_TRANSPOSE ) then ta = \"T\" else if ( opa == LA_HERMITIAN_TRANSPOSE ) then ta = \"H\" else ta = \"N\" end if if ( opb == LA_TRANSPOSE ) then tb = \"T\" else if ( opb == LA_HERMITIAN_TRANSPOSE ) then tb = \"H\" else tb = \"N\" end if if ( opa == LA_TRANSPOSE . or . opa == LA_HERMITIAN_TRANSPOSE ) then nrowa = k else nrowa = m end if if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then nrowb = n else nrowb = k end if ! Input Checking if ( lda < nrowa . or . ldb < nrowb . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Call ZGEMM directly call ZGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ) end function ! ------------------------------------------------------------------------------ !> @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C, !! or C = alpha * op(B) * A + beta * C. !! !! @param lside Set to true to apply matrix A from the left; else, set !!  to false to apply matrix A from the left. !! @param trans Set to true if op(B) == B**T; else, set to false if !!  op(B) == B. !! @param m The number of rows in the matrix C. !! @param n The number of columns in the matrix C. !! @param k The inner dimension of the matrix product A * op(B). !! @param alpha A scalar multiplier. !! @param a A P-element array containing the diagonal elements of matrix A !!  where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k) !!  if @p lside is false. !! @param b The LDB-by-TDB matrix B where (LDB = leading dimension of B, !!  and TDB = trailing dimension of B): !!  - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k !!  - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n !!  - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m !!  - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k !! @param ldb The leading dimension of matrix B. !! @param beta A scalar multiplier. !! @param c The @p m by @p n matrix C. !! @param ldc The leading dimension of matrix C. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not !!      correct. !!  - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are !!      incorrect. function la_diag_mtx_mult ( lside , transb , m , n , k , alpha , a , b , ldb , & beta , c , ldc ) bind ( C , name = \"la_diag_mtx_mult\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: lside , transb integer ( c_int ), intent ( in ), value :: m , n , k , ldb , ldc real ( c_double ), intent ( in ), value :: alpha , beta real ( c_double ), intent ( in ) :: a ( * ), b ( ldb , * ) real ( c_double ), intent ( inout ) :: c ( ldc , * ) integer ( c_int ) :: flag ! Local Variabes integer ( c_int ) :: nrows , ncols , p logical :: ls , tb type ( errors ) :: err ! Initialization call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lside . and . transb ) then nrows = n ncols = k p = min ( k , m ) ls = . true . tb = . true . else if ( lside . and . . not . transb ) then nrows = k ncols = n p = min ( k , m ) ls = . true . tb = . false . else if (. not . lside . and . transb ) then nrows = k ncols = m p = min ( k , n ) ls = . false . tb = . true . else nrows = m ncols = k p = min ( k , n ) ls = . false . tb = . false . end if ! Error Checking if ( ldb < nrows . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call diag_mtx_mult ( ls , tb , alpha , a ( 1 : p ), b ( 1 : nrows , 1 : ncols ), & beta , c ( 1 : m , 1 : n ), err ) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C, !! or C = alpha * op(B) * A + beta * C. !! !! @param lside Set to true to apply matrix A from the left; else, set !!  to false to apply matrix A from the left. !! @param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B, !!  set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose !!  of B, otherwise, set to NO_OPERATION to compute op(B) as B. !! @param m The number of rows in the matrix C. !! @param n The number of columns in the matrix C. !! @param k The inner dimension of the matrix product A * op(B). !! @param alpha A scalar multiplier. !! @param a A P-element array containing the diagonal elements of matrix A !!  where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k) !!  if @p lside is false. !! @param b The LDB-by-TDB matrix B where (LDB = leading dimension of B, !!  and TDB = trailing dimension of B): !!  - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k !!  - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n !!  - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m !!  - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k !! @param ldb The leading dimension of matrix B. !! @param beta A scalar multiplier. !! @param c The @p m by @p n matrix C. !! @param ldc The leading dimension of matrix C. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not !!      correct. !!  - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are !!      incorrect. function la_diag_mtx_mult_mixed ( lside , opb , m , n , k , alpha , a , b , ldb , & beta , c , ldc ) bind ( C , name = \"la_diag_mtx_mult_mixed\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: lside integer ( c_int ), intent ( in ), value :: opb , m , n , k , ldb , ldc complex ( c_double ), intent ( in ), value :: alpha , beta real ( c_double ), intent ( in ) :: a ( * ) complex ( c_double ), intent ( in ) :: b ( ldb , * ) complex ( c_double ), intent ( inout ) :: c ( ldc , * ) integer ( c_int ) :: flag ! Local Variabes integer ( c_int ) :: nrows , ncols , p logical :: ls , tb type ( errors ) :: err ! Initialization call err % set_exit_on_error (. false .) flag = LA_NO_ERROR tb = . false . if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) tb = . true . if ( lside . and . tb ) then nrows = n ncols = k p = min ( k , m ) ls = . true . else if ( lside . and . . not . tb ) then nrows = k ncols = n p = min ( k , m ) ls = . true . else if (. not . lside . and . tb ) then nrows = k ncols = m p = min ( k , n ) ls = . false . else nrows = m ncols = k p = min ( k , n ) ls = . false . end if ! Error Checking if ( ldb < nrows . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call diag_mtx_mult ( ls , opb , alpha , a ( 1 : p ), b ( 1 : nrows , 1 : ncols ), & beta , c ( 1 : m , 1 : n )) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the matrix operation: C = alpha * A * op(B) + beta * C, !! or C = alpha * op(B) * A + beta * C. !! !! @param lside Set to true to apply matrix A from the left; else, set !!  to false to apply matrix A from the left. !! @param opb Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B, !!  set to  LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose !!  of B, otherwise, set to NO_OPERATION to compute op(B) as B. !! @param m The number of rows in the matrix C. !! @param n The number of columns in the matrix C. !! @param k The inner dimension of the matrix product A * op(B). !! @param alpha A scalar multiplier. !! @param a A P-element array containing the diagonal elements of matrix A !!  where P = MIN(@p m, @p k) if @p lside is true; else, P = MIN(@p n, @p k) !!  if @p lside is false. !! @param b The LDB-by-TDB matrix B where (LDB = leading dimension of B, !!  and TDB = trailing dimension of B): !!  - @p lside == true & @p trans == true: LDB = @p n, TDB = @p k !!  - @p lside == true & @p trans == false: LDB = @p k, TDB = @p n !!  - @p lside == false & @p trans == true: LDB = @p k, TDB = @p m !!  - @p lside == false & @p trans == false: LDB = @p m, TDB = @p k !! @param ldb The leading dimension of matrix B. !! @param beta A scalar multiplier. !! @param c The @p m by @p n matrix C. !! @param ldc The leading dimension of matrix C. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldb, or @p ldc are not !!      correct. !!  - LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are !!      incorrect. function la_diag_mtx_mult_cmplx ( lside , opb , m , n , k , alpha , a , b , & ldb , beta , c , ldc ) bind ( C , name = \"la_diag_mtx_mult_cmplx\" ) & result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: lside integer ( c_int ), intent ( in ), value :: opb , m , n , k , ldb , ldc complex ( c_double ), intent ( in ), value :: alpha , beta complex ( c_double ), intent ( in ) :: a ( * ), b ( ldb , * ) complex ( c_double ), intent ( inout ) :: c ( ldc , * ) integer ( c_int ) :: flag ! Local Variabes integer ( c_int ) :: nrows , ncols , p logical :: ls , tb type ( errors ) :: err ! Initialization call err % set_exit_on_error (. false .) flag = LA_NO_ERROR tb = . false . if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) tb = . true . if ( lside . and . tb ) then nrows = n ncols = k p = min ( k , m ) ls = . true . else if ( lside . and . . not . tb ) then nrows = k ncols = n p = min ( k , m ) ls = . true . else if (. not . lside . and . tb ) then nrows = k ncols = m p = min ( k , n ) ls = . false . else nrows = m ncols = k p = min ( k , n ) ls = . false . end if ! Error Checking if ( ldb < nrows . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call diag_mtx_mult ( ls , opb , alpha , a ( 1 : p ), b ( 1 : nrows , 1 : ncols ), & beta , c ( 1 : m , 1 : n )) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank of a matrix. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param a The M-by-N matrix.  The matrix is overwritten as part of this !!  operation. !! @param lda The leading dimension of matrix A. !! @param[out] rnk The rank of @p a. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process !!      could not converge to a zero value. function la_rank ( m , n , a , lda , rnk ) bind ( C , name = \"la_rank\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ), intent ( out ) :: rnk integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Input Check call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process rnk = mtx_rank ( a ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank of a matrix. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param a The M-by-N matrix.  The matrix is overwritten as part of this !!  operation. !! @param lda The leading dimension of matrix A. !! @param[out] rnk The rank of @p a. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process !!      could not converge to a zero value. function la_rank_cmplx ( m , n , a , lda , rnk ) bind ( C , name = \"la_rank_cmplx\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ), intent ( out ) :: rnk integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Input Check call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process rnk = mtx_rank ( a ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the determinant of a square matrix. !! !! @param n The dimension of the matrix. !! @param a The N-by-N matrix.  The matrix is overwritten on output. !! @param lda The leading dimension of the matrix. !! @param[out] d The determinant of @p a. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized !!      appropriately. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_det ( n , a , lda , d ) bind ( C , name = \"la_det\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: d integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process d = det ( a ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the determinant of a square matrix. !! !! @param n The dimension of the matrix. !! @param a The N-by-N matrix.  The matrix is overwritten on output. !! @param lda The leading dimension of the matrix. !! @param[out] d The determinant of @p a. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized !!      appropriately. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_det_cmplx ( n , a , lda , d ) bind ( C , name = \"la_det_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: d integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process d = det ( a ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) flag = err % get_error_flag () end function ! ------------------------------------------------------------------------------ !> @brief Computes the triangular matrix operation: !! B = alpha * A**T * A + beta * B, or B = alpha * A * A**T + beta * B, !! where A is a triangular matrix. !! !! @param upper Set to true if matrix A is upper triangular, and !!  B = alpha * A**T * A + beta * B is to be calculated; else, set to false !!  if A is lower triangular, and B = alpha * A * A**T + beta * B is to !!  be computed. !! @param alpha A scalar multiplier. !! @param n The dimension of the matrix. !! @param a The @p n by @p n triangular matrix A.  Notice, if @p upper is !!  true, only the upper triangular portion of this matrix is referenced; !!  else, if @p upper is false, only the lower triangular portion of this !!  matrix is referenced. !! @param lda The leading dimension of matrix A. !! @param beta A scalar multiplier. !! @param b On input, the @p n by @p n matrix B.  On output, the @p n by !!  @p n resulting matrix. !! @param ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldb are not correct. function la_tri_mtx_mult ( upper , alpha , n , a , lda , beta , b , ldb ) & bind ( C , name = \"la_tri_mtx_mult\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: n , lda , ldb real ( c_double ), intent ( in ), value :: alpha , beta real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Error Checking flag = LA_NO_ERROR if ( lda < n . or . ldb < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call tri_mtx_mult ( logical ( upper ), alpha , a ( 1 : n , 1 : n ), beta , b ( 1 : n , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the triangular matrix operation: !! B = alpha * A**T * A + beta * B, or B = alpha * A * A**T + beta * B, !! where A is a triangular matrix. !! !! @param upper Set to true if matrix A is upper triangular, and !!  B = alpha * A**T * A + beta * B is to be calculated; else, set to false !!  if A is lower triangular, and B = alpha * A * A**T + beta * B is to !!  be computed. !! @param alpha A scalar multiplier. !! @param n The dimension of the matrix. !! @param a The @p n by @p n triangular matrix A.  Notice, if @p upper is !!  true, only the upper triangular portion of this matrix is referenced; !!  else, if @p upper is false, only the lower triangular portion of this !!  matrix is referenced. !! @param lda The leading dimension of matrix A. !! @param beta A scalar multiplier. !! @param b On input, the @p n by @p n matrix B.  On output, the @p n by !!  @p n resulting matrix. !! @param ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldb are not correct. function la_tri_mtx_mult_cmplx ( upper , alpha , n , a , lda , beta , b , ldb ) & bind ( C , name = \"la_tri_mtx_mult_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: n , lda , ldb complex ( c_double ), intent ( in ), value :: alpha , beta complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Error Checking flag = LA_NO_ERROR if ( lda < n . or . ldb < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call tri_mtx_mult ( logical ( upper ), alpha , a ( 1 : n , 1 : n ), beta , b ( 1 : n , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the LU factorization of an M-by-N matrix. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix on which to operate.  On !! output, the LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. !! @param lda The leading dimension of matrix A. !! @param[out] ipvt An MIN(M, N)-element array used to track row-pivot !!  operations.  The array stored pivot information such that row I is !!  interchanged with row IPVT(I). !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if @p a is found to be !!      singular. function la_lu_factor ( m , n , a , lda , ipvt ) bind ( C , name = \"la_lu_factor\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ), intent ( out ) :: ipvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call lu_factor ( a ( 1 : m , 1 : n ), ipvt ( 1 : mn ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the LU factorization of an M-by-N matrix. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix on which to operate.  On !! output, the LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. !! @param lda The leading dimension of matrix A. !! @param[out] ipvt An MIN(M, N)-element array used to track row-pivot !!  operations.  The array stored pivot information such that row I is !!  interchanged with row IPVT(I). !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if @p a is found to be !!      singular. function la_lu_factor_cmplx ( m , n , a , lda , ipvt ) & bind ( C , name = \"la_lu_factor_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ), intent ( out ) :: ipvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call lu_factor ( a ( 1 : m , 1 : n ), ipvt ( 1 : mn ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Extracts the L, U, and P matrices from the LU factorization !! output from la_lu_factor. !! !! @param n The dimension of the input matrix. !! @param[in,out] a On input, the N-by-N matrix as output by !!  @ref la_lu_factor.  On output, the N-by-N lower triangular matrix L. !! @param lda The leading dimension of @p a. !! @param ipvt The N-element pivot array as output by !!  @ref la_lu_factor. !! @param[out] u An N-by-N matrix where the U matrix will be written. !! @param ldu The leading dimension of @p u. !! @param[out] p An N-by-N matrix where the row permutation matrix will be !!  written. !! @param ldp The leading dimension of @p p. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldp is not !!      correct. function la_form_lu ( n , a , lda , ipvt , u , ldu , p , ldp ) & bind ( C , name = \"la_form_lu\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda , ldu , ldp real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: u ( ldu , * ), p ( ldp , * ) integer ( c_int ), intent ( in ) :: ipvt ( * ) integer ( c_int ) :: flag ! Input Checking flag = LA_NO_ERROR if ( lda < n . or . ldu < n . or . ldp < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call form_lu ( a ( 1 : n , 1 : n ), ipvt ( 1 : n ), u ( 1 : n , 1 : n ), p ( 1 : n , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Extracts the L, U, and P matrices from the LU factorization !! output from la_lu_factor. !! !! @param n The dimension of the input matrix. !! @param[in,out] a On input, the N-by-N matrix as output by !!  @ref la_lu_factor.  On output, the N-by-N lower triangular matrix L. !! @param lda The leading dimension of @p a. !! @param ipvt The N-element pivot array as output by !!  @ref la_lu_factor. !! @param[out] u An N-by-N matrix where the U matrix will be written. !! @param ldu The leading dimension of @p u. !! @param[out] p An N-by-N matrix where the row permutation matrix will be !!  written. !! @param ldp The leading dimension of @p p. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldp is not !!      correct. function la_form_lu_cmplx ( n , a , lda , ipvt , u , ldu , p , ldp ) & bind ( C , name = \"la_form_lu_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda , ldu , ldp complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: u ( ldu , * ) real ( c_double ), intent ( out ) :: p ( ldp , * ) integer ( c_int ), intent ( in ) :: ipvt ( * ) integer ( c_int ) :: flag ! Input Checking flag = LA_NO_ERROR if ( lda < n . or . ldu < n . or . ldp < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call form_lu ( a ( 1 : n , 1 : n ), ipvt ( 1 : n ), u ( 1 : n , 1 : n ), p ( 1 : n , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Computes the QR factorization of an M-by-N matrix without !! pivoting. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a  On input, the M-by-N matrix to factor.  On output, the !!  elements on and above the diagonal contain the MIN(M, N)-by-N upper !!  trapezoidal matrix R (R is upper triangular if M >= N).  The elements !!  below the diagonal, along with the array @p tau, represent the !!  orthogonal matrix Q as a product of elementary reflectors. !! @param lda The leading dimension of matrix A. !! @param[out] tau A MIN(M, N)-element array used to store the scalar !!  factors of the elementary reflectors. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_factor ( m , n , a , lda , tau ) bind ( C , name = \"la_qr_factor\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the QR factorization of an M-by-N matrix without !! pivoting. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a  On input, the M-by-N matrix to factor.  On output, the !!  elements on and above the diagonal contain the MIN(M, N)-by-N upper !!  trapezoidal matrix R (R is upper triangular if M >= N).  The elements !!  below the diagonal, along with the array @p tau, represent the !!  orthogonal matrix Q as a product of elementary reflectors. !! @param lda The leading dimension of matrix A. !! @param[out] tau A MIN(M, N)-element array used to store the scalar !!  factors of the elementary reflectors. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_factor_cmplx ( m , n , a , lda , tau ) & bind ( C , name = \"la_qr_factor_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the QR factorization of an M-by-N matrix with column !! pivoting. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a  On input, the M-by-N matrix to factor.  On output, the !!  elements on and above the diagonal contain the MIN(M, N)-by-N upper !!  trapezoidal matrix R (R is upper triangular if M >= N).  The elements !!  below the diagonal, along with the array @p tau, represent the !!  orthogonal matrix Q as a product of elementary reflectors. !! @param lda The leading dimension of matrix A. !! @param[out] tau A MIN(M, N)-element array used to store the scalar !!  factors of the elementary reflectors. !! @param[in,out] jpvt On input, an N-element array that if JPVT(I) .ne. 0, !!  the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, !!  the I-th column of A is a free column.  On output, if JPVT(I) = K, then !!  the I-th column of A * P was the K-th column of A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_factor_pvt ( m , n , a , lda , tau , jpvt ) & bind ( C , name = \"la_qr_factor_pvt\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ), intent ( inout ) :: jpvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), jpvt ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the QR factorization of an M-by-N matrix with column !! pivoting. !! !! @param m The number of rows in the matrix. !! @param n The number of columns in the matrix. !! @param[in,out] a  On input, the M-by-N matrix to factor.  On output, the !!  elements on and above the diagonal contain the MIN(M, N)-by-N upper !!  trapezoidal matrix R (R is upper triangular if M >= N).  The elements !!  below the diagonal, along with the array @p tau, represent the !!  orthogonal matrix Q as a product of elementary reflectors. !! @param lda The leading dimension of matrix A. !! @param[out] tau A MIN(M, N)-element array used to store the scalar !!  factors of the elementary reflectors. !! @param[in,out] jpvt On input, an N-element array that if JPVT(I) .ne. 0, !!  the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, !!  the I-th column of A is a free column.  On output, if JPVT(I) = K, then !!  the I-th column of A * P was the K-th column of A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_factor_cmplx_pvt ( m , n , a , lda , tau , jpvt ) & bind ( C , name = \"la_qr_factor_cmplx_pvt\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ), intent ( inout ) :: jpvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), jpvt ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. !! !! @param[in] fullq Set to true to always return the full Q matrix; else, !!  set to false, and in the event that M > N, Q may be supplied as M-by-N, !!  and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the !!  factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] r On input, the M-by-N factored matrix as returned by the !!  QR factorization routine.  On output, the upper triangular matrix R. !! @param[in] ldr The leading dimension of matrix R. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  each elementary reflector defined in @p r. !! @param[out] q An M-by-M matrix where the full Q matrix will be written. !!  In the event that @p fullq is set to false, and M > N, this matrix need !!  only by M-by-N. !! @param[in] ldq The leading dimension of matrix Q. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_form_qr ( fullq , m , n , r , ldr , tau , q , ldq ) & bind ( C , name = \"la_form_qr\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: fullq integer ( c_int ), intent ( in ), value :: m , n , ldr , ldq real ( c_double ), intent ( inout ) :: r ( ldr , * ) real ( c_double ), intent ( in ) :: tau ( * ) real ( c_double ), intent ( out ) :: q ( ldq , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn , nq ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < m . or . ldq < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) nq = m if (. not . fullq ) nq = n call form_qr ( r ( 1 : m , 1 : n ), tau ( 1 : mn ), q ( 1 : m , 1 : nq ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. !! !! @param[in] fullq Set to true to always return the full Q matrix; else, !!  set to false, and in the event that M > N, Q may be supplied as M-by-N, !!  and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the !!  factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] r On input, the M-by-N factored matrix as returned by the !!  QR factorization routine.  On output, the upper triangular matrix R. !! @param[in] ldr The leading dimension of matrix R. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  each elementary reflector defined in @p r. !! @param[out] q An M-by-M matrix where the full Q matrix will be written. !!  In the event that @p fullq is set to false, and M > N, this matrix need !!  only by M-by-N. !! @param[in] ldq The leading dimension of matrix Q. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_form_qr_cmplx ( fullq , m , n , r , ldr , tau , q , ldq ) & bind ( C , name = \"la_form_qr_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: fullq integer ( c_int ), intent ( in ), value :: m , n , ldr , ldq complex ( c_double ), intent ( inout ) :: r ( ldr , * ) complex ( c_double ), intent ( in ) :: tau ( * ) complex ( c_double ), intent ( out ) :: q ( ldq , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn , nq ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < m . or . ldq < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) nq = m if (. not . fullq ) nq = n call form_qr ( r ( 1 : m , 1 : n ), tau ( 1 : mn ), q ( 1 : m , 1 : nq ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm.  This !! routine also inflates the pivot array into an N-by-N matrix P such !! that A * P = Q * R. !! !! @param[in] fullq Set to true to always return the full Q matrix; else, !!  set to false, and in the event that M > N, Q may be supplied as M-by-N, !!  and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the !!  factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] r On input, the M-by-N factored matrix as returned by the !!  QR factorization routine.  On output, the upper triangular matrix R. !! @param[in] ldr The leading dimension of matrix R. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  each elementary reflector defined in @p r. !! @param[in] pvt An N-element array containing the pivot information from !!  the QR factorization. !! @param[out] q An M-by-M matrix where the full Q matrix will be written. !!  In the event that @p fullq is set to false, and M > N, this matrix need !!  only by M-by-N. !! @param[in] ldq The leading dimension of matrix Q. !! @param[out] p An N-by-N matrix where the pivot matrix P will be written. !! @param[in] ldp The leading dimension of matrix P. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_form_qr_pvt ( fullq , m , n , r , ldr , tau , pvt , q , ldq , p , ldp ) & bind ( C , name = \"la_form_qr_pvt\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: fullq integer ( c_int ), intent ( in ), value :: m , n , ldr , ldq , ldp real ( c_double ), intent ( inout ) :: r ( ldr , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ), intent ( in ) :: pvt ( * ) real ( c_double ), intent ( out ) :: q ( ldq , * ), p ( ldp , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn , nq ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < m . or . ldq < m . or . ldp < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) nq = m if (. not . fullq ) nq = n call form_qr ( r ( 1 : m , 1 : n ), tau ( 1 : mn ), pvt ( 1 : n ), q ( 1 : m , 1 : nq ), p ( 1 : n , 1 : n ), & err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm.  This !! routine also inflates the pivot array into an N-by-N matrix P such !! that A * P = Q * R. !! !! @param[in] fullq Set to true to always return the full Q matrix; else, !!  set to false, and in the event that M > N, Q may be supplied as M-by-N, !!  and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the !!  factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] r On input, the M-by-N factored matrix as returned by the !!  QR factorization routine.  On output, the upper triangular matrix R. !! @param[in] ldr The leading dimension of matrix R. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  each elementary reflector defined in @p r. !! @param[in] pvt An N-element array containing the pivot information from !!  the QR factorization. !! @param[out] q An M-by-M matrix where the full Q matrix will be written. !!  In the event that @p fullq is set to false, and M > N, this matrix need !!  only by M-by-N. !! @param[in] ldq The leading dimension of matrix Q. !! @param[out] p An N-by-N matrix where the pivot matrix P will be written. !! @param[in] ldp The leading dimension of matrix P. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_form_qr_cmplx_pvt ( fullq , m , n , r , ldr , tau , pvt , q , ldq , p , & ldp ) bind ( C , name = \"la_form_qr_cmplx_pvt\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: fullq integer ( c_int ), intent ( in ), value :: m , n , ldr , ldq , ldp complex ( c_double ), intent ( inout ) :: r ( ldr , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ), intent ( in ) :: pvt ( * ) complex ( c_double ), intent ( out ) :: q ( ldq , * ), p ( ldp , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn , nq ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < m . or . ldq < m . or . ldp < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) nq = m if (. not . fullq ) nq = n call form_qr ( r ( 1 : m , 1 : n ), tau ( 1 : mn ), pvt ( 1 : n ), q ( 1 : m , 1 : nq ), p ( 1 : n , 1 : n ), & err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that: C = op(Q) * C, or C = C * op(Q). !! !! @param[in] lside Set to true to apply Q or Q**T from the left; else, set !!  to false to apply Q or Q**T from the right. !! @param[in] trans Set to true to apply Q**T; else, set to false. !! @param[in] m The number of rows in matrix C. !! @param[in] n The number of columns in matrix C. !! @param[in] k The number of elementary reflectors whose product defines !!  the matrix Q. !! @param[in] a On input, an LDA-by-K matrix containing the elementary !!  reflectors output from the QR factorization.  If @p lside is set to !!  true, LDA = M, and M >= K >= 0; else, if @p lside is set to false, !!  LDA = N, and N >= K >= 0.  Notice, the contents of this matrix are !!  restored on exit. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A K-element array containing the scalar factors of each !!  elementary reflector defined in @p a. !! @param[in,out] c On input, the M-by-N matrix C.  On output, the product !!  of the orthogonal matrix Q and the original matrix C. !! @param[in] ldc THe leading dimension of matrix C. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_mult_qr ( lside , trans , m , n , k , a , lda , tau , c , ldc ) & bind ( C , name = \"la_mult_qr\" ) result ( flag ) ! Local Variables logical ( c_bool ), intent ( in ), value :: lside , trans integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldc real ( c_double ), intent ( inout ) :: a ( lda , * ), c ( ldc , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma , na ! Initialization if ( lside ) then ma = m na = m else ma = n na = n end if ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if if ( k > na . or . k < 0 ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mult_qr ( logical ( lside ), logical ( trans ), a ( 1 : ma , 1 : k ), tau ( 1 : k ), & c ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that: C = op(Q) * C, or C = C * op(Q). !! !! @param[in] lside Set to true to apply Q or Q**H from the left; else, set !!  to false to apply Q or Q**H from the right. !! @param[in] trans Set to true to apply Q**H; else, set to false. !! @param[in] m The number of rows in matrix C. !! @param[in] n The number of columns in matrix C. !! @param[in] k The number of elementary reflectors whose product defines !!  the matrix Q. !! @param[in] a On input, an LDA-by-K matrix containing the elementary !!  reflectors output from the QR factorization.  If @p lside is set to !!  true, LDA = M, and M >= K >= 0; else, if @p lside is set to false, !!  LDA = N, and N >= K >= 0.  Notice, the contents of this matrix are !!  restored on exit. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A K-element array containing the scalar factors of each !!  elementary reflector defined in @p a. !! @param[in,out] c On input, the M-by-N matrix C.  On output, the product !!  of the orthogonal matrix Q and the original matrix C. !! @param[in] ldc THe leading dimension of matrix C. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_mult_qr_cmplx ( lside , trans , m , n , k , a , lda , tau , c , ldc ) & bind ( C , name = \"la_mult_qr_cmplx\" ) result ( flag ) ! Local Variables logical ( c_bool ), intent ( in ), value :: lside , trans integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldc complex ( c_double ), intent ( inout ) :: a ( lda , * ), c ( ldc , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma , na ! Initialization if ( lside ) then ma = m na = m else ma = n na = n end if ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma . or . ldc < m ) then flag = LA_INVALID_INPUT_ERROR return end if if ( k > na . or . k < 0 ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mult_qr ( logical ( lside ), logical ( trans ), a ( 1 : ma , 1 : k ), tau ( 1 : k ), & c ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 update to an M-by-N QR factored matrix A !! (M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. !! !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] q On input, the original M-by-K orthogonal matrix Q.  On !!  output, the updated matrix Q1. !! @param[in] ldq The leading dimension of matrix Q. !! @param[in,out] r On input, the M-by-N matrix R.  On output, the updated !!  matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the M-element U update vector.  On output, !!  the original content of the array is overwritten. !! @param[in,out] v On input, the N-element V update vector.  On output, !!  the original content of the array is overwritten. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldq or @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_rank1_update ( m , n , q , ldq , r , ldr , u , v ) & bind ( C , name = \"la_qr_rank1_update\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , ldq , ldr real ( c_double ), intent ( inout ) :: q ( ldq , * ), r ( ldr , * ), u ( * ), v ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldq < m . or . ldr < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_rank1_update ( q ( 1 : m , 1 : mn ), r ( 1 : m , 1 : n ), u ( 1 : m ), v ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 update to an M-by-N QR factored matrix A !! (M >= N) where A = Q * R, and A1 = A + U * V**T such that A1 = Q1 * R1. !! !! @param[in] m The number of rows in R. !! @param[in] n The number of columns in R. !! @param[in,out] q On input, the original M-by-K orthogonal matrix Q.  On !!  output, the updated matrix Q1. !! @param[in] ldq The leading dimension of matrix Q. !! @param[in,out] r On input, the M-by-N matrix R.  On output, the updated !!  matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the M-element U update vector.  On output, !!  the original content of the array is overwritten. !! @param[in,out] v On input, the N-element V update vector.  On output, !!  the original content of the array is overwritten. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldq or @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory !!      available. function la_qr_rank1_update_cmplx ( m , n , q , ldq , r , ldr , u , v ) & bind ( C , name = \"la_qr_rank1_update_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , ldq , ldr complex ( c_double ), intent ( inout ) :: q ( ldq , * ), r ( ldr , * ), u ( * ), v ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldq < m . or . ldr < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call qr_rank1_update ( q ( 1 : m , 1 : mn ), r ( 1 : m , 1 : n ), u ( 1 : m ), v ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the Cholesky factorization of a symmetric, positive !! definite matrix. !! !! @param[in] upper Set to true to compute the upper triangular factoriztion !!  A = U**T * U; else, set to false to compute the lower triangular !!  factorzation A = L * L**T. !! @param[in] n The dimension of matrix A. !! @param[in,out] a On input, the N-by-N matrix to factor.  On output, the !!  factored matrix is returned in either the upper or lower triangular !!  portion of the matrix, dependent upon the value of @p upper. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_MATRIX_FORMAT_ERROR: Occurs if @p a is not positive definite. function la_cholesky_factor ( upper , n , a , lda ) & bind ( C , name = \"la_cholesky_factor\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_factor ( a ( 1 : n , 1 : n ), logical ( upper ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the Cholesky factorization of a symmetric, positive !! definite matrix. !! !! @param[in] upper Set to true to compute the upper triangular factoriztion !!  A = U**H * U; else, set to false to compute the lower triangular !!  factorzation A = L * L**H. !! @param[in] n The dimension of matrix A. !! @param[in,out] a On input, the N-by-N matrix to factor.  On output, the !!  factored matrix is returned in either the upper or lower triangular !!  portion of the matrix, dependent upon the value of @p upper. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_MATRIX_FORMAT_ERROR: Occurs if @p a is not positive definite. function la_cholesky_factor_cmplx ( upper , n , a , lda ) & bind ( C , name = \"la_cholesky_factor_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_factor ( a ( 1 : n , 1 : n ), logical ( upper ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 update to a Cholesky factored matrix (upper !! triangular). !! !! @param[in] n The dimension of the matrix. !! @param[in,out] r On input, the N-by-N upper triangular matrix R.  On !!  output, the updated matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the N-element update vector U.  On output, !!  the rotation sines used to transform R to R1. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_cholesky_rank1_update ( n , r , ldr , u ) & bind ( C , name = \"la_cholesky_rank1_update\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , ldr real ( c_double ), intent ( inout ) :: r ( ldr , * ), u ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_rank1_update ( r ( 1 : n , 1 : n ), u ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 update to a Cholesky factored matrix (upper !! triangular). !! !! @param[in] n The dimension of the matrix. !! @param[in,out] r On input, the N-by-N upper triangular matrix R.  On !!  output, the updated matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the N-element update vector U.  On output, !!  the rotation sines used to transform R to R1. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_cholesky_rank1_update_cmplx ( n , r , ldr , u ) & bind ( C , name = \"la_cholesky_rank1_update_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , ldr complex ( c_double ), intent ( inout ) :: r ( ldr , * ), u ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_rank1_update ( r ( 1 : n , 1 : n ), u ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper !! triangular). !! !! @param[in] n The dimension of the matrix. !! @param[in,out] r On input, the N-by-N upper triangular matrix R.  On !!  output, the updated matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the N-element update vector U.  On output, !!  the rotation sines used to transform R to R1. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not !!      positive definite. function la_cholesky_rank1_downdate ( n , r , ldr , u ) & bind ( C , name = \"la_cholesky_rank1_downdate\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , ldr real ( c_double ), intent ( inout ) :: r ( ldr , * ), u ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_rank1_downdate ( r ( 1 : n , 1 : n ), u ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the rank 1 downdate to a Cholesky factored matrix (upper !! triangular). !! !! @param[in] n The dimension of the matrix. !! @param[in,out] r On input, the N-by-N upper triangular matrix R.  On !!  output, the updated matrix R1. !! @param[in] ldr The leading dimension of matrix R. !! @param[in,out] u On input, the N-element update vector U.  On output, !!  the rotation sines used to transform R to R1. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldr is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not !!      positive definite. function la_cholesky_rank1_downdate_cmplx ( n , r , ldr , u ) & bind ( C , name = \"la_cholesky_rank1_downdate_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , ldr complex ( c_double ), intent ( inout ) :: r ( ldr , * ), u ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldr < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call cholesky_rank1_downdate ( r ( 1 : n , 1 : n ), u ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the singular value decomposition of a matrix A.  The !!  SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal !!  matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal !!  matrix. !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix to factor.  The matrix is !!  overwritten on output. !! @param[in] lda The leading dimension of matrix A. !! @param[out] s A MIN(M, N)-element array containing the singular values !!  of @p a sorted in descending order. !! @param[out] u An M-by-M matrix where the orthogonal U matrix will be !!  written. !! @param[in] ldu The leading dimension of matrix U. !! @param[out] vt An N-by-N matrix where the transpose of the right !!  singular vector matrix V. !! @param[in] ldv The leading dimension of matrix V. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldv is not !!      correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process !!      could not converge to a zero value. function la_svd ( m , n , a , lda , s , u , ldu , vt , ldv ) & bind ( C , name = \"la_svd\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldu , ldv real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: s ( * ), u ( ldu , * ), vt ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldu < m . or . ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call svd ( a ( 1 : m , 1 : n ), s ( 1 : mn ), u ( 1 : m , 1 : m ), vt ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the singular value decomposition of a matrix A.  The !!  SVD is defined as: A = U * S * V**T, where U is an M-by-M orthogonal !!  matrix, S is an M-by-N diagonal matrix, and V is an N-by-N orthogonal !!  matrix. !! !! @param[in] m The number of rows in the matrix. !! @param[in] n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix to factor.  The matrix is !!  overwritten on output. !! @param[in] lda The leading dimension of matrix A. !! @param[out] s A MIN(M, N)-element array containing the singular values !!  of @p a sorted in descending order. !! @param[out] u An M-by-M matrix where the orthogonal U matrix will be !!  written. !! @param[in] ldu The leading dimension of matrix U. !! @param[out] vt An N-by-N matrix where the transpose of the right !!  singular vector matrix V. !! @param[in] ldv The leading dimension of matrix V. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, @p ldu, or @p ldv is not !!      correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process !!      could not converge to a zero value. function la_svd_cmplx ( m , n , a , lda , s , u , ldu , vt , ldv ) & bind ( C , name = \"la_svd_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldu , ldv complex ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: s ( * ) complex ( c_double ), intent ( out ) :: u ( ldu , * ), vt ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldu < m . or . ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process mn = min ( m , n ) call svd ( a ( 1 : m , 1 : n ), s ( 1 : mn ), u ( 1 : m , 1 : m ), vt ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves one of the matrix equations: op(A) * X = alpha * B, or !! X * op(A) = alpha * B, where A is a triangular matrix. !! !! @param[in] lside Set to true to solve op(A) * X = alpha * B; else, set to !!  false to solve X * op(A) = alpha * B. !! @param[in] upper Set to true if A is an upper triangular matrix; else, !!  set to false if A is a lower triangular matrix. !! @param[in] trans Set to true if op(A) = A**T; else, set to false if !!  op(A) = A. !! @param[in] nounit Set to true if A is not a unit-diagonal matrix (ones on !!  every diagonal element); else, set to false if A is a unit-diagonal !!  matrix. !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] alpha The scalar multiplier to B. !! @param[in] a If @p lside is true, the M-by-M triangular matrix on which !!  to operate; else, if @p lside is false, the N-by-N triangular matrix on !!  which to operate. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b On input, the M-by-N right-hand-side.  On output, the !!  M-by-N solution. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_tri_mtx ( lside , upper , trans , nounit , m , n , alpha , a , & lda , b , ldb ) bind ( C , name = \"la_solve_tri_mtx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: lside , upper , trans , nounit integer ( c_int ), intent ( in ), value :: m , n , lda , ldb real ( c_double ), intent ( in ), value :: alpha real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization if ( lside ) then ma = m else ma = n end if ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_triangular_system ( logical ( lside ), logical ( upper ), & logical ( trans ), logical ( nounit ), alpha , a ( 1 : ma , 1 : ma ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves one of the matrix equations: op(A) * X = alpha * B, or !! X * op(A) = alpha * B, where A is a triangular matrix. !! !! @param[in] lside Set to true to solve op(A) * X = alpha * B; else, set to !!  false to solve X * op(A) = alpha * B. !! @param[in] upper Set to true if A is an upper triangular matrix; else, !!  set to false if A is a lower triangular matrix. !! @param[in] trans Set to true if op(A) = A**H; else, set to false if !!  op(A) = A. !! @param[in] nounit Set to true if A is not a unit-diagonal matrix (ones on !!  every diagonal element); else, set to false if A is a unit-diagonal !!  matrix. !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] alpha The scalar multiplier to B. !! @param[in] a If @p lside is true, the M-by-M triangular matrix on which !!  to operate; else, if @p lside is false, the N-by-N triangular matrix on !!  which to operate. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b On input, the M-by-N right-hand-side.  On output, the !!  M-by-N solution. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_tri_mtx_cmplx ( lside , upper , trans , nounit , m , n , & alpha , a , lda , b , ldb ) & bind ( C , name = \"la_solve_tri_mtx_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: lside , upper , trans , nounit integer ( c_int ), intent ( in ), value :: m , n , lda , ldb complex ( c_double ), intent ( in ), value :: alpha complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization if ( lside ) then ma = m else ma = n end if ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_triangular_system ( logical ( lside ), logical ( upper ), & logical ( trans ), logical ( nounit ), alpha , a ( 1 : ma , 1 : ma ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of LU-factored equations. !! !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] a The M-by-M LU factored matrix. !! @param[in] lda The leading dimension of matrix A. !! @param[in] ipvt The M-element pivot array from the LU factorization. !! @param[in,out] b On input, the M-by-N right-hand-side.  On output, the !!  M-by-N solution. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_lu ( m , n , a , lda , ipvt , b , ldb ) & bind ( C , name = \"la_solve_lu\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldb real ( c_double ), intent ( in ) :: a ( lda , * ) integer ( c_int ), intent ( in ) :: ipvt ( * ) real ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_lu ( a ( 1 : m , 1 : m ), ipvt ( 1 : m ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of LU-factored equations. !! !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] a The M-by-M LU factored matrix. !! @param[in] lda The leading dimension of matrix A. !! @param[in] ipvt The M-element pivot array from the LU factorization. !! @param[in,out] b On input, the M-by-N right-hand-side.  On output, the !!  M-by-N solution. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_lu_cmplx ( m , n , a , lda , ipvt , b , ldb ) & bind ( C , name = \"la_solve_lu_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldb complex ( c_double ), intent ( in ) :: a ( lda , * ) integer ( c_int ), intent ( in ) :: ipvt ( * ) complex ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_lu ( a ( 1 : m , 1 : m ), ipvt ( 1 : m ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of M QR-factored equations of N unknowns where !! M >= N. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N QR factored matrix as returned by !!  qr_factor.  On output, the contents of this matrix are restored. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  the elementary reflectors as returned by qr_factor. !! @param[in,out] b On input, the M-by-K right-hand-side matrix.  On output, !!  the first N rows are overwritten by the solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct, or !!      if @p m is less than @p n. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_solve_qr ( m , n , k , a , lda , tau , b , ldb ) & bind ( C , name = \"la_solve_qr\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb real ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: minmn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m . or . m < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process minmn = min ( m , n ) call solve_qr ( a ( 1 : m , 1 : n ), tau ( 1 : minmn ), b ( 1 : m , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of M QR-factored equations of N unknowns where !! M >= N. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N QR factored matrix as returned by !!  qr_factor.  On output, the contents of this matrix are restored. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  the elementary reflectors as returned by qr_factor. !! @param[in,out] b On input, the M-by-K right-hand-side matrix.  On output, !!  the first N rows are overwritten by the solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct, or !!      if @p m is less than @p n. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_solve_qr_cmplx ( m , n , k , a , lda , tau , b , ldb ) & bind ( C , name = \"la_solve_qr_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb complex ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: minmn ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m . or . m < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process minmn = min ( m , n ) call solve_qr ( a ( 1 : m , 1 : n ), tau ( 1 : minmn ), b ( 1 : m , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of M QR-factored equations of N unknowns. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N QR factored matrix as returned by !!  qr_factor.  On output, the contents of this matrix are restored. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  the elementary reflectors as returned by qr_factor. !! @param[in] jpvt The N-element array that was used to track the column !!  pivoting operations in the QR factorization. !! @param[in,out] b On input, the M-by-K right-hand-side matrix.  On output, !!  the first N rows are overwritten by the solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_solve_qr_pvt ( m , n , k , a , lda , tau , jpvt , b , ldb ) & bind ( C , name = \"la_solve_qr_pvt\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb real ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ), intent ( in ) :: jpvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: minmn , maxmn ! Error Checking minmn = min ( m , n ) maxmn = max ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < maxmn ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_qr ( a ( 1 : m , 1 : n ), tau ( 1 : minmn ), jpvt ( 1 : n ), b ( 1 : maxmn , 1 : k ), & err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of M QR-factored equations of N unknowns. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N QR factored matrix as returned by !!  qr_factor.  On output, the contents of this matrix are restored. !! @param[in] lda The leading dimension of matrix A. !! @param[in] tau A MIN(M, N)-element array containing the scalar factors of !!  the elementary reflectors as returned by qr_factor. !! @param[in] jpvt The N-element array that was used to track the column !!  pivoting operations in the QR factorization. !! @param[in,out] b On input, the M-by-K right-hand-side matrix.  On output, !!  the first N rows are overwritten by the solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_solve_qr_cmplx_pvt ( m , n , k , a , lda , tau , jpvt , b , ldb ) & bind ( C , name = \"la_solve_qr_cmplx_pvt\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb complex ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ), intent ( in ) :: jpvt ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: minmn , maxmn ! Error Checking minmn = min ( m , n ) maxmn = max ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < maxmn ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_qr ( a ( 1 : m , 1 : n ), tau ( 1 : minmn ), jpvt ( 1 : n ), b ( 1 : maxmn , 1 : k ), & err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of Cholesky factored equations. !! !! @param[in] upper Set to true if the original matrix A was factored such !!  that A = U**T * U; else, set to false if the factorization of A was !!  A = L**T * L. !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] a The M-by-M Cholesky factored matrix. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b On input, the M-by-N right-hand-side matrix B.  On !!  output, the M-by-N solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_cholesky ( upper , m , n , a , lda , b , ldb ) & bind ( C , name = \"la_solve_cholesky\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: m , n , lda , ldb real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_cholesky ( logical ( upper ), a ( 1 : m , 1 : m ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves a system of Cholesky factored equations. !! !! @param[in] upper Set to true if the original matrix A was factored such !!  that A = U**T * U; else, set to false if the factorization of A was !!  A = L**T * L. !! @param[in] m The number of rows in matrix B. !! @param[in] n The number of columns in matrix B. !! @param[in] a The M-by-M Cholesky factored matrix. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b On input, the M-by-N right-hand-side matrix B.  On !!  output, the M-by-N solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. function la_solve_cholesky_cmplx ( upper , m , n , a , lda , b , ldb ) & bind ( C , name = \"la_solve_cholesky_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: upper integer ( c_int ), intent ( in ), value :: m , n , lda , ldb complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( inout ) :: b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_cholesky ( logical ( upper ), a ( 1 : m , 1 : m ), b ( 1 : m , 1 : n )) end function ! ------------------------------------------------------------------------------ !> @brief Solves the overdetermined or underdetermined system (A*X = B) of !! M equations of N unknowns using a QR or LQ factorization of the matrix A. !! Notice, it is assumed that matrix A has full rank. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N matrix A.  On output, if M >= N, !!  the QR factorization of A in the form as output by qr_factor; else, !!  if M < N, the LQ factorization of A. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b If M >= N, the M-by-NRHS matrix B.  On output, the first !!  N rows contain the N-by-NRHS solution matrix X.  If M < N, an !!  N-by-NRHS matrix with the first M rows containing the matrix B.  On !!  output, the N-by-NRHS solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_INVALID_OPERATION_ERROR: Occurs if @p a is not of full rank. function la_solve_least_squares ( m , n , k , a , lda , b , ldb ) & bind ( C , name = \"la_solve_least_squares\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb real ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: maxmn ! Error Checking maxmn = max ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < maxmn ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_least_squares ( a ( 1 : m , 1 : n ), b ( 1 : maxmn , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Solves the overdetermined or underdetermined system (A*X = B) of !! M equations of N unknowns using a QR or LQ factorization of the matrix A. !! Notice, it is assumed that matrix A has full rank. !! !! @param[in] m The number of equations (rows in matrix A). !! @param[in] n The number of unknowns (columns in matrix A). !! @param[in] k The number of columns in the right-hand-side matrix. !! @param[in,out] a On input, the M-by-N matrix A.  On output, if M >= N, !!  the QR factorization of A in the form as output by qr_factor; else, !!  if M < N, the LQ factorization of A. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b If M >= N, the M-by-NRHS matrix B.  On output, the first !!  N rows contain the N-by-NRHS solution matrix X.  If M < N, an !!  N-by-NRHS matrix with the first M rows containing the matrix B.  On !!  output, the N-by-NRHS solution matrix X. !! @param[in] ldb The leading dimension of matrix B. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldb is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_INVALID_OPERATION_ERROR: Occurs if @p a is not of full rank. function la_solve_least_squares_cmplx ( m , n , k , a , lda , b , ldb ) & bind ( C , name = \"la_solve_least_squares_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb complex ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: maxmn ! Error Checking maxmn = max ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < maxmn ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_least_squares ( a ( 1 : m , 1 : n ), b ( 1 : maxmn , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the inverse of a square matrix. !! !! @param[in] n The dimension of matrix A. !! @param[in,out] a On input, the N-by-N matrix to invert.  On output, the !!  inverted matrix. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. function la_inverse ( n , a , lda ) bind ( C , name = \"la_inverse\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mtx_inverse ( a ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the inverse of a square matrix. !! !! @param[in] n The dimension of matrix A. !! @param[in,out] a On input, the N-by-N matrix to invert.  On output, the !!  inverted matrix. !! @param[in] lda The leading dimension of matrix A. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. function la_inverse_cmplx ( n , a , lda ) bind ( C , name = \"la_inverse_cmplx\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mtx_inverse ( a ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by !! means of singular value decomposition. !! !! @param[in] m The number of rows in the matrix. !! @parma[in] n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix to invert.  The matrix is !!  overwritten on output. !! @param[in] lda The leading dimension of matrix A. !! @param[out] ainv The N-by-M matrix where the pseudo-inverse of @p a !!  will be written. !! @param[in] ldai The leading dimension of matrix AINV. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldai is not correct. function la_pinverse ( m , n , a , lda , ainv , ldai ) & bind ( C , name = \"la_pinverse\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldai real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: ainv ( ldai , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldai < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mtx_pinverse ( a ( 1 : m , 1 : n ), ainv ( 1 : n , 1 : m ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by !! means of singular value decomposition. !! !! @param[in] m The number of rows in the matrix. !! @parma[in] n The number of columns in the matrix. !! @param[in,out] a On input, the M-by-N matrix to invert.  The matrix is !!  overwritten on output. !! @param[in] lda The leading dimension of matrix A. !! @param[out] ainv The N-by-M matrix where the pseudo-inverse of @p a !!  will be written. !! @param[in] ldai The leading dimension of matrix AINV. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda, or @p ldai is not correct. function la_pinverse_cmplx ( m , n , a , lda , ainv , ldai ) & bind ( C , name = \"la_pinverse_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda , ldai complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: ainv ( ldai , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldai < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mtx_pinverse ( a ( 1 : m , 1 : n ), ainv ( 1 : n , 1 : m ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the eigenvalues, and optionally the eigenvectors of a !! real, symmetric matrix. !! !! @param[in] vecs Set to true to compute the eigenvectors as well as the !!  eigenvalues; else, set to false to just compute the eigenvalues. !! @param[in] n The dimension of the matrix. !! @param[in,out] a On input, the N-by-N symmetric matrix on which to !!  operate.  On output, and if @p vecs is set to true, the matrix will !!  contain the eigenvectors (one per column) corresponding to each !!  eigenvalue in @p vals.  If @p vecs is set to false, the lower triangular !!  portion of the matrix is overwritten. !! @param[in] lda The leading dimension of matrix A. !! @param[out] vals An N-element array that will contain the eigenvalues !!  sorted into ascending order. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. function la_eigen_symm ( vecs , n , a , lda , vals ) & bind ( C , name = \"la_eigen_symm\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: vecs integer ( c_int ), intent ( in ), value :: n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: vals ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call eigen ( logical ( vecs ), a ( 1 : n , 1 : n ), vals ( 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the eigenvalues, and optionally the right eigenvectors of !! a square matrix. !! !! @param[in] vecs Set to true to compute the eigenvectors as well as the !!  eigenvalues; else, set to false to just compute the eigenvalues. !! @param[in] n The dimension of the matrix. !! @param[in,out] a On input, the N-by-N matrix on which to operate.  On !!  output, the contents of this matrix are overwritten. !! @param[in] lda The leading dimension of matrix A. !! @param[out] vals An N-element array containing the eigenvalues of the !!  matrix.  The eigenvalues are not sorted. !! @param[out] v An N-by-N matrix where the right eigenvectors will be !!  written (one per column). !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. function la_eigen_asymm ( vecs , n , a , lda , vals , v , ldv ) & bind ( C , name = \"la_eigen_asymm\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: vecs integer ( c_int ), intent ( in ), value :: n , lda , ldv real ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: vals ( * ), v ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( vecs ) then if ( lda < n . or . ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if else if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if end if ! Process if ( vecs ) then call eigen ( a ( 1 : n , 1 : n ), vals ( 1 : n ), v ( 1 : n , 1 : n ), err = err ) else call eigen ( a ( 1 : n , 1 : n ), vals ( 1 : n )) end if if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the eigenvalues, and optionally the right eigenvectors of !! a square matrix assuming the structure of the eigenvalue problem is !! A*X = lambda*B*X. !! !! @param[in] vecs Set to true to compute the eigenvectors as well as the !!  eigenvalues; else, set to false to just compute the eigenvalues. !! @param[in] n The dimension of the matrix. !! @param[in,out] a On input, the N-by-N matrix A.  On output, the contents !!  of this matrix are overwritten. !! @param[in] lda The leading dimension of matrix A. !! @param[in,out] b On input, the N-by-N matrix B.  On output, the contents !!  of this matrix are overwritten. !! @param[in] ldb The leading dimension of matrix B. !! @param[out] alpha An N-element array that, if @p beta is not supplied, !!  contains the eigenvalues.  If @p beta is supplied however, the !!  eigenvalues must be computed as ALPHA / BETA.  This however, is not as !!  trivial as it seems as it is entirely possible, and likely, that !!  ALPHA / BETA can overflow or underflow.  With that said, the values in !!  ALPHA will always be less than and usually comparable with the NORM(A). !! @param[out] beta An optional N-element array that if provided forces !!  @p alpha to return the numerator, and this array contains the !!  denominator used to determine the eigenvalues as ALPHA / BETA.  If used, !!  the values in this array will always be less than and usually comparable !!  with the NORM(B). !! @param[out] v An N-by-N matrix where the right eigenvectors will be !!  written (one per column). !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. function la_eigen_gen ( vecs , n , a , lda , b , ldb , alpha , beta , v , ldv ) & bind ( C , name = \"la_eigen_gen\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: vecs integer ( c_int ), intent ( in ), value :: n , lda , ldb , ldv real ( c_double ), intent ( inout ) :: a ( lda , * ), b ( ldb , * ) real ( c_double ), intent ( out ) :: beta ( * ) complex ( c_double ), intent ( out ) :: alpha ( * ), v ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( vecs ) then if ( lda < n . or . ldb < n . or . ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if else if ( lda < n . or . ldb < n ) then flag = LA_INVALID_INPUT_ERROR return end if end if ! Process if ( vecs ) then call eigen ( a ( 1 : n , 1 : n ), b ( 1 : n , 1 : n ), alpha ( 1 : n ), beta ( 1 : n ), & v ( 1 : n , 1 : n ), err = err ) else call eigen ( a ( 1 : n , 1 : n ), b ( 1 : n , 1 : n ), alpha ( 1 : n ), beta ( 1 : n ), err = err ) end if if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief Computes the eigenvalues, and optionally the right eigenvectors of !! a square matrix. !! !! @param[in] vecs Set to true to compute the eigenvectors as well as the !!  eigenvalues; else, set to false to just compute the eigenvalues. !! @param[in] n The dimension of the matrix. !! @param[in,out] a On input, the N-by-N matrix on which to operate.  On !!  output, the contents of this matrix are overwritten. !! @param[in] lda The leading dimension of matrix A. !! @param[out] vals An N-element array containing the eigenvalues of the !!  matrix.  The eigenvalues are not sorted. !! @param[out] v An N-by-N matrix where the right eigenvectors will be !!  written (one per column). !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p lda or @p ldv is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. !!  - LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. function la_eigen_cmplx ( vecs , n , a , lda , vals , v , ldv ) & bind ( C , name = \"la_eigen_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: vecs integer ( c_int ), intent ( in ), value :: n , lda , ldv complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: vals ( * ), v ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( vecs ) then if ( lda < n . or . ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if else if ( lda < n ) then flag = LA_INVALID_INPUT_ERROR return end if end if ! Process if ( vecs ) then call eigen ( a ( 1 : n , 1 : n ), vals ( 1 : n ), v ( 1 : n , 1 : n ), err = err ) else call eigen ( a ( 1 : n , 1 : n ), vals ( 1 : n )) end if if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief A sorting routine specifically tailored for sorting of eigenvalues !! and their associated eigenvectors using a quick-sort approach. !! !! @param[in] ascend !! @param[in] n The number of eigenvalues. !! @param[in,out] vals On input, an N-element array containing the !!  eigenvalues.  On output, the sorted eigenvalues. !! @param[in,out] vecs On input, an N-by-N matrix containing the !!  eigenvectors associated with @p vals (one vector per column).  On !!  output, the sorted eigenvector matrix. !! @param[in] ldv The leading dimension of @p vecs. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldv is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_sort_eigen ( ascend , n , vals , vecs , ldv ) & bind ( C , name = \"la_sort_eigen\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: ascend integer ( c_int ), intent ( in ), value :: n , ldv real ( c_double ), intent ( inout ) :: vals ( * ), vecs ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call sort ( vals ( 1 : n ), vecs ( 1 : n , 1 : n ), logical ( ascend ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ !> @brief A sorting routine specifically tailored for sorting of eigenvalues !! and their associated eigenvectors using a quick-sort approach. !! !! @param[in] ascend !! @param[in] n The number of eigenvalues. !! @param[in,out] vals On input, an N-element array containing the !!  eigenvalues.  On output, the sorted eigenvalues. !! @param[in,out] vecs On input, an N-by-N matrix containing the !!  eigenvectors associated with @p vals (one vector per column).  On !!  output, the sorted eigenvector matrix. !! @param[in] ldv The leading dimension of @p vecs. !! !! @return An error code.  The following codes are possible. !!  - LA_NO_ERROR: No error occurred.  Successful operation. !!  - LA_INVALID_INPUT_ERROR: Occurs if @p ldv is not correct. !!  - LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and !!      there is insufficient memory available. function la_sort_eigen_cmplx ( ascend , n , vals , vecs , ldv ) & bind ( C , name = \"la_sort_eigen_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: ascend integer ( c_int ), intent ( in ), value :: n , ldv complex ( c_double ), intent ( inout ) :: vals ( * ), vecs ( ldv , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err ! Error Checking call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldv < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call sort ( vals ( 1 : n ), vecs ( 1 : n , 1 : n ), logical ( ascend ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_lq_factor ( m , n , a , lda , tau ) bind ( C , name = \"la_lq_factor\" ) & result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call lq_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_lq_factor_cmplx ( m , n , a , lda , tau ) & bind ( C , name = \"la_lq_factor_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , lda complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( out ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call lq_factor ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_form_lq ( m , n , l , ldl , tau , q , ldq ) & bind ( C , name = \"la_form_lq\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , ldl , ldq real ( c_double ), intent ( inout ) :: l ( ldl , * ) real ( c_double ), intent ( in ) :: tau ( * ) real ( c_double ), intent ( out ) :: q ( ldq , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) flag = LA_NO_ERROR if ( ldl < m . or . ldq < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call form_lq ( l ( 1 : m , 1 : n ), tau ( 1 : mn ), q ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_form_lq_cmplx ( m , n , l , ldl , tau , q , ldq ) & bind ( C , name = \"la_form_lq_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , ldl , ldq complex ( c_double ), intent ( inout ) :: l ( ldl , * ) complex ( c_double ), intent ( in ) :: tau ( * ) complex ( c_double ), intent ( out ) :: q ( ldq , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) flag = LA_NO_ERROR if ( ldl < m . or . ldq < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call form_lq ( l ( 1 : m , 1 : n ), tau ( 1 : mn ), q ( 1 : n , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_mult_lq ( lside , trans , m , n , k , a , lda , tau , c , ldc ) & bind ( C , name = \"la_mult_lq\" ) result ( flag ) ! Local Variables logical ( c_bool ), intent ( in ), value :: lside , trans integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldc real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( inout ) :: c ( ldc , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lside ) then ma = m else ma = n end if if ( lda < k . or . ldc < m . or . k < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mult_lq ( logical ( lside ), logical ( trans ), a ( 1 : k , 1 : ma ), tau ( 1 : k ), & c ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_mult_lq_cmplx ( lside , trans , m , n , k , a , lda , tau , c , ldc ) & bind ( C , name = \"la_mult_lq_cmplx\" ) result ( flag ) ! Local Variables logical ( c_bool ), intent ( in ), value :: lside , trans integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldc complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( inout ) :: c ( ldc , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lside ) then ma = m else ma = n end if if ( lda < k . or . ldc < m . or . k < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call mult_lq ( logical ( lside ), logical ( trans ), a ( 1 : k , 1 : ma ), tau ( 1 : k ), & c ( 1 : m , 1 : n ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_solve_lq ( m , n , k , a , lda , tau , b , ldb ) & bind ( C , name = \"la_solve_lq\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb real ( c_double ), intent ( in ) :: a ( lda , * ) real ( c_double ), intent ( inout ) :: b ( ldb , * ) real ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_lq ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), b ( 1 : n , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_solve_lq_cmplx ( m , n , k , a , lda , tau , b , ldb ) & bind ( C , name = \"la_solve_lq_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , k , lda , ldb complex ( c_double ), intent ( in ) :: a ( lda , * ) complex ( c_double ), intent ( inout ) :: b ( ldb , * ) complex ( c_double ), intent ( in ) :: tau ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: mn ! Initialization mn = min ( m , n ) call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < m . or . ldb < n ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call solve_lq ( a ( 1 : m , 1 : n ), tau ( 1 : mn ), b ( 1 : n , 1 : k ), err = err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_mtx_vec_mult ( trans , m , n , kl , ku , alpha , a , lda , x , beta , y ) & bind ( C , name = \"la_band_mtx_vec_mult\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: trans integer ( c_int ), intent ( in ), value :: m , n , kl , ku , lda real ( c_double ), intent ( in ), value :: alpha , beta real ( c_double ), intent ( in ) :: a ( lda , * ), x ( * ) real ( c_double ), intent ( inout ) :: y ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: nx , ny , ma ! Initialization ma = kl + ku + 1 if ( trans ) then nx = m ny = n else nx = n ny = m end if call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_mtx_mult ( logical ( trans ), kl , ku , alpha , a ( 1 : ma , 1 : n ), x ( 1 : nx ), & beta , y ( 1 : ny ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_mtx_vec_mult_cmplx ( trans , m , n , kl , ku , alpha , a , lda , x , & beta , y ) bind ( C , name = \"la_band_mtx_vec_mult_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: trans , m , n , kl , ku , lda complex ( c_double ), intent ( in ), value :: alpha , beta complex ( c_double ), intent ( in ) :: a ( lda , * ), x ( * ) complex ( c_double ), intent ( inout ) :: y ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: nx , ny , ma ! Initialization ma = kl + ku + 1 if ( trans == LA_TRANSPOSE . or . trans == LA_HERMITIAN_TRANSPOSE ) then nx = m ny = n else nx = n ny = m end if call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_mtx_mult ( trans , kl , ku , alpha , a ( 1 : ma , 1 : n ), x ( 1 : nx ), beta , y ( 1 : ny ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_to_full_mtx ( m , n , kl , ku , b , ldb , f , ldf ) & bind ( C , name = \"la_band_to_full_mtx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , kl , ku , ldb , ldf real ( c_double ), intent ( in ) :: b ( ldb , * ) real ( c_double ), intent ( out ) :: f ( ldf , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization ma = kl + ku + 1 call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldb < ma ) then flag = LA_INVALID_INPUT_ERROR return end if if ( ldf < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_mtx_to_full_mtx ( kl , ku , b ( 1 : ma , 1 : n ), f ( 1 : m , 1 : n ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_to_full_mtx_cmplx ( m , n , kl , ku , b , ldb , f , ldf ) & bind ( C , name = \"la_band_to_full_mtx_cmplx\" ) result ( flag ) ! Arguments integer ( c_int ), intent ( in ), value :: m , n , kl , ku , ldb , ldf complex ( c_double ), intent ( in ) :: b ( ldb , * ) complex ( c_double ), intent ( out ) :: f ( ldf , * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma ! Initialization ma = kl + ku + 1 call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( ldb < ma ) then flag = LA_INVALID_INPUT_ERROR return end if if ( ldf < m ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_mtx_to_full_mtx ( kl , ku , b ( 1 : ma , 1 : n ), f ( 1 : m , 1 : n ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_diag_mtx_mult ( left , m , n , kl , ku , alpha , a , lda , b ) & bind ( C , name = \"la_band_diag_mtx_mult\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: left integer ( c_int ), intent ( in ), value :: m , n , kl , ku , lda real ( c_double ), intent ( in ), value :: alpha real ( c_double ), intent ( inout ) :: a ( lda , * ) real ( c_double ), intent ( in ) :: b ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma , nb ! Initialization ma = kl + ku + 1 if ( left ) then nb = n else nb = m end if call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_diag_mtx_mult ( logical ( left ), m , kl , ku , alpha , a ( 1 : ma , 1 : n ), & b ( 1 : nb ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ function la_band_diag_mtx_mult_cmplx ( left , m , n , kl , ku , alpha , a , lda , b ) & bind ( C , name = \"la_band_diag_mtx_mult_cmplx\" ) result ( flag ) ! Arguments logical ( c_bool ), intent ( in ), value :: left integer ( c_int ), intent ( in ), value :: m , n , kl , ku , lda complex ( c_double ), intent ( in ), value :: alpha complex ( c_double ), intent ( inout ) :: a ( lda , * ) complex ( c_double ), intent ( in ) :: b ( * ) integer ( c_int ) :: flag ! Local Variables type ( errors ) :: err integer ( c_int ) :: ma , nb ! Initialization ma = kl + ku + 1 if ( left ) then nb = n else nb = m end if call err % set_exit_on_error (. false .) flag = LA_NO_ERROR if ( lda < ma ) then flag = LA_INVALID_INPUT_ERROR return end if ! Process call band_diag_mtx_mult ( logical ( left ), m , kl , ku , alpha , a ( 1 : ma , 1 : n ), & b ( 1 : nb ), err ) if ( err % has_error_occurred ()) then flag = err % get_error_flag () return end if end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_c_api.f90.html"},{"title":"linalg_eigen.f90 – LINALG","text":"Contents Modules linalg_eigen Source Code linalg_eigen.f90 Source Code ! linalg_eigen.f90 module linalg_eigen use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use ferror implicit none private public :: eigen interface eigen !! An interface to the eigenvalue and eigenvector routines. module procedure :: eigen_symm module procedure :: eigen_asymm module procedure :: eigen_gen module procedure :: eigen_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine eigen_symm ( vecs , a , vals , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is a symmetric matrix. logical , intent ( in ) :: vecs !! Set to true to compute the eigenvectors as well as the eigenvalues; !! else, set to false to just compute the eigenvalues. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N symmetric matrix on which to operate.  On !! output, and if vecs is set to true, the matrix will contain the !! eigenvectors (one per column) corresponding to each eigenvalue in !! vals.  If vecs is set to false, the lower triangular portion of the !! matrix is overwritten. real ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array that will contain the eigenvalues sorted into !! ascending order. real ( real64 ), intent ( out ), pointer , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: jobz integer ( int32 ) :: n , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( vecs ) then jobz = 'V' else jobz = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_symm\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_symm\" , errmgr , \"vals\" , n , & size ( vals )) return end if ! Workspace Query call DSYEV ( jobz , 'L' , n , a , n , vals , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_symm\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_symm\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DSYEV ( jobz , 'L' , n , a , n , vals , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"eigen_symm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_asymm ( a , vals , vecs , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is square, but not necessarily symmetric. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix on which to operate.  On output, the !! contents of this matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array containing the eigenvalues of the matrix.  The !! eigenvalues are not sorted. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. real ( real64 ), intent ( out ), pointer , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns without !! performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , n1 , n2a , n2b , n3a , n3b , istat , flag , & lwork , lwork1 real ( real64 ) :: eps real ( real64 ), dimension ( 1 ) :: dummy , temp real ( real64 ), dimension ( 1 , 1 ) :: dummy_mtx real ( real64 ), pointer , dimension (:) :: wr , wi , wptr , w real ( real64 ), pointer , dimension (:,:) :: vr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization jobvl = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) eps = two * epsilon ( eps ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_asymm\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_asymm\" , errmgr , \"vals\" , n , & size ( vals )) return else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_asymm\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call DGEEV ( jobvl , jobvr , n , a , n , dummy , dummy , dummy_mtx , n , & dummy_mtx , n , temp , - 1 , flag ) lwork1 = int ( temp ( 1 ), int32 ) if ( present ( vecs )) then lwork = lwork1 + 2 * n + n * n else lwork = lwork1 + 2 * n end if if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_asymm\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_asymm\" , errmgr , istat ) return end if wptr => wrk end if ! Locate each array within the workspace array n1 = n n2a = n1 + 1 n2b = n2a + n - 1 n3a = n2b + 1 n3b = n3a + lwork1 - 1 ! Assign pointers wr => wptr ( 1 : n1 ) wi => wptr ( n2a : n2b ) w => wptr ( n3a : n3b ) ! Process if ( present ( vecs )) then ! Assign a pointer to the eigenvector matrix vr ( 1 : n , 1 : n ) => wptr ( n3b + 1 : lwork ) ! Compute the eigenvectors and eigenvalues call DGEEV ( jobvl , jobvr , n , a , n , wr , wi , dummy_mtx , n , vr , n , & w , lwork1 , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_asymm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues and eigenvectors j = 1 do while ( j <= n ) if ( abs ( wi ( j )) < eps ) then ! We've got a real-valued eigenvalue vals ( j ) = cmplx ( wr ( j ), zero , real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), zero , real64 ) end do else ! We've got a complex cojugate pair of eigenvalues jp1 = j + 1 vals ( j ) = cmplx ( wr ( j ), wi ( j ), real64 ) vals ( jp1 ) = conjg ( vals ( j )) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), vr ( i , jp1 ), real64 ) vecs ( i , jp1 ) = conjg ( vecs ( i , j )) end do ! Increment j and continue the loop j = j + 2 cycle end if ! Increment j j = j + 1 end do else ! Compute just the eigenvalues call DGEEV ( jobvl , jobvr , n , a , n , wr , wi , dummy_mtx , n , & dummy_mtx , n , w , lwork1 , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_asymm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues do i = 1 , n vals ( i ) = cmplx ( wr ( i ), wi ( i ), real64 ) end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_gen ( a , b , alpha , beta , vecs , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, by solving !! the eigenvalue problem: A X = \\lambda B X. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix A.  On output, the contents of this !! matrix are overwritten. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-N matrix B.  On output, the contents of this !! matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: alpha !! An N-element array that, if beta is not supplied, contains the !! eigenvalues.  If beta is supplied however, the eigenvalues must be !! computed as \\lambda = \\alpha / \\beta.  This however, is not as !! trivial as it seems as it is entirely possible, and likely, that !! \\alpha / \\beta can overflow or underflow.  With that said, the !! values in \\alpha will always be less than and usually comparable !! with the NORM(A). real ( real64 ), intent ( out ), optional , dimension (:) :: beta !! An optional N-element array that if provided forces alpha to return !! the numerator, and this array contains the denominator used to !! determine the eigenvalues as \\lambda = \\alpha / \\beta.  If used, !! the values in this array will always be less than and usually !! comparable with the NORM(B). complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. real ( real64 ), intent ( out ), optional , pointer , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , n1 , n2a , n2b , n3a , n3b , n4a , n4b , & istat , flag , lwork , lwork1 real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 , 1 ) :: dummy real ( real64 ), pointer , dimension (:) :: wptr , w , alphar , alphai , bptr real ( real64 ), pointer , dimension (:,:) :: vr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ) :: eps class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization jobvl = 'N' jobvr = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) eps = two * epsilon ( eps ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_gen\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_gen\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return else if ( size ( alpha ) /= n ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"alpha\" , n , & size ( alpha )) return else if ( present ( beta )) then if ( size ( beta ) /= n ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"beta\" , n , & size ( beta )) return end if else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_gen\" , errmgr , \"vecs\" , n , n , & size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call DGGEV ( jobvl , jobvr , n , a , n , b , n , temp , temp , temp , dummy , n , & dummy , n , temp , - 1 , flag ) lwork1 = int ( temp ( 1 ), int32 ) lwork = lwork1 + 2 * n if (. not . present ( beta )) then lwork = lwork + n end if if ( present ( vecs )) then lwork = lwork + n * n end if if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_gen\" , errmgr , istat ) return end if wptr => wrk end if ! Locate each array within the workspace array & assign pointers n1 = n n2a = n1 + 1 n2b = n2a + n - 1 n3a = n2b + 1 n3b = n3a + lwork1 - 1 n4b = n3b alphar => wptr ( 1 : n1 ) alphai => wptr ( n2a : n2b ) w => wptr ( n3a : n3b ) if (. not . present ( beta )) then n4a = n3b + 1 n4b = n4a + n - 1 bptr => wptr ( n4a : n4b ) end if ! Process if ( present ( vecs )) then ! Assign a pointer to the eigenvector matrix vr ( 1 : n , 1 : n ) => wptr ( n4b + 1 : lwork ) ! Compute the eigenvalues and eigenvectors if ( present ( beta )) then call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & beta , dummy , n , vr , n , w , lwork1 , flag ) else call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & bptr , dummy , n , vr , n , w , lwork1 , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_gen\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues and eigenvectors j = 1 do while ( j <= n ) if ( abs ( alphai ( j )) < eps ) then ! Real-Valued alpha ( j ) = cmplx ( alphar ( j ), zero , real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), zero , real64 ) end do else ! Complex-Valued jp1 = j + 1 alpha ( j ) = cmplx ( alphar ( j ), alphai ( j ), real64 ) alpha ( jp1 ) = cmplx ( alphar ( jp1 ), alphai ( jp1 ), real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), vr ( i , jp1 ), real64 ) vecs ( i , jp1 ) = conjg ( vecs ( i , j )) end do ! Increment j and continue j = j + 2 cycle end if ! Increment j j = j + 1 end do if (. not . present ( beta )) alpha = alpha / bptr else ! Compute just the eigenvalues if ( present ( beta )) then call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & beta , dummy , n , dummy , n , w , lwork1 , flag ) else call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & bptr , dummy , n , dummy , n , w , lwork1 , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_gen\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues do i = 1 , n alpha ( i ) = cmplx ( alphar ( i ), alphai ( i ), real64 ) end do if (. not . present ( beta )) alpha = alpha / bptr end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_cmplx ( a , vals , vecs , work , olwork , rwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is square, but not necessarily symmetric. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix on which to operate.  On output, the !! contents of this matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array containing the eigenvalues of the matrix.  The !! eigenvalues are not sorted. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 2 * N. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns without !! performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: n , flag , lwork , lrwork real ( real64 ) :: rdummy ( 1 ) complex ( real64 ) :: temp ( 1 ), dummy ( 1 ), dummy_mtx ( 1 , 1 ) complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: rwrk real ( real64 ), pointer , dimension (:) :: rwptr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if jobvl = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) lrwork = 2 * n ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"vals\" , n , & size ( vals )) return else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_cmplx\" , errmgr , \"vecs\" , n , n , & size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call ZGEEV ( jobvl , jobvr , n , a , n , dummy , dummy_mtx , n , dummy_mtx , n , temp , & - 1 , rdummy , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work else allocate ( wrk ( lwork ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"eigen_cmplx\" , errmgr , flag ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"rwork\" , & lrwork , size ( rwork )) return end if rwptr => rwork else allocate ( rwrk ( lrwork ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"eigen_cmplx\" , errmgr , flag ) return end if rwptr => rwrk end if ! Process if ( present ( vecs )) then call ZGEEV ( jobvl , jobvr , n , a , n , vals , dummy_mtx , n , vecs , n , & wptr , lwork , rwptr , flag ) else call ZGEEV ( jobvl , jobvr , n , a , n , vals , dummy_mtx , n , dummy_mtx , n , & wptr , lwork , rwptr , flag ) end if if ( flag > 0 ) then call errmgr % report_error ( \"eigen_cmplx\" , & \"The algorithm failed to converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_eigen.f90.html"},{"title":"linalg_errors.f90 – LINALG","text":"Contents Modules linalg_errors Source Code linalg_errors.f90 Source Code module linalg_errors use iso_fortran_env use ferror implicit none integer ( int32 ), parameter :: LA_NO_ERROR = 0 !! An flag denoting no error condition. integer ( int32 ), parameter :: LA_INVALID_INPUT_ERROR = 101 !! An error flag denoting an invalid input. integer ( int32 ), parameter :: LA_ARRAY_SIZE_ERROR = 102 !! An error flag denoting an improperly sized array. integer ( int32 ), parameter :: LA_SINGULAR_MATRIX_ERROR = 103 !! An error flag denoting a singular matrix. integer ( int32 ), parameter :: LA_MATRIX_FORMAT_ERROR = 104 !! An error flag denoting an issue with the matrix format. integer ( int32 ), parameter :: LA_OUT_OF_MEMORY_ERROR = 105 !! An error flag denoting that there is insufficient memory available. integer ( int32 ), parameter :: LA_CONVERGENCE_ERROR = 106 !! An error flag denoting a convergence failure. integer ( int32 ), parameter :: LA_INVALID_OPERATION_ERROR = 107 !! An error resulting from an invalid operation. contains subroutine report_memory_error ( fcn , err , flag ) !! Reports a memory allocation error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. integer ( int32 ), intent ( in ) :: flag !! The error flag. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Memory allocation failed in \" , fcn , & \" with code \" , flag , \".\" call err % report_error ( fcn , trim ( msg ), LA_OUT_OF_MEMORY_ERROR ) ! Formatting 100 format ( A , A , A , I0 , A ) end subroutine subroutine report_array_size_error ( fcn , err , name , expected , actual ) !! Reports an array size error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the array. integer ( int32 ), intent ( in ) :: expected !! The expected size of the array. integer ( int32 ), intent ( in ) :: actual !! The actual size of the array. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected array size of \" , expected , & \" but received \" , actual , \" in \" , fcn , \"for array \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_matrix_size_error ( fcn , err , name , expectedRows , & expectedCols , actualRows , actualCols ) !! Reports a matrix size error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the matrix. integer ( int32 ), intent ( in ) :: expectedRows !! The expected number of rows in the matrix. integer ( int32 ), intent ( in ) :: expectedCols !! The expected number of columns in the matrix. integer ( int32 ), intent ( in ) :: actualRows !! The actual number of rows in the matrix. integer ( int32 ), intent ( in ) :: actualCols !! The actual number of columns in the matrix. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected matrix size of \" , expectedRows , \" x \" , & expectedCols , \" but received \" , actualRows , \" x \" , actualCols , & \" in \" , fcn , \"for matrix \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_inner_matrix_dimension_error ( fcn , err , name1 , name2 , & expected , actual ) !! Reports an inner matrix dimension error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name1 !! The name of the first matrix. character ( len =* ), intent ( in ) :: name2 !! The name of the second matrix. integer ( int32 ), intent ( in ) :: expected !! The expected inner dimension. integer ( int32 ), intent ( in ) :: actual !! The actual inner dimension. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected inner matrix dimension of \" , expected , & \" but received \" , actual , \" in \" , fcn , \"for matrices \" , name1 , & \" and \" , name2 , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_square_matrix_error ( fcn , err , name , expectedSize , & actualRows , actualCols ) !! Reports an error where a square matrix was expected but a non-square !! matrix was provided. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the matrix. integer ( int32 ), intent ( in ) :: expectedSize !! The expected size of the square matrix. integer ( int32 ), intent ( in ) :: actualRows !! The actual number of rows in the matrix. integer ( int32 ), intent ( in ) :: actualCols !! The actual number of columns in the matrix. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected square matrix of size \" , expectedSize , & \" but received \" , actualRows , \" x \" , actualCols , \" in \" , fcn , & \"for matrix \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_singular_matrix_warning ( fcn , err , row ) !! Reports a singular matrix error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. integer ( int32 ), intent ( in ) :: row !! The row index where the singularity issue was first encountered. ! Local Variables character ( len = 256 ) :: msg ! Write the error message write ( msg , 100 ) & \"A singular matrix was encountered with the issue found at row \" , & row , \" of the matrix.\" call err % report_warning ( fcn , trim ( msg ), LA_SINGULAR_MATRIX_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine end module","tags":"","loc":"sourcefile\\linalg_errors.f90.html"},{"title":"linalg_inverse.f90 – LINALG","text":"Contents Modules linalg_inverse Source Code linalg_inverse.f90 Source Code module linalg_inverse use iso_fortran_env , only : int32 , real64 use lapack use blas use linalg_errors implicit none private public :: mtx_inverse public :: mtx_pinverse interface mtx_inverse module procedure :: mtx_inverse_dbl module procedure :: mtx_inverse_cmplx end interface interface mtx_pinverse module procedure :: mtx_pinverse_dbl module procedure :: mtx_pinverse_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine mtx_inverse_dbl ( a , iwork , work , olwork , err ) !! Computes the inverse of a square matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to invert.  On output, the inverted !! matrix. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An optional N-element integer workspace array. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , liwork , lwork , istat , flag , itemp ( 1 ) integer ( int32 ), pointer , dimension (:) :: iptr integer ( int32 ), allocatable , target , dimension (:) :: iwrk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) liwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"mtx_inverse_dbl\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DGETRI ( n , a , n , itemp , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Workspace Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"mtx_inverse_dbl\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Integer Workspace Allocation if ( present ( iwork )) then if ( size ( iwork ) < liwork ) then call report_array_size_error ( \"mtx_inverse_dbl\" , errmgr , \"iwork\" , & liwork , size ( iwork )) return end if iptr => iwork ( 1 : liwork ) else allocate ( iwrk ( liwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_dbl\" , errmgr , istat ) return end if iptr => iwrk end if ! Compute the LU factorization of A call DGETRF ( n , n , a , n , iptr , flag ) ! Compute the inverse of the LU factored matrix call DGETRI ( n , a , n , iptr , wptr , lwork , flag ) ! Check for a singular matrix if ( flag > 0 ) then call errmgr % report_error ( \"mtx_inverse_dbl\" , & \"The matrix is singular; therefore, the inverse could \" // & \"not be computed.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_inverse_cmplx ( a , iwork , work , olwork , err ) !! Computes the inverse of a square matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to invert.  On output, the inverted !! matrix. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An optional N-element integer workspace array. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , liwork , lwork , istat , flag , itemp ( 1 ) integer ( int32 ), pointer , dimension (:) :: iptr integer ( int32 ), allocatable , target , dimension (:) :: iwrk complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) liwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"mtx_inverse_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZGETRI ( n , a , n , itemp , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Workspace Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_inverse_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Integer Workspace Allocation if ( present ( iwork )) then if ( size ( iwork ) < liwork ) then call report_array_size_error ( \"mtx_inverse_cmplx\" , errmgr , \"iwork\" , & liwork , size ( iwork )) return end if iptr => iwork ( 1 : liwork ) else allocate ( iwrk ( liwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_cmplx\" , errmgr , istat ) return end if iptr => iwrk end if ! Compute the LU factorization of A call ZGETRF ( n , n , a , n , iptr , flag ) ! Compute the inverse of the LU factored matrix call ZGETRI ( n , a , n , iptr , wptr , lwork , flag ) ! Check for a singular matrix if ( flag > 0 ) then call errmgr % report_error ( \"mtx_inverse_cmplx\" , & \"The matrix is singular; therefore, the inverse could \" // & \"not be computed.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_pinverse_dbl ( a , ainv , tol , work , olwork , err ) !! Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the !! singular value decomposition of the matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to invert.  The matrix is overwritten !! on output. real ( real64 ), intent ( out ), dimension (:,:) :: ainv !! The N-by-M matrix where the pseudo-inverse of A will be written. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default tolerance !! on singular values such that singular values less than this !! tolerance are forced to have a reciprocal of zero, as opposed to !! 1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , istat , flag , i1 , i2a , i2b , i3a , & i3b , i4 , lrwork real ( real64 ), pointer , dimension (:) :: s , wptr , w real ( real64 ), pointer , dimension (:,:) :: u , vt real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: t , tref , tolcheck , ss class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) i1 = m * mn i2a = i1 + 1 i2b = i2a + n * mn - 1 i3a = i2b + 1 i3b = i3a + mn - 1 i4 = i3b + 1 tolcheck = dlamch ( 's' ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( ainv , 1 ) /= n . or . size ( ainv , 2 ) /= m ) then call report_matrix_size_error ( \"mtx_pinverse_dbl\" , errmgr , \"ainv\" , & n , m , size ( ainv , 1 ), size ( ainv , 2 )) return end if ! Workspace Query call DGESVD ( 'S' , 'S' , m , n , a , m , temp , a , m , a , n , temp , - 1 , flag ) lrwork = int ( temp ( 1 ), int32 ) lwork = lrwork + m * m + n * n + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_pinverse_dbl\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_dbl\" , errmgr , istat ) return end if wptr => wrk end if u ( 1 : m , 1 : mn ) => wptr ( 1 : i1 ) vt ( 1 : mn , 1 : n ) => wptr ( i2a : i2b ) s => wptr ( i3a : i3b ) w => wptr ( i4 : lwork ) ! Compute the SVD of A call DGESVD ( 'S' , 'S' , m , n , a , m , s , u , m , vt , n , w , lrwork , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"mtx_pinverse_dbl\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if !if (t < safe_denom(t)) then if ( t < tolcheck ) then ! The supplied tolerance is too small, simply fall back to the ! default, but issue a warning to the user t = tref ! call errmgr%report_warning(\"pinverse_1\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Compute the pseudoinverse such that pinv(A) = V * inv(S) * U**T by ! first computing inv(S) * U**T do i = 1 , mn if ( s ( i ) < t ) then ss = s ( i ) else ss = 1.0d0 / s ( i ) end if call DSCAL ( m , ss , u (:, i ), 1 ) end do call DGEMM ( \"T\" , \"T\" , n , m , mn , one , vt , n , u , m , zero , ainv , n ) end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_pinverse_cmplx ( a , ainv , tol , work , olwork , rwork , err ) !! Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the !! singular value decomposition of the matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to invert.  The matrix is overwritten !! on output. complex ( real64 ), intent ( out ), dimension (:,:) :: ainv !! The N-by-M matrix where the pseudo-inverse of A will be written. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default tolerance !! on singular values such that singular values less than this !! tolerance are forced to have a reciprocal of zero, as opposed to !! 1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , dimension (:), optional :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 6 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , istat , flag , i1 , i2a , i2b , i3 , & lrwork , j , k real ( real64 ), pointer , dimension (:) :: s , rwptr , rw real ( real64 ), allocatable , target , dimension (:) :: rwrk complex ( real64 ), pointer , dimension (:) :: wptr , w complex ( real64 ), pointer , dimension (:,:) :: u , vt complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ) :: temp ( 1 ), val real ( real64 ) :: t , tref , tolcheck , rtemp ( 1 ) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 6 * mn i1 = m * mn i2a = i1 + 1 i2b = i2a + n * n - 1 i3 = i2b + 1 tolcheck = dlamch ( 's' ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( ainv , 1 ) /= n . or . size ( ainv , 2 ) /= m ) then call report_matrix_size_error ( \"mtx_pinverse_cmplx\" , errmgr , \"ainv\" , & n , m , size ( ainv , 1 ), size ( ainv , 2 )) return end if ! Workspace Query call ZGESVD ( 'S' , 'A' , m , n , a , m , rtemp , a , m , a , n , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) lwork = lwork + m * mn + n * n if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_pinverse_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"mtx_pinverse_cmplx\" , errmgr , & \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if u ( 1 : m , 1 : mn ) => wptr ( 1 : i1 ) vt ( 1 : n , 1 : n ) => wptr ( i2a : i2b ) w => wptr ( i3 : lwork ) s => rwptr ( 1 : mn ) rw => rwptr ( mn + 1 : lrwork ) ! Compute the SVD of A call ZGESVD ( 'S' , 'A' , m , n , a , m , s , u , m , vt , n , w , size ( w ), rw , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"mtx_pinverse_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if !if (t < safe_denom(t)) then if ( t < tolcheck ) then ! The supplied tolerance is too small, simply fall back to the ! default, but issue a warning to the user t = tref ! call errmgr%report_warning(\"pinverse_1\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Compute the pseudoinverse such that pinv(A) = V * inv(S) * U**T by ! first computing V * inv(S) (result is N-by-M), and store in the first ! MN rows of VT in a transposed manner. do i = 1 , mn ! Apply 1 / S(I) to VT(I,:) if ( s ( i ) < t ) then vt ( i ,:) = zero else ! call recip_mult_array(s(i), vt(i,1:n)) vt ( i , 1 : n ) = conjg ( vt ( i , 1 : n )) / s ( i ) end if end do ! Compute (VT**T * inv(S)) * U**H ! ainv = n-by-m ! vt is n-by-n ! u is m-by-mn such that u**H = mn-by-m ! Compute ainv = vt**T * u**H do j = 1 , m do i = 1 , n val = zero do k = 1 , mn val = val + vt ( k , i ) * conjg ( u ( j , k )) end do ainv ( i , j ) = val end do end do end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_inverse.f90.html"},{"title":"linalg_least_squares.f90 – LINALG","text":"Contents Modules linalg_least_squares Source Code linalg_least_squares.f90 Source Code module linalg_least_squares use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors implicit none private public :: solve_least_squares public :: solve_least_squares_full public :: solve_least_squares_svd interface solve_least_squares module procedure :: solve_least_squares_mtx module procedure :: solve_least_squares_mtx_cmplx module procedure :: solve_least_squares_vec module procedure :: solve_least_squares_vec_cmplx end interface interface solve_least_squares_full module procedure :: solve_least_squares_mtx_pvt module procedure :: solve_least_squares_mtx_pvt_cmplx module procedure :: solve_least_squares_vec_pvt module procedure :: solve_least_squares_vec_pvt_cmplx end interface interface solve_least_squares_svd module procedure :: solve_least_squares_mtx_svd module procedure :: solve_least_squares_mtx_svd_cmplx module procedure :: solve_least_squares_vec_svd module procedure :: solve_least_squares_vec_svd_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx ( a , b , work , olwork , err ) !! Solves the system of equations A X = B assuming matrix A is of !! full rank. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_cmplx ( a , b , work , olwork , err ) !! Solves the system of equations A X = B assuming matrix A is of !! full rank. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_cmplx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec ( a , b , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} assuming matrix !! A is of full rank. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call DGELS ( 'N' , m , n , 1 , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DGELS ( 'N' , m , n , 1 , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_cmplx ( a , b , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} assuming matrix !! A is of full rank. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_cmplx\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELS ( 'N' , m , n , 1 , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZGELS ( 'N' , m , n , 1 , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_cmplx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_pvt ( a , b , ipvt , arnk , work , olwork , err ) !! Solves the system of equations A X = B using a full orthogonal !! factorization of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag , rnk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr real ( real64 ), dimension ( 1 ) :: temp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELSY ( m , n , nrhs , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSY ( m , n , nrhs , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_pvt_cmplx ( a , b , ipvt , arnk , & work , olwork , rwork , err ) !! Solves the system of equations A X = B using a full orthogonal !! factorization of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 2 * N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag , rnk , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) lrwork = 2 * n rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELSY ( m , n , nrhs , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSY ( m , n , nrhs , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_pvt ( a , b , ipvt , arnk , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a full !! orthogonal factorization of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag , rnk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr real ( real64 ), dimension ( 1 ) :: temp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call DGELSY ( m , n , 1 , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt\" , errmgr , & istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSY ( m , n , 1 , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_pvt_cmplx ( a , b , ipvt , arnk , & work , olwork , rwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a full !! orthogonal factorization of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 2 * N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , lrwork , istat , flag , rnk complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) lrwork = 2 * n rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELSY ( m , n , 1 , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , rtemp , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSY ( m , n , 1 , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_svd ( a , b , s , arnk , work , olwork , err ) !! Solves the system of equations A X = B using a singular value !! decomposition of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , nrhs , mn , maxmn , istat , flag , lwork , rnk real ( real64 ), pointer , dimension (:) :: wptr , sptr real ( real64 ), allocatable , target , dimension (:) :: wrk , sing real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_svd\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELSS ( m , n , nrhs , a , m , b , maxmn , temp , rcond , rnk , temp , - 1 , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_mtx_svd\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd\" , errmgr , & istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSS ( m , n , nrhs , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_svd\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_svd_cmplx ( a , b , s , arnk , work , & olwork , rwork , err ) !! Solves the system of equations A X = B using a singular value !! decomposition of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , nrhs , mn , maxmn , istat , flag , lwork , rnk , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr , sptr real ( real64 ), allocatable , target , dimension (:) :: rwrk , sing complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) mn = min ( m , n ) lrwork = 5 * mn maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELSS ( m , n , nrhs , a , m , b , maxmn , rtemp , rcond , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSS ( m , n , nrhs , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_svd ( a , b , s , arnk , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a singular !! value decomposition of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , maxmn , istat , flag , lwork , rnk real ( real64 ), pointer , dimension (:) :: wptr , sptr real ( real64 ), allocatable , target , dimension (:) :: wrk , sing real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call DGELSS ( m , n , 1 , a , m , b , maxmn , temp , rcond , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd\" , errmgr , & istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSS ( m , n , 1 , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec_svd\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_svd_cmplx ( a , b , s , arnk , work , & olwork , rwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a singular !! value decomposition of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , maxmn , istat , flag , lwork , rnk , lrwork real ( real64 ), pointer , dimension (:) :: rwptr , sptr real ( real64 ), allocatable , target , dimension (:) :: rwrk , sing complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 5 * mn maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELSS ( m , n , 1 , a , m , b , maxmn , rtemp , rcond , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSS ( m , n , 1 , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec_svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_least_squares.f90.html"},{"title":"linalg_lq.f90 – LINALG","text":"Contents Modules linalg_lq Source Code linalg_lq.f90 Source Code module linalg_lq use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use linalg_tri implicit none private public :: lq_factor public :: form_lq public :: mult_lq public :: solve_lq interface lq_factor module procedure :: lq_factor_no_pivot module procedure :: lq_factor_no_pivot_cmplx end interface interface form_lq module procedure :: form_lq_no_pivot module procedure :: form_lq_no_pivot_cmplx end interface interface mult_lq module procedure :: mult_lq_mtx module procedure :: mult_lq_mtx_cmplx module procedure :: mult_lq_vec module procedure :: mult_lq_vec_cmplx end interface interface solve_lq module procedure :: solve_lq_mtx module procedure :: solve_lq_mtx_cmplx module procedure :: solve_lq_vec module procedure :: solve_lq_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine lq_factor_no_pivot ( a , tau , work , olwork , err ) !! Computes the LQ factorization of an M-by-N matrix A = L Q where !! L is a lower triangular (or lower trapezoidal) matrix and Q is !! a orthogonal matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and below the diagonal contain the MIN(M, N)-by-N lower trapezoidal !! matrix L (L is lower triangular if M >= N).  The elements !! above the diagonal, along with the array tau, represent the !! orthogonal matrix Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"lq_factor_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return end if ! Workspace Query call DGELQF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"lq_factor_no_pivot\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"lq_factor_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGELQF call DGELQF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine lq_factor_no_pivot_cmplx ( a , tau , work , olwork , err ) !! Computes the LQ factorization of an M-by-N matrix A = L Q where !! L is a lower triangular (or lower trapezoidal) matrix and Q is !! a orthogonal matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and below the diagonal contain the MIN(M, N)-by-N lower trapezoidal !! matrix L (L is lower triangular if M >= N).  The elements !! above the diagonal, along with the array tau, represent the !! orthogonal matrix Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return end if ! Workspace Query call ZGELQF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGELQF call ZGELQF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_lq_no_pivot ( l , tau , q , work , olwork , err ) !! Forms the orthogonal matrix Q from the elementary reflectors returned !! by the LQ factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: l !! On input, an M-by-N matrix where the elements above the diagonal !! contain the elementary reflectors generated from the LQ factorization !! performed by lq_factor.  On and below the diagonal the matrix !! contains the matrix L.  On output, the elements above the !! diagonal are zeroed sucht hat the remaining matrix is the M-by-N !! lower trapezoidal matrix L where only the M-by-M submatrix is !! the lower triangular matrix L.  Notice, M must be less than or !! equal to N for this routine. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in L. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An N-by-N matrix where the orthogonal matrix Q will be written. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , m , n , mn , k , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( l , 1 ) n = size ( l , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"form_lq_no_pivot\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_lq_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= n . or . size ( q , 2 ) /= n ) then call report_matrix_size_error ( \"form_lq_no_pivot\" , errmgr , \"q\" , & n , n , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call DORGLQ ( n , n , mn , q , n , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_lq_no_pivot\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_lq_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the upper triangular portion of L to Q, and then zero it out in L do j = 2 , n k = min ( j - 1 , m ) q ( 1 : k , j ) = l ( 1 : k , j ) l ( 1 : k , j ) = zero end do ! Build Q call DORGLQ ( n , n , mn , q , n , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_lq_no_pivot_cmplx ( l , tau , q , work , olwork , err ) !! Forms the orthogonal matrix Q from the elementary reflectors returned !! by the LQ factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: l !! On input, an M-by-N matrix where the elements above the diagonal !! contain the elementary reflectors generated from the LQ factorization !! performed by lq_factor.  On and below the diagonal the matrix !! contains the matrix L.  On output, the elements above the !! diagonal are zeroed sucht hat the remaining matrix is the M-by-N !! lower trapezoidal matrix L where only the M-by-M submatrix is !! the lower triangular matrix L.  Notice, M must be less than or !! equal to N for this routine. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in L. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An N-by-N matrix where the orthogonal matrix Q will be written. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , m , n , mn , k , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( l , 1 ) n = size ( l , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"form_lq_no_pivot_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= n . or . size ( q , 2 ) /= n ) then call report_matrix_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , \"q\" , & n , n , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call ZUNGLQ ( n , n , mn , q , n , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_lq_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the upper triangular portion of L to Q, and then zero it out in L do j = 2 , n k = min ( j - 1 , m ) q ( 1 : k , j ) = l ( 1 : k , j ) l ( 1 : k , j ) = zero end do ! Build Q call ZUNGLQ ( n , n , mn , q , n , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_mtx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a matrix by the orthogonal matrix Q from an LQ !! factorization. logical , intent ( in ) :: lside !! Set to true to compute C = op(Q) C; else, set to false to !! compute C = C op(Q). logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;T; else, set to false to !! compute op(Q) = Q. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-P matrix containing the elementary reflectors !! output from the LQ factorization.  If lside is set to true, P = M; !! else, if lside is set to false, P = N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , ncola , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' ncola = m else side = 'R' ncola = n end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= ncola ) then call report_matrix_size_error ( \"mult_lq_mtx\" , errmgr , \"a\" , k , ncola , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_mtx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMLQ call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_mtx_cmplx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a matrix by the orthogonal matrix Q from an LQ !! factorization. logical , intent ( in ) :: lside !! Set to true to compute C = op(Q) C; else, set to false to !! compute C = C op(Q). logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;H; else, set to false to !! compute op(Q) = Q. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-P matrix containing the elementary reflectors !! output from the LQ factorization.  If lside is set to true, P = M; !! else, if lside is set to false, P = N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , ncola , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' ncola = m else side = 'R' ncola = n end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= ncola ) then call report_matrix_size_error ( \"mult_lq_mtx_cmplx\" , errmgr , \"a\" , k , & ncola , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMLQ call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_vec ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector with the orthogonal matrix Q from an LQ !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;T; else, set to false to !! compute op(Q) = Q. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-M matrix containing the elementary reflectors !! output from the LQ factorization.  Notice, the contents of this !! matrix are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the product !! of the orthogonal matrix Q and the original vector \\vec{c}. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) n = 1 k = size ( tau ) side = 'L' if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= m ) then call report_matrix_size_error ( \"mult_lq_vec\" , errmgr , \"a\" , k , m , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMLQ call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_vec_cmplx ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector with the orthogonal matrix Q from an LQ !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;H; else, set to false to !! compute op(Q) = Q. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-M matrix containing the elementary reflectors !! output from the LQ factorization.  Notice, the contents of this !! matrix are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the product !! of the orthogonal matrix Q and the original vector \\vec{c}. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) n = 1 k = size ( tau ) side = 'L' if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= m ) then call report_matrix_size_error ( \"mult_lq_vec_cmplx\" , errmgr , \"a\" , k , m , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMLQ call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_mtx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form A X = L Q X = B. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, an N-by-NRHS matrix where the first M rows contain !! the right-hand-side matrix B.  On output, the N-by-NRHS solution !! matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_mtx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_mtx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lq_mtx\" , errmgr , \"b\" , n , nrhs , & size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_lq (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_mtx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. true ., . false ., . false ., . true ., one , & a ( 1 : m , 1 : m ), b ( 1 : m ,:), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., . true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_mtx_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form A X = L Q X = B. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, an N-by-NRHS matrix where the first M rows contain !! the right-hand-side matrix B.  On output, the N-by-NRHS solution !! matrix X. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_mtx_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"b\" , n , & nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_lq (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. true ., . false ., . false ., . true ., one , & a ( 1 : m , 1 : m ), b ( 1 : m ,:), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., . true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_vec ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form !! A \\vec{x} = L Q \\vec{x} = \\vec{b}. real ( real64 ), intent ( in ), dimension (:,:) :: a !! !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, an N-element vector where the first M rows contain the !! right-hand-side vector \\vec{b}.  On output, the N-element vector !! \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_vec\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_vec\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b ) /= n ) then call report_memory_error ( \"solve_lq_vec\" , errmgr , istat ) return end if ! Workspace Query call mult_lq (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. false ., . false ., . true ., a ( 1 : m , 1 : m ), & b ( 1 : m ), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_vec_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form !! A \\vec{x} = L Q \\vec{x} = \\vec{b}. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, an N-element vector where the first M rows contain the !! right-hand-side vector \\vec{b}.  On output, the N-element vector !! \\vec{x}. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_vec_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_vec_cmplx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b ) /= n ) then call report_memory_error ( \"solve_lq_vec_cmplx\" , errmgr , istat ) return end if ! Workspace Query call mult_lq (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. false ., . false ., . true ., a ( 1 : m , 1 : m ), & b ( 1 : m ), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_lq.f90.html"},{"title":"linalg_lu.f90 – LINALG","text":"Contents Modules linalg_lu Source Code linalg_lu.f90 Source Code module linalg_lu use iso_fortran_env use linalg_errors use linalg_sparse use linalg_basic use ferror use lapack use sparskit implicit none private public :: lu_factor public :: form_lu public :: solve_lu interface lu_factor module procedure :: lu_factor_dbl module procedure :: lu_factor_cmplx module procedure :: csr_lu_factor end interface interface form_lu module procedure :: form_lu_all module procedure :: form_lu_all_cmplx module procedure :: form_lu_only module procedure :: form_lu_only_cmplx end interface interface solve_lu module procedure :: solve_lu_mtx module procedure :: solve_lu_mtx_cmplx module procedure :: solve_lu_vec module procedure :: solve_lu_vec_cmplx module procedure :: csr_lu_solve end interface contains ! ------------------------------------------------------------------------------ subroutine lu_factor_dbl ( a , ipvt , err ) !! Computes the LU factorization of an M-by-N matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix on which to operate.  On output, the !! LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. integer ( int32 ), intent ( out ), dimension (:) :: ipvt !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I). class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( ipvt ) /= mn ) then ! ERROR: IPVT not sized correctly call report_array_size_error ( \"lu_factor_dbl\" , errmgr , \"ipvt\" , mn , & size ( ipvt )) return end if ! Compute the LU factorization by calling the LAPACK routine DGETRF call DGETRF ( m , n , a , m , ipvt , flag ) ! If flag > 0, the matrix is singular.  Notice, flag should not be ! able to be < 0 as we've already verrified inputs prior to making the ! call to LAPACK if ( flag > 0 ) then ! WARNING: Singular matrix call report_singular_matrix_warning ( \"lu_factor_dbl\" , errmgr , flag ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine lu_factor_cmplx ( a , ipvt , err ) !! Computes the LU factorization of an M-by-N matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix on which to operate.  On output, the !! LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. integer ( int32 ), intent ( out ), dimension (:) :: ipvt !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I). class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( ipvt ) /= mn ) then ! ERROR: IPVT not sized correctly call errmgr % report_error ( \"lu_factor_cmplx\" , & \"Incorrectly sized input array IPVT, argument 2.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Compute the LU factorization by calling the LAPACK routine ZGETRF call ZGETRF ( m , n , a , m , ipvt , flag ) ! If flag > 0, the matrix is singular.  Notice, flag should not be ! able to be < 0 as we've already verrified inputs prior to making the ! call to LAPACK if ( flag > 0 ) then ! WARNING: Singular matrix call report_singular_matrix_warning ( \"lu_factor_cmplx\" , errmgr , flag ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine csr_lu_factor ( a , lu , ju , droptol , err ) !! Factors a matrix using an LU decomposition. class ( csr_matrix ), intent ( in ) :: a !! The matrix to factor. type ( msr_matrix ), intent ( out ) :: lu !! The LU matrix. integer ( int32 ), intent ( out ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( in ), optional :: droptol !! The drop tolerance for the ILUT factorization. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , m , n , nn , nnz , lfil , iwk , ierr , flag integer ( int32 ), allocatable , dimension (:) :: jlu , jw real ( real64 ), allocatable , dimension (:) :: alu , w real ( real64 ) :: dt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( droptol )) then dt = droptol else dt = sqrt ( epsilon ( dt )) end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Check if ( size ( ju ) /= m ) then call report_array_size_error ( \"csr_lu_factor\" , errmgr , \"ju\" , m , size ( ju )) return end if ! Parameter Determination lfil = 1 do i = 1 , m lfil = max ( lfil , a % row_indices ( i + 1 ) - a % row_indices ( i )) end do iwk = max ( lfil * m , nnz ) ! somewhat arbitrary - can be adjusted ! Local Memory Allocation allocate ( alu ( iwk ), w ( n + 1 ), jlu ( iwk ), jw ( 2 * n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Factorization do ! Factor the matrix call ilut ( n , a % values , a % column_indices , a % row_indices , lfil , dt , & alu , jlu , ju , iwk , w , jw , ierr ) ! Check the error flag if ( ierr == 0 ) then ! Success exit else if ( ierr > 0 ) then ! Zero pivot else if ( ierr == - 1 ) then ! The input matrix is not formatted correctly go to 20 else if ( ierr == - 2 . or . ierr == - 3 ) then ! ALU and JLU are too small - try something larger ! This is the main reason for the loop - to offload worrying about ! workspace size from the user iwk = min ( iwk + m + n , m * n ) deallocate ( alu ) deallocate ( jlu ) allocate ( alu ( iwk ), jlu ( iwk ), stat = flag ) if ( flag /= 0 ) go to 10 else if ( ierr == - 4 ) then ! Illegal value for LFIL - reset and try again lfil = n else if ( ierr == - 5 ) then ! Zero row encountered go to 30 else ! We should never get here, but just in case go to 40 end if end do ! Determine the actual number of non-zero elements nnz = jlu ( m + 1 ) - 1 ! Copy the contents to the output arrays lu % m = m lu % n = n lu % nnz = nnz nn = m + 1 + nnz - min ( m , n ) allocate ( lu % values ( nn ), source = alu (: nn ), stat = flag ) if ( flag /= 0 ) go to 10 allocate ( lu % indices ( nn ), source = jlu (: nn ), stat = flag ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_lu_factor\" , errmgr , flag ) return ! Matrix Format Error 20 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"The input matrix was incorrectly formatted.  A row with more \" // & \"than N entries was found.\" , LA_MATRIX_FORMAT_ERROR ) return ! Zero Row Error 30 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"A row with all zeros was encountered in the matrix.\" , & LA_SINGULAR_MATRIX_ERROR ) return ! Unknown Error 40 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , \"ILUT encountered \" // & \"an unknown error.  The error code from the ILUT routine is \" // & \"provided in the output.\" , ierr ) return ! Zero Pivot Error 50 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"A zero pivot was encountered.\" , LA_SINGULAR_MATRIX_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_all ( lu , ipvt , u , p , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the row permutation matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , jp , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_all\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"form_lu_all\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return else if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Ensure P starts off as an identity matrix call DLASET ( 'A' , n , n , zero , one , p , n ) ! Process do j = 1 , n ! Define the pivot matrix jp = ipvt ( j ) if ( j /= jp ) call swap ( p ( j , 1 : n ), p ( jp , 1 : n )) ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_all_cmplx ( lu , ipvt , u , p , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the row permutation matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , jp , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 complex ( real64 ), parameter :: c_zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: c_one = ( 1.0d0 , 0.0d0 ) ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_all_cmplx\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"form_lu_all_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all_cmplx\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return else if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all_cmplx\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Ensure P starts off as an identity matrix call DLASET ( 'A' , n , n , zero , one , p , n ) ! Process do j = 1 , n ! Define the pivot matrix jp = ipvt ( j ) if ( j /= jp ) call swap ( p ( j , 1 : n ), p ( jp , 1 : n )) ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = c_zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = c_zero lu ( j , j ) = c_one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_only ( lu , u , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. real ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_only\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_only\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return end if ! Process do j = 1 , n ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_only_cmplx ( lu , u , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. complex ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_only_cmplx\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_only_cmplx\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return end if ! Process do j = 1 , n ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_mtx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS right-hand-side matrix.  On output, the !! N-by-NRHS solution matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_mtx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_mtx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lu_mtx\" , errmgr , \"b\" , n , & size ( b , 2 ), size ( b , 1 ), size ( b , 2 )) return end if ! Call DGETRS call DGETRS ( \"N\" , n , nrhs , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_mtx_cmplx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS right-hand-side matrix.  On output, the !! N-by-NRHS solution matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"b\" , n , & size ( b , 2 ), size ( b , 1 ), size ( b , 2 )) return end if ! Call ZGETRS call ZGETRS ( \"N\" , n , nrhs , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_vec ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! The N-element right-hand-side array. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_vec\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_vec\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_lu_vec\" , errmgr , \"b\" , n , & size ( b )) return end if ! Call DGETRS call DGETRS ( \"N\" , n , 1 , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_vec_cmplx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! The N-element right-hand-side array. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_vec_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_vec_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_lu_vec_cmplx\" , errmgr , \"b\" , n , & size ( b )) return end if ! Call ZGETRS call ZGETRS ( \"N\" , n , 1 , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_lu_solve ( lu , ju , b , x , err ) !! Solves a linear system using an LU decomposition. class ( msr_matrix ), intent ( in ) :: lu !! The LU matrix. integer ( int32 ), intent ( in ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( in ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( lu , 1 ) n = size ( lu , 2 ) ! Input Check if ( m /= n ) then call report_square_matrix_error ( \"csr_lu_solve\" , errmgr , \"lu\" , m , m , n ) return end if if ( size ( x ) /= m ) then call report_inner_matrix_dimension_error ( \"csr_lu_solve\" , errmgr , & \"lu\" , \"x\" , m , size ( x )) return end if if ( size ( b ) /= m ) then call report_array_size_error ( \"csr_lu_solve\" , errmgr , \"b\" , m , size ( b )) return end if if ( size ( ju ) /= m ) then call report_array_size_error ( \"csr_lu_solve\" , errmgr , \"ju\" , m , size ( ju )) return end if ! Process call lusol ( m , b , x , lu % values , lu % indices , ju ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_lu.f90.html"},{"title":"linalg_qr.f90 – LINALG","text":"Contents Modules linalg_qr Source Code linalg_qr.f90 Source Code module linalg_qr use iso_fortran_env use linalg_errors use linalg_rz use linalg_tri use lapack use blas use ferror use qrupdate implicit none private public :: qr_factor public :: form_qr public :: mult_qr public :: qr_rank1_update public :: solve_qr interface qr_factor module procedure :: qr_factor_no_pivot module procedure :: qr_factor_no_pivot_cmplx module procedure :: qr_factor_pivot module procedure :: qr_factor_pivot_cmplx end interface interface form_qr module procedure :: form_qr_no_pivot module procedure :: form_qr_no_pivot_cmplx module procedure :: form_qr_pivot module procedure :: form_qr_pivot_cmplx end interface interface mult_qr module procedure :: mult_qr_mtx module procedure :: mult_qr_mtx_cmplx module procedure :: mult_qr_vec module procedure :: mult_qr_vec_cmplx end interface interface qr_rank1_update module procedure :: qr_rank1_update_dbl module procedure :: qr_rank1_update_cmplx end interface interface solve_qr module procedure :: solve_qr_no_pivot_mtx module procedure :: solve_qr_no_pivot_mtx_cmplx module procedure :: solve_qr_no_pivot_vec module procedure :: solve_qr_no_pivot_vec_cmplx module procedure :: solve_qr_pivot_mtx module procedure :: solve_qr_pivot_mtx_cmplx module procedure :: solve_qr_pivot_vec module procedure :: solve_qr_pivot_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine qr_factor_no_pivot ( a , tau , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then ! ERROR: TAU not sized correctly call report_array_size_error ( \"qr_factor_no_pivot\" , errmgr , \"tau\" , mn , & size ( tau )) return end if ! Workspace Query call DGEQRF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"qr_factor_no_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGEQRF call DGEQRF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_no_pivot_cmplx ( a , tau , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return end if ! Workspace Query call ZGEQRF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGEQRF call ZGEQRF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_pivot ( a , tau , jpvt , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix using column pivoting !! such that A P = Q R. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. integer ( int32 ), intent ( inout ), dimension (:) :: jpvt !! On input, an N-element array that if JPVT(I) .ne. 0, the I-th column !! of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th !! column of A is a free column.  On output, if JPVT(I) = K, then the !! I-th column of A * P was the K-th column of A. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"tau\" , mn , & size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"jpvt\" , n , & size ( jpvt )) return end if ! Workspace Query call DGEQP3 ( m , n , a , m , jpvt , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_pivot\" , errmgr , istat ) end if wptr => wrk end if ! Call DGEQP3 call DGEQP3 ( m , n , a , m , jpvt , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_pivot_cmplx ( a , tau , jpvt , work , olwork , rwork , err ) !! Computes the QR factorization of an M-by-N matrix using column pivoting !! such that A P = Q R. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. integer ( int32 ), intent ( inout ), dimension (:) :: jpvt !! On input, an N-element array that if JPVT(I) .ne. 0, the I-th column !! of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th !! column of A is a free column.  On output, if JPVT(I) = K, then the !! I-th column of A * P was the K-th column of A. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , dimension (:), optional :: rwork !! An optional input, that if provided, prevents any local allocate of !! real-valued memory.  If not provided, the memory required is !! allocated within.  If provided, the length of the array must be at !! least 2*N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return end if if ( present ( rwork )) then if ( size ( rwork ) < 2 * n ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"rwork\" , 2 * n , size ( rwork )) return end if rptr => rwork ( 1 : 2 * n ) else allocate ( rwrk ( 2 * n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"qr_factor_pivot_cmplx\" , errmgr , flag ) return end if rptr => rwrk end if ! Workspace Query call ZGEQP3 ( m , n , a , m , jpvt , tau , temp , - 1 , rptr , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGEQP3 call ZGEQP3 ( m , n , a , m , jpvt , tau , wptr , lwork , rptr , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_no_pivot ( r , tau , q , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , m , n , mn , qcol , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) qcol = size ( q , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_qr_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= m . or . ( qcol /= m . and . qcol /= n )) then call report_matrix_size_error ( \"form_qr_no_pivot\" , errmgr , \"q\" , m , mn , & size ( q , 1 ), size ( q , 2 )) return else if ( qcol == n . and . m < n ) then call report_matrix_size_error ( \"form_qr_no_pivot\" , errmgr , \"q\" , m , m , & size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call DORGQR ( m , qcol , mn , q , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_qr_no_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_qr_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the sub-diagonal portion of R to Q, and then zero out the ! sub-diagonal portion of R do j = 1 , mn q ( j + 1 : m , j ) = r ( j + 1 : m , j ) r ( j + 1 : m , j ) = zero end do ! Build Q - Build M-by-M or M-by-N, but M-by-N only for M >= N call DORGQR ( m , qcol , mn , q , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_no_pivot_cmplx ( r , tau , q , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , m , n , mn , qcol , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) qcol = size ( q , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= m . or . ( qcol /= m . and . qcol /= n )) then call report_matrix_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"q\" , & m , mn , size ( q , 1 ), size ( q , 2 )) return else if ( qcol == n . and . m < n ) then call report_matrix_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call ZUNGQR ( m , qcol , mn , q , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_qr_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the sub-diagonal portion of R to Q, and then zero out the ! sub-diagonal portion of R do j = 1 , mn q ( j + 1 : m , j ) = r ( j + 1 : m , j ) r ( j + 1 : m , j ) = zero end do ! Build Q - Build M-by-M or M-by-N, but M-by-N only for M >= N call ZUNGQR ( m , qcol , mn , q , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_pivot ( r , tau , pvt , q , p , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. integer ( int32 ), intent ( in ), dimension (:) :: pvt !! An N-element column pivot array as returned by the QR factorization. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the pivot matrix will be written. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: j , jp , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_qr_pivot\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Generate Q and R call form_qr_no_pivot ( r , tau , q , work = work , olwork = olwork , & err = errmgr ) if ( present ( olwork )) return ! Just a workspace query if ( errmgr % has_error_occurred ()) return ! Form P do j = 1 , n jp = pvt ( j ) p (:, j ) = zero p ( jp , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_pivot_cmplx ( r , tau , pvt , q , p , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. integer ( int32 ), intent ( in ), dimension (:) :: pvt !! An N-element column pivot array as returned by the QR factorization. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. complex ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the pivot matrix will be written. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , jp , m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_qr_pivot_cmplx\" , errmgr , \"p\" , & n , n , size ( p , 1 ), size ( p , 2 )) return end if ! Generate Q and R call form_qr_no_pivot_cmplx ( r , tau , q , work = work , olwork = olwork , & err = errmgr ) if ( present ( olwork )) return ! Just a workspace query if ( errmgr % has_error_occurred ()) return ! Form P do j = 1 , n jp = pvt ( j ) p (:, j ) = zero p ( jp , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_mtx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that C = op(Q) C or C = C op(Q). logical , intent ( in ) :: lside !! Set to true to apply Q or Q&#94;T from the left; else, set to !! false to apply Q or Q&#94;T from the right. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;T; else, set to false to apply Q. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an LDA-by-K matrix containing the elementary reflectors !! output from the QR factorization.  If lside is set to true, LDA = M, !! and M >= K >= 0; else, if lside is set to false, LDA = N, and !! N >= K >= 0.  Notice, the contents of this matrix are !! restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , nrowa , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' nrowa = m else side = 'R' nrowa = n end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then ! A is M-by-K, M >= K >= 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if else ! A is N-by-K, N >= K >= 0 if ( size ( a , 1 ) /= n . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx\" , errmgr , \"a\" , n , k , & size ( a , 1 ), size ( a , 2 )) return end if end if ! Workspace Query call DORMQR ( side , t , m , n , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_mtx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMQR call DORMQR ( side , t , m , n , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_mtx_cmplx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that C = op(Q) C or C = C op(Q). logical , intent ( in ) :: lside !! Set to true to apply Q or Q&#94;H from the left; else, set to !! false to apply Q or Q&#94;H from the right. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;H; else, set to false to apply Q. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an LDA-by-K matrix containing the elementary reflectors !! output from the QR factorization.  If lside is set to true, LDA = M, !! and M >= K >= 0; else, if lside is set to false, LDA = N, and !! N >= K >= 0.  Notice, the contents of this matrix are !! restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , nrowa , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' nrowa = m else side = 'R' nrowa = n end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then ! A is M-by-K, M >= K >= 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"a\" , & m , k , size ( a , 1 ), size ( a , 2 )) return end if else ! A is N-by-K, N >= K >= 0 if ( size ( a , 1 ) /= n . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"a\" , & n , k , size ( a , 1 ), size ( a , 2 )) return end if end if ! Workspace Query call ZUNMQR ( side , t , m , n , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMQR call ZUNMQR ( side , t , m , n , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_vec ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector by the orthogonal matrix Q from a QR !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;T; else, set to false to apply Q. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an M-by-K matrix containing the elementary reflectors !! output from the QR factorization. Notice, the contents of this matrix !! are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the !! product of the orthogonal matrix Q and the original vector !! \\vec{c}. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: side , t integer ( int32 ) :: m , k , nrowa , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) k = size ( tau ) side = 'L' nrowa = m if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_vec\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMQR call DORMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_vec_cmplx ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector by the orthogonal matrix Q from a QR !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;H; else, set to false to apply Q. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an M-by-K matrix containing the elementary reflectors !! output from the QR factorization. Notice, the contents of this matrix !! are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the !! product of the orthogonal matrix Q and the original vector !! \\vec{c}. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables character :: side , t integer ( int32 ) :: m , k , nrowa , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) side = 'L' nrowa = m if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_vec_cmplx\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMQR call ZUNMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_rank1_update_dbl ( q , r , u , v , work , err ) !! Computes the rank-1 update to an M-by-N QR factored matrix A where !! M \\ge N, A = Q R, and A_1 = A + \\vec{u} \\vec{v}&#94;T such that !! A_1 = Q_1 R_1. real ( real64 ), intent ( inout ), dimension (:,:) :: q !! On input, the original M-by-K orthogonal matrix Q.  On output, !! the updated matrix Q_1. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the M-by-N matrix R.  On output, the updated matrix !! R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the M-element \\vec{u} update vector.  On output, the !! original content of the array is overwritten. real ( real64 ), intent ( inout ), dimension (:) :: v !! On input, the N-element \\vec{v} update vector.  On output, the !! original content of the array is overwritten. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least 2 K elements. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables logical :: full integer ( int32 ) :: m , n , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( u , 1 ) n = size ( r , 2 ) k = min ( m , n ) full = size ( q , 2 ) == m lwork = 2 * k if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"qr_rank1_update_dbl\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if (. not . full . and . size ( q , 2 ) /= k ) then call report_matrix_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return else if ( size ( r , 1 ) /= m ) then call report_inner_matrix_dimension_error ( \"qr_rank1_update_dbl\" , & errmgr , \"q\" , \"r\" , m , size ( r , 1 )) return else if ( size ( u ) /= m ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"u\" , m , & size ( u )) return else if ( size ( v ) /= n ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"v\" , n , & size ( v )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DQR1UP ( m , n , k , q , m , r , m , u , v , wptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_rank1_update_cmplx ( q , r , u , v , work , rwork , err ) !! Computes the rank-1 update to an M-by-N QR factored matrix A where !! M \\ge N, A = Q R, and A_1 = A + \\vec{u} \\vec{v}&#94;H such that !! A_1 = Q_1 R_1. complex ( real64 ), intent ( inout ), dimension (:,:) :: q !! On input, the original M-by-K orthogonal matrix Q.  On output, !! the updated matrix Q_1. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the M-by-N matrix R.  On output, the updated matrix !! R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the M-element \\vec{u} update vector.  On output, the !! original content of the array is overwritten. complex ( real64 ), intent ( inout ), dimension (:) :: v !! On input, the N-element \\vec{v} update vector.  On output, the !! original content of the array is overwritten. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least K elements. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least K elements. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables logical :: full integer ( int32 ) :: m , n , k , lwork , istat , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( u , 1 ) n = size ( r , 2 ) k = min ( m , n ) full = size ( q , 2 ) == m lwork = k lrwork = k if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"qr_rank1_update_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if (. not . full . and . size ( q , 2 ) /= k ) then call report_matrix_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return else if ( size ( r , 1 ) /= m ) then call report_inner_matrix_dimension_error ( \"qr_rank1_update_cmplx\" , & errmgr , \"q\" , \"r\" , m , size ( r , 1 )) return else if ( size ( u ) /= m ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"u\" , m , & size ( u )) return else if ( size ( v ) /= n ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"v\" , n , & size ( v )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , & \"rwork\" , lrwork , size ( rwork )) return end if wptr => work ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZQR1UP ( m , n , k , q , m , r , m , u , v , wptr , rwptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_mtx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-NRHS right-hand-side matrix.  On output, the !! first N rows are overwritten by the solution matrix. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx\" , errmgr , \"tau\" , & k , size ( tau )) return else if ( size ( b , 1 ) /= m ) then call report_matrix_size_error ( \"solve_qr_no_pivot_mtx\" , errmgr , \"b\" , & m , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_qr (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"Incorrectly sized input array WORK, argument 4.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"Insufficient memory available.\" , & LA_OUT_OF_MEMORY_ERROR ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., . true ., a , tau , b , wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N,:) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : n , 1 : n ), b ( 1 : n ,:)) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_mtx_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-NRHS right-hand-side matrix.  On output, the !! first N rows are overwritten by the solution matrix. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , errmgr , & \"tau\" , k , size ( tau )) return else if ( size ( b , 1 ) /= m ) then call report_matrix_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , errmgr , & \"b\" , m , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_qr (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., . true ., a , tau , b , wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N,:) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : n , 1 : n ), b ( 1 : n ,:)) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_vec ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the M-element right-hand-side vector.  On output, the first !! N elements are overwritten with the solution vector. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , flag , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_vec\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , \"tau\" , & k , size ( tau )) return else if ( size ( b ) /= m ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , \"b\" , & m , size ( b )) return end if ! Workspace Query call mult_qr (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., a , tau , b , work = wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : n , 1 : n ), b ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_vec_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the M-element right-hand-side vector.  On output, the first !! N elements are overwritten with the solution vector. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_vec_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , errmgr , & \"tau\" , k , size ( tau )) return else if ( size ( b ) /= m ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , errmgr , & \"b\" , m , size ( b )) return end if ! Workspace Query call mult_qr (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_vec_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., a , tau , b , work = wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : n , 1 : n ), b ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_mtx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output, !! the first N rows are overwritten by the solution matrix. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , j , m , n , mn , nrhs , lwork , ismin , ismax , & rnk , maxmn , istat , lwork1 , lwork2 , lwork3 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr , s1 , c1 , s2 , c2 real ( real64 ), pointer , dimension (:) :: wptr , w , tau2 real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return else if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"b\" , & maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), olwork = lwork2 ) call mult_rz (. true ., . true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ,:), & olwork = lwork3 ) lwork = max ( lwork1 , lwork2 , lwork3 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( 1 : maxmn ,:) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call DLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call DLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), w ) ! Solve the triangular system T11 * B(1:rnk,1:nrhs) = B(1:rnk,1:nrhs) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : rnk , 1 : rnk ), b ( 1 : rnk ,:)) if ( n > rnk ) b ( rnk + 1 : n ,:) = zero ! Compute B(1:n,1:nrhs) = Y**T * B(1:n,1:nrhs) if ( rnk < n ) then call mult_rz (. true ., . true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ,:), w ) end if ! Apply the pivoting: B(1:N,1:NRHS) = P * B(1:N,1:NRHS) do j = 1 , nrhs do i = 1 , n wptr ( jpvt ( i )) = b ( i , j ) end do b ( 1 : n , j ) = wptr ( 1 : n ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_mtx_cmplx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output, !! the first N rows are overwritten by the solution matrix. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , m , n , mn , nrhs , lwork , ismin , ismax , & rnk , maxmn , istat , lwork1 , lwork2 , lwork3 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr complex ( real64 ) :: s1 , c1 , s2 , c2 complex ( real64 ), pointer , dimension (:) :: wptr , w , tau2 complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"jpvt\" , n , size ( jpvt )) return else if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , \"b\" , & maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), olwork = lwork2 ) call mult_rz (. true ., . true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ,:), & olwork = lwork3 ) lwork = max ( lwork1 , lwork2 , lwork3 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( 1 : maxmn ,:) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call ZLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call ZLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), w ) ! Solve the triangular system T11 * B(1:rnk,1:nrhs) = B(1:rnk,1:nrhs) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : rnk , 1 : rnk ), b ( 1 : rnk ,:)) if ( n > rnk ) b ( rnk + 1 : n ,:) = zero ! Compute B(1:n,1:nrhs) = Y**T * B(1:n,1:nrhs) if ( rnk < n ) then call mult_rz (. true ., . true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ,:), w ) end if ! Apply the pivoting: B(1:N,1:NRHS) = P * B(1:N,1:NRHS) do j = 1 , nrhs do i = 1 , n wptr ( jpvt ( i )) = b ( i , j ) end do b ( 1 : n , j ) = wptr ( 1 : n ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_vec ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output, !! the first N rows are overwritten by the solution vector. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , ismin , ismax , rnk , maxmn , & istat , lwork1 , lwork2 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr , s1 , c1 , s2 , c2 real ( real64 ), pointer , dimension (:) :: wptr , w , tau2 real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return else if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_rz (. true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ), olwork = lwork2 ) lwork = max ( lwork1 , lwork2 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( maxmn ) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call DLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call DLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., a , tau , b ( 1 : m )) ! Solve the triangular system T11 * B(1:rnk) = B(1:rnk) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : rnk , 1 : rnk ), & b ( 1 : rnk )) if ( n > rnk ) b ( rnk + 1 : n ) = zero ! Compute B(1:n) = Y**T * B(1:n) if ( rnk < n ) then call mult_rz (. true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ), w ) end if ! Apply the pivoting: B(1:N) = P * B(1:N) do i = 1 , n wptr ( jpvt ( i )) = b ( i ) end do b = wptr ( 1 : n ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_vec_cmplx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output, !! the first N rows are overwritten by the solution vector. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , ismin , ismax , rnk , maxmn , & istat , lwork1 , lwork2 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr complex ( real64 ) :: s1 , c1 , s2 , c2 complex ( real64 ), pointer , dimension (:) :: wptr , w , tau2 complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"jpvt\" , n , size ( jpvt )) return else if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_rz (. true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ), olwork = lwork2 ) lwork = max ( lwork1 , lwork2 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( maxmn ) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call ZLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call ZLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., a , tau , b ( 1 : m )) ! Solve the triangular system T11 * B(1:rnk) = B(1:rnk) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : rnk , 1 : rnk ), & b ( 1 : rnk )) if ( n > rnk ) b ( rnk + 1 : n ) = zero ! Compute B(1:n) = Y**T * B(1:n) if ( rnk < n ) then call mult_rz (. true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ), w ) end if ! Apply the pivoting: B(1:N) = P * B(1:N) do i = 1 , n wptr ( jpvt ( i )) = b ( i ) end do b = wptr ( 1 : n ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_qr.f90.html"},{"title":"linalg_rz.f90 – LINALG","text":"Contents Modules linalg_rz Source Code linalg_rz.f90 Source Code module linalg_rz use iso_fortran_env , only : int32 , real64 use linalg_errors use lapack use ferror implicit none private public :: rz_factor public :: mult_rz interface rz_factor module procedure :: rz_factor_dbl module procedure :: rz_factor_cmplx end interface interface mult_rz module procedure :: mult_rz_mtx module procedure :: mult_rz_mtx_cmplx module procedure :: mult_rz_vec module procedure :: mult_rz_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine rz_factor_dbl ( a , tau , work , olwork , err ) !! Factors an upper trapezoidal matrix by means of orthogonal !! transformations such that A = R Z = (R 0) Z . Z is an orthogonal !! matrix of dimension N-by-N, and R is an M-by-M upper triangular !! matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N upper trapezoidal matrix to factor.  On output, !! the leading M-by-M upper triangular part of the matrix contains the !! upper triangular matrix R, and elements N-L+1 to N of the !! first M rows of A, with the array tau, represent the orthogonal !! matrix Z as a product of M elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! An M-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , lwork , flag , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= m ) then call report_array_size_error ( \"rz_factor_dbl\" , errmgr , \"tau\" , m , & size ( tau )) return end if ! Workspace Query call DTZRZF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"rz_factor_dbl\" , errmgr , \"lwork\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"rz_factor_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Call DTZRZF call DTZRZF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine rz_factor_cmplx ( a , tau , work , olwork , err ) !! Factors an upper trapezoidal matrix by means of orthogonal !! transformations such that A = R Z = (R 0) Z . Z is an orthogonal !! matrix of dimension N-by-N, and R is an M-by-M upper triangular !! matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N upper trapezoidal matrix to factor.  On output, !! the leading M-by-M upper triangular part of the matrix contains the !! upper triangular matrix R, and elements N-L+1 to N of the !! first M rows of A, with the array tau, represent the orthogonal !! matrix Z as a product of M elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! An M-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , lwork , flag , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( tau ) /= m ) then call report_array_size_error ( \"rz_factor_cmplx\" , errmgr , \"tau\" , m , & size ( tau )) return end if ! Workspace Query call ZTZRZF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"rz_factor_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"rz_factor_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZTZRZF call ZTZRZF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_mtx ( lside , trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C or C = C op(Z) logical , intent ( in ) :: lside !! Set to true to compute C = op(Z) C; else, set to false to !! compute C = C op(Z). logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors.  If lside is true, M \\ge L \\ge 0; !! else, if lside is false, N \\ge L \\ge 0. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the K-by-LTA matrix Z, where LTA = M if !! lside is true; else, LTA = N if lside is false.  The I-th row !! must contain the Householder vector in the last k rows. Notice, !! the contents of this matrix are restored on exit. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product !! of the orthogonal matrix Z and the original matrix C. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of the elementary !! reflectors, where M \\ge K \\ge 0 if lside is true; else, !! N \\ge K \\ge 0 if lside is false. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , lwork , flag , istat , lda real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) lda = size ( a , 1 ) if ( lside ) then side = 'L' else side = 'R' end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( l > m . or . l < 0 ) then flag = 3 else if ( k > m ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 4 end if else if ( l > n . or . l < 0 ) then flag = 3 else if ( k > n ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= n ) then flag = 4 end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_mtx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call DORMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_mtx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMRZ call DORMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_mtx_cmplx ( lside , trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C or C = C op(Z). logical , intent ( in ) :: lside !! Set to true to compute C = op(Z) C; else, set to false to !! compute C = C op(Z). logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors.  If lside is true, M \\ge L \\ge 0; !! else, if lside is false, N \\ge L \\ge 0. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the K-by-LTA matrix Z, where LTA = M if !! lside is true; else, LTA = N if lside is false.  The I-th row !! must contain the Householder vector in the last k rows. Notice, !! the contents of this matrix are restored on exit. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product !! of the orthogonal matrix Z and the original matrix C. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of the elementary !! reflectors, where M \\ge K \\ge 0 if lside is true; else, !! N \\ge K \\ge 0 if lside is false. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , lwork , flag , istat , lda complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) lda = size ( a , 1 ) if ( lside ) then side = 'L' else side = 'R' end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( l > m . or . l < 0 ) then flag = 3 else if ( k > m ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 4 end if else if ( l > n . or . l < 0 ) then flag = 3 else if ( k > n ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= n ) then flag = 4 end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_mtx_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call ZUNMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMRZ call ZUNMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_vec ( trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C. logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the M-by-M matrix Z.  The I-th row must contain !! the Householder vector in the last k rows. Notice, the contents !! of this matrix are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! An M-element array containing the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element array C.  On output, the product !! of Z and C. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , k , lwork , flag , istat , lda real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) lda = size ( a , 1 ) side = 'L' if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( l > m . or . l < 0 ) then flag = 2 else if ( k > m ) then flag = 4 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_vec\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call DORMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMRZ call DORMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_vec_cmplx ( trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C. logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the M-by-M matrix Z.  The I-th row must contain !! the Householder vector in the last k rows. Notice, the contents !! of this matrix are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! An M-element array containing the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element array C.  On output, the product !! of Z and C. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , k , lwork , flag , istat , lda complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) lda = size ( a , 1 ) side = 'L' if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( l > m . or . l < 0 ) then flag = 2 else if ( k > m ) then flag = 4 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_vec_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call ZUNMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMRZ call ZUNMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_rz.f90.html"},{"title":"linalg_sorting.f90 – LINALG","text":"Contents Modules linalg_sorting Source Code linalg_sorting.f90 Source Code ! linalg_sorting.f90 module linalg_sorting use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use ferror implicit none private public :: sort interface sort !! An interface to the sorting routines. module procedure :: sort_dbl_array module procedure :: sort_dbl_array_ind module procedure :: sort_cmplx_array module procedure :: sort_cmplx_array_ind module procedure :: sort_eigen_cmplx module procedure :: sort_eigen_dbl module procedure :: sort_int32_array module procedure :: sort_int32_array_ind end interface contains ! ****************************************************************************** ! SORTING ROUTINES ! ------------------------------------------------------------------------------ subroutine sort_dbl_array ( x , ascend ) !! Sorts an array. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables character :: id integer ( int32 ) :: n , info ! Initialization if ( present ( ascend )) then if ( ascend ) then id = 'I' else id = 'D' end if else id = 'I' end if n = size ( x ) ! Process call DLASRT ( id , n , x , info ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_dbl_array_ind ( x , ind , ascend , err ) !! Sorts an array. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_dbl_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_dbl_ind ( dir , x , ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_cmplx_array ( x , ascend ) !! Sorts an array. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables logical :: dir ! Initialization if ( present ( ascend )) then dir = ascend else dir = . true . end if ! Process call qsort_cmplx ( dir , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_cmplx_array_ind ( x , ind , ascend , err ) !! Sorts an array. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_cmplx_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_cmplx_ind ( dir , x , ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_eigen_cmplx ( vals , vecs , ascend , err ) !! Sorts eigenvalues and their associated eigenvectors. complex ( real64 ), intent ( inout ), dimension (:) :: vals !! On input, an N-element array containing the eigenvalues.  On output, !! the sored eigenvalues. complex ( real64 ), intent ( inout ), dimension (:,:) :: vecs !! On input, the N-by-N matrix containing the eigenvectors (one vector !! per column) associated with vals.  On output, the sorted eigenvector !! matrix. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , n , flag logical :: dir integer ( int32 ), allocatable , dimension (:) :: ind ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Ensure the eigenvector matrix is sized appropriately n = size ( vals ) if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"sort_eigen_cmplx\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) end if ! Allocate memory for the tracking array allocate ( ind ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"sort_eigen_cmplx\" , errmgr , flag ) return end if do i = 1 , n ind ( i ) = i end do ! Sort call qsort_cmplx_ind ( dir , vals , ind ) ! Shift the eigenvectors around to keep them associated with the ! appropriate eigenvalue vecs = vecs (:, ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_eigen_dbl ( vals , vecs , ascend , err ) !! Sorts eigenvalues and their associated eigenvectors. real ( real64 ), intent ( inout ), dimension (:) :: vals !! On input, an N-element array containing the eigenvalues.  On output, !! the sored eigenvalues. real ( real64 ), intent ( inout ), dimension (:,:) :: vecs !! On input, the N-by-N matrix containing the eigenvectors (one vector !! per column) associated with vals.  On output, the sorted eigenvector !! matrix. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , n , flag logical :: dir integer ( int32 ), allocatable , dimension (:) :: ind ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Ensure the eigenvector matrix is sized appropriately n = size ( vals ) if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"sort_eigen_dbl\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) return end if ! Allocate memory for the tracking array allocate ( ind ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"sort_eigen_dbl\" , errmgr , flag ) return end if do i = 1 , n ind ( i ) = i end do ! Sort call qsort_dbl_ind ( dir , vals , ind ) ! Shift the eigenvectors around to keep them associated with the ! appropriate eigenvalue vecs = vecs (:, ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_int32_array ( x , ascend ) !! Sorts an array. integer ( int32 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables logical :: dir ! Initialization if ( present ( ascend )) then dir = ascend else dir = . true . end if ! Process call qsort_int32 ( dir , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_int32_array_ind ( x , ind , ascend , err ) !! Sorts an array. integer ( int32 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_int32_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_int32_ind ( dir , x , ind ) end subroutine ! ****************************************************************************** ! PRIVATE HELPER ROUTINES ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_dbl_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend real ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call dbl_partition_ind ( ascend , x , ind , iq ) call qsort_dbl_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_dbl_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine dbl_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend real ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp real ( real64 ) :: temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 recursive subroutine qsort_cmplx ( ascend , x ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call cmplx_partition ( ascend , x , iq ) call qsort_cmplx ( ascend , x (: iq - 1 )) call qsort_cmplx ( ascend , x ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[out] marker The partioning marker. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. subroutine cmplx_partition ( ascend , x , marker ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j complex ( real64 ) :: temp real ( real64 ) :: pivot ! Process pivot = real ( x ( 1 ), real64 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 recursive subroutine qsort_cmplx_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call cmplx_partition_ind ( ascend , x , ind , iq ) call qsort_cmplx_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_cmplx_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. subroutine cmplx_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp complex ( real64 ) :: temp real ( real64 ) :: pivot ! Process pivot = real ( x ( 1 ), real64 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_int32 ( ascend , x ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call int32_partition ( ascend , x , iq ) call qsort_int32 ( ascend , x (: iq - 1 )) call qsort_int32 ( ascend , x ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine int32_partition ( ascend , x , marker ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_int32_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call int32_partition_ind ( ascend , x , ind , iq ) call qsort_int32_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_int32_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine int32_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp , temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_sorting.f90.html"},{"title":"linalg_sparse.f90 – LINALG","text":"Contents Modules linalg_sparse Source Code linalg_sparse.f90 Source Code module linalg_sparse use iso_fortran_env , only : int32 , real64 use sparskit use blas use ferror use linalg_errors implicit none private public :: csr_matrix public :: msr_matrix public :: size public :: create_empty_csr_matrix public :: create_empty_msr_matrix public :: nonzero_count public :: dense_to_csr public :: diag_to_csr public :: banded_to_csr public :: csr_to_dense public :: csr_to_msr public :: msr_to_csr public :: dense_to_msr public :: msr_to_dense public :: create_csr_matrix public :: matmul public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) public :: operator ( / ) public :: assignment ( = ) public :: transpose public :: sparse_direct_solve public :: pgmres_solver type :: csr_matrix !! A sparse matrix stored in compressed sparse row (CSR) format. integer ( int32 ), allocatable , dimension (:) :: row_indices !! An M+1 element array containing the indices in V an JA at which the !! requested row starts. integer ( int32 ), allocatable , dimension (:) :: column_indices !! An NNZ-element array, where NNZ is the number of non-zero values, !! containing the column indices of each value. real ( real64 ), allocatable , dimension (:) :: values !! An NNZ-element array, where NNZ is the number of non-zero values, !! containing the non-zero values of the matrix. integer ( int32 ), private :: n = 0 !! The number of columns in the matrix. contains procedure , public :: get => csr_get_element procedure , public :: extract_diagonal => csr_extract_diagonal end type ! ------------------------------------------------------------------------------ type :: msr_matrix !! A sparse matrix stored in modified sparse row format. integer ( int32 ), allocatable , dimension (:) :: indices !! An NNZ-element array containing the index information. real ( real64 ), allocatable , dimension (:) :: values !! An NNZ-element array containing the non-zero values from the !! matrix.  The first MIN(M,N) elements contain the diagonal. integer ( int32 ) :: m = 0 !! The number of rows in the matrix. integer ( int32 ) :: n = 0 !! The number of columns in the matrix. integer ( int32 ) :: nnz = 0 !! The number of nonzero values in the matrix. end type ! ------------------------------------------------------------------------------ interface nonzero_count module procedure :: nonzero_count_csr module procedure :: nonzero_count_msr end interface interface size module procedure :: csr_size module procedure :: msr_size end interface interface matmul module procedure :: csr_mtx_mtx_mult module procedure :: csr_mtx_vec_mult end interface interface operator ( + ) module procedure :: csr_mtx_add end interface interface operator ( - ) module procedure :: csr_mtx_sub end interface interface operator ( * ) module procedure :: csr_mtx_mult_scalar_1 module procedure :: csr_mtx_mult_scalar_2 end interface interface operator ( / ) module procedure :: csr_mtx_divide_scalar_1 end interface interface assignment ( = ) module procedure :: csr_assign_to_dense module procedure :: dense_assign_to_csr module procedure :: msr_assign_to_dense module procedure :: dense_assign_to_msr module procedure :: csr_assign_to_msr module procedure :: msr_assign_to_csr end interface interface transpose module procedure :: csr_transpose end interface interface sparse_direct_solve module procedure :: csr_solve_sparse_direct end interface interface pgmres_solver module procedure :: csr_pgmres_solver end interface contains ! ****************************************************************************** ! CSR ROUTINES ! ------------------------------------------------------------------------------ function csr_get_element ( this , i , j ) result ( rst ) !! Retrieves the element at the specified row and column. class ( csr_matrix ), intent ( in ) :: this !! The CSR matrix object. integer ( int32 ), intent ( in ) :: i !! The row index. integer ( int32 ), intent ( in ) :: j !! The column index. real ( real64 ) :: rst !! The value at the specified row and column. ! Local Variables integer ( int32 ) :: iadd logical :: sorted ! Initialization sorted = . false . ! Process if (. not . allocated ( this % row_indices ) . or . & . not . allocated ( this % column_indices ) . or . & . not . allocated ( this % values )) & then rst = 0.0d0 return end if rst = getelm ( i , j , this % values , this % column_indices , this % row_indices , & iadd , sorted ) end function ! ------------------------------------------------------------------------------ pure function csr_size ( x , dim ) result ( rst ) !! Returns the size of the matrix along the specified dimension. class ( csr_matrix ), intent ( in ) :: x !! The CSR matrix object. integer ( int32 ), intent ( in ) :: dim !! The dimension to return the size of. integer ( int32 ) :: rst !! The size of the matrix along the specified dimension. ! Process select case ( dim ) case ( 1 ) if ( allocated ( x % row_indices )) then rst = size ( x % row_indices ) - 1 else rst = 0 end if case ( 2 ) rst = x % n case default rst = 0 end select end function ! ------------------------------------------------------------------------------ pure function nonzero_count_csr ( x ) result ( rst ) !! Returns the number of non-zero values in the matrix. class ( csr_matrix ), intent ( in ) :: x !! The CSR matrix object. integer ( int32 ) :: rst !! The number of non-zero values in the matrix. ! Process if ( allocated ( x % values )) then rst = size ( x % values ) else rst = 0 end if end function ! ------------------------------------------------------------------------------ function create_empty_csr_matrix ( m , n , nnz , err ) result ( rst ) !! Creates an empty CSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ) :: nnz !! The number of non-zero values in the matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The empty CSR matrix. ! Local Variables integer ( int32 ) :: flag , m1 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m1 = m + 1 ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( nnz < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of non-zero values must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Allocation rst % n = n allocate ( rst % row_indices ( m1 ), rst % column_indices ( nnz ), source = 0 , & stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nnz ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_empty_csr_matrix\" , errmgr , flag ) return end if end function ! ------------------------------------------------------------------------------ function dense_to_csr ( a , err ) result ( rst ) !! Converts a dense matrix to a CSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The dense matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , j , k , m , n , nnz real ( real64 ) :: t class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if t = 2.0d0 * epsilon ( t ) m = size ( a , 1 ) n = size ( a , 2 ) nnz = 0 ! Determine how many non-zero values exist do j = 1 , n do i = 1 , m if ( abs ( a ( i , j )) > t ) then nnz = nnz + 1 end if end do end do ! Memory Allocation rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Store the non-zero values k = 1 rst % row_indices ( 1 ) = 1 do i = 1 , m inner_loop : do j = 1 , n if ( abs ( a ( i , j )) < t ) cycle inner_loop rst % column_indices ( k ) = j rst % values ( k ) = a ( i , j ) k = k + 1 end do inner_loop rst % row_indices ( i + 1 ) = k end do end function ! ------------------------------------------------------------------------------ function banded_to_csr ( m , ml , mu , a , err ) result ( rst ) !! Converts a banded matrix to a CSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix. integer ( int32 ), intent ( in ) :: ml !! The number of lower diagonals in the banded matrix. integer ( int32 ), intent ( in ) :: mu !! The number of upper diagonals in the banded matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: n , nnz , flag , lowd , lda integer ( int32 ), allocatable , dimension (:) :: ia , ja real ( real64 ), allocatable , dimension (:) :: v class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if lda = size ( a , 1 ) n = size ( a , 2 ) nnz = lda * n lowd = ml + mu + 1 ! Input Checking if ( ml < 0 . or . mu < 0 ) then call errmgr % report_error ( \"banded_to_csr\" , \"The bandwidth \" // & \"dimensions cannot be negative.\" , LA_INVALID_INPUT_ERROR ) return end if if ( lda /= ml + mu + 1 ) then call errmgr % report_error ( \"banded_to_csr\" , \"The number of rows in \" // & \"the banded matrix does not match the supplied bandwidth \" // & \"dimensions.\" , LA_MATRIX_FORMAT_ERROR ) return end if ! Allocation allocate ( ia ( m + 1 ), ja ( nnz ), v ( nnz ), stat = flag ) if ( flag /= 0 ) go to 10 ! Process call bndcsr ( m , a , lda , lowd , ml , mu , v , ja , ia , nnz , flag ) nnz = ia ( m + 1 ) - 1 ! Put into the sparse matrix structure allocate ( rst % row_indices ( m + 1 ), source = ia , stat = flag ) if ( flag == 0 ) allocate ( rst % column_indices ( nnz ), source = ja (: nnz ), & stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nnz ), source = v (: nnz ), stat = flag ) if ( flag /= 0 ) go to 10 rst % n = n ! End return ! Memory Error 10 continue call report_memory_error ( \"banded_to_csr\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ subroutine csr_to_dense ( a , x , err ) !! Converts a CSR matrix to a dense matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , j , k , m , n , nnz , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Check if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call report_matrix_size_error ( \"csr_to_dense\" , errmgr , \"x\" , m , n , & size ( x , 1 ), size ( x , 2 )) return end if ! Process do i = 1 , m x ( i ,:) = 0.0d0 do k = a % row_indices ( i ), a % row_indices ( i + 1 ) - 1 j = a % column_indices ( k ) x ( i , j ) = a % values ( k ) end do end do end subroutine ! ------------------------------------------------------------------------------ function diag_to_csr ( a , err ) result ( rst ) !! Converts a diagonal matrix to a CSR matrix. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , n , n1 , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a ) n1 = n + 1 ! Allocation allocate ( rst % row_indices ( n1 ), rst % column_indices ( n ), stat = flag ) if ( flag == 0 ) allocate ( rst % values ( n ), source = a , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"diag_to_csr\" , errmgr , flag ) return end if rst % n = n ! Populate IA & JA do i = 1 , n rst % column_indices ( i ) = i rst % row_indices ( i ) = i end do rst % row_indices ( n1 ) = n1 end function ! ------------------------------------------------------------------------------ subroutine csr_assign_to_dense ( dense , sparse ) !! Assigns the values of a CSR matrix to a dense matrix. real ( real64 ), intent ( out ), dimension (:,:) :: dense !! The dense matrix. class ( csr_matrix ), intent ( in ) :: sparse !! The CSR matrix. ! Process call csr_to_dense ( sparse , dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine dense_assign_to_csr ( sparse , dense ) !! Assigns the values of a dense matrix to a CSR matrix. type ( csr_matrix ), intent ( out ) :: sparse !! The CSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: dense !! The dense matrix. ! Process sparse = dense_to_csr ( dense ) end subroutine ! ------------------------------------------------------------------------------ function csr_mtx_mtx_mult ( a , b ) result ( rst ) !! Multiplies two CSR matrices together. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_mult = 0 integer ( int32 ), parameter :: full_mult = 1 integer ( int32 ) :: flag , m , n , k , nnza , nnzb , nnzc , ierr integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Check if ( size ( b , 1 ) /= k ) then call report_inner_matrix_dimension_error ( \"csr_mtx_mtx_mult\" , errmgr , & \"a\" , \"b\" , k , size ( b , 1 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call amub ( m , n , sym_mult , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call amub ( m , n , sym_mult , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actual NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual product call amub ( m , n , full_mult , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_mtx_mult\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_vec_mult ( a , b ) result ( rst ) !! Multiplies a CSR matrix by a vector. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ), dimension (:) :: b !! The vector. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting vector. ! Local Variables integer ( int32 ) :: i , k , k1 , k2 , n , p , flag real ( real64 ) :: t type ( errors ) :: errmgr ! Initialization n = size ( a , 1 ) p = size ( a , 2 ) ! Input Check if ( size ( b ) /= p ) then call report_inner_matrix_dimension_error ( \"csr_mtx_vec_mult\" , errmgr , & \"a\" , \"b\" , p , size ( b )) return end if ! Memory Allocation allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_mtx_vec_mult\" , errmgr , flag ) return end if ! Process do i = 1 , n t = 0.0d0 k1 = a % row_indices ( i ) k2 = a % row_indices ( i + 1 ) - 1 do k = k1 , k2 t = t + a % values ( k ) * b ( a % column_indices ( k )) end do rst ( i ) = t end do end function ! ------------------------------------------------------------------------------ function csr_mtx_add ( a , b ) result ( rst ) !! Adds two CSR matrices. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_add = 0 integer ( int32 ), parameter :: full_add = 1 integer ( int32 ) :: m , n , nnza , nnzb , nnzc , ierr , flag integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Checking if ( size ( b , 1 ) /= m . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"csr_mtx_add\" , errmgr , \"b\" , m , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call aplb ( m , n , sym_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call aplb ( m , n , sym_add , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actuall NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual sum call aplb ( m , n , full_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_add\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_sub ( a , b ) result ( rst ) !! Subtracts two CSR matrices. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_add = 0 integer ( int32 ) :: m , n , nnza , nnzb , nnzc , ierr , flag integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Checking if ( size ( b , 1 ) /= m . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"csr_mtx_sub\" , errmgr , \"b\" , m , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call aplb ( m , n , sym_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call aplb ( m , n , sym_add , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actuall NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual sum call aplsb ( m , n , a % values , a % column_indices , a % row_indices , - 1.0d0 , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_sub\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_mult_scalar_1 ( a , b ) result ( rst ) !! Multiplies a CSR matrix by a scalar. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ) :: b !! The scalar. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = a % row_indices rst % column_indices = a % column_indices rst % values = b * a % values end function ! ------------------------------------------------------------------------------ function csr_mtx_mult_scalar_2 ( a , b ) result ( rst ) !! Multiplies a scalar by a CSR matrix. real ( real64 ), intent ( in ) :: a !! The scalar. class ( csr_matrix ), intent ( in ) :: b !! The CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) nnz = nonzero_count ( b ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = b % row_indices rst % column_indices = b % column_indices rst % values = a * b % values end function ! ------------------------------------------------------------------------------ function csr_mtx_divide_scalar_1 ( a , b ) result ( rst ) !! Divides a CSR matrix by a scalar. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ) :: b !! The scalar. type ( csr_matrix ) :: rst ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = a % row_indices rst % column_indices = a % column_indices rst % values = a % values / b end function ! ------------------------------------------------------------------------------ function csr_transpose ( a ) result ( rst ) !! Transposes a CSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. type ( csr_matrix ) :: rst !! The transposed CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) rst = create_empty_csr_matrix ( n , m , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Process call csrcsc2 ( m , n , 1 , 1 , a % values , a % column_indices , a % row_indices , & rst % values , rst % column_indices , rst % row_indices ) end function ! ------------------------------------------------------------------------------ subroutine csr_extract_diagonal ( a , diag , err ) !! Extracts the diagonal from a CSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The diagonal values. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , len , flag integer ( int32 ), allocatable , dimension (:) :: idiag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Check if ( size ( diag ) /= mn ) then call report_array_size_error ( \"csr_extract_diagonal\" , errmgr , \"diag\" , & mn , size ( diag )) return end if ! Memory Allocation allocate ( idiag ( mn ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_extract_diagonal\" , errmgr , flag ) return end if ! Process call getdia ( m , n , 0 , a % values , a % column_indices , a % row_indices , len , & diag , idiag , 0 ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_solve_sparse_direct ( a , b , x , droptol , err ) !! Solves a linear system using a direct method. class ( csr_matrix ), intent ( in ) :: a !! The matrix. real ( real64 ), intent ( in ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. real ( real64 ), intent ( in ), optional :: droptol !! The drop tolerance for the ILUT factorization. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , m , n , nnz , lfil , iwk , ierr , flag integer ( int32 ), allocatable , dimension (:) :: jlu , ju , jw real ( real64 ), allocatable , dimension (:) :: alu , w real ( real64 ) :: dt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( droptol )) then dt = droptol else dt = sqrt ( epsilon ( dt )) end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Checking if ( m /= n ) then call report_square_matrix_error ( \"csr_solve_sparse_direct\" , errmgr , & \"a\" , m , m , n ) return end if if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"csr_solve_sparse_direct\" , & errmgr , \"a\" , \"x\" , n , size ( x )) return end if if ( size ( b ) /= n ) then call report_array_size_error ( \"csr_solve_sparse_direct\" , errmgr , \"b\" , & n , size ( b )) return end if ! Parameter Determination lfil = 1 do i = 1 , m lfil = max ( lfil , a % row_indices ( i + 1 ) - a % row_indices ( i )) end do iwk = max ( lfil * m , nnz ) ! somewhat arbitrary - can be adjusted ! Local Memory Allocation allocate ( alu ( iwk ), w ( n + 1 ), jlu ( iwk ), ju ( n ), jw ( 2 * n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Factorization do ! Factor the matrix call ilut ( n , a % values , a % column_indices , a % row_indices , lfil , dt , & alu , jlu , ju , iwk , w , jw , ierr ) ! Check the error flag if ( ierr == 0 ) then ! Success exit else if ( ierr > 0 ) then ! Zero pivot else if ( ierr == - 1 ) then ! The input matrix is not formatted correctly go to 20 else if ( ierr == - 2 . or . ierr == - 3 ) then ! ALU and JLU are too small - try something larger iwk = min ( iwk + m + n , m * n ) deallocate ( alu ) deallocate ( jlu ) allocate ( alu ( iwk ), jlu ( iwk ), stat = flag ) if ( flag /= 0 ) go to 10 else if ( ierr == - 4 ) then ! Illegal value for LFIL - reset and try again lfil = n else if ( ierr == - 5 ) then ! Zero row encountered go to 30 else ! We should never get here, but just in case go to 40 end if end do ! Solution call lusol ( n , b , x , alu , jlu , ju ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_solve_sparse_direct\" , errmgr , flag ) return ! Matrix Format Error 20 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"The input matrix was incorrectly formatted.  A row with more \" // & \"than N entries was found.\" , LA_MATRIX_FORMAT_ERROR ) return ! Zero Row Error 30 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"A row with all zeros was encountered in the matrix.\" , & LA_SINGULAR_MATRIX_ERROR ) return ! Unknown Error 40 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , \"ILUT encountered \" // & \"an unknown error.  The error code from the ILUT routine is \" // & \"provided in the output.\" , ierr ) return ! Zero Pivot Error 50 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"A zero pivot was encountered.\" , LA_SINGULAR_MATRIX_ERROR ) return end subroutine ! ****************************************************************************** ! MSR ROUTINES ! ------------------------------------------------------------------------------ ! TO DO: MSR_GET_ELEMENT ! ------------------------------------------------------------------------------ pure function msr_size ( x , dim ) result ( rst ) !! Returns the size of the specified dimension of an MSR matrix. class ( msr_matrix ), intent ( in ) :: x !! The MSR matrix. integer ( int32 ), intent ( in ) :: dim !! The dimension to return the size of. integer ( int32 ) :: rst !! The size of the specified dimension. ! Process select case ( dim ) case ( 1 ) rst = x % m case ( 2 ) rst = x % n case default rst = 0 end select end function ! ------------------------------------------------------------------------------ pure function nonzero_count_msr ( x ) result ( rst ) !! Returns the number of non-zero elements in an MSR matrix. class ( msr_matrix ), intent ( in ) :: x !! The MSR matrix. integer ( int32 ) :: rst !! The number of non-zero elements. ! Process rst = x % nnz end function ! ------------------------------------------------------------------------------ function create_empty_msr_matrix ( m , n , nnz , err ) result ( rst ) !! Creates an empty MSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ) :: nnz !! The number of non-zero elements in the matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables integer ( int32 ) :: nelem , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( nnz < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of non-zero values must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Allocation rst % m = m rst % n = n rst % nnz = nnz mn = min ( m , n ) nelem = m + 1 + nnz - mn allocate ( rst % indices ( nelem ), source = 0 , stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nelem ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_empty_msr_matrix\" , errmgr , flag ) return end if end function ! ------------------------------------------------------------------------------ function csr_to_msr ( a , err ) result ( rst ) !! Converts a CSR matrix to an MSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz , flag integer ( int32 ), allocatable , dimension (:) :: iwork , jc , ic real ( real64 ), allocatable , dimension (:) :: work , ac class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Memory Allocation rst = create_empty_msr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( work ( m ), iwork ( m + 1 ), stat = flag ) if ( flag == 0 ) allocate ( ac ( nnz ), source = a % values , stat = flag ) if ( flag == 0 ) allocate ( jc ( nnz ), source = a % column_indices , stat = flag ) if ( flag == 0 ) allocate ( ic ( m + 1 ), source = a % row_indices , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_to_msr\" , errmgr , flag ) return end if ! Perform the conversion call csrmsr ( m , ac , jc , ic , rst % values , rst % indices , work , iwork ) end function ! ------------------------------------------------------------------------------ function msr_to_csr ( a , err ) result ( rst ) !! Converts an MSR matrix to a CSR matrix. class ( msr_matrix ), intent ( in ) :: a !! The MSR matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz , flag integer ( int32 ), allocatable , dimension (:) :: iwork real ( real64 ), allocatable , dimension (:) :: work class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Memory Allocation rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( work ( m ), iwork ( m + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"msr_to_csr\" , errmgr , flag ) return end if ! Process call msrcsr ( m , a % values , a % indices , rst % values , rst % column_indices , & rst % row_indices , work , iwork ) end function ! ------------------------------------------------------------------------------ function dense_to_msr ( a , err ) result ( rst ) !! Converts a dense matrix to an MSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The dense matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables type ( csr_matrix ) :: csr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Convert to CSR, and then from CSR to MSR csr = dense_to_csr ( a , errmgr ) ! Convert to MSR rst = csr_to_msr ( csr , errmgr ) end function ! ------------------------------------------------------------------------------ subroutine msr_to_dense ( a , x , err ) !! Converts an MSR matrix to a dense matrix. class ( msr_matrix ), intent ( in ) :: a !! The MSR matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , flag type ( csr_matrix ) :: csr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) ! Input Check if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call report_matrix_size_error ( \"msr_to_dense\" , errmgr , \"x\" , m , n , & size ( x , 1 ), size ( x , 2 )) return end if ! Process csr = msr_to_csr ( a , errmgr ) if ( errmgr % has_error_occurred ()) return call csr_to_dense ( csr , x , errmgr ) end subroutine ! ------------------------------------------------------------------------------ subroutine msr_assign_to_dense ( dense , msr ) !! Assigns an MSR matrix to a dense matrix. real ( real64 ), intent ( out ), dimension (:,:) :: dense !! The dense matrix. class ( msr_matrix ), intent ( in ) :: msr !! The MSR matrix. ! Process call msr_to_dense ( msr , dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine dense_assign_to_msr ( msr , dense ) !! Assigns a dense matrix to an MSR matrix. type ( msr_matrix ), intent ( out ) :: msr !! The MSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: dense !! The dense matrix. ! Process msr = dense_to_msr ( dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_assign_to_msr ( msr , csr ) !! Assigns a CSR matrix to an MSR matrix. type ( msr_matrix ), intent ( out ) :: msr !! The MSR matrix. class ( csr_matrix ), intent ( in ) :: csr !! The CSR matrix. ! Process msr = csr_to_msr ( csr ) end subroutine ! ------------------------------------------------------------------------------ subroutine msr_assign_to_csr ( csr , msr ) !! Assigns an MSR matrix to a CSR matrix. type ( csr_matrix ), intent ( out ) :: csr !! The CSR matrix. class ( msr_matrix ), intent ( in ) :: msr !! The MSR matrix. ! Process csr = msr_to_csr ( msr ) end subroutine ! ------------------------------------------------------------------------------ function create_csr_matrix ( m , n , rows , cols , vals , err ) result ( rst ) !! Creates a CSR matrix from the input data. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ), dimension (:) :: rows !! The row indices. integer ( int32 ), intent ( in ), dimension (:) :: cols !! The column indices. real ( real64 ), intent ( in ), dimension (:) :: vals !! The values. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , flag , nnz integer ( int32 ), allocatable , dimension (:) :: ir class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nnz = size ( rows ) ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( cols ) /= nnz . or . size ( vals ) /= nnz ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The size of the input arrays must be the same.\" , & LA_ARRAY_SIZE_ERROR ) return end if do i = 1 , nnz if ( rows ( i ) < 1 . or . rows ( i ) > m ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"All row indices must be within the bounds of the matrix.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( cols ( i ) < 1 . or . cols ( i ) > n ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"All column indices must be within the bounds of the matrix.\" , & LA_INVALID_INPUT_ERROR ) return end if end do allocate ( ir ( nnz ), source = rows , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_csr_matrix\" , errmgr , flag ) return end if ! Create an empty matrix rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Populate the empty matrix call coocsr ( m , nnz , vals , ir , cols , rst % values , rst % column_indices , & rst % row_indices ) call csort ( m , rst % values , rst % column_indices , rst % row_indices , . true .) end function ! ****************************************************************************** ! ITERATIVE SOLVERS ! ------------------------------------------------------------------------------ ! Additional References: ! - https://www.diva-portal.org/smash/get/diva2:360739/FULLTEXT01.pdf subroutine csr_pgmres_solver ( a , lu , ju , b , x , im , tol , maxits , iout , err ) !! Solves a linear system using the PGMRES method. class ( csr_matrix ), intent ( in ) :: a !! The matrix. class ( msr_matrix ), intent ( in ) :: lu !! The LU factored matrix. integer ( int32 ), intent ( in ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( inout ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. integer ( int32 ), intent ( in ), optional :: im !! The Krylov subspace size. integer ( int32 ), intent ( in ), optional :: maxits !! The maximum number of iterations. integer ( int32 ), intent ( in ), optional :: iout !! The output level. real ( real64 ), intent ( in ), optional :: tol !! The convergence tolerance. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , ierr , flag , io , mit , krylov real ( real64 ) :: eps real ( real64 ), allocatable , dimension (:,:) :: vv class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( im )) then krylov = im else krylov = min ( n , 50 ) end if if ( present ( tol )) then eps = tol else eps = sqrt ( epsilon ( eps )) end if if ( present ( maxits )) then mit = maxits else mit = 100 end if if ( present ( iout )) then io = iout else io = 0 end if ! Input Checking if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"csr_pgmres_solver\" , errmgr , \"a\" , n , n , & size ( a , 2 )) return end if if ( size ( lu , 1 ) /= n . or . size ( lu , 2 ) /= n ) then call report_matrix_size_error ( \"csr_pgmres_solver\" , errmgr , \"lu\" , n , n , & size ( lu , 1 ), size ( lu , 2 )) return end if if ( size ( b ) /= n ) then call report_array_size_error ( \"csr_pgmres_solver\" , errmgr , \"b\" , n , size ( b )) return end if if ( size ( x ) /= n ) then call report_array_size_error ( \"csr_pgmres_solver\" , errmgr , \"x\" , n , size ( x )) return end if if ( eps < epsilon ( eps )) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"The convergence tolerance is too small.\" , LA_INVALID_INPUT_ERROR ) return end if if ( mit < 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"Too few iterations allowed.\" , LA_INVALID_INPUT_ERROR ) return end if if ( krylov < 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"The requested Krylov subspace size is too small.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Memory Allocation allocate ( vv ( n , krylov + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_pgmres_solver\" , errmgr , flag ) return end if ! Process call pgmres ( n , krylov , b , x , vv , eps , mit , io , a % values , a % column_indices , & a % row_indices , lu % values , lu % indices , ju , ierr ) if ( ierr == 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"Convergence could not be achieved to the requested tolerance \" // & \"in the allowed number of iterations.\" , LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_sparse.f90.html"},{"title":"linalg_svd.f90 – LINALG","text":"Contents Modules linalg_svd Source Code linalg_svd.f90 Source Code module linalg_svd use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors implicit none private public :: svd interface svd module procedure :: svd_dbl module procedure :: svd_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine svd_dbl ( a , s , u , vt , work , olwork , err ) !! Computes the singular value decomposition of an M-by-N matrix A such !! that A = U S V&#94;T where U is an M-by-M orthogonal matrix, S !! is an M-by-N diagonal matrix containing the singular values, and V !! is an N-by-N orthogonal matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  The matrix is overwritten on !! output. real ( real64 ), intent ( out ), dimension (:) :: s !! A MIN(M, N)-element array containing the singular values of a sorted !! in descending order. real ( real64 ), intent ( out ), optional , dimension (:,:) :: u !! An optional argument, that if supplied, is used to contain the !! orthogonal matrix U from the decomposition.  The matrix U !! contains the left singular vectors, and can be either M-by-M !! (all left singular vectors are computed), or M-by-MIN(M,N) (only the !! first MIN(M, N) left singular vectors are computed). real ( real64 ), intent ( out ), optional , dimension (:,:) :: vt !! An optional argument, that if supplied, is used to contain the !! transpose of the N-by-N orthogonal matrix V.  The matrix V !! contains the right singular vectors. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: jobu , jobvt integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else if ( size ( u , 2 ) == mn ) then jobu = 'S' end if else jobu = 'N' end if if ( present ( vt )) then jobvt = 'A' else jobvt = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( s ) /= mn ) then call report_array_size_error ( \"svd_dbl\" , errmgr , \"s\" , mn , size ( s )) return else if ( present ( u )) then if ( size ( u , 1 ) /= m ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if if ( size ( u , 2 ) /= m . and . size ( u , 2 ) /= mn ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if else if ( present ( vt )) then if ( size ( vt , 1 ) /= n . or . size ( vt , 2 ) /= n ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"vt\" , n , n , & size ( vt , 1 ), size ( vt , 2 )) return end if end if ! Workspace Query call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , temp , - 1 , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"svd_dbl\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGESVD if ( present ( u ) . and . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , u , m , vt , n , wptr , lwork , & flag ) else if ( present ( u ) . and . . not . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , u , m , temp , n , wptr , & lwork , flag ) else if (. not . present ( u ) . and . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , vt , n , wptr , & lwork , flag ) else call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , wptr , & lwork , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"svd_dbl\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine svd_cmplx ( a , s , u , vt , work , olwork , rwork , err ) !! Computes the singular value decomposition of an M-by-N matrix A such !! that A = U S V&#94;H where U is an M-by-M orthogonal matrix, S !! is an M-by-N diagonal matrix containing the singular values, and V !! is an N-by-N orthogonal matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  The matrix is overwritten on !! output. real ( real64 ), intent ( out ), dimension (:) :: s !! A MIN(M, N)-element array containing the singular values of a sorted !! in descending order. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: u !! An optional argument, that if supplied, is used to contain the !! orthogonal matrix U from the decomposition.  The matrix U !! contains the left singular vectors, and can be either M-by-M !! (all left singular vectors are computed), or M-by-MIN(M,N) (only the !! first MIN(M, N) left singular vectors are computed). complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vt !! An optional argument, that if supplied, is used to contain the !! conjugate transpose of the N-by-N orthogonal matrix V.  The !! matrix V contains the right singular vectors. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: jobu , jobvt integer ( int32 ) :: m , n , mn , istat , lwork , flag , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 5 * mn if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else if ( size ( u , 2 ) == mn ) then jobu = 'S' end if else jobu = 'N' end if if ( present ( vt )) then jobvt = 'A' else jobvt = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( s ) /= mn ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"s\" , mn , size ( s )) return else if ( present ( u )) then if ( size ( u , 1 ) /= m ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if if ( size ( u , 2 ) /= m . and . size ( u , 2 ) /= mn ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if else if ( present ( vt )) then if ( size ( vt , 1 ) /= n . or . size ( vt , 2 ) /= n ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"vt\" , n , n , & size ( vt , 1 ), size ( vt , 2 )) return end if end if ! Workspace Query call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"rwork\" , lrwork , & size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if ! Call ZGESVD if ( present ( u ) . and . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , u , m , vt , n , wptr , lwork , & rwptr , flag ) else if ( present ( u ) . and . . not . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , u , m , temp , n , wptr , & lwork , rwptr , flag ) else if (. not . present ( u ) . and . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , vt , n , wptr , & lwork , rwptr , flag ) else call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , wptr , & lwork , rwptr , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_svd.f90.html"},{"title":"linalg_tri.f90 – LINALG","text":"Contents Modules linalg_tri Source Code linalg_tri.f90 Source Code module linalg_tri use iso_fortran_env use blas use linalg_errors implicit none private public :: solve_triangular_system interface solve_triangular_system module procedure :: solve_tri_mtx module procedure :: solve_tri_mtx_cmplx module procedure :: solve_tri_vec module procedure :: solve_tri_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine solve_tri_mtx ( lside , upper , trans , nounit , alpha , a , b , err ) !! Solves a triangular system of equations of the form !! op(A) X = \\alpha B or X op(A) = \\alpha B where A is a !! triangular matrix (either upper or lower) for the unknown X. logical , intent ( in ) :: lside !! Set to true to solve op(A) X = \\alpha B; else, set to false to !! solve X op(A) = \\alpha B. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if !! A is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. real ( real64 ), intent ( in ) :: alpha !! The scalar multiplier \\alpha. real ( real64 ), intent ( in ), dimension (:,:) :: a !! If lside is true, the M-by-M triangular matrix A; else, A is !! N-by-N if lside is false. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-N matrix B.  On output, the M-by-N solution !! matrix X. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters character :: side , uplo , transa , diag ! Local Variables integer ( int32 ) :: m , n , nrowa class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) if ( lside ) then nrowa = m side = 'L' else nrowa = n side = 'R' end if if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then transa = 'T' else transa = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check - matrix A must be square if ( size ( a , 1 ) /= nrowa . or . size ( a , 2 ) /= nrowa ) then call report_matrix_size_error ( \"solve_tri_mtx\" , errmgr , \"a\" , & nrowa , nrowa , size ( a , 1 ), size ( a , 2 )) return end if ! Call DTRSM call DTRSM ( side , uplo , transa , diag , m , n , alpha , a , nrowa , b , m ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_mtx_cmplx ( lside , upper , trans , nounit , alpha , a , b , err ) !! Solves a triangular system of equations of the form !! op(A) X = \\alpha B or X op(A) = \\alpha B where A is a !! triangular matrix (either upper or lower) for the unknown X. logical , intent ( in ) :: lside !! Set to true to solve op(A) X = \\alpha B; else, set to false to !! solve X op(A) = \\alpha B. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if !! A is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;H; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. complex ( real64 ), intent ( in ) :: alpha !! The scalar multiplier \\alpha. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! If lside is true, the M-by-M triangular matrix A; else, A is !! N-by-N if lside is false. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-N matrix B.  On output, the M-by-N solution !! matrix X. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters character :: side , uplo , transa , diag ! Local Variables integer ( int32 ) :: m , n , nrowa class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) if ( lside ) then nrowa = m side = 'L' else nrowa = n side = 'R' end if if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then transa = 'C' else transa = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check - matrix A must be square if ( size ( a , 1 ) /= nrowa . or . size ( a , 2 ) /= nrowa ) then call report_matrix_size_error ( \"solve_tri_mtx_cmplx\" , errmgr , \"a\" , & nrowa , nrowa , size ( a , 1 ), size ( a , 2 )) return end if ! Call ZTRSM call ZTRSM ( side , uplo , transa , diag , m , n , alpha , a , nrowa , b , m ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_vec ( upper , trans , nounit , a , x , err ) !! Solves the triangular system op(A) \\vec{x} = \\vec{b} where A !! is a triangular matrix. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if A !! is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular matrix A. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the N-element vector \\vec{b}.  On output, the !! N-element solution vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo , t , diag integer ( int32 ) :: n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then t = 'T' else t = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_tri_vec\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"solve_tri_vec\" , errmgr , & \"a\" , \"x\" , n , size ( x )) return end if ! Call DTRSV call DTRSV ( uplo , t , diag , n , a , n , x , 1 ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_vec_cmplx ( upper , trans , nounit , a , x , err ) !! Solves the triangular system op(A) \\vec{x} = \\vec{b} where A !! is a triangular matrix. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if A !! is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular matrix A. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the N-element vector \\vec{b}.  On output, the !! N-element solution vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo , t , diag integer ( int32 ) :: n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then t = 'C' else t = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_tri_vec_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"solve_tri_vec_cmplx\" , & errmgr , \"a\" , \"x\" , n , size ( x )) return end if ! Call ZTRSV call ZTRSV ( uplo , t , diag , n , a , n , x , 1 ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_tri.f90.html"},{"title":"linear_algebra.f90 – LINALG","text":"Contents Modules linear_algebra Source Code linear_algebra.f90 Source Code module linear_algebra !! This module contains pure functions for basic linear algebra operations. use iso_fortran_env use ieee_arithmetic use lapack use blas implicit none private public :: swap_arrays public :: identity public :: lu_factors public :: qr_factors public :: svd_factors public :: eigen_solution public :: lu_factor public :: qr_factor public :: cholesky_factor public :: svd public :: solve_triangular_system public :: solve_linear_system public :: solve_least_squares public :: inverse public :: pinverse public :: eigen type :: lu_factors !! A container for the results of a LU factorization. real ( real64 ), allocatable , dimension (:,:) :: L !! The lower-triangular factorization. real ( real64 ), allocatable , dimension (:,:) :: U !! The upper-triangular factorization. real ( real64 ), allocatable , dimension (:,:) :: P !! The pivot tracking matrix. end type type :: qr_factors !! A container for the results of a QR factorization of an M-by-N !! matrix. real ( real64 ), allocatable , dimension (:,:) :: Q !! The M-by-M orthogonal matrix, Q. real ( real64 ), allocatable , dimension (:,:) :: R !! The M-by-N upper trapezoidal matrix, R. real ( real64 ), allocatable , dimension (:,:) :: P !! The N-by-N pivot tracking matrix. end type type :: svd_factors !! A container for the results of a singular value decomposition of !! an M-by-N matrix. real ( real64 ), allocatable , dimension (:,:) :: U !! The M-by-M orthogonal matrix  U . real ( real64 ), allocatable , dimension (:,:) :: S !! The M-by-N diagonal matrix S containing the singular values !! on the diagonal. real ( real64 ), allocatable , dimension (:,:) :: Vt !! The transpose of the N-by-N right singular vector matrix V. end type type :: eigen_solution !! A container for both eigenvectors and eigenvalues. complex ( real64 ), allocatable , dimension (:) :: values !! An array of eigenvalues. complex ( real64 ), allocatable , dimension (:,:) :: vectors !! A collection of eigenvectors, stored columnwise. end type interface solve_triangular_system module procedure :: solve_triangular_system_mtx module procedure :: solve_triangular_system_vec end interface interface solve_linear_system module procedure :: solve_linear_system_mtx module procedure :: solve_linear_system_vec end interface interface solve_least_squares module procedure :: solve_least_squares_mtx module procedure :: solve_least_squares_vec end interface interface eigen module procedure :: eigen_1 module procedure :: eigen_2 end interface contains ! ****************************************************************************** ! COMMON OPERATIONS ! ------------------------------------------------------------------------------ pure subroutine swap_arrays ( x , y ) !! Swaps the contents of two arrays. real ( real64 ), intent ( inout ), dimension (:) :: x !! The first array. real ( real64 ), intent ( inout ), dimension (:) :: y !! The second array. ! Local Variables integer ( int32 ) :: i , m , mp1 , nx , ny , n real ( real64 ) :: temp ! Initialization nx = size ( x ) ny = size ( y ) n = min ( nx , ny ) m = mod ( n , 3 ) mp1 = m + 1 ! Process if ( m /= 0 ) then do i = 1 , m temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp end do if ( n < 3 ) return end if do i = mp1 , n , 3 temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp temp = x ( i + 1 ) x ( i + 1 ) = y ( i + 1 ) y ( i + 1 ) = temp temp = x ( i + 2 ) x ( i + 2 ) = y ( i + 2 ) y ( i + 2 ) = temp end do end subroutine ! ------------------------------------------------------------------------------ pure function identity ( n ) result ( rst ) !! Constructs an N-by-N identity matrix. integer ( int32 ), intent ( in ) :: n !! The size of the matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables integer ( int32 ) :: i ! Process if ( n < 1 ) return allocate ( rst ( n , n ), source = 0.0d0 ) do i = 1 , n rst ( i , i ) = 1.0d0 end do end function ! ****************************************************************************** ! FACTORIZATIONS ! ------------------------------------------------------------------------------ pure function lu_factor ( a ) result ( rst ) use linalg_lu , only : form_lu !! Computes the LU factorization of a square matrix such that !!  P A = L U . real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N matrix to factor. type ( lu_factors ) :: rst !! The factored form of the matrix. ! Local Variables integer ( int32 ) :: i , ip , n , info real ( real64 ), allocatable , dimension (:,:) :: u integer ( int32 ), allocatable , dimension (:) :: p ! Initialization n = size ( a , 1 ) if ( size ( a , 2 ) /= n ) return allocate ( rst % L ( n , n ), source = a ) allocate ( rst % U ( n , n ), source = 0.0d0 ) allocate ( p ( n )) ! Process call DGETRF ( n , n , rst % L , n , p , info ) rst % P = identity ( n ) do i = 1 , n ! Build the pivot matrix ip = p ( i ) if ( i /= ip ) call swap_arrays ( rst % P ( i ,:), rst % P ( ip ,:)) ! Build L & U rst % U ( 1 : i , i ) = rst % L ( 1 : i , i ) if ( i > 1 ) rst % L ( 1 : i - 1 , i ) = 0.0d0 rst % L ( i , i ) = 1.0d0 end do end function ! ------------------------------------------------------------------------------ pure function qr_factor ( a , pivot ) result ( rst ) !! Computes the QR factorization of an M-by-N matrix such that either !! A = Q R  (no pivoting), or A P = Q R (with pivoting). real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix to factor. logical , intent ( in ), optional :: pivot !! An optional parameter used to specifiy if pivoting should be used !! (true); else, false if no pivoting is used.  The default is false !! such that no pivoting is performed. type ( qr_factors ) :: rst !! The factored form of the matrix. ! Local Variables logical :: pvt integer ( int32 ) :: j , jp , m , n , mn , lwork , info integer ( int32 ), allocatable , dimension (:) :: jpvt real ( real64 ) :: temp1 ( 1 ), temp2 ( 1 ) real ( real64 ), allocatable , dimension (:) :: tau , work ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) allocate ( tau ( mn )) pvt = . false . if ( present ( pivot )) pvt = pivot allocate ( rst % Q ( m , m ), source = 0.0d0 ) allocate ( rst % R ( m , n ), source = a ) rst % P = identity ( n ) ! Determine the workspace requirements if ( pvt ) then allocate ( jpvt ( n ), source = 0 ) call DGEQP3 ( m , n , rst % R , m , jpvt , tau , temp1 , - 1 , info ) else call DGEQRF ( m , n , rst % R , m , tau , temp1 , - 1 , info ) end if call DORGQR ( m , m , mn , rst % R , m , tau , temp2 , - 1 , info ) lwork = int ( max ( temp1 ( 1 ), temp2 ( 1 )), int32 ) allocate ( work ( lwork )) ! Compute the factorization if ( pvt ) then call DGEQP3 ( m , n , rst % R , m , jpvt , tau , work , lwork , info ) else call DGEQRF ( m , n , rst % R , m , tau , work , lwork , info ) end if ! Build the matrices do j = 1 , mn rst % Q ( j + 1 : m , j ) = rst % R ( j + 1 : m , j ) rst % R ( j + 1 : m , j ) = 0.0d0 end do call DORGQR ( m , m , mn , rst % Q , m , tau , work , lwork , info ) ! Construct the pivot matrix, if necessary if ( pvt ) then do j = 1 , n jp = jpvt ( j ) rst % P (:, j ) = 0.0d0 rst % P ( jp , j ) = 1.0d0 end do end if end function ! ------------------------------------------------------------------------------ pure function cholesky_factor ( a , upper ) result ( rst ) !! Computes the Cholesky factorization of a positive-definite matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix to factor. logical , intent ( in ), optional :: upper !! An optional parameter to specifiy if the upper factorization !! A = R&#94;{T} R  should be computed (true); else, false for the lower !! factorization  A = L L&#94;{T} .  The default is to compute the upper !! factorization. real ( real64 ), allocatable , dimension (:,:) :: rst !! The factored matrix, either R or L. ! Local Variables integer ( int32 ) :: i , n , info character :: uplo ! Initialization n = size ( a , 1 ) if ( size ( a , 2 ) /= n ) return uplo = 'U' if ( present ( upper )) then if (. not . upper ) uplo = 'L' end if allocate ( rst ( n , n ), source = a ) ! Factor call DPOTRF ( uplo , n , rst , n , info ) ! Zero out the non-used upper or lower diagonal portions of the matrix if ( uplo == 'U' ) then do i = 1 , n - 1 rst ( i + 1 : n , i ) = 0.0d0 end do else do i = 2 , n rst ( 1 : i - 1 , i ) = 0.0d0 end do end if end function ! ------------------------------------------------------------------------------ pure function svd ( a ) result ( rst ) !! Computes the singular value decomposition of an M-by-N matrix such that !!  A = U S V&#94;{T} . real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix to factor. type ( svd_factors ) :: rst !! The factored form of the matrix. ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , info real ( real64 ) :: temp ( 1 ) real ( real64 ), allocatable , dimension (:) :: sigma , work real ( real64 ), allocatable , dimension (:,:) :: ac ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ac = a allocate ( rst % U ( m , m ), rst % S ( m , n ), rst % Vt ( n , n ), sigma ( mn ), source = 0.0d0 ) ! Determine the workspace call DGESVD ( 'A' , 'A' , m , n , ac , m , sigma , rst % U , m , rst % Vt , n , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) ! Compute the factorization call DGESVD ( 'A' , 'A' , m , n , ac , m , sigma , rst % U , m , rst % Vt , n , work , lwork , info ) ! Populate the diagonal singular-value matrix do i = 1 , mn rst % S ( i , i ) = sigma ( i ) end do end function ! ****************************************************************************** ! SOLVERS ! ------------------------------------------------------------------------------ pure function solve_triangular_system_mtx ( a , b , upper ) result ( rst ) !! Solves a triangular system of the form A X = B where A is a !! triangular matrix, either upper or lower, for equation X. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular A matrix. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The N-by-NRHS B matrix. logical , intent ( in ), optional :: upper !! An optional argument specifying if the A matrix is upper !! triangular (true), or lower triangular (false).  The default !! assumption is that A is an upper triangular matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The N-by-NRHS solution matrix, X. ! Local Variables character :: uplo , side , transa , diag integer ( int32 ) :: n , nrhs ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) side = 'L' transa = 'N' diag = 'N' uplo = 'U' if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if end if if ( size ( a , 2 ) /= n . or . size ( b , 1 ) /= n ) return allocate ( rst ( n , nrhs ), source = b ) ! Process call DTRSM ( side , uplo , transa , diag , n , nrhs , 1.0d0 , a , n , rst , n ) end function ! ------------------------------------------------------------------------------ pure function solve_triangular_system_vec ( a , b , upper ) result ( rst ) !! Solves a triangular system of the form A X = B where A is a !! triangular matrix, either upper or lower, for equation X. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular A matrix. real ( real64 ), intent ( in ), dimension (:) :: b !! The N-element B array. logical , intent ( in ), optional :: upper !! An optional argument specifying if the A matrix is upper !! triangular (true), or lower triangular (false).  The default !! assumption is that A is an upper triangular matrix. real ( real64 ), allocatable , dimension (:) :: rst !! The N-element solution array, X. ! Local Variables character :: uplo , side , transa , diag integer ( int32 ) :: n , nrhs ! Initialization n = size ( a , 1 ) nrhs = 1 side = 'L' transa = 'N' diag = 'N' uplo = 'U' if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if end if if ( size ( a , 2 ) /= n . or . size ( b , 1 ) /= n ) return allocate ( rst ( n ), source = b ) ! Process call DTRSM ( side , uplo , transa , diag , n , nrhs , 1.0d0 , a , n , rst , n ) end function ! ------------------------------------------------------------------------------ pure function solve_linear_system_mtx ( a , b ) result ( rst ) !! Solves the M-by-N linear system A X = B for X. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix A. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The M-by-NRHS matrix B. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting N-by-NRHS matrix X. ! Local Variables logical :: usedgels integer ( int32 ) :: m , n , maxmn , nrhs , lwork , info integer ( int32 ), allocatable , dimension (:) :: ipiv real ( real64 ) :: temp ( 1 ) real ( real64 ), allocatable , dimension (:) :: work real ( real64 ), allocatable , dimension (:,:) :: ac , xc ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) if ( size ( b , 1 ) /= m ) return usedgels = . false . if ( m /= n ) usedgels = . true . allocate ( ac ( m , n ), source = a ) maxmn = max ( m , n ) ! Process if ( usedgels ) then allocate ( xc ( maxmn , nrhs )) if ( m >= n ) then xc = b else xc ( 1 : m ,:) = b end if call DGELS ( 'N' , m , n , nrhs , ac , m , xc , maxmn , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) call DGELS ( 'N' , m , n , nrhs , ac , m , xc , maxmn , work , lwork , info ) if ( m >= n ) then allocate ( rst ( n , nrhs ), source = xc ( 1 : n ,:)) else allocate ( rst ( n , nrhs ), source = xc ) end if else ! Use LU factorization to solve allocate ( rst ( n , nrhs ), source = b ) allocate ( ipiv ( n )) call DGESV ( n , nrhs , ac , n , ipiv , rst , n , info ) end if end function ! ------------------------------------------------------------------------------ pure function solve_linear_system_vec ( a , b ) result ( rst ) !! Solves the M-by-N linear system A X = B for X. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix A. real ( real64 ), intent ( in ), dimension (:) :: b !! The M-element array B. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting N-element array X. ! Local Variables logical :: usedgels integer ( int32 ) :: m , n , maxmn , nrhs , lwork , info integer ( int32 ), allocatable , dimension (:) :: ipiv real ( real64 ) :: temp ( 1 ) real ( real64 ), allocatable , dimension (:) :: work , xc real ( real64 ), allocatable , dimension (:,:) :: ac ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = 1 if ( size ( b ) /= m ) return usedgels = . false . if ( m /= n ) usedgels = . true . allocate ( ac ( m , n ), source = a ) maxmn = max ( m , n ) ! Process if ( usedgels ) then allocate ( xc ( maxmn )) if ( m >= n ) then xc = b else xc ( 1 : m ) = b end if call DGELS ( 'N' , m , n , nrhs , ac , m , xc , maxmn , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) call DGELS ( 'N' , m , n , nrhs , ac , m , xc , maxmn , work , lwork , info ) if ( m >= n ) then allocate ( rst ( n ), source = xc ( 1 : n )) else allocate ( rst ( n ), source = xc ) end if else ! Use LU factorization to solve allocate ( rst ( n ), source = b ) allocate ( ipiv ( n )) call DGESV ( n , nrhs , ac , n , ipiv , rst , n , info ) end if end function ! ------------------------------------------------------------------------------ pure function solve_least_squares_mtx ( a , b ) result ( rst ) !! Solves the least squares problem by minimizing || A X - B || using !! a complete orthogonal factorization of A. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix A. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The M-by-NRHS matrix B. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting N-by-NRHS matrix X. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , info , rnk integer ( int32 ), allocatable , dimension (:) :: jpvt real ( real64 ) :: rcond , temp ( 1 ) real ( real64 ), allocatable , dimension (:) :: work real ( real64 ), allocatable , dimension (:,:) :: ac , x ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) maxmn = max ( m , n ) if ( size ( b , 1 ) /= m ) return allocate ( jpvt ( n ), source = 0 ) allocate ( ac ( m , n ), source = a ) allocate ( x ( maxmn , nrhs )) if ( m >= n ) then x = b else x ( 1 : m ,:) = b end if call DGELSY ( m , n , nrhs , ac , m , x , maxmn , jpvt , rcond , rnk , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) ! Process call DGELSY ( m , n , nrhs , ac , m , x , maxmn , jpvt , rcond , rnk , work , lwork , info ) allocate ( rst ( n , nrhs ), source = x ( 1 : n ,:)) end function ! ------------------------------------------------------------------------------ pure function solve_least_squares_vec ( a , b ) result ( rst ) !! Solves the least squares problem by minimizing || A X - B || using !! a complete orthogonal factorization of A. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix A. real ( real64 ), intent ( in ), dimension (:) :: b !! The M-element array B. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting N-element array X. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , info , rnk integer ( int32 ), allocatable , dimension (:) :: jpvt real ( real64 ) :: rcond , temp ( 1 ) real ( real64 ), allocatable , dimension (:) :: work , x real ( real64 ), allocatable , dimension (:,:) :: ac ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = 1 maxmn = max ( m , n ) if ( size ( b ) /= m ) return allocate ( jpvt ( n ), source = 0 ) allocate ( ac ( m , n ), source = a ) allocate ( x ( maxmn )) if ( m >= n ) then x = b else x ( 1 : m ) = b end if call DGELSY ( m , n , nrhs , ac , m , x , maxmn , jpvt , rcond , rnk , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) ! Process call DGELSY ( m , n , nrhs , ac , m , x , maxmn , jpvt , rcond , rnk , work , lwork , info ) allocate ( rst ( n ), source = x ( 1 : n )) end function ! ****************************************************************************** ! INVERSE OPERATIONS ! ------------------------------------------------------------------------------ pure function inverse ( a ) result ( rst ) !! Computes the inverse of a square matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N matrix to invert. real ( real64 ), allocatable , dimension (:,:) :: rst !! The N-by-N inverted matrix. ! Local Variables integer ( int32 ) :: n , lwork , info integer ( int32 ), allocatable , dimension (:) :: ipvt real ( real64 ) :: temp ( 1 ), nan real ( real64 ), allocatable , dimension (:) :: work ! Process n = size ( a , 1 ) if ( size ( a , 2 ) /= n ) return allocate ( rst ( n , n ), source = a ) allocate ( ipvt ( n )) call DGETRI ( n , rst , n , ipvt , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) ! Compute the LU factorization of A call DGETRF ( n , n , rst , n , ipvt , info ) if ( info > 0 ) then nan = ieee_value ( nan , IEEE_QUIET_NAN ) rst = nan return end if ! Compute the inverse of the LU factored matrix call DGETRI ( n , rst , n , ipvt , work , lwork , info ) end function ! ------------------------------------------------------------------------------ pure function pinverse ( a ) result ( rst ) !! Computes the Moore-Penrose pseudoinverse of an M-by-N matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix to invert. real ( real64 ), allocatable , dimension (:,:) :: rst !! The N-by-M inverted matrix. ! Local Variables integer ( int32 ) :: i , m , n , mn , info , lwork real ( real64 ) :: temp ( 1 ), t , ss real ( real64 ), allocatable , dimension (:) :: s , work real ( real64 ), allocatable , dimension (:,:) :: ac , u , vt ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) allocate ( ac ( m , n ), source = a ) allocate ( s ( mn ), u ( m , mn ), vt ( mn , n )) call DGESVD ( 'S' , 'S' , m , n , ac , m , s , u , m , vt , mn , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) allocate ( rst ( n , m )) ! Compute the SVD of A call DGESVD ( 'S' , 'S' , m , n , ac , m , s , u , m , vt , mn , work , lwork , info ) ! Compute u = U * inv(S) t = max ( m , n ) * epsilon ( t ) * s ( 1 ) do i = 1 , mn if ( s ( i ) > t ) then ss = 1.0d0 / s ( i ) else ss = s ( i ) end if u (:, i ) = ss * u (:, i ) end do ! Compute pinv(A) = (V**T)**T * u**T call DGEMM ( 'T' , 'T' , n , m , mn , 1.0d0 , vt , mn , u , m , 0.0d0 , rst , n ) end function ! ****************************************************************************** ! EIGEN ANALYSIS ! ------------------------------------------------------------------------------ pure function eigen_1 ( a , right ) result ( rst ) !! Solves the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} where !! matrix is A is square, but not necessarily symmetric.  Optionally, !! the left eigenvalue problem can be solved such that \\vec{u}&#94;{H} A = !! \\lambda \\vec{u}&#94;{H}. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A. logical , intent ( in ), optional :: right !! An optional parameter specifying if the right eigenvalue solution !! should be computed (true), or the left eigenvalue solution should be !! computed (false).  The default is true such that the right eigenvalue !! problem is solved. type ( eigen_solution ) :: rst !! The solution. ! Local Variables logical :: solveright character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , lwork , info real ( real64 ) :: temp ( 1 ), eps real ( real64 ), allocatable , dimension (:) :: work , wr , wi real ( real64 ), allocatable , dimension (:,:) :: ac , vecs ! Initialization n = size ( a , 1 ) if ( size ( a , 2 ) /= n ) return eps = 2.0d0 * epsilon ( eps ) solveright = . true . if ( present ( right )) solveright = right if ( solveright ) then jobvl = 'N' jobvr = 'V' else jobvl = 'V' jobvr = 'N' end if allocate ( ac ( n , n ), source = a ) allocate ( wr ( n ), wi ( n ), vecs ( n , n )) call DGEEV ( jobvl , jobvr , n , ac , n , wr , wi , vecs , n , vecs , n , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) ! Solve the problem call DGEEV ( jobvl , jobvr , n , ac , n , wr , wi , vecs , n , vecs , n , work , lwork , info ) ! Store the solution allocate ( rst % values ( n ), rst % vectors ( n , n )) j = 1 do while ( j <= n ) if ( abs ( wi ( j )) < eps ) then ! We've got a real-valued eigenvalue rst % values ( j ) = cmplx ( wr ( j ), 0.0d0 , real64 ) do i = 1 , n rst % vectors ( i , j ) = cmplx ( vecs ( i , j ), 0.0d0 , real64 ) end do else ! We've got a complex conjugate pair of eigenvalues jp1 = j + 1 rst % values ( j ) = cmplx ( wr ( j ), wi ( j ), real64 ) rst % values ( jp1 ) = conjg ( rst % values ( j )) do i = 1 , n rst % vectors ( i , j ) = cmplx ( vecs ( i , j ), vecs ( i , jp1 ), real64 ) rst % vectors ( i , jp1 ) = conjg ( rst % vectors ( i , j )) end do ! Increment j and continue j = j + 2 cycle end if ! Increment j j = j + 1 end do end function ! ------------------------------------------------------------------------------ pure function eigen_2 ( a , b , right ) result ( rst ) !! Solves the eigenvalue problem A \\vec{v} = \\lambda B \\vec{v} where !! A and B are both N-by-N matrices.  Optionally, the left !! eigenvalue problem can be solved such that \\vec{u}&#94;{H} A = !! \\lambda \\vec{u}&#94;{H} B. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B. logical , intent ( in ), optional :: right !! An optional parameter specifying if the right eigenvalue solution !! should be computed (true), or the left eigenvalue solution should be !! computed (false).  The default is true such that the right eigenvalue !! problem is solved. type ( eigen_solution ) :: rst !! The solution. ! Local Variables logical :: solveright character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , lwork , info real ( real64 ) :: temp ( 1 ), eps real ( real64 ), allocatable , dimension (:) :: work , alphar , alphai , beta real ( real64 ), allocatable , dimension (:,:) :: ac , bc , vecs ! Initialization n = size ( a , 1 ) if ( size ( a , 2 ) /= n . or . size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) return eps = 2.0d0 * epsilon ( eps ) solveright = . true . if ( present ( right )) solveright = right if ( solveright ) then jobvl = 'N' jobvr = 'V' else jobvl = 'V' jobvr = 'N' end if allocate ( ac ( n , n ), source = a ) allocate ( bc ( n , n ), source = b ) allocate ( alphar ( n ), alphai ( n ), beta ( n ), vecs ( n , n )) call DGGEV3 ( jobvl , jobvr , n , ac , n , bc , n , alphar , alphai , beta , vecs , n , & vecs , n , temp , - 1 , info ) lwork = int ( temp ( 1 ), int32 ) allocate ( work ( lwork )) allocate ( rst % values ( n ), rst % vectors ( n , n )) ! Solve the problem call DGGEV3 ( jobvl , jobvr , n , ac , n , bc , n , alphar , alphai , beta , vecs , n , & vecs , n , work , lwork , info ) ! Store the solution j = 1 do while ( j <= n ) if ( abs ( alphai ( j )) < eps ) then ! Real-Valued rst % values ( j ) = cmplx ( alphar ( j ), 0.0d0 , real64 ) / beta ( j ) do i = 1 , n rst % vectors ( i , j ) = cmplx ( vecs ( i , j ), 0.0d0 , real64 ) end do else ! Complex-Valued jp1 = j + 1 rst % values ( j ) = cmplx ( alphar ( j ), alphai ( j ), real64 ) / beta ( j ) rst % values ( jp1 ) = cmplx ( alphar ( jp1 ), alphai ( jp1 ), real64 ) / beta ( jp1 ) do i = 1 , n rst % vectors ( i , j ) = cmplx ( vecs ( i , j ), vecs ( i , jp1 ), real64 ) rst % vectors ( i , jp1 ) = conjg ( rst % vectors ( i , j )) end do ! Increment j and continue j = j + 2 cycle end if ! Increment j j = j + 1 end do end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linear_algebra.f90.html"},{"title":"qrupdate.f90 – LINALG","text":"Contents Modules qrupdate Source Code qrupdate.f90 Source Code !> @brief A module providing explicit interfaces for the QRUPDATE library. module qrupdate implicit none interface pure subroutine DQR1UP ( m , n , k , q , ldq , r , ldr , u , v , w ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , ldq , ldr real ( real64 ), intent ( inout ) :: q ( ldq , * ), r ( ldr , * ), u ( * ), v ( * ) real ( real64 ), intent ( out ) :: w ( * ) end subroutine pure subroutine ZQR1UP ( m , n , k , q , ldq , r , ldr , u , v , w , rw ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: m , n , k , ldq , ldr complex ( real64 ), intent ( inout ) :: q ( ldq , * ), r ( ldr , * ), u ( * ), v ( * ) complex ( real64 ), intent ( out ) :: w ( * ) real ( real64 ), intent ( out ) :: rw ( * ) end subroutine pure subroutine DCH1UP ( n , r , ldr , u , w ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ldr real ( real64 ), intent ( inout ) :: r ( ldr , * ), u ( * ) real ( real64 ), intent ( out ) :: w ( * ) end subroutine pure subroutine ZCH1UP ( n , r , ldr , u , w ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ldr complex ( real64 ), intent ( inout ) :: r ( ldr , * ), u ( * ) real ( real64 ), intent ( out ) :: w ( * ) end subroutine pure subroutine DCH1DN ( n , r , ldr , u , w , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ldr real ( real64 ), intent ( inout ) :: r ( ldr , * ), u ( * ) real ( real64 ), intent ( out ) :: w ( * ) integer ( int32 ), intent ( out ) :: info end subroutine pure subroutine ZCH1DN ( n , r , ldr , u , rw , info ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ldr complex ( real64 ), intent ( inout ) :: r ( ldr , * ), u ( * ) real ( real64 ), intent ( out ) :: rw ( * ) integer ( int32 ), intent ( out ) :: info end subroutine end interface end module","tags":"","loc":"sourcefile\\qrupdate.f90.html"},{"title":"sparskit.f90 – LINALG","text":"Contents Modules sparskit Source Code sparskit.f90 Source Code !> @brief An interface to the SPARSKIT library available at !! https://www-users.cse.umn.edu/~saad/software/SPARSKIT/. module sparskit implicit none ! BLASSM.F interface !> @brief Computes the matrix product: C = A * B. !! !! @param[in] nrow The row dimension of matrices A & C. !! @param[in] ncol The column dimension of matrices B & C. !! @param[in] job Set to 0 to compute only the structure (JC & IC); !!  else, set to any non-zero value. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] b The non-zero elements of matrix B. !! @param[in] jb The column indices of matrix B. !! @param[in] ib The index in B where the requested row starts. !! @param[out] c The non-zero elements of matrix C. !! @param[out] jc The column indices of matrix C. !! @param[out] ic The index in C where the requested row starts. !! @param[in] nzmax The length of arrays C & JC.  The routine will stop !!  if the results matrix C has a number of elements that exceeds NZMAX. !! @param[out] iw A workspace array with a length equal to the number of !!  of columns in matrix C. !! @param[out] ierr An error message indicator. !!  * 0: Normal return !!  * .gt. 0: Routine failed in row I with IERR = I because the number !!     of elements in C exceeds NZMAX. pure subroutine amub ( nrow , ncol , job , a , ja , ia , b , jb , ib , c , jc , ic , & nzmax , iw , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: nrow , ncol , job , nzmax integer ( int32 ), intent ( in ) :: ja ( * ), ia ( nrow + 1 ), jb ( * ), ib ( * ) integer ( int32 ), intent ( out ) :: jc ( * ), ic ( * ), iw ( ncol ), ierr real ( real64 ), intent ( in ) :: a ( * ), b ( * ) real ( real64 ), intent ( out ) :: c ( * ) end subroutine !> @brief Computes the matrix sum: C = A + B, where the matrices are !! given in CSR format. !! !! @param[in] nrow The number of rows in the matrices. !! @param[in] ncol The number of columns in the matrices. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] b The non-zero elements of matrix B. !! @param[in] jb The column indices of matrix B. !! @param[in] ib The index in B where the requested row starts. !! @param[out] c The non-zero elements of matrix C. !! @param[out] jc The column indices of matrix C. !! @param[out] ic The index in C where the requested row starts. !! @param[in] nzmax The length of arrays C & JC.  The routine will stop !!  if the results matrix C has a number of elements that exceeds NZMAX. !! @param[out] iw A workspace array with a length equal to the number of !!  of columns in matrix A. !! @param[out] ierr An error message indicator. !!  * 0: Normal return !!  * .gt. 0: Routine failed in row I with IERR = I because the number !!     of elements in C exceeds NZMAX. pure subroutine aplb ( nrow , ncol , job , a , ja , ia , b , jb , ib , c , jc , ic , & nzmax , iw , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: nrow , ncol , job , nzmax integer ( int32 ), intent ( in ) :: ja ( * ), ia ( nrow + 1 ), jb ( * ), ib ( nrow + 1 ) real ( real64 ), intent ( in ) :: a ( * ), b ( * ) real ( real64 ), intent ( out ) :: c ( * ) integer ( int32 ), intent ( out ) :: jc ( * ), ic ( nrow + 1 ), iw ( ncol ), ierr end subroutine !> @brief Computes the matrix sum: C = A + s * B, where the matrices !! are given in CSR format. !! !! @param[in] nrow The number of rows in the matrices. !! @param[in] ncol The number of columns in the matrices. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] s The scalar multiplier. !! @param[in] b The non-zero elements of matrix B. !! @param[in] jb The column indices of matrix B. !! @param[in] ib The index in B where the requested row starts. !! @param[out] c The non-zero elements of matrix C. !! @param[out] jc The column indices of matrix C. !! @param[out] ic The index in C where the requested row starts. !! @param[in] nzmax The length of arrays C & JC.  The routine will stop !!  if the results matrix C has a number of elements that exceeds NZMAX. !! @param[out] iw A workspace array with a length equal to the number of !!  of columns in matrix A. !! @param[out] ierr An error message indicator. !!  * 0: Normal return !!  * .gt. 0: Routine failed in row I with IERR = I because the number !!     of elements in C exceeds NZMAX. pure subroutine aplsb ( nrow , ncol , a , ja , ia , s , b , jb , ib , c , jc , ic , & nzmax , iw , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: nrow , ncol , nzmax integer ( int32 ), intent ( in ) :: ja ( * ), ia ( nrow + 1 ), jb ( * ), ib ( nrow + 1 ) integer ( int32 ), intent ( out ) :: ierr integer ( int32 ), intent ( out ) :: jc ( * ), ic ( nrow + 1 ), iw ( ncol ) real ( real64 ), intent ( in ) :: s real ( real64 ), intent ( in ) :: a ( * ), b ( * ) real ( real64 ), intent ( out ) :: c ( * ) end subroutine end interface ! FORMATS.F interface !> @brief Converts a CSR matrix into a CSC matrix (transposition). !! !! @param[in] n The number of rows in the CSR matrix. !! @param[in] n2 The number of columns in the CSC matrix. !! @param[in] job Fill the values (job == 1) or only the pattern !!  (job /= 1). !! @param[in] ipos Starting position of A0 in JA0. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[out] a0 The non-zero elements of the transposed array. !! @param[out] ja0 The size NNZ array containing the column indices. !! @param[out] ia0 The N+1 size array containing the column starts. pure subroutine csrcsc2 ( n , n2 , job , ipos , a , ja , ia , a0 , ja0 , ia0 ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , n2 , job , ipos , ja ( * ), ia ( n + 1 ) integer ( int32 ), intent ( out ) :: ja0 ( * ), ia0 ( n2 + 1 ) real ( real64 ), intent ( in ) :: a ( * ) real ( real64 ), intent ( out ) :: a0 ( * ) end subroutine !> @brief Converts the LINPACK, BLAS, LAPACK banded matrix format into !! a CSR format. !! !! @param[in] n The row dimension of the matrix. !! @param[in] abd The banded matrix. !! @param[in] nabd The leading dimension of @p abd. !! @param[in] lowd The row index where the lowest diagonal (leftmost) of !!  A is located.  LINPACK uses LOWD = 2 * ML + MU + 1. !! @param[in] ml The bandwidth of the strict lower part of A. !! @param[in] mu The bandwidth of the strict upper part of A. !! @param[out] a The non-zero elements of matrix A. !! @param[out] ja The column indices of matrix A. !! @param[out] ia The index in A where the requested row starts. !! @param[in] len The length of @p a and @p ja. !! @param[out] ierr Error message output. !!  * 0: Normal return. !!  * -1: Invalid @p lowd value. !!  * Positive Valued: Not enough storage in @p a and @p ja. pure subroutine bndcsr ( n , abd , nabd , lowd , ml , mu , a , ja , ia , len , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , nabd , lowd , ml , mu , len real ( real64 ), intent ( in ) :: abd ( nabd , * ) real ( real64 ), intent ( out ) :: a ( * ) integer ( int32 ), intent ( out ) :: ia ( n + 1 ), ja ( * ), ierr end subroutine !> @brief Converts a CSR matrix to an MSR matrix. !! !! @param[in] n The row dimension of the matrix. !! @param[in,out] a The non-zero elements of matrix A. !! @param[in,out] ja The column indices of matrix A. !! @param[in,out] ia The index in A where the requested row starts. !! @param[out] ao An NNZ-element array containing the non-zero elements !!  for the MSR matrix. !! @param[out] jao An NNZ-element index tracking array for the MSR !!  matrix. !! @param[out] wk An N-element workspace array. !! @param[out] iwk An N+1 element workspace array. pure subroutine csrmsr ( n , a , ja , ia , ao , jao , wk , iwk ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n integer ( int32 ), intent ( inout ) :: ja ( * ), ia ( n + 1 ) integer ( int32 ), intent ( out ) :: jao ( * ), iwk ( n + 1 ) real ( real64 ), intent ( inout ) :: a ( * ) real ( real64 ), intent ( out ) :: ao ( * ), wk ( n ) end subroutine !> @brief Converts and MSR matrix to a CSR matrix. !! !! @param[in] n The row dimension of the matrix. !! @param[in] a An NNZ-element array containing the non-zero elements !!  for the MSR matrix. !! @param[in] ja An NNZ-element index tracking array for the MSR !!  matrix. !! @param[out] ao The non-zero elements of matrix A. !! @param[out] jao The column indices of matrix A. !! @param[out] iao The index in A where the requested row starts. !! @param[out] wk An N-element workspace array. !! @param[out] iwk An N+1 element workspace array. pure subroutine msrcsr ( n , a , ja , ao , jao , iao , wk , iwk ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ja ( * ) integer ( int32 ), intent ( out ) :: jao ( * ), iao ( n + 1 ), iwk ( n + 1 ) real ( real64 ), intent ( in ) :: a ( * ) real ( real64 ), intent ( out ) :: ao ( * ), wk ( n ) end subroutine !> @brief Converte a matrix stored in coordinate format to CSR format. !! !! @param[in] nrow The number of rows in the matrix. !! @param[in] nnz The number of non-zero elements in the matrix. !! @param[in] a An NNZ-element array containing the non-zero elements !!  of the matrix. !! @param[in,out] ir An NNZ-element array containing the row indices of !!  each non-zero element. !! @param[in] jc An NNZ-element array containing the column indices of !!  each non-zero element. !! @param[out] ao The non-zero elements of matrix A. !! @param[out] jao The column indices of matrix A. !! @param[out] iao The index in A where the requested row starts. pure subroutine coocsr ( nrow , nnz , a , ir , jc , ao , jao , iao ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: nrow , nnz , jc ( * ) integer ( int32 ), intent ( inout ) :: ir ( * ) real ( real64 ), intent ( in ) :: a ( * ) integer ( int32 ), intent ( out ) :: jao ( * ), iao ( * ) real ( real64 ), intent ( out ) :: ao ( * ) end subroutine end interface ! UNARY.F interface !> @brief Gets element A(i,j) of matrix A for any pair (i,j). !! !! @param[in] i The row index. !! @param[in] j The column index. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[out] iadd The address of element A(i,j) in arrays A & JA, if !!  found; else, zero if not found. !! @param[in] sorted Indicates whether the matrix is known to be sorted. !! !! @return The requested value. function getelm ( i , j , a , ja , ia , iadd , sorted ) result ( rst ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: i , j , ia ( * ), ja ( * ) real ( real64 ), intent ( in ) :: a ( * ) integer ( int32 ), intent ( out ) :: iadd logical , intent ( in ) :: sorted real ( real64 ) :: rst end function !> @brief Extracts the diagonal from a matrix. !! !! @param[in] nrow The number of rows. !! @param[in] ncol The number of columns. !! @param[in] job Set to 0 to not alter @p a, @p ja, and @p ia; else, !! set to a non-zero value to perform this as an in-place operation. !! @param[out] len The number of non-zero elements found in @p diag. !! @param[out] idiag An array of length @p len containing the original !!  positions in the original arrays @p a and @p ja of the diagonal !!  elements collected in diagl. !! @param[in] ioff The offset of the wanted diagonal. pure subroutine getdia ( nrow , ncol , job , a , ja , ia , len , diag , idiag , ioff ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: nrow , ncol , job , ja ( * ), ia ( * ), ioff integer ( int32 ), intent ( out ) :: len , idiag ( * ) real ( real64 ), intent ( in ) :: a ( * ) real ( real64 ), intent ( out ) :: diag ( * ) end subroutine !> @brief Sorces the elements of a CSR matrix in increasing order of !! their column indices within each row. !! !! @param[in] n The number of rows in the matrix. !! @param[in,out] a The non-zero values. !! @param[in,out] ja An array of column indices of the elements in A. !! @param[in] ia An array of pointers to the rows. !! @param[in] values Idicates whether A must also be permuted.  If !!  false, A can be a dummy array. pure subroutine csort ( n , a , ja , ia , values ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n real ( real64 ), intent ( inout ) :: a ( * ) integer ( int32 ), intent ( inout ) :: ja ( * ) integer ( int32 ), intent ( in ) :: ia ( * ) logical , intent ( in ) :: values end subroutine !> @breif Cleans up a CSR matrix. !! !! @param[in] job The job to perform. !!  - 0: Nothing is done !!  - 1: Eliminate duplicate entries and zero entries. !!  - 2: Eliminate duplicate entries and perform partial ordering. !!  - 3: Eliminate duplicate entries and sort the entries in increasing !!      order of column indices. !! @param[in] value2 0 if the matrix is pattern only (A is not touched), !!  or 1 if the matrix has values. !! @param[in] nrow The number of rows in the matrix. !! @param[in,out] a The non-zero values. !! @param[in,out] ja An array of column indices of the elements in A. !! @param[in,out] ia An array of pointers to the rows. !! @param[out] indu An NROW array containing pointers to the beginning !!  of the upper triangular portion if job > 1. !! @param[out] iwk An NROW+1 element workspace array. pure subroutine clncsr ( job , value2 , nrow , a , ja , ia , indu , iwk ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: job , value2 , nrow real ( real64 ), intent ( inout ) :: a ( * ) integer ( int32 ), intent ( inout ) :: ja ( * ), ia ( * ) integer ( int32 ), intent ( inout ) :: indu ( * ), iwk ( * ) end subroutine end interface ! ILUT.F interface !> @brief Computes the incomplete LU factorization of a sparse matrix !! in CSR format using a dual truncation mechanism. !! !! @param[in] n The row dimension of the matrix. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] lfil The fill-in parameter.  Each row of L and each row !!  of U will have a maximum of @p lfil elements, excluding the !!  diagonal element.  @p lfil must be greater than or equal to zero. !! @param[in] droptol The threshold for dropping small terms in the !!  factorization. !! @param[out] alu The factored matrix stored in Modified Sparse Row !!  (MSR) format containing the L and U factors together.  The diagonal, !!  stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU !!  matrix contains the i-th row of L, excluding the diagonal entry, !!  followed by the i-th row of U. !! @param[out] jlu The column indices for the factored matrix. !! @param[out] ju An N-element array containing the pointers to the !!  beginning of each row of U in the factored matrix. !! @param[in] iwk The lengths of @p alu and @p jlu. !! @param[out] w An N+1 element workspace array. !! @param[out] jw A 2*N element workspace array. !! @param[out] ierr Error flag: !!  * 0: Successful return !!  * .gt. 0: Zero pivot encountered at step number IERR. !!  * -1: Input matrix is incorrect.  The elimination process generated !!      a row in L or U whose length is greater than N. !!  * -2: The matrix L overflows the output array. !!  * -3: The matrix U overflows the output array. !!  * -4: Illegal value for @P lfil. !!  * -5: Zero-valued row encountered. pure subroutine ilut ( n , a , ja , ia , lfil , droptol , alu , jlu , ju , iwk , w , & jw , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , ja ( * ), ia ( n + 1 ), lfil , iwk integer ( int32 ), intent ( out ) :: jlu ( * ), ju ( n ), jw ( 2 * n ), ierr real ( real64 ), intent ( in ) :: a ( * ), droptol real ( real64 ), intent ( out ) :: alu ( * ), w ( n + 1 ) end subroutine !> @brief Computes the incomplete LU factorization of a sparse matrix !! in CSR format using a dual truncation mechanism and pivoting. !! !! @param[in] n The row dimension of the matrix. !! @param[in,out] a The non-zero elements of matrix A.  On output, the !!  columns are permuted. !! @param[in,out] ja The column indices of matrix A.  On output, the !!  columns are permuted. !! @param[in,out] ia The index in A where the requested row starts.  On !!  output, the columns are permuted. !! @param[in] lfil The fill-in parameter.  Each row of L and each row !!  of U will have a maximum of @p lfil elements, excluding the !!  diagonal element.  @p lfil must be greater than or equal to zero. !! @param[in] droptol The threshold for dropping small terms in the !!  factorization. !! @param[in] permtol A tolerance ratio used to determine whether or !!  not to permute two columns.  At step I, columns I and J are !!  permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values !!  are typically between 0.1 to 0.01. !! @param[in] mbloc If desired, permuting can be done only within the !!  diagonal blocks of size MBLOC.  Useful for PDE problems with many !!  degrees of freedom.  If this feature is not required, simply set !!  MBLOC equal to N. !! @param[out] alu The factored matrix stored in Modified Sparse Row !!  (MSR) format containing the L and U factors together.  The diagonal, !!  stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU !!  matrix contains the i-th row of L, excluding the diagonal entry, !!  followed by the i-th row of U. !! @param[out] jlu The column indices for the factored matrix. !! @param[out] ju An N-element array containing the pointers to the !!  beginning of each row of U in the factored matrix. !! @param[in] iwk The lengths of @p alu and @p jlu. !! @param[out] w An N+1 element workspace array. !! @param[out] jw A 2*N element workspace array. !! @param[out] iperm A 2*N element array containing the permutation !!  arrays.  IPERM(1:N) contains the old numbers of unknowns, and !!  IPERM(N+1:) contains the new unknowns. !! @param[out] ierr Error flag: !!  * 0: Successful return !!  * .gt. 0: Zero pivot encountered at step number IERR. !!  * -1: Input matrix is incorrect.  The elimination process generated !!      a row in L or U whose length is greater than N. !!  * -2: The matrix L overflows the output array. !!  * -3: The matrix U overflows the output array. !!  * -4: Illegal value for @P lfil. !!  * -5: Zero-valued row encountered. !! !! @par Remarks !! To avoid permuting the solution vector arrays for each LU-solve, the !! matrix A is permuted on return.  Similarly for the U matrix.  To !! permute the matrix back to its original state, use the following !! code. !! @code{.f90} !! do k = ia(1), ia(n+1) - 1 !!  ja(k) = iperm(ja(k)) !! end do !! @endcode pure subroutine ilutp ( n , a , ja , ia , lfil , droptol , permtol , mbloc , alu , & jlu , ju , iwk , w , jw , iperm , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , lfil , iwk , mbloc integer ( int32 ), intent ( inout ) :: ja ( * ), ia ( n + 1 ) integer ( int32 ), intent ( out ) :: jlu ( * ), ju ( n ), jw ( 2 * n ), & iperm ( 2 * n ), ierr real ( real64 ), intent ( in ) :: droptol , permtol real ( real64 ), intent ( inout ) :: a ( * ) real ( real64 ), intent ( out ) :: alu ( * ), w ( n + 1 ) end subroutine !> @brief Computes the incomplete LU factorization of a sparse matrix !! in CSR format with standard dropping strategy. !! !! @param[in] n The row dimension of the matrix. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] alph The diagonal compensation parameter.  If ALPH = 0, !!  the process is approximately equivalent to ILU with threshold; else, !!  if ALPH = 1, the process is approximately equivalent to MILU with !!  threshold. !! @param[in] tol The threshold parameter for dropping small terms in !!  the factorization. !! @param[out] alu The factored matrix stored in Modified Sparse Row !!  (MSR) format containing the L and U factors together.  The diagonal, !!  stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU !!  matrix contains the i-th row of L, excluding the diagonal entry, !!  followed by the i-th row of U. !! @param[out] jlu The column indices for the factored matrix. !! @param[out] ju An N-element array containing the pointers to the !!  beginning of each row of U in the factored matrix. !! @param[in] iwk The lengths of @p alu and @p jlu. !! @param[out] w An N+1 element workspace array. !! @param[out] jw A 2*N element workspace array. !! @param[out] ierr Error flag: !!  * 0: Successful return !!  * .gt. 0: Zero pivot encountered at step number IERR. !!  * -1: Input matrix is incorrect.  The elimination process generated !!      a row in L or U whose length is greater than N. !!  * -2: Insufficient storage for the LU factors. !!  * -3: Zero-valued row encountered. pure subroutine ilud ( n , a , ja , ia , alph , tol , alu , jlu , ju , iwk , w , jw , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , iwk , ja ( * ), ia ( n + 1 ) integer ( int32 ), intent ( out ) :: jlu ( * ), ju ( n ), jw ( 2 * n ), ierr real ( real64 ), intent ( in ) :: a ( * ), alph , tol real ( real64 ), intent ( out ) :: alu ( * ), w ( 2 * n ) end subroutine !> @brief Computes the incomplete LU factorization of a sparse matrix !! in CSR format with standard dropping strategy. !! !! @param[in] n The row dimension of the matrix. !! @param[in] a The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] alph The diagonal compensation parameter.  If ALPH = 0, !!  the process is approximately equivalent to ILU with threshold; else, !!  if ALPH = 1, the process is approximately equivalent to MILU with !!  threshold. !! @param[in] droptol The threshold for dropping small terms in the !!  factorization. !! @param[in] permtol A tolerance ratio used to determine whether or !!  not to permute two columns.  At step I, columns I and J are !!  permuted when ABS(A(I,J)) * PERMTOL .GT. ABS(A(I,I)).  Good values !!  are typically between 0.1 to 0.01. !! @param[in] mbloc If desired, permuting can be done only within the !!  diagonal blocks of size MBLOC.  Useful for PDE problems with many !!  degrees of freedom.  If this feature is not required, simply set !!  MBLOC equal to N. !! @param[out] alu The factored matrix stored in Modified Sparse Row !!  (MSR) format containing the L and U factors together.  The diagonal, !!  stored in ALU(1:N), is inverted.  Each i-th row of the ALU, JLU !!  matrix contains the i-th row of L, excluding the diagonal entry, !!  followed by the i-th row of U. !! @param[out] jlu The column indices for the factored matrix. !! @param[out] ju An N-element array containing the pointers to the !!  beginning of each row of U in the factored matrix. !! @param[in] iwk The lengths of @p alu and @p jlu. !! @param[out] w An N+1 element workspace array. !! @param[out] jw A 2*N element workspace array. !! @param[out] ierr Error flag: !!  * 0: Successful return !!  * .gt. 0: Zero pivot encountered at step number IERR. !!  * -1: Input matrix is incorrect.  The elimination process generated !!      a row in L or U whose length is greater than N. !!  * -2: Insufficient storage for the LU factors. !!  * -3: Zero-valued row encountered. pure subroutine iludp ( n , a , ja , ia , alph , droptol , permtol , mbloc , alu , & jlu , ju , iwk , w , jw , iperm , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , iwk , mbloc integer ( int32 ), intent ( inout ) :: ja ( * ), ia ( n + 1 ) integer ( int32 ), intent ( out ) :: jlu ( * ), ju ( n ), jw ( 2 * n ), iperm ( 2 * n ), & ierr real ( real64 ), intent ( in ) :: alph , droptol , permtol real ( real64 ), intent ( inout ) :: a ( * ) real ( real64 ), intent ( out ) :: alu ( * ), w ( 2 * n ) end subroutine !> @brief An ILUT preconditioned GMRES algorithm.  This routine utilizes !! the L and U matrices generated by the ILUT routine to precondition !! the GMRES algorithm.  The stopping criteria utilized is based simply !! on reducing the residual norm to the requested tolerance. !! !! @param[in] n The row dimension of the matrix. !! @param[in] im The size of the Krylov subspace.  This value should !!  not exceed 50. !! @param[in,out] rhs The N-element right-hand-side vector.  On output, !!  the contents of this array are overwritten. !! @param[in,out] sol On input, the N-element solution estimate.  On !!  output, the computed solution. !! @param[out] vv An N-by-IM+1 workspace matrix. !! @param[in] eps The convergence tolerance against which the norm of !!  the residual is checked. !! @param[in] maxits The maximum number of iterations to allow. !! @param[in] iout The device output number for printing intermediate !!  results.  Set to a value less than or equal to zero to suppress !!  printing. !! @param[in] aa The non-zero elements of matrix A. !! @param[in] ja The column indices of matrix A. !! @param[in] ia The index in A where the requested row starts. !! @param[in] alu The LU-factored matrix from ILUT. !! @param[in] jlu The LU-factored matrix from ILUT. !! @param[in] ju The LU-factored matrix from ILUT. !! @param[out] ierr Error flag: !!  * 0: Successful return !!  * 1: Convergence not achieved. !!  * -1: The initial guess seems to be the exact solution. pure subroutine pgmres ( n , im , rhs , sol , vv , eps , maxits , iout , aa , ja , ia , & alu , jlu , ju , ierr ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , im , maxits , iout , ja ( * ), ia ( n + 1 ), & jlu ( * ), ju ( n ) integer ( int32 ), intent ( out ) :: ierr real ( real64 ), intent ( in ) :: aa ( * ), eps , alu ( * ) real ( real64 ), intent ( inout ) :: rhs ( n ), sol ( n ) real ( real64 ), intent ( out ) :: vv ( n , * ) end subroutine !> @brief Solves the LU-factored system (LU) x = y. !! !! @param[in] n The dimension of the system. !! @param[in] y The N-element right-hand-side vector. !! @param[out] x The N-element solution vector. !! @param[in] alu The LU-factored matrix. !! @param[in] jlu The LU-factored matrix. !! @param[in] ju The LU-factored matrix. pure subroutine lusol ( n , y , x , alu , jlu , ju ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: n , jlu ( * ), ju ( * ) real ( real64 ), intent ( in ) :: y ( n ), alu ( * ) real ( real64 ), intent ( out ) :: x ( n ) end subroutine end interface end module","tags":"","loc":"sourcefile\\sparskit.f90.html"},{"title":"caxcpy.f – LINALG","text":"Contents Subroutines caxcpy Source Code caxcpy.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine caxcpy ( n , a , x , incx , y , incy ) c purpose:      constant times a conjugated vector plus a vector. c arguments: c n (in)        vector length c a (in)        complex factor c x (in)        added vector c incx (in)     x increments c y (io)        accumulator vector c incy (in)     y increments c integer n , incx , incy complex a , x ( * ), y ( * ) integer i , ix , iy c quick return if possible. if ( n <= 0 ) return if ( incx /= 1 . or . incy /= 1 ) then c code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n y ( iy ) = y ( iy ) + a * conjg ( x ( ix )) ix = ix + incx iy = iy + incy end do else c code for both increments equal to 1 do i = 1 , n y ( i ) = y ( i ) + a * conjg ( x ( i )) end do end if end subroutine","tags":"","loc":"sourcefile\\caxcpy.f.html"},{"title":"cch1dn.f – LINALG","text":"Contents Subroutines cch1dn Source Code cch1dn.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cch1dn ( n , R , ldr , u , rw , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine downdates R -> R1 so that c               R1'*R1 = A - u*u' c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the reflector sines c               used to transform R to R1. c rw (out)      cosine parts of reflectors. c c info (out)    on exit, error code: c                info = 0: success. c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , ldr complex R ( ldr , * ), u ( * ) real rw ( * ) integer info external ctrsv , clartg , scnrm2 complex crho , rr , ui , t real scnrm2 , rho integer i , j c quick return if possible. if ( n == 0 ) return c check arguments. info = 0 if ( n < 0 ) then info = - 1 else if ( ldr < n ) then info = - 3 end if if ( info /= 0 ) then call xerbla ( 'CCH1DN' , - info ) return end if c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0e0 ) goto 20 end do c form R' \\ u call ctrsv ( 'U' , 'C' , 'N' , n , R , ldr , u , 1 ) rho = scnrm2 ( n , u , 1 ) c check positive definiteness rho = 1 - rho ** 2 if ( rho <= 0e0 ) goto 10 crho = sqrt ( rho ) c eliminate R' \\ u do i = n , 1 , - 1 ui = u ( i ) c generate next rotation call clartg ( crho , ui , rw ( i ), u ( i ), rr ) crho = rr end do c apply rotations do i = n , 1 , - 1 ui = 0e0 do j = i , 1 , - 1 t = rw ( j ) * ui + u ( j ) * R ( j , i ) R ( j , i ) = rw ( j ) * R ( j , i ) - conjg ( u ( j )) * ui ui = t end do end do c normal return return c error returns 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\cch1dn.f.html"},{"title":"cch1up.f – LINALG","text":"Contents Subroutines cch1up Source Code cch1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cch1up ( n , R , ldr , u , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A + u*u' c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the rotation sines c               used to transform R to R1. c w (out)       cosine parts of rotations. c integer n , ldr complex R ( ldr , * ), u ( * ) real w ( * ) external clartg complex rr , ui , t integer i , j do i = 1 , n c apply stored rotations, column-wise ui = conjg ( u ( i )) do j = 1 , i - 1 t = w ( j ) * R ( j , i ) + u ( j ) * ui ui = w ( j ) * ui - conjg ( u ( j )) * R ( j , i ) R ( j , i ) = t end do c generate next rotation call clartg ( R ( i , i ), ui , w ( i ), u ( i ), rr ) R ( i , i ) = rr end do end subroutine","tags":"","loc":"sourcefile\\cch1up.f.html"},{"title":"cchdex.f – LINALG","text":"Contents Subroutines cchdex Source Code cchdex.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cchdex ( n , R , ldr , j , rw ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(jj,jj), where jj = [1:j-1,j+1:n+1]. c               (complex version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n. c j (in)        the position of the deleted row/column. c rw (out)      a real workspace vector of size n. c integer n , ldr , j complex R ( ldr , * ) real rw ( * ) integer info , i external xerbla , ccopy , cqhqr c quick return if possible if ( n == 1 ) return c check arguments info = 0 if ( n < 0 ) then info = 1 else if ( j < 1 . or . j > n ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'CCHDEX' , info ) return end if c delete the j-th column. do i = j , n - 1 call ccopy ( n , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < n ) then call cqhqr ( n + 1 - j , n - j , R ( j , j ), ldr , rw , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\cchdex.f.html"},{"title":"cchinx.f – LINALG","text":"Contents Subroutines cchinx Source Code cchinx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cchinx ( n , R , ldr , j , u , rw , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A1, A1(jj,jj) = A, A(j,:) = u', A(:,j) = u, c               jj = [1:j-1,j+1:n+1]. c               (complex version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n+1. c j (in)        the position of the inserted row/column c u (io)        on entry, the inserted row/column. c               on exit, u is destroyed. c rw (out)      real workspace vector of size n+1. c info (out)    on exit, error code: c                info = 0: success. c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c                info = 3: diagonal element of u is not real. c integer n , j , ldr , info complex R ( ldr , * ), u ( * ), rw ( * ) external xerbla , ccopy , scnrm2 , ctrsv , cqrtv1 , cqrqh complex t real scnrm2 , rho integer i c check arguments info = 0 if ( n < 0 ) then info = - 1 else if ( j < 1 . or . j > n + 1 ) then info = - 4 end if if ( info /= 0 ) then call xerbla ( 'CCHINX' , info ) return end if c shift vector. t = u ( j ) do i = j , n u ( i ) = u ( i + 1 ) end do c the diagonal element must be real. if ( imag ( t ) /= 0e0 ) goto 30 c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0e0 ) goto 20 end do c form R' \\ u call ctrsv ( 'U' , 'C' , 'N' , n , R , ldr , u , 1 ) rho = scnrm2 ( n , u , 1 ) c check positive definiteness. rho = t - rho ** 2 if ( rho <= 0e0 ) goto 10 c shift columns do i = n , j , - 1 call ccopy ( i , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) R ( i + 1 , i + 1 ) = 0e0 end do call ccopy ( n , u , 1 , R ( 1 , j ), 1 ) R ( n + 1 , j ) = sqrt ( rho ) c retriangularize if ( j < n + 1 ) then c eliminate the introduced spike. call cqrtv1 ( n + 2 - j , R ( j , j ), rw ) c apply rotations to R call cqrqh ( n + 2 - j , n + 1 - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c zero spike. do i = j + 1 , n + 1 R ( i , j ) = 0e0 end do end if c normal return. return c error returns. 10 info = 1 return 20 info = 2 return 30 info = 3 return end subroutine","tags":"","loc":"sourcefile\\cchinx.f.html"},{"title":"cchshx.f – LINALG","text":"Contents Subroutines cchshx Source Code cchshx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cchshx ( n , R , ldr , i , j , w , rw ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(p,p), where p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c i (in)        the first index determining the range (see above). c j (in)        the second index determining the range (see above). c w (o)         a workspace vector of size n. c rw (o)        a real workspace vector of size n. c integer n , ldr , i , j complex R ( ldr , * ), w ( * ) real rw ( * ) external xerbla , ccopy , cqrtv1 , cqrqh , cqhqr integer info , l c quick return if possible. if ( n == 0 . or . n == 1 ) return info = 0 c check arguments. if ( n < 0 ) then info = 1 else if ( i < 1 . or . i > n ) then info = 4 else if ( j < 1 . or . j > n ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'CCHSHX' , info ) return end if if ( i < j ) then c shift columns call ccopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call ccopy ( n , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call ccopy ( n , w , 1 , R ( 1 , j ), 1 ) c retriangularize call cqhqr ( n + 1 - i , n + 1 - i , R ( i , i ), ldr , rw , w ) else if ( j < i ) then c shift columns call ccopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call ccopy ( n , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call ccopy ( n , w , 1 , R ( 1 , j ), 1 ) c eliminate the introduced spike. call cqrtv1 ( n + 1 - j , R ( j , j ), rw ) c apply rotations to R call cqrqh ( n + 1 - j , n - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c zero spike. do l = j + 1 , n R ( l , j ) = 0e0 end do end if end subroutine","tags":"","loc":"sourcefile\\cchshx.f.html"},{"title":"cgqvec.f – LINALG","text":"Contents Subroutines cgqvec Source Code cgqvec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cgqvec ( m , n , Q , ldq , u ) c purpose:      given an unitary m-by-n matrix Q, n < m, generates c               a vector u such that Q'*u = 0 and norm(u) = 1. c arguments: c m (in)        number of rows of matrix Q. c n (in)        number of columns of matrix Q. c Q (in)        the unitary matrix Q. c ldq (in)      leading dimension of Q. c u (out)       the generated vector. c integer m , n , ldq complex Q ( ldq , * ), u ( * ) external cdotu , caxpy , scnrm2 , csscal complex cdotu real scnrm2 , r integer info , i , j c quick return if possible. if ( m == 0 ) return if ( n == 0 ) then u ( 1 ) = 1e0 do i = 2 , m u ( i ) = 0e0 end do return end if c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldq < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'CGQVEC' , info ) return end if j = 1 10 continue c probe j-th canonical unit vector. do i = 1 , m u ( i ) = 0e0 end do u ( j ) = 1e0 c form u - Q*Q'*u do i = 1 , n r = cdotu ( m , Q ( 1 , i ), 1 , u , 1 ) call caxpy ( m , - r , Q ( 1 , i ), 1 , u , 1 ) end do r = scnrm2 ( m , u , 1 ) if ( r == 0e0 ) then j = j + 1 if ( j > n ) then c this is fatal, and in theory, it can't happen. stop 'fatal: impossible condition in CGQVEC' else j = j + 1 goto 10 end if end if call csscal ( m , 1e0 / r , u , 1 ) end subroutine","tags":"","loc":"sourcefile\\cgqvec.f.html"},{"title":"clu1up.f – LINALG","text":"Contents Subroutines clu1up Source Code clu1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine clu1up ( m , n , L , ldl , R , ldr , u , v ) c purpose:      updates an LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal and a k-by-n upper-trapezoidal matrix R, c               where k = min(m,n), c               this subroutine updates L -> L1 and R -> R1 so that c               L is again lower unit triangular, R upper trapezoidal, c               and L1*R1 = L*R + u*v.'. c               (complex version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c c REMARK:       Algorithm is due to c               J. Bennett: Triangular factors of modified matrices, c                           Numerische Mathematik, 7 (1965) c integer m , n , ldl , ldr complex L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ) complex ui , vi integer k , info , i , j external xerbla c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'CLU1UP' , info ) return end if c The Bennett algorithm, modified for column-major access. c The leading part. do i = 1 , k c prefetch ui = u ( i ) vi = v ( i ) c delayed R update do j = 1 , i - 1 R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do c diagonal update R ( i , i ) = R ( i , i ) + ui * vi vi = vi / R ( i , i ) c L update do j = i + 1 , m u ( j ) = u ( j ) - ui * L ( j , i ) L ( j , i ) = L ( j , i ) + u ( j ) * vi end do u ( i ) = ui v ( i ) = vi end do c Finish the trailing part of R if needed. do i = k + 1 , n vi = v ( i ) do j = 1 , k R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do v ( i ) = vi end do end subroutine","tags":"","loc":"sourcefile\\clu1up.f.html"},{"title":"clup1up.f – LINALG","text":"Contents Subroutines clup1up Source Code clup1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine clup1up ( m , n , L , ldl , R , ldr , p , u , v , w ) c purpose:      updates a row-pivoted LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal, a k-by-n upper-trapezoidal matrix R, and a c               permutation matrix P, where k = min(m,n), c               this subroutine updates L -> L1, R -> R1 and P -> P1 so that c               L is again lower unit triangular, R upper trapezoidal, c               P permutation and P1'*L1*R1 = P'*L*R + u*v.'. c               (complex version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c p (in)        the permutation vector representing P c u (in)        the left m-vector. c v (in)        the right n-vector. c w (work)      a workspace vector of size m. c c REMARK:       Algorithm is due to c               A. Kielbasinski, H. Schwetlick, Numerische Lineare c               Algebra, Verlag Harri Deutsch, 1988 c integer m , n , ldl , ldr , p ( * ) complex L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) complex one , tmp real tau parameter ( one = 1e0 , tau = 1e-1 ) integer k , info , i , j , itmp external xerbla , ccopy , caxpy , ctrsv , cgeru , cgemv c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'CLU1UP' , info ) return end if c form L \\ P*u. do i = 1 , m w ( i ) = u ( p ( i )) end do call ctrsv ( 'L' , 'N' , 'U' , k , L , ldl , w , 1 ) c if m > k = n, subtract the trailing part. if ( m > k ) then call cgemv ( 'N' , m - k , k , - one , L ( k + 1 , 1 ), ldl , w , 1 , one , w ( k + 1 ), 1 ) end if c work from bottom to top do j = k - 1 , 1 , - 1 if ( abs ( w ( j )) < tau * abs ( L ( j + 1 , j ) * w ( j ) + w ( j + 1 ))) then c need pivoting. swap j and j+1 tmp = w ( j ) w ( j ) = w ( j + 1 ) w ( j + 1 ) = tmp c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call cswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call cswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call cswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call caxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call caxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) c update w w ( j ) = w ( j ) - tmp * w ( j + 1 ) end if c eliminate w(j+1) tmp = w ( j + 1 ) / w ( j ) w ( j + 1 ) = 0 c update R. call caxpy ( n - j + 1 , - tmp , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c update L. call caxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c add a multiple of v to R call caxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c forward sweep do j = 1 , k - 1 if ( abs ( R ( j , j )) < tau * abs ( L ( j + 1 , j ) * R ( j , j ) + R ( j + 1 , j ))) then c need pivoting. swap j and j+1 c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call cswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call cswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call cswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call caxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call caxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) end if c eliminate R(j+1,j) tmp = R ( j + 1 , j ) / R ( j , j ) c update R. R ( j + 1 , j ) = 0e0 call caxpy ( n - j , - tmp , R ( j , j + 1 ), ldr , R ( j + 1 , j + 1 ), ldr ) c update L. call caxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c if m > k = n, complete the update by updating the lower part of L. if ( m > k ) then call ccopy ( k , v , 1 , w , 1 ) call ctrsv ( 'U' , 'T' , 'N' , k , R , ldr , w , 1 ) call cgeru ( m - k , k , one , w ( k + 1 ), 1 , w , 1 , L ( k + 1 , 1 ), ldl ) endif end subroutine","tags":"","loc":"sourcefile\\clup1up.f.html"},{"title":"cqhqr.f – LINALG","text":"Contents Subroutines cqhqr Source Code cqhqr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqhqr ( m , n , R , ldr , c , s ) c purpose:      given an m-by-n upper Hessenberg matrix R, this c               subroutine updates R to upper trapezoidal form c               using min(m-1,n) Givens rotations. c               (complex version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(out)        rotation cosines, size at least min(m-1,n) c s(out)        rotation sines, size at least min(m-1,n) c integer m , n , ldr complex R ( ldr , * ), s ( * ) real c ( * ) external xerbla , clartg complex t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'CQHQR' , info ) return end if do i = 1 , n c apply stored rotations, column-wise t = R ( 1 , i ) ii = min ( m , i ) do j = 1 , ii - 1 R ( j , i ) = c ( j ) * t + s ( j ) * R ( j + 1 , i ) t = c ( j ) * R ( j + 1 , i ) - conjg ( s ( j )) * t end do if ( ii < m ) then c generate next rotation call clartg ( t , R ( ii + 1 , i ), c ( i ), s ( i ), R ( ii , i )) R ( ii + 1 , i ) = 0e0 else R ( ii , i ) = t end if end do end subroutine","tags":"","loc":"sourcefile\\cqhqr.f.html"},{"title":"cqr1up.f – LINALG","text":"Contents Subroutines cqr1up Source Code cqr1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqr1up ( m , n , k , Q , ldq , R , ldr , u , v , w , rw ) c purpose:      updates a QR factorization after rank-1 modification c               i.e., given a m-by-k unitary Q and m-by-n upper c               trapezoidal R, an m-vector u and n-vector v, c               this subroutine updates Q -> Q1 and R -> R1 so that c               Q1*R1 = Q*R + u*v', and Q1 is again unitary c               and R1 upper trapezoidal. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      the leading dimension of Q. ldq >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R.. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= k. c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c w (out)       a workspace vector of size k. c rw (out)      a real workspace vector of size k. c integer m , n , k , ldq , ldr complex Q ( ldq , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) real rw ( * ) external cqrqh , cqhqr , cqrot , cqrtv1 , caxcpy external caxpy , cdotc , scnrm2 , slamch , csscal , crot complex cdotc real scnrm2 , slamch , ru , ruu integer info , i logical full c quick return if possible. if ( k == 0 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 endif if ( info /= 0 ) then call xerbla ( 'CQR1UP' , info ) return end if full = k == m c in the non-full case, we shall need the norm of u. if (. not . full ) ru = scnrm2 ( m , u , 1 ) c form Q'*u. In the non-full case, form also u - Q*Q'u. do i = 1 , k w ( i ) = cdotc ( m , Q ( 1 , i ), 1 , u , 1 ) if (. not . full ) call caxpy ( m , - w ( i ), Q ( 1 , i ), 1 , u , 1 ) end do c generate rotations to eliminate Q'*u. call cqrtv1 ( k , w , rw ) c apply rotations to R. call cqrqh ( k , n , R , ldr , rw , w ( 2 )) c apply rotations to Q. call cqrot ( 'B' , m , k , Q , ldq , rw , w ( 2 )) c update the first row of R. call caxcpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c retriangularize R. call cqhqr ( k , n , R , ldr , rw , w ) c apply rotations to Q. call cqrot ( 'F' , m , min ( k , n + 1 ), Q , ldq , rw , w ) c in the full case, we're finished if ( full ) return c compute relative residual norm ruu = scnrm2 ( m , u , 1 ) ru = ru * slamch ( 'e' ) if ( ruu <= ru ) return c update the orthogonal basis. call csscal ( n , ruu , v , 1 ) call csscal ( m , 1e0 / ruu , u , 1 ) call cch1up ( n , R , ldr , v , rw ) do i = 1 , n call crot ( m , Q ( 1 , i ), 1 , u , 1 , rw ( i ), conjg ( v ( i ))) end do end subroutine","tags":"","loc":"sourcefile\\cqr1up.f.html"},{"title":"cqrdec.f – LINALG","text":"Contents Subroutines cqrdec Source Code cqrdec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrdec ( m , n , k , Q , ldq , R , ldr , j , rw ) c purpose:      updates a QR factorization after deleting c               a column. c               i.e., given an m-by-k unitary matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 remains unitary, R1 is upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1) A(:,j+1:n)], c               where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form, c               basis dimension will decrease). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c j (in)        the position of the deleted column in R. c               1 <= j <= n. c rw (o)        a real workspace vector of size k-j. c integer m , n , k , ldq , ldr , j complex Q ( ldq , * ), R ( ldr , * ) real rw ( * ) external xerbla , ccopy , cqhqr , cqrot integer info , i c quick return if possible. if ( m == 0 . or . n == 0 . or . j == n ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'CQRDEC' , info ) return end if c delete the j-th column. do i = j , n - 1 call ccopy ( k , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < k ) then call cqhqr ( k + 1 - j , n - j , R ( j , j ), ldr , rw , R ( 1 , n )) c apply rotations to Q. call cqrot ( 'F' , m , min ( k , n ) + 1 - j , Q ( 1 , j ), ldq , rw , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\cqrdec.f.html"},{"title":"cqrder.f – LINALG","text":"Contents Subroutines cqrder Source Code cqrder.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrder ( m , n , Q , ldq , R , ldr , j , w , rw ) c purpose:      updates a QR factorization after deleting a row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m, this subroutine updates Q ->Q1 and an R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); A(j+1:m,:)], where A = Q*R. c               (complex version) c c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m. c j (in)        the position of the deleted row. c w (out)       a workspace vector of size m. c rw (out)      a real workspace vector of size m. c integer m , n , j , ldq , ldr complex Q ( ldq , * ), R ( ldr , * ), w ( * ) real rw ( * ) external xerbla , ccopy , cqrtv1 , cqrot , cqrqh integer info , i , k c quick return if possible if ( m == 1 ) return c check arguments info = 0 if ( m < 1 ) then info = 1 else if ( j < 1 . or . j > m ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'CQRDER' , info ) return end if c eliminate Q(j,2:m). do k = 1 , m w ( k ) = conjg ( Q ( j , k )) end do call cqrtv1 ( m , w , rw ) c apply rotations to Q. call cqrot ( 'B' , m , m , Q , ldq , rw , w ( 2 )) c form Q1. do k = 1 , m - 1 if ( j > 1 ) call ccopy ( j - 1 , Q ( 1 , k + 1 ), 1 , Q ( 1 , k ), 1 ) if ( j < m ) call ccopy ( m - j , Q ( j + 1 , k + 1 ), 1 , Q ( j , k ), 1 ) end do c apply rotations to R. call cqrqh ( m , n , R , ldr , rw , w ( 2 )) c form R1. do k = 1 , n do i = 1 , m - 1 R ( i , k ) = R ( i + 1 , k ) end do end do end subroutine","tags":"","loc":"sourcefile\\cqrder.f.html"},{"title":"cqrinc.f – LINALG","text":"Contents Subroutines cqrinc Source Code cqrinc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrinc ( m , n , k , Q , ldq , R , ldr , j , x , rw ) c purpose:      updates a QR factorization after inserting a new c               column. c               i.e., given an m-by-k unitary matrix Q, an m-by-n upper c               trapezoidal matrix R and index j in the range 1:n+1, c               this subroutine updates the matrix Q -> Q1 and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, and c               Q1*R1 = [A(:,1:j-1); x; A(:,j:n)], where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n <= m (economical form, c               basis dimension will increase). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= min(m,n+1). c j (in)        the position of the new column in R1 c x (in)        the column being inserted c rw (out)      a real workspace vector of size k. c integer m , n , k , ldq , ldr , j complex Q ( ldq , * ), R ( ldr , * ), x ( * ) real rw ( * ) external cqrtv1 , cqrqh , cqrot external xerbla , ccopy , cdotc , caxpy , csscal , scnrm2 complex cdotc real scnrm2 , rx integer info , i , k1 logical full c quick return if possible. if ( m == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < min ( m , k + 1 )) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'CQRINC' , info ) return end if full = k == m c insert empty column at j-th position do i = n , j , - 1 call ccopy ( k , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) end do c insert Q'*u into R. In the nonfull case, form also u-Q*Q'*u. if ( full ) then k1 = k do i = 1 , k R ( i , j ) = cdotc ( m , Q ( 1 , i ), 1 , x , 1 ) end do else k1 = k + 1 c zero last row of R do i = 1 , n + 1 R ( k1 , i ) = 0e0 end do call ccopy ( m , x , 1 , Q ( 1 , k1 ), 1 ) do i = 1 , k R ( i , j ) = cdotc ( m , Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) call caxpy ( m , - R ( i , j ), Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) end do c get norm of the inserted column rx = scnrm2 ( m , Q ( 1 , k1 ), 1 ) R ( k1 , j ) = rx if ( rx == 0e0 ) then c in the rare case when rx is exact zero, we still need to provide c a valid orthogonal unit vector. The details are boring, so handle c that elsewhere. call cgqvec ( m , k , Q , ldq , Q ( 1 , k1 )) else c otherwise, just normalize the added column. call csscal ( m , 1e0 / rx , Q ( 1 , k1 ), 1 ) end if end if c maybe we're finished. if ( j > k ) return c eliminate the spike. call cqrtv1 ( k1 + 1 - j , R ( j , j ), rw ) c apply rotations to R(j:k,j:n). if ( j <= n ) call cqrqh ( k1 + 1 - j , n + 1 - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c apply rotations to Q(:,j:k). call cqrot ( 'B' , m , k1 + 1 - j , Q ( 1 , j ), ldq , rw , R ( j + 1 , j )) c zero spike. do i = j + 1 , k1 R ( i , j ) = 0e0 end do end subroutine","tags":"","loc":"sourcefile\\cqrinc.f.html"},{"title":"cqrinr.f – LINALG","text":"Contents Subroutines cqrinr Source Code cqrinr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrinr ( m , n , Q , ldq , R , ldr , j , x , rw ) c purpose:      updates a QR factorization after inserting a new c               row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m+1, this subroutine updates Q -> Q1  and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); x; A(j:m,:)], where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m+1. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m+1. c j (in)        the position of the new row in R1 c x (io)        on entry, the row being added c               on exit, x is destroyed. c rw (out)      a real workspace vector of size min(m,n). c integer m , n , j , ldq , ldr complex Q ( ldq , * ), R ( ldr , * ), x ( * ) real rw ( * ) external xerbla , ccopy , cqhqr , cqrot integer info , i , k c check arguments info = 0 if ( n < 0 ) then info = 2 else if ( j < 1 . or . j > m + 1 ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'CQRINR' , info ) return end if c permute the columns of Q1 and rows of R1 so that c the new row ends c up being the topmost row of R1. do i = m , 1 , - 1 if ( j > 1 ) then call ccopy ( j - 1 , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 ) end if Q ( j , i + 1 ) = 0e0 if ( j <= m ) then call ccopy ( m + 1 - j , Q ( j , i ), 1 , Q ( j + 1 , i + 1 ), 1 ) end if end do c set up the 1st column do i = 1 , j - 1 Q ( i , 1 ) = 0e0 end do Q ( j , 1 ) = 1e0 do i = j + 1 , m + 1 Q ( i , 1 ) = 0e0 end do c set up the new matrix R1 do k = 1 , n if ( k < m ) R ( m + 1 , k ) = 0e0 do i = min ( m , k ), 1 , - 1 R ( i + 1 , k ) = R ( i , k ) end do R ( 1 , k ) = x ( k ) end do c retriangularize R call cqhqr ( m + 1 , n , R , ldr , rw , x ) c apply rotations to Q call cqrot ( 'F' , m + 1 , min ( m , n ) + 1 , Q , ldq , rw , x ) end subroutine","tags":"","loc":"sourcefile\\cqrinr.f.html"},{"title":"cqrot.f – LINALG","text":"Contents Subroutines cqrot Source Code cqrot.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrot ( dir , m , n , Q , ldq , c , s ) c purpose:      Apply a sequence of inv. rotations from right c c arguments: c dir (in)      if 'B' or 'b', rotations are applied from backwards c               if 'F' or 'f', from forwards. c m (in)        number of rows of matrix Q c n (in)        number of columns of the matrix Q c Q (io)        on entry, the matrix Q c               on exit, the updated matrix Q1 c ldq (in)      the leading dimension of Q c c (in)        n-1 rotation cosines c s (in)        n-1 rotation sines c character dir integer m , n , ldq complex Q ( ldq , * ), s ( * ) real c ( * ) external crot , lsame logical lsame , fwd integer info , i c quick return if possible if ( m == 0 . or . n == 0 . or . n == 1 ) return c check arguments. info = 0 fwd = lsame ( dir , 'F' ) if (. not .( fwd . or . lsame ( dir , 'B' ))) then info = 1 else if ( m < 0 ) then info = 2 else if ( n < 0 ) then info = 3 else if ( ldq < m ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'CQROT' , info ) return end if if ( fwd ) then do i = 1 , n - 1 call crot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), conjg ( s ( i ))) end do else do i = n - 1 , 1 , - 1 call crot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), conjg ( s ( i ))) end do end if end subroutine","tags":"","loc":"sourcefile\\cqrot.f.html"},{"title":"cqrqh.f – LINALG","text":"Contents Subroutines cqrqh Source Code cqrqh.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrqh ( m , n , R , ldr , c , s ) c purpose:      brings an upper trapezoidal matrix R into upper c               Hessenberg form using min(m-1,n) Givens rotations. c               (complex version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(in)         rotation cosines, size at least min(m-1,n) c s(in)         rotation sines, size at least min(m-1,n) c integer m , n , ldr complex R ( ldr , * ), s ( * ) real c ( * ) external xerbla complex t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'CQRQH' , info ) return end if do i = 1 , n c apply stored rotations, column-wise ii = min ( m - 1 , i ) t = R ( ii + 1 , i ) do j = ii , 1 , - 1 R ( j + 1 , i ) = c ( j ) * t - conjg ( s ( j )) * R ( j , i ) t = c ( j ) * R ( j , i ) + s ( j ) * t end do R ( 1 , i ) = t end do end subroutine","tags":"","loc":"sourcefile\\cqrqh.f.html"},{"title":"cqrshc.f – LINALG","text":"Contents Subroutines cqrshc Source Code cqrshc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrshc ( m , n , k , Q , ldq , R , ldr , i , j , w , rw ) c purpose:      updates a QR factorization after circular shift of c               columns. c               i.e., given an m-by-k unitary matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again unitary, R1 upper c               trapezoidal, and c               Q1*R1 = A(:,p), where A = Q*R and p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q1, and rows of R1. Must be c               either k = m (full Q) or k = n <= m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c i (in)        the first index determining the range (see above) c j (in)        the second index determining the range (see above) c w (o)         a workspace vector of size k. c rw (o)        a real workspace vector of size k. c integer m , n , k , ldq , ldr , i , j complex Q ( ldq , * ), R ( ldr , * ), w ( * ) real rw ( * ) external xerbla , ccopy , cqrtv1 , cqrqh , cqhqr integer info , jj , kk , l c quick return if possible. if ( m == 0 . or . n == 1 ) return info = 0 c check arguments. if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( i < 1 . or . i > n ) then info = 6 else if ( j < 1 . or . j > n ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'CQRSHC' , info ) return end if if ( i < j ) then c shift columns call ccopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call ccopy ( k , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call ccopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( i < k ) then kk = min ( k , j ) call cqhqr ( kk + 1 - i , n + 1 - i , R ( i , i ), ldr , rw , w ) c apply rotations to Q. call cqrot ( 'F' , m , kk + 1 - i , Q ( 1 , i ), ldq , rw , w ) end if else if ( j < i ) then c shift columns call ccopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call ccopy ( k , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call ccopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( j < k ) then jj = min ( j + 1 , n ) kk = min ( k , i ) c eliminate the introduced spike. call cqrtv1 ( kk + 1 - j , R ( j , j ), rw ) c apply rotations to R call cqrqh ( kk + 1 - j , n - j , R ( j , jj ), ldr , rw , R ( j + 1 , j )) c apply rotations to Q call cqrot ( 'B' , m , kk + 1 - j , Q ( 1 , j ), ldq , rw , R ( j + 1 , j )) c zero spike. do l = j + 1 , kk R ( l , j ) = 0e0 end do end if end if end subroutine","tags":"","loc":"sourcefile\\cqrshc.f.html"},{"title":"cqrtv1.f – LINALG","text":"Contents Subroutines cqrtv1 Source Code cqrtv1.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine cqrtv1 ( n , u , w ) c purpose:      generates a sequence of n-1 Givens rotations that c               eliminate all but the first element of a vector u. c arguments: c n (in)        the length of the vector u c u (io)        on entry, the vector u. c               on exit, u(2:n) contains the rotation sines, u(1) c               contains the remaining element. c w (o)         on exit, w contains the rotation cosines. c integer n complex u ( * ) real w ( * ) external clartg complex rr , t integer i c quick return if possible. if ( n <= 0 ) return rr = u ( n ) do i = n - 1 , 1 , - 1 call clartg ( u ( i ), rr , w ( i ), u ( i + 1 ), t ) rr = t end do u ( 1 ) = rr end subroutine","tags":"","loc":"sourcefile\\cqrtv1.f.html"},{"title":"dch1dn.f – LINALG","text":"Contents Subroutines dch1dn Source Code dch1dn.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dch1dn ( n , R , ldr , u , w , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine downdates R -> R1 so that c               R1'*R1 = A - u*u' c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the reflector sines c               used to transform R to R1. c w (out)       cosine parts of reflectors. c c info (out)    on exit, error code: c                info = 0: success. c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , ldr double precision R ( ldr , * ), u ( * ), w ( * ) integer info external dtrsv , dlartg , dnrm2 double precision dnrm2 , rho , rr , ui , t integer i , j c quick return if possible. if ( n == 0 ) return c check arguments. info = 0 if ( n < 0 ) then info = - 1 else if ( ldr < n ) then info = - 3 end if if ( info /= 0 ) then call xerbla ( 'DCH1DN' , - info ) return end if c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0 d0 ) goto 20 end do c form R' \\ u call dtrsv ( 'U' , 'T' , 'N' , n , R , ldr , u , 1 ) rho = dnrm2 ( n , u , 1 ) c check positive definiteness rho = 1 - rho ** 2 if ( rho <= 0 d0 ) goto 10 rho = sqrt ( rho ) c eliminate R' \\ u do i = n , 1 , - 1 ui = u ( i ) c generate next rotation call dlartg ( rho , ui , w ( i ), u ( i ), rr ) rho = rr end do c apply rotations do i = n , 1 , - 1 ui = 0 d0 do j = i , 1 , - 1 t = w ( j ) * ui + u ( j ) * R ( j , i ) R ( j , i ) = w ( j ) * R ( j , i ) - u ( j ) * ui ui = t end do end do c normal return return c error returns 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\dch1dn.f.html"},{"title":"dch1up.f – LINALG","text":"Contents Subroutines dch1up Source Code dch1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dch1up ( n , R , ldr , u , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A + u*u' c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the rotation sines c               used to transform R to R1. c w (out)       cosine parts of rotations. c integer n , ldr double precision R ( ldr , * ), u ( * ) double precision w ( * ) external dlartg double precision rr , ui , t integer i , j do i = 1 , n c apply stored rotations, column-wise ui = u ( i ) do j = 1 , i - 1 t = w ( j ) * R ( j , i ) + u ( j ) * ui ui = w ( j ) * ui - u ( j ) * R ( j , i ) R ( j , i ) = t end do c generate next rotation call dlartg ( R ( i , i ), ui , w ( i ), u ( i ), rr ) R ( i , i ) = rr end do end subroutine","tags":"","loc":"sourcefile\\dch1up.f.html"},{"title":"dchdex.f – LINALG","text":"Contents Subroutines dchdex Source Code dchdex.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dchdex ( n , R , ldr , j , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(jj,jj), where jj = [1:j-1,j+1:n+1]. c               (real version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n. c j (in)        the position of the deleted row/column. c w (out)       a workspace vector of size n. c integer n , ldr , j double precision R ( ldr , * ), w ( * ) integer info , i external xerbla , dcopy , dqhqr c quick return if possible if ( n == 1 ) return c check arguments info = 0 if ( n < 0 ) then info = 1 else if ( j < 1 . or . j > n ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'DCHDEX' , info ) return end if c delete the j-th column. do i = j , n - 1 call dcopy ( n , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < n ) then call dqhqr ( n + 1 - j , n - j , R ( j , j ), ldr , w , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\dchdex.f.html"},{"title":"dchinx.f – LINALG","text":"Contents Subroutines dchinx Source Code dchinx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dchinx ( n , R , ldr , j , u , w , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A1, A1(jj,jj) = A, A(j,:) = u', A(:,j) = u, c               jj = [1:j-1,j+1:n+1]. c               (real version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n+1. c j (in)        the position of the inserted row/column c u (io)        on entry, the inserted row/column. c               on exit, u is destroyed. c w (out)       workspace vector of size n+1. c info (out)    on exit, error code: c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , j , ldr , info double precision R ( ldr , * ), u ( * ), w ( * ) external xerbla , dcopy , dnrm2 , dtrsv , dqrtv1 , dqrqh double precision dnrm2 , t , rho integer i c check arguments info = 0 if ( n < 0 ) then info = - 1 else if ( j < 1 . or . j > n + 1 ) then info = - 4 end if if ( info /= 0 ) then call xerbla ( 'DCHINX' , - info ) return end if c shift vector. t = u ( j ) do i = j , n u ( i ) = u ( i + 1 ) end do c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0 d0 ) goto 20 end do c form R' \\ u call dtrsv ( 'U' , 'C' , 'N' , n , R , ldr , u , 1 ) rho = dnrm2 ( n , u , 1 ) c check positive definiteness. rho = t - rho ** 2 if ( rho <= 0 d0 ) goto 10 c shift columns do i = n , j , - 1 call dcopy ( i , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) R ( i + 1 , i + 1 ) = 0 d0 end do call dcopy ( n , u , 1 , R ( 1 , j ), 1 ) R ( n + 1 , j ) = sqrt ( rho ) c retriangularize if ( j < n + 1 ) then c eliminate the introduced spike. call dqrtv1 ( n + 2 - j , R ( j , j ), w ) c apply rotations to R call dqrqh ( n + 2 - j , n + 1 - j , R ( j , j + 1 ), ldr , w , R ( j + 1 , j )) c zero spike. do i = j + 1 , n + 1 R ( i , j ) = 0 d0 end do end if c normal return. return c error returns. 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\dchinx.f.html"},{"title":"dchshx.f – LINALG","text":"Contents Subroutines dchshx Source Code dchshx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dchshx ( n , R , ldr , i , j , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(p,p), where p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c i (in)        the first index determining the range (see above). c j (in)        the second index determining the range (see above). c w (o)         a workspace vector of size 2*n. c integer n , ldr , i , j double precision R ( ldr , * ), w ( * ) external xerbla , dcopy , dqrtv1 , dqrqh , dqhqr integer info , l c quick return if possible. if ( n == 0 . or . n == 1 ) return info = 0 c check arguments. if ( n < 0 ) then info = 1 else if ( i < 1 . or . i > n ) then info = 4 else if ( j < 1 . or . j > n ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'DCHSHX' , info ) return end if if ( i < j ) then c shift columns call dcopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call dcopy ( n , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call dcopy ( n , w , 1 , R ( 1 , j ), 1 ) c retriangularize call dqhqr ( n + 1 - i , n + 1 - i , R ( i , i ), ldr , w ( n + 1 ), w ) else if ( j < i ) then c shift columns call dcopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call dcopy ( n , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call dcopy ( n , w , 1 , R ( 1 , j ), 1 ) c eliminate the introduced spike. call dqrtv1 ( n + 1 - j , R ( j , j ), w ( n + 1 )) c apply rotations to R call dqrqh ( n + 1 - j , n - j , R ( j , j + 1 ), ldr , w ( n + 1 ), R ( j + 1 , j )) c zero spike. do l = j + 1 , n R ( l , j ) = 0 d0 end do end if end subroutine","tags":"","loc":"sourcefile\\dchshx.f.html"},{"title":"dgqvec.f – LINALG","text":"Contents Subroutines dgqvec Source Code dgqvec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dgqvec ( m , n , Q , ldq , u ) c purpose:      given an orthogonal m-by-n matrix Q, n < m, generates c               a vector u such that Q'*u = 0 and norm(u) = 1. c arguments: c m (in)        number of rows of matrix Q. c n (in)        number of columns of matrix Q. c Q (in)        the orthogonal matrix Q. c ldq (in)      leading dimension of Q. c u (out)       the generated vector. c integer m , n , ldq double precision Q ( ldq , * ), u ( * ) external ddot , daxpy , dnrm2 , dscal double precision ddot , dnrm2 , r integer info , i , j c quick return if possible. if ( m == 0 ) return if ( n == 0 ) then u ( 1 ) = 1 d0 do i = 2 , m u ( i ) = 0 d0 end do return end if c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldq < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'DGQVEC' , info ) return end if j = 1 10 continue c probe j-th canonical unit vector. do i = 1 , m u ( i ) = 0 d0 end do u ( j ) = 1 d0 c form u - Q*Q'*u do i = 1 , n r = ddot ( m , Q ( 1 , i ), 1 , u , 1 ) call daxpy ( m , - r , Q ( 1 , i ), 1 , u , 1 ) end do r = dnrm2 ( m , u , 1 ) if ( r == 0 d0 ) then j = j + 1 if ( j > n ) then c this is fatal, and in theory, it can't happen. stop 'fatal: impossible condition in DGQVEC' else j = j + 1 goto 10 end if end if call dscal ( m , 1 d0 / r , u , 1 ) end subroutine","tags":"","loc":"sourcefile\\dgqvec.f.html"},{"title":"dlu1up.f – LINALG","text":"Contents Subroutines dlu1up Source Code dlu1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dlu1up ( m , n , L , ldl , R , ldr , u , v ) c purpose:      updates an LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal and a k-by-n upper-trapezoidal matrix R, c               where k = min(m,n), c               this subroutine updates L -> L1 and R -> R1 so that c               L is again lower unit triangular, R upper trapezoidal, c               and L1*R1 = L*R + u*v.'. c               (real version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c c REMARK:       Algorithm is due to c               J. Bennett: Triangular factors of modified matrices, c                           Numerische Mathematik, 7 (1965) c integer m , n , ldl , ldr double precision L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ) double precision ui , vi integer k , info , i , j external xerbla c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'DLU1UP' , info ) return end if c The Bennett algorithm, modified for column-major access. c The leading part. do i = 1 , k c prefetch ui = u ( i ) vi = v ( i ) c delayed R update do j = 1 , i - 1 R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do c diagonal update R ( i , i ) = R ( i , i ) + ui * vi vi = vi / R ( i , i ) c L update do j = i + 1 , m u ( j ) = u ( j ) - ui * L ( j , i ) L ( j , i ) = L ( j , i ) + u ( j ) * vi end do u ( i ) = ui v ( i ) = vi end do c Finish the trailing part of R if needed. do i = k + 1 , n vi = v ( i ) do j = 1 , k R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do v ( i ) = vi end do end subroutine","tags":"","loc":"sourcefile\\dlu1up.f.html"},{"title":"dlup1up.f – LINALG","text":"Contents Subroutines dlup1up Source Code dlup1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dlup1up ( m , n , L , ldl , R , ldr , p , u , v , w ) c purpose:      updates a row-pivoted LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal, a k-by-n upper-trapezoidal matrix R, and a c               permutation matrix P, where k = min(m,n), c               this subroutine updates L -> L1, R -> R1 and P -> P1 so that c               L is again lower unit triangular, R upper trapezoidal, c               P permutation and P1'*L1*R1 = P'*L*R + u*v.'. c               (real version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c p (in)        the permutation vector representing P c u (in)        the left m-vector. c v (in)        the right n-vector. c w (work)      a workspace vector of size m. c c REMARK:       Algorithm is due to c               A. Kielbasinski, H. Schwetlick, Numerische Lineare c               Algebra, Verlag Harri Deutsch, 1988 c integer m , n , ldl , ldr , p ( * ) double precision L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) double precision one , tau , tmp parameter ( one = 1 d0 , tau = 1 d - 1 ) integer k , info , i , j , itmp external xerbla , dcopy , daxpy , dtrsv , dger , dgemv c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'DLU1UP' , info ) return end if c form L \\ P*u. do i = 1 , m w ( i ) = u ( p ( i )) end do call dtrsv ( 'L' , 'N' , 'U' , k , L , ldl , w , 1 ) c if m > k = n, subtract the trailing part. if ( m > k ) then call dgemv ( 'N' , m - k , k , - one , L ( k + 1 , 1 ), ldl , w , 1 , one , w ( k + 1 ), 1 ) end if c work from bottom to top do j = k - 1 , 1 , - 1 if ( abs ( w ( j )) < tau * abs ( L ( j + 1 , j ) * w ( j ) + w ( j + 1 ))) then c need pivoting. swap j and j+1 tmp = w ( j ) w ( j ) = w ( j + 1 ) w ( j + 1 ) = tmp c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call dswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call dswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call dswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call daxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call daxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) c update w w ( j ) = w ( j ) - tmp * w ( j + 1 ) end if c eliminate w(j+1) tmp = w ( j + 1 ) / w ( j ) w ( j + 1 ) = 0 c update R. call daxpy ( n - j + 1 , - tmp , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c update L. call daxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c add a multiple of v to R call daxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c forward sweep do j = 1 , k - 1 if ( abs ( R ( j , j )) < tau * abs ( L ( j + 1 , j ) * R ( j , j ) + R ( j + 1 , j ))) then c need pivoting. swap j and j+1 c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call dswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call dswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call dswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call daxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call daxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) end if c eliminate R(j+1,j) tmp = R ( j + 1 , j ) / R ( j , j ) c update R. R ( j + 1 , j ) = 0 d0 call daxpy ( n - j , - tmp , R ( j , j + 1 ), ldr , R ( j + 1 , j + 1 ), ldr ) c update L. call daxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c if m > k = n, complete the update by updating the lower part of L. if ( m > k ) then call dcopy ( k , v , 1 , w , 1 ) call dtrsv ( 'U' , 'T' , 'N' , k , R , ldr , w , 1 ) call dger ( m - k , k , one , w ( k + 1 ), 1 , w , 1 , L ( k + 1 , 1 ), ldl ) endif end subroutine","tags":"","loc":"sourcefile\\dlup1up.f.html"},{"title":"dqhqr.f – LINALG","text":"Contents Subroutines dqhqr Source Code dqhqr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqhqr ( m , n , R , ldr , c , s ) c purpose:      given an m-by-n upper Hessenberg matrix R, this c               subroutine updates R to upper trapezoidal form c               using min(m-1,n) Givens rotations. c               (real version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(out)        rotation cosines, size at least min(m-1,n) c s(out)        rotation sines, size at least min(m-1,n) c integer m , n , ldr double precision R ( ldr , * ), c ( * ), s ( * ) external xerbla , dlartg double precision t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'DQHQR' , info ) return end if do i = 1 , n c apply stored rotations, column-wise t = R ( 1 , i ) ii = min ( m , i ) do j = 1 , ii - 1 R ( j , i ) = c ( j ) * t + s ( j ) * R ( j + 1 , i ) t = c ( j ) * R ( j + 1 , i ) - s ( j ) * t end do if ( ii < m ) then c generate next rotation call dlartg ( t , R ( ii + 1 , i ), c ( i ), s ( i ), R ( ii , i )) R ( ii + 1 , i ) = 0 d0 else R ( ii , i ) = t end if end do end subroutine","tags":"","loc":"sourcefile\\dqhqr.f.html"},{"title":"dqr1up.f – LINALG","text":"Contents Subroutines dqr1up Source Code dqr1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqr1up ( m , n , k , Q , ldq , R , ldr , u , v , w ) c purpose:      updates a QR factorization after rank-1 modification c               i.e., given a m-by-k orthogonal Q and m-by-n upper c               trapezoidal R, an m-vector u and n-vector v, c               this subroutine updates Q -> Q1 and R -> R1 so that c               Q1*R1 = Q*R + u*v', and Q1 is again orthonormal c               and R1 upper trapezoidal. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form). c Q (io)        on entry, the orthogonal m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      the leading dimension of Q. ldq >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R.. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= k. c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c w (out)       a workspace vector of size 2*k c integer m , n , k , ldq , ldr double precision Q ( ldq , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) external dqrqh , dqhqr , dqrot , dqrtv1 external daxpy , ddot , dnrm2 , dlamch , dscal , drot double precision ddot , dnrm2 , dlamch , ru , ruu integer info , i logical full c quick return if possible. if ( k == 0 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 endif if ( info /= 0 ) then call xerbla ( 'DQR1UP' , info ) return end if full = k == m c in the non-full case, we shall need the norm of u. if (. not . full ) ru = dnrm2 ( m , u , 1 ) c form Q'*u. In the non-full case, form also u - Q*Q'u. do i = 1 , k w ( i ) = ddot ( m , Q ( 1 , i ), 1 , u , 1 ) if (. not . full ) call daxpy ( m , - w ( i ), Q ( 1 , i ), 1 , u , 1 ) end do c generate rotations to eliminate Q'*u. call dqrtv1 ( k , w , w ( k + 1 )) c apply rotations to R. call dqrqh ( k , n , R , ldr , w ( k + 1 ), w ( 2 )) c apply rotations to Q. call dqrot ( 'B' , m , k , Q , ldq , w ( k + 1 ), w ( 2 )) c update the first row of R. call daxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c retriangularize R. call dqhqr ( k , n , R , ldr , w ( k + 1 ), w ) c apply rotations to Q. call dqrot ( 'F' , m , min ( k , n + 1 ), Q , ldq , w ( k + 1 ), w ) c in the full case, we're finished if ( full ) return c compute relative residual norm ruu = dnrm2 ( m , u , 1 ) ru = ru * dlamch ( 'e' ) if ( ruu <= ru ) return c update the orthogonal basis. call dscal ( n , ruu , v , 1 ) call dscal ( m , 1 d0 / ruu , u , 1 ) call dch1up ( n , R , ldr , v , w ( k + 1 )) do i = 1 , n call drot ( m , Q ( 1 , i ), 1 , u , 1 , w ( k + i ), v ( i )) end do end subroutine","tags":"","loc":"sourcefile\\dqr1up.f.html"},{"title":"dqrdec.f – LINALG","text":"Contents Subroutines dqrdec Source Code dqrdec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrdec ( m , n , k , Q , ldq , R , ldr , j , w ) c purpose:      updates a QR factorization after deleting c               a column. c               i.e., given an m-by-k orthogonal matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 remains orthogonal, R1 is upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1) A(:,j+1:n)], c               where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form, c               basis dimension will decrease). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c j (in)        the position of the deleted column in R. c               1 <= j <= n. c w (o)         a workspace vector of size k-j. c integer m , n , k , ldq , ldr , j double precision Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , dcopy , dqhqr , dqrot integer info , i c quick return if possible. if ( m == 0 . or . n == 0 . or . j == n ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'DQRDEC' , info ) return end if c delete the j-th column. do i = j , n - 1 call dcopy ( k , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < k ) then call dqhqr ( k + 1 - j , n - j , R ( j , j ), ldr , w , R ( 1 , n )) c apply rotations to Q. call dqrot ( 'F' , m , min ( k , n ) + 1 - j , Q ( 1 , j ), ldq , w , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\dqrdec.f.html"},{"title":"dqrder.f – LINALG","text":"Contents Subroutines dqrder Source Code dqrder.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrder ( m , n , Q , ldq , R , ldr , j , w ) c purpose:      updates a QR factorization after deleting a row. c               i.e., given an m-by-m orthogonal matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m, this subroutine updates Q ->Q1 and an R -> R1 c               so that Q1 is again orthogonal, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); A(j+1:m,:)], where A = Q*R. c               (real version) c c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the orthogonal matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m. c j (in)        the position of the deleted row. c w (out)       a workspace vector of size 2*m. c integer m , n , j , ldq , ldr double precision Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , dcopy , dqrtv1 , dqrot , dqrqh integer info , i , k c quick return if possible if ( m == 1 ) return c check arguments info = 0 if ( m < 1 ) then info = 1 else if ( j < 1 . or . j > m ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'DQRDER' , info ) return end if c eliminate Q(j,2:m). call dcopy ( m , Q ( j , 1 ), ldq , w , 1 ) call dqrtv1 ( m , w , w ( m + 1 )) c apply rotations to Q. call dqrot ( 'B' , m , m , Q , ldq , w ( m + 1 ), w ( 2 )) c form Q1. do k = 1 , m - 1 if ( j > 1 ) call dcopy ( j - 1 , Q ( 1 , k + 1 ), 1 , Q ( 1 , k ), 1 ) if ( j < m ) call dcopy ( m - j , Q ( j + 1 , k + 1 ), 1 , Q ( j , k ), 1 ) end do c apply rotations to R. call dqrqh ( m , n , R , ldr , w ( m + 1 ), w ( 2 )) c form R1. do k = 1 , n do i = 1 , m - 1 R ( i , k ) = R ( i + 1 , k ) end do end do end subroutine","tags":"","loc":"sourcefile\\dqrder.f.html"},{"title":"dqrinc.f – LINALG","text":"Contents Subroutines dqrinc Source Code dqrinc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrinc ( m , n , k , Q , ldq , R , ldr , j , x , w ) c purpose:      updates a QR factorization after inserting a new c               column. c               i.e., given an m-by-k orthogonal matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again orthogonal, R1 upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1); x; A(:,j:n)], c               where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n <= m (economical form, c               basis dimension will increase). c Q (io)        on entry, the orthogonal m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= min(m,n+1). c j (in)        the position of the new column in R1 c x (in)        the column being inserted c w (out)       a workspace vector of size k. c integer m , n , k , ldq , ldr , j double precision Q ( ldq , * ), R ( ldr , * ), x ( * ), w ( * ) external dqrtv1 , dqrqh , dqrot external xerbla , dcopy , ddot , daxpy , dscal , dnrm2 double precision ddot , dnrm2 , rx integer info , i , k1 logical full c quick return if possible. if ( m == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < min ( m , k + 1 )) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'DQRINC' , info ) return end if full = k == m c insert empty column at j-th position. do i = n , j , - 1 call dcopy ( k , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) end do c insert Q'*u into R. In the nonfull case, form also u-Q*Q'*u. if ( full ) then k1 = k do i = 1 , k R ( i , j ) = ddot ( m , Q ( 1 , i ), 1 , x , 1 ) end do else k1 = k + 1 c zero last row of R do i = 1 , n + 1 R ( k1 , i ) = 0 d0 end do call dcopy ( m , x , 1 , Q ( 1 , k1 ), 1 ) do i = 1 , k R ( i , j ) = ddot ( m , Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) call daxpy ( m , - R ( i , j ), Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) end do c get norm of the inserted column rx = dnrm2 ( m , Q ( 1 , k1 ), 1 ) R ( k1 , j ) = rx if ( rx == 0 d0 ) then c in the rare case when rx is exact zero, we still need to provide c a valid orthogonal unit vector. The details are boring, so handle c that elsewhere. call dgqvec ( m , k , Q , ldq , Q ( 1 , k1 )) else c otherwise, just normalize the added column. call dscal ( m , 1 d0 / rx , Q ( 1 , k1 ), 1 ) end if end if c maybe we're finished. if ( j > k ) return c eliminate the spike. call dqrtv1 ( k1 + 1 - j , R ( j , j ), w ) c apply rotations to R(j:k,j:n). if ( j <= n ) call dqrqh ( k1 + 1 - j , n + 1 - j , R ( j , j + 1 ), ldr , w , R ( j + 1 , j )) c apply rotations to Q(:,j:k). call dqrot ( 'B' , m , k1 + 1 - j , Q ( 1 , j ), ldq , w , R ( j + 1 , j )) c zero spike. do i = j + 1 , k1 R ( i , j ) = 0 d0 end do end subroutine","tags":"","loc":"sourcefile\\dqrinc.f.html"},{"title":"dqrinr.f – LINALG","text":"Contents Subroutines dqrinr Source Code dqrinr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrinr ( m , n , Q , ldq , R , ldr , j , x , w ) c purpose:      updates a QR factorization after inserting a new c               row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m+1, this subroutine updates Q -> Q1  and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); x; A(j:m,:)], where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m+1. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m+1. c j (in)        the position of the new row in R1 c x (io)        on entry, the row being added c               on exit, x is destroyed. c w (out)       a workspace vector of size min(m,n). c integer m , n , j , ldq , ldr double precision Q ( ldq , * ), R ( ldr , * ), x ( * ), w ( * ) external xerbla , dcopy , dqhqr , dqrot integer info , i , k c check arguments info = 0 if ( n < 0 ) then info = 2 else if ( j < 1 . or . j > m + 1 ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'DQRINR' , info ) return end if c permute the columns of Q1 and rows of R1 so that c the new row ends c up being the topmost row of R1. do i = m , 1 , - 1 if ( j > 1 ) then call dcopy ( j - 1 , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 ) end if Q ( j , i + 1 ) = 0 d0 if ( j <= m ) then call dcopy ( m + 1 - j , Q ( j , i ), 1 , Q ( j + 1 , i + 1 ), 1 ) end if end do c set up the 1st column do i = 1 , j - 1 Q ( i , 1 ) = 0 d0 end do Q ( j , 1 ) = 1 d0 do i = j + 1 , m + 1 Q ( i , 1 ) = 0 d0 end do c set up the new matrix R1 do k = 1 , n if ( k < m ) R ( m + 1 , k ) = 0 d0 do i = min ( m , k ), 1 , - 1 R ( i + 1 , k ) = R ( i , k ) end do R ( 1 , k ) = x ( k ) end do c retriangularize R call dqhqr ( m + 1 , n , R , ldr , w , x ) c apply rotations to Q call dqrot ( 'F' , m + 1 , min ( m , n ) + 1 , Q , ldq , w , x ) end subroutine","tags":"","loc":"sourcefile\\dqrinr.f.html"},{"title":"dqrot.f – LINALG","text":"Contents Subroutines dqrot Source Code dqrot.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrot ( dir , m , n , Q , ldq , c , s ) c purpose:      Apply a sequence of inv. rotations from right c c arguments: c dir (in)      if 'B' or 'b', rotations are applied from backwards c               if 'F' or 'f', from forwards. c m (in)        number of rows of matrix Q c n (in)        number of columns of the matrix Q c Q (io)        on entry, the matrix Q c               on exit, the updated matrix Q1 c ldq (in)      the leading dimension of Q c c (in)        n-1 rotation cosines c s (in)        n-1 rotation sines c character dir integer m , n , ldq double precision Q ( ldq , * ), c ( * ), s ( * ) external drot , lsame logical lsame , fwd integer info , i c quick return if possible if ( m == 0 . or . n == 0 . or . n == 1 ) return c check arguments. info = 0 fwd = lsame ( dir , 'F' ) if (. not .( fwd . or . lsame ( dir , 'B' ))) then info = 1 else if ( m < 0 ) then info = 2 else if ( n < 0 ) then info = 3 else if ( ldq < m ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'DQROT' , info ) return end if if ( fwd ) then do i = 1 , n - 1 call drot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), s ( i )) end do else do i = n - 1 , 1 , - 1 call drot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), s ( i )) end do end if end subroutine","tags":"","loc":"sourcefile\\dqrot.f.html"},{"title":"dqrqh.f – LINALG","text":"Contents Subroutines dqrqh Source Code dqrqh.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrqh ( m , n , R , ldr , c , s ) c purpose:      brings an upper trapezoidal matrix R into upper c               Hessenberg form using min(m-1,n) Givens rotations. c               (real version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(in)         rotation cosines, size at least min(m-1,n) c s(in)         rotation sines, size at least min(m-1,n) c integer m , n , ldr double precision R ( ldr , * ), c ( * ), s ( * ) external xerbla double precision t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'DQRQH' , info ) return end if do i = 1 , n ii = min ( m - 1 , i ) c apply stored rotations, column-wise t = R ( ii + 1 , i ) do j = ii , 1 , - 1 R ( j + 1 , i ) = c ( j ) * t - s ( j ) * R ( j , i ) t = c ( j ) * R ( j , i ) + s ( j ) * t end do R ( 1 , i ) = t end do end subroutine","tags":"","loc":"sourcefile\\dqrqh.f.html"},{"title":"dqrshc.f – LINALG","text":"Contents Subroutines dqrshc Source Code dqrshc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrshc ( m , n , k , Q , ldq , R , ldr , i , j , w ) c purpose:      updates a QR factorization after circular shift of c               columns. c               i.e., given an m-by-k orthogonal matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again orthogonal, R1 upper c               trapezoidal, and c               Q1*R1 = A(:,p), where A = Q*R and p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q1, and rows of R1. Must be c               either k = m (full Q) or k = n <= m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c i (in)        the first index determining the range (see above) c j (in)        the second index determining the range (see above) c w (o)         a workspace vector of size 2*k. c integer m , n , k , ldq , ldr , i , j double precision Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , dcopy , dqrtv1 , dqrqh , dqhqr integer info , jj , kk , l c quick return if possible. if ( m == 0 . or . n == 1 ) return info = 0 c check arguments. if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( i < 1 . or . i > n ) then info = 6 else if ( j < 1 . or . j > n ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'DQRSHC' , info ) return end if if ( i < j ) then c shift columns call dcopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call dcopy ( k , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call dcopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( i < k ) then kk = min ( k , j ) call dqhqr ( kk + 1 - i , n + 1 - i , R ( i , i ), ldr , w ( k + 1 ), w ) c apply rotations to Q. call dqrot ( 'F' , m , kk + 1 - i , Q ( 1 , i ), ldq , w ( k + 1 ), w ) end if else if ( j < i ) then c shift columns call dcopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call dcopy ( k , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call dcopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( j < k ) then jj = min ( j + 1 , n ) kk = min ( k , i ) c eliminate the introduced spike. call dqrtv1 ( kk + 1 - j , R ( j , j ), w ( k + 1 )) c apply rotations to R call dqrqh ( kk + 1 - j , n - j , R ( j , jj ), ldr , w ( k + 1 ), R ( j + 1 , j )) c apply rotations to Q call dqrot ( 'B' , m , kk + 1 - j , Q ( 1 , j ), ldq , w ( k + 1 ), R ( j + 1 , j )) c zero spike. do l = j + 1 , kk R ( l , j ) = 0 d0 end do end if end if end subroutine","tags":"","loc":"sourcefile\\dqrshc.f.html"},{"title":"dqrtv1.f – LINALG","text":"Contents Subroutines dqrtv1 Source Code dqrtv1.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine dqrtv1 ( n , u , w ) c purpose:      generates a sequence of n-1 Givens rotations that c               eliminate all but the first element of a vector u. c arguments: c n (in)        the length of the vector u c u (io)        on entry, the vector u. c               on exit, u(2:n) contains the rotation sines, u(1) c               contains the remaining element. c w (o)         on exit, w contains the rotation cosines. c integer n double precision u ( * ), w ( * ) external dlartg double precision rr , t integer i c quick return if possible. if ( n <= 0 ) return rr = u ( n ) do i = n - 1 , 1 , - 1 call dlartg ( u ( i ), rr , w ( i ), u ( i + 1 ), t ) rr = t end do u ( 1 ) = rr end subroutine","tags":"","loc":"sourcefile\\dqrtv1.f.html"},{"title":"sch1dn.f – LINALG","text":"Contents Subroutines sch1dn Source Code sch1dn.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sch1dn ( n , R , ldr , u , w , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine downdates R -> R1 so that c               R1'*R1 = A - u*u' c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the reflector sines c               used to transform R to R1. c w (out)       cosine parts of reflectors. c c info (out)    on exit, error code: c                info = 0: success. c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , ldr real R ( ldr , * ), u ( * ), w ( * ) integer info external strsv , slartg , snrm2 real snrm2 , rho , rr , ui , t integer i , j c quick return if possible. if ( n == 0 ) return c check arguments. info = 0 if ( n < 0 ) then info = - 1 else if ( ldr < n ) then info = - 3 end if if ( info /= 0 ) then call xerbla ( 'SCH1DN' , - info ) return end if c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0e0 ) goto 20 end do c form R' \\ u call strsv ( 'U' , 'T' , 'N' , n , R , ldr , u , 1 ) rho = snrm2 ( n , u , 1 ) c check positive definiteness rho = 1 - rho ** 2 if ( rho <= 0e0 ) goto 10 rho = sqrt ( rho ) c eliminate R' \\ u do i = n , 1 , - 1 ui = u ( i ) c generate next rotation call slartg ( rho , ui , w ( i ), u ( i ), rr ) rho = rr end do c apply rotations do i = n , 1 , - 1 ui = 0e0 do j = i , 1 , - 1 t = w ( j ) * ui + u ( j ) * R ( j , i ) R ( j , i ) = w ( j ) * R ( j , i ) - u ( j ) * ui ui = t end do end do c normal return return c error returns 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\sch1dn.f.html"},{"title":"sch1up.f – LINALG","text":"Contents Subroutines sch1up Source Code sch1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sch1up ( n , R , ldr , u , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A + u*u' c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the rotation sines c               used to transform R to R1. c w (out)       cosine parts of rotations. c integer n , ldr real R ( ldr , * ), u ( * ) real w ( * ) external slartg real rr , ui , t integer i , j do i = 1 , n c apply stored rotations, column-wise ui = u ( i ) do j = 1 , i - 1 t = w ( j ) * R ( j , i ) + u ( j ) * ui ui = w ( j ) * ui - u ( j ) * R ( j , i ) R ( j , i ) = t end do c generate next rotation call slartg ( R ( i , i ), ui , w ( i ), u ( i ), rr ) R ( i , i ) = rr end do end subroutine","tags":"","loc":"sourcefile\\sch1up.f.html"},{"title":"schdex.f – LINALG","text":"Contents Subroutines schdex Source Code schdex.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine schdex ( n , R , ldr , j , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(jj,jj), where jj = [1:j-1,j+1:n+1]. c               (real version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n. c j (in)        the position of the deleted row/column. c w (out)       a workspace vector of size n. c integer n , ldr , j real R ( ldr , * ), w ( * ) integer info , i external xerbla , scopy , sqhqr c quick return if possible if ( n == 1 ) return c check arguments info = 0 if ( n < 0 ) then info = 1 else if ( j < 1 . or . j > n ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'SCHDEX' , info ) return end if c delete the j-th column. do i = j , n - 1 call scopy ( n , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < n ) then call sqhqr ( n + 1 - j , n - j , R ( j , j ), ldr , w , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\schdex.f.html"},{"title":"schinx.f – LINALG","text":"Contents Subroutines schinx Source Code schinx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine schinx ( n , R , ldr , j , u , w , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A1, A1(jj,jj) = A, A(j,:) = u', A(:,j) = u, c               jj = [1:j-1,j+1:n+1]. c               (real version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n+1. c j (in)        the position of the inserted row/column c u (io)        on entry, the inserted row/column. c               on exit, u is destroyed. c w (out)       workspace vector of size n+1. c info (out)    on exit, error code: c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , j , ldr , info real R ( ldr , * ), u ( * ), w ( * ) external xerbla , scopy , snrm2 , strsv , sqrtv1 , sqrqh real snrm2 , t , rho integer i c check arguments info = 0 if ( n < 0 ) then info = - 1 else if ( j < 1 . or . j > n + 1 ) then info = - 4 end if if ( info /= 0 ) then call xerbla ( 'SCHINX' , - info ) return end if c shift vector. t = u ( j ) do i = j , n u ( i ) = u ( i + 1 ) end do c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0e0 ) goto 20 end do c form R' \\ u call strsv ( 'U' , 'T' , 'N' , n , R , ldr , u , 1 ) rho = snrm2 ( n , u , 1 ) c check positive definiteness. rho = t - rho ** 2 if ( rho <= 0e0 ) goto 10 c shift columns do i = n , j , - 1 call scopy ( i , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) R ( i + 1 , i + 1 ) = 0e0 end do call scopy ( n , u , 1 , R ( 1 , j ), 1 ) R ( n + 1 , j ) = sqrt ( rho ) c retriangularize if ( j < n + 1 ) then c eliminate the introduced spike. call sqrtv1 ( n + 2 - j , R ( j , j ), w ) c apply rotations to R call sqrqh ( n + 2 - j , n + 1 - j , R ( j , j + 1 ), ldr , w , R ( j + 1 , j )) c zero spike. do i = j + 1 , n + 1 R ( i , j ) = 0e0 end do end if c normal return. return c error returns. 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\schinx.f.html"},{"title":"schshx.f – LINALG","text":"Contents Subroutines schshx Source Code schshx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine schshx ( n , R , ldr , i , j , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(p,p), where p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (real version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c i (in)        the first index determining the range (see above). c j (in)        the second index determining the range (see above). c w (o)         a workspace vector of size 2*n. c integer n , ldr , i , j real R ( ldr , * ), w ( * ) external xerbla , scopy , sqrtv1 , sqrqh , sqhqr integer info , l c quick return if possible. if ( n == 0 . or . n == 1 ) return info = 0 c check arguments. if ( n < 0 ) then info = 1 else if ( i < 1 . or . i > n ) then info = 4 else if ( j < 1 . or . j > n ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'SCHSHX' , info ) return end if if ( i < j ) then c shift columns call scopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call scopy ( n , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call scopy ( n , w , 1 , R ( 1 , j ), 1 ) c retriangularize call sqhqr ( n + 1 - i , n + 1 - i , R ( i , i ), ldr , w ( n + 1 ), w ) else if ( j < i ) then c shift columns call scopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call scopy ( n , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call scopy ( n , w , 1 , R ( 1 , j ), 1 ) c eliminate the introduced spike. call sqrtv1 ( n + 1 - j , R ( j , j ), w ( n + 1 )) c apply rotations to R call sqrqh ( n + 1 - j , n - j , R ( j , j + 1 ), ldr , w ( n + 1 ), R ( j + 1 , j )) c zero spike. do l = j + 1 , n R ( l , j ) = 0e0 end do end if end subroutine","tags":"","loc":"sourcefile\\schshx.f.html"},{"title":"sgqvec.f – LINALG","text":"Contents Subroutines sgqvec Source Code sgqvec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sgqvec ( m , n , Q , ldq , u ) c purpose:      given an orthogonal m-by-n matrix Q, n < m, generates c               a vector u such that Q'*u = 0 and norm(u) = 1. c arguments: c m (in)        number of rows of matrix Q. c n (in)        number of columns of matrix Q. c Q (in)        the orthogonal matrix Q. c ldq (in)      leading dimension of Q. c u (out)       the generated vector. c integer m , n , ldq real Q ( ldq , * ), u ( * ) external sdot , saxpy , snrm2 , sscal real sdot , snrm2 , r integer info , i , j c quick return if possible. if ( m == 0 ) return if ( n == 0 ) then u ( 1 ) = 1e0 do i = 2 , m u ( i ) = 0e0 end do return end if c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldq < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'SGQVEC' , info ) return end if j = 1 10 continue c probe j-th canonical unit vector. do i = 1 , m u ( i ) = 0e0 end do u ( j ) = 1e0 c form u - Q*Q'*u do i = 1 , n r = sdot ( m , Q ( 1 , i ), 1 , u , 1 ) call saxpy ( m , - r , Q ( 1 , i ), 1 , u , 1 ) end do r = snrm2 ( m , u , 1 ) if ( r == 0e0 ) then j = j + 1 if ( j > n ) then c this is fatal, and in theory, it can't happen. stop 'fatal: impossible condition in DGQVEC' else j = j + 1 goto 10 end if end if call sscal ( m , 1e0 / r , u , 1 ) end subroutine","tags":"","loc":"sourcefile\\sgqvec.f.html"},{"title":"slu1up.f – LINALG","text":"Contents Subroutines slu1up Source Code slu1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine slu1up ( m , n , L , ldl , R , ldr , u , v ) c purpose:      updates an LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal and a k-by-n upper-trapezoidal matrix R, c               where k = min(m,n), c               this subroutine updates L -> L1 and R -> R1 so that c               L is again lower unit triangular, R upper trapezoidal, c               and L1*R1 = L*R + u*v.'. c               (real version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c c REMARK:       Algorithm is due to c               J. Bennett: Triangular factors of modified matrices, c                           Numerische Mathematik, 7 (1965) c integer m , n , ldl , ldr real L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ) real ui , vi integer k , info , i , j external xerbla c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'SLU1UP' , info ) return end if c The Bennett algorithm, modified for column-major access. c The leading part. do i = 1 , k c prefetch ui = u ( i ) vi = v ( i ) c delayed R update do j = 1 , i - 1 R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do c diagonal update R ( i , i ) = R ( i , i ) + ui * vi vi = vi / R ( i , i ) c L update do j = i + 1 , m u ( j ) = u ( j ) - ui * L ( j , i ) L ( j , i ) = L ( j , i ) + u ( j ) * vi end do u ( i ) = ui v ( i ) = vi end do c Finish the trailing part of R if needed. do i = k + 1 , n vi = v ( i ) do j = 1 , k R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do v ( i ) = vi end do end subroutine","tags":"","loc":"sourcefile\\slu1up.f.html"},{"title":"slup1up.f – LINALG","text":"Contents Subroutines slup1up Source Code slup1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine slup1up ( m , n , L , ldl , R , ldr , p , u , v , w ) c purpose:      updates a row-pivoted LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal, a k-by-n upper-trapezoidal matrix R, and a c               permutation matrix P, where k = min(m,n), c               this subroutine updates L -> L1, R -> R1 and P -> P1 so that c               L is again lower unit triangular, R upper trapezoidal, c               P permutation and P1'*L1*R1 = P'*L*R + u*v.'. c               (real version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c p (in)        the permutation vector representing P c u (in)        the left m-vector. c v (in)        the right n-vector. c w (work)      a workspace vector of size m. c c REMARK:       Algorithm is due to c               A. Kielbasinski, H. Schwetlick, Numerische Lineare c               Algebra, Verlag Harri Deutsch, 1988 c integer m , n , ldl , ldr , p ( * ) real L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) real one , tau , tmp parameter ( one = 1e0 , tau = 1e-1 ) integer k , info , i , j , itmp external xerbla , scopy , saxpy , strsv , sger , sgemv c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'SLU1UP' , info ) return end if c form L \\ P*u. do i = 1 , m w ( i ) = u ( p ( i )) end do call strsv ( 'L' , 'N' , 'U' , k , L , ldl , w , 1 ) c if m > k = n, subtract the trailing part. if ( m > k ) then call sgemv ( 'N' , m - k , k , - one , L ( k + 1 , 1 ), ldl , w , 1 , one , w ( k + 1 ), 1 ) end if c work from bottom to top do j = k - 1 , 1 , - 1 if ( abs ( w ( j )) < tau * abs ( L ( j + 1 , j ) * w ( j ) + w ( j + 1 ))) then c need pivoting. swap j and j+1 tmp = w ( j ) w ( j ) = w ( j + 1 ) w ( j + 1 ) = tmp c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call sswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call sswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call sswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call saxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call saxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) c update w w ( j ) = w ( j ) - tmp * w ( j + 1 ) end if c eliminate w(j+1) tmp = w ( j + 1 ) / w ( j ) w ( j + 1 ) = 0 c update R. call saxpy ( n - j + 1 , - tmp , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c update L. call saxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c add a multiple of v to R call saxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c forward sweep do j = 1 , k - 1 if ( abs ( R ( j , j )) < tau * abs ( L ( j + 1 , j ) * R ( j , j ) + R ( j + 1 , j ))) then c need pivoting. swap j and j+1 c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call sswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call sswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call sswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call saxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call saxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) end if c eliminate R(j+1,j) tmp = R ( j + 1 , j ) / R ( j , j ) c update R. R ( j + 1 , j ) = 0e0 call saxpy ( n - j , - tmp , R ( j , j + 1 ), ldr , R ( j + 1 , j + 1 ), ldr ) c update L. call saxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c if m > k = n, complete the update by updating the lower part of L. if ( m > k ) then call scopy ( k , v , 1 , w , 1 ) call strsv ( 'U' , 'T' , 'N' , k , R , ldr , w , 1 ) call sger ( m - k , k , one , w ( k + 1 ), 1 , w , 1 , L ( k + 1 , 1 ), ldl ) endif end subroutine","tags":"","loc":"sourcefile\\slup1up.f.html"},{"title":"sqhqr.f – LINALG","text":"Contents Subroutines sqhqr Source Code sqhqr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqhqr ( m , n , R , ldr , c , s ) c purpose:      given an m-by-n upper Hessenberg matrix R, this c               subroutine updates R to upper trapezoidal form c               using min(m-1,n) Givens rotations. c               (real version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(out)        rotation cosines, size at least min(m-1,n) c s(out)        rotation sines, size at least min(m-1,n) c integer m , n , ldr real R ( ldr , * ), c ( * ), s ( * ) external xerbla , slartg real t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'SQHQR' , info ) return end if do i = 1 , n c apply stored rotations, column-wise t = R ( 1 , i ) ii = min ( m , i ) do j = 1 , ii - 1 R ( j , i ) = c ( j ) * t + s ( j ) * R ( j + 1 , i ) t = c ( j ) * R ( j + 1 , i ) - s ( j ) * t end do if ( ii < m ) then c generate next rotation call slartg ( t , R ( ii + 1 , i ), c ( i ), s ( i ), R ( ii , i )) R ( ii + 1 , i ) = 0e0 else R ( ii , i ) = t end if end do end subroutine","tags":"","loc":"sourcefile\\sqhqr.f.html"},{"title":"sqr1up.f – LINALG","text":"Contents Subroutines sqr1up Source Code sqr1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqr1up ( m , n , k , Q , ldq , R , ldr , u , v , w ) c purpose:      updates a QR factorization after rank-1 modification c               i.e., given a m-by-k orthogonal Q and m-by-n upper c               trapezoidal R, an m-vector u and n-vector v, c               this subroutine updates Q -> Q1 and R -> R1 so that c               Q1*R1 = Q*R + u*v', and Q1 is again orthonormal c               and R1 upper trapezoidal. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form). c Q (io)        on entry, the orthogonal m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      the leading dimension of Q. ldq >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R.. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= k. c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c w (out)       a workspace vector of size 2*k c integer m , n , k , ldq , ldr real Q ( ldq , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) external sqrqh , sqhqr , sqrot , sqrtv1 external saxpy , sdot , snrm2 , slamch , sscal , srot real sdot , snrm2 , slamch , ru , ruu integer info , i logical full c quick return if possible. if ( k == 0 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 endif if ( info /= 0 ) then call xerbla ( 'SQR1UP' , info ) return end if full = k == m c in the non-full case, we shall need the norm of u. if (. not . full ) ru = snrm2 ( m , u , 1 ) c form Q'*u. In the non-full case, form also u - Q*Q'u. do i = 1 , k w ( i ) = sdot ( m , Q ( 1 , i ), 1 , u , 1 ) if (. not . full ) call saxpy ( m , - w ( i ), Q ( 1 , i ), 1 , u , 1 ) end do c generate rotations to eliminate Q'*u. call sqrtv1 ( k , w , w ( k + 1 )) c apply rotations to R. call sqrqh ( k , n , R , ldr , w ( k + 1 ), w ( 2 )) c apply rotations to Q. call sqrot ( 'B' , m , k , Q , ldq , w ( k + 1 ), w ( 2 )) c update the first row of R. call saxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c retriangularize R. call sqhqr ( k , n , R , ldr , w ( k + 1 ), w ) c apply rotations to Q. call sqrot ( 'F' , m , min ( k , n + 1 ), Q , ldq , w ( k + 1 ), w ) c in the full case, we're finished if ( full ) return c compute relative residual norm ruu = snrm2 ( m , u , 1 ) ru = ru * slamch ( 'e' ) if ( ruu <= ru ) return c update the orthogonal basis. call sscal ( n , ruu , v , 1 ) call sscal ( m , 1e0 / ruu , u , 1 ) call sch1up ( n , R , ldr , v , w ( k + 1 )) do i = 1 , n call srot ( m , Q ( 1 , i ), 1 , u , 1 , w ( k + i ), v ( i )) end do end subroutine","tags":"","loc":"sourcefile\\sqr1up.f.html"},{"title":"sqrdec.f – LINALG","text":"Contents Subroutines sqrdec Source Code sqrdec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrdec ( m , n , k , Q , ldq , R , ldr , j , w ) c purpose:      updates a QR factorization after deleting c               a column. c               i.e., given an m-by-k orthogonal matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 remains orthogonal, R1 is upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1) A(:,j+1:n)], c               where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form, c               basis dimension will decrease). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c j (in)        the position of the deleted column in R. c               1 <= j <= n. c w (o)         a workspace vector of size k-j. c integer m , n , k , ldq , ldr , j real Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , scopy , sqhqr , sqrot integer info , i c quick return if possible. if ( m == 0 . or . n == 0 . or . j == n ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'SQRDEC' , info ) return end if c delete the j-th column. do i = j , n - 1 call scopy ( k , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < k ) then call sqhqr ( k + 1 - j , n - j , R ( j , j ), ldr , w , R ( 1 , n )) c apply rotations to Q. call sqrot ( 'F' , m , min ( k , n ) + 1 - j , Q ( 1 , j ), ldq , w , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\sqrdec.f.html"},{"title":"sqrder.f – LINALG","text":"Contents Subroutines sqrder Source Code sqrder.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrder ( m , n , Q , ldq , R , ldr , j , w ) c purpose:      updates a QR factorization after deleting a row. c               i.e., given an m-by-m orthogonal matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m, this subroutine updates Q ->Q1 and an R -> R1 c               so that Q1 is again orthogonal, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); A(j+1:m,:)], where A = Q*R. c               (real version) c c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the orthogonal matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m. c j (in)        the position of the deleted row. c w (out)       a workspace vector of size 2*m. c integer m , n , j , ldq , ldr real Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , scopy , sqrtv1 , sqrot , sqrqh integer info , i , k c quick return if possible if ( m == 1 ) return c check arguments info = 0 if ( m < 1 ) then info = 1 else if ( j < 1 . or . j > m ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'SQRDER' , info ) return end if c eliminate Q(j,2:m). call scopy ( m , Q ( j , 1 ), ldq , w , 1 ) call sqrtv1 ( m , w , w ( m + 1 )) c apply rotations to Q. call sqrot ( 'B' , m , m , Q , ldq , w ( m + 1 ), w ( 2 )) c form Q1. do k = 1 , m - 1 if ( j > 1 ) call scopy ( j - 1 , Q ( 1 , k + 1 ), 1 , Q ( 1 , k ), 1 ) if ( j < m ) call scopy ( m - j , Q ( j + 1 , k + 1 ), 1 , Q ( j , k ), 1 ) end do c apply rotations to R. call sqrqh ( m , n , R , ldr , w ( m + 1 ), w ( 2 )) c form R1. do k = 1 , n do i = 1 , m - 1 R ( i , k ) = R ( i + 1 , k ) end do end do end subroutine","tags":"","loc":"sourcefile\\sqrder.f.html"},{"title":"sqrinc.f – LINALG","text":"Contents Subroutines sqrinc Source Code sqrinc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrinc ( m , n , k , Q , ldq , R , ldr , j , x , w ) c purpose:      updates a QR factorization after inserting a new c               column. c               i.e., given an m-by-k orthogonal matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again orthogonal, R1 upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1); x; A(:,j:n)], c               where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n <= m (economical form, c               basis dimension will increase). c Q (io)        on entry, the orthogonal m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= min(m,n+1). c j (in)        the position of the new column in R1 c x (in)        the column being inserted c w (out)       a workspace vector of size k. c integer m , n , k , ldq , ldr , j real Q ( ldq , * ), R ( ldr , * ), x ( * ), w ( * ) external sqrtv1 , sqrqh , sqrot external xerbla , scopy , sdot , saxpy , sscal , snrm2 real sdot , snrm2 , rx integer info , i , k1 logical full c quick return if possible. if ( m == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < min ( m , k + 1 )) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'SQRINC' , info ) return end if full = k == m c insert empty column at j-th position. do i = n , j , - 1 call scopy ( k , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) end do c insert Q'*u into R. In the nonfull case, form also u-Q*Q'*u. if ( full ) then k1 = k do i = 1 , k R ( i , j ) = sdot ( m , Q ( 1 , i ), 1 , x , 1 ) end do else k1 = k + 1 c zero last row of R do i = 1 , n + 1 R ( k1 , i ) = 0e0 end do call scopy ( m , x , 1 , Q ( 1 , k1 ), 1 ) do i = 1 , k R ( i , j ) = sdot ( m , Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) call saxpy ( m , - R ( i , j ), Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) end do c get norm of the inserted column rx = snrm2 ( m , Q ( 1 , k1 ), 1 ) R ( k1 , j ) = rx if ( rx == 0e0 ) then c in the rare case when rx is exact zero, we still need to provide c a valid orthogonal unit vector. The details are boring, so handle c that elsewhere. call sgqvec ( m , k , Q , ldq , Q ( 1 , k1 )) else c otherwise, just normalize the added column. call sscal ( m , 1e0 / rx , Q ( 1 , k1 ), 1 ) end if end if c maybe we're finished. if ( j > k ) return c eliminate the spike. call sqrtv1 ( k1 + 1 - j , R ( j , j ), w ) c apply rotations to R(j:k,j:n). if ( j <= n ) call sqrqh ( k1 + 1 - j , n + 1 - j , R ( j , j + 1 ), ldr , w , R ( j + 1 , j )) c apply rotations to Q(:,j:k). call sqrot ( 'B' , m , k1 + 1 - j , Q ( 1 , j ), ldq , w , R ( j + 1 , j )) c zero spike. do i = j + 1 , k1 R ( i , j ) = 0e0 end do end subroutine","tags":"","loc":"sourcefile\\sqrinc.f.html"},{"title":"sqrinr.f – LINALG","text":"Contents Subroutines sqrinr Source Code sqrinr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrinr ( m , n , Q , ldq , R , ldr , j , x , w ) c purpose:      updates a QR factorization after inserting a new c               row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m+1, this subroutine updates Q -> Q1  and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); x; A(j:m,:)], where A = Q*R. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m+1. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m+1. c j (in)        the position of the new row in R1 c x (io)        on entry, the row being added c               on exit, x is destroyed. c w (out)       a workspace vector of size min(m,n). c integer m , n , j , ldq , ldr real Q ( ldq , * ), R ( ldr , * ), x ( * ), w ( * ) external xerbla , scopy , sqhqr , sqrot integer info , i , k c check arguments info = 0 if ( n < 0 ) then info = 2 else if ( j < 1 . or . j > m + 1 ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'SQRINR' , info ) return end if c permute the columns of Q1 and rows of R1 so that c the new row ends c up being the topmost row of R1. do i = m , 1 , - 1 if ( j > 1 ) then call scopy ( j - 1 , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 ) end if Q ( j , i + 1 ) = 0e0 if ( j <= m ) then call scopy ( m + 1 - j , Q ( j , i ), 1 , Q ( j + 1 , i + 1 ), 1 ) end if end do c set up the 1st column do i = 1 , j - 1 Q ( i , 1 ) = 0e0 end do Q ( j , 1 ) = 1e0 do i = j + 1 , m + 1 Q ( i , 1 ) = 0e0 end do c set up the new matrix R1 do k = 1 , n if ( k < m ) R ( m + 1 , k ) = 0e0 do i = min ( m , k ), 1 , - 1 R ( i + 1 , k ) = R ( i , k ) end do R ( 1 , k ) = x ( k ) end do c retriangularize R call sqhqr ( m + 1 , n , R , ldr , w , x ) c apply rotations to Q call sqrot ( 'F' , m + 1 , min ( m , n ) + 1 , Q , ldq , w , x ) end subroutine","tags":"","loc":"sourcefile\\sqrinr.f.html"},{"title":"sqrot.f – LINALG","text":"Contents Subroutines sqrot Source Code sqrot.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrot ( dir , m , n , Q , ldq , c , s ) c purpose:      Apply a sequence of inv. rotations from right c c arguments: c dir (in)      if 'B' or 'b', rotations are applied from backwards c               if 'F' or 'f', from forwards. c m (in)        number of rows of matrix Q c n (in)        number of columns of the matrix Q c Q (io)        on entry, the matrix Q c               on exit, the updated matrix Q1 c ldq (in)      the leading dimension of Q c c (in)        n-1 rotation cosines c s (in)        n-1 rotation sines c character dir integer m , n , ldq real Q ( ldq , * ), c ( * ), s ( * ) external srot , lsame logical lsame , fwd integer info , i c quick return if possible if ( m == 0 . or . n == 0 . or . n == 1 ) return c check arguments. info = 0 fwd = lsame ( dir , 'F' ) if (. not .( fwd . or . lsame ( dir , 'B' ))) then info = 1 else if ( m < 0 ) then info = 2 else if ( n < 0 ) then info = 3 else if ( ldq < m ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'SQROT' , info ) return end if if ( fwd ) then do i = 1 , n - 1 call srot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), s ( i )) end do else do i = n - 1 , 1 , - 1 call srot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), s ( i )) end do end if end subroutine","tags":"","loc":"sourcefile\\sqrot.f.html"},{"title":"sqrqh.f – LINALG","text":"Contents Subroutines sqrqh Source Code sqrqh.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrqh ( m , n , R , ldr , c , s ) c purpose:      brings an upper trapezoidal matrix R into upper c               Hessenberg form using min(m-1,n) Givens rotations. c               (real version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(in)         rotation cosines, size at least min(m-1,n) c s(in)         rotation sines, size at least min(m-1,n) c integer m , n , ldr real R ( ldr , * ), c ( * ), s ( * ) external xerbla real t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'SQRQH' , info ) return end if do i = 1 , n ii = min ( m - 1 , i ) c apply stored rotations, column-wise t = R ( ii + 1 , i ) do j = ii , 1 , - 1 R ( j + 1 , i ) = c ( j ) * t - s ( j ) * R ( j , i ) t = c ( j ) * R ( j , i ) + s ( j ) * t end do R ( 1 , i ) = t end do end subroutine","tags":"","loc":"sourcefile\\sqrqh.f.html"},{"title":"sqrshc.f – LINALG","text":"Contents Subroutines sqrshc Source Code sqrshc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrshc ( m , n , k , Q , ldq , R , ldr , i , j , w ) c purpose:      updates a QR factorization after circular shift of c               columns. c               i.e., given an m-by-k orthogonal matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again orthogonal, R1 upper c               trapezoidal, and c               Q1*R1 = A(:,p), where A = Q*R and p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (real version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q1, and rows of R1. Must be c               either k = m (full Q) or k = n <= m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c i (in)        the first index determining the range (see above) c j (in)        the second index determining the range (see above) c w (o)         a workspace vector of size 2*k. c integer m , n , k , ldq , ldr , i , j real Q ( ldq , * ), R ( ldr , * ), w ( * ) external xerbla , scopy , sqrtv1 , sqrqh , sqhqr integer info , jj , kk , l c quick return if possible. if ( m == 0 . or . n == 1 ) return info = 0 c check arguments. if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( i < 1 . or . i > n ) then info = 6 else if ( j < 1 . or . j > n ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'SQRSHC' , info ) return end if if ( i < j ) then c shift columns call scopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call scopy ( k , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call scopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( i < k ) then kk = min ( k , j ) call sqhqr ( kk + 1 - i , n + 1 - i , R ( i , i ), ldr , w ( k + 1 ), w ) c apply rotations to Q. call sqrot ( 'F' , m , kk + 1 - i , Q ( 1 , i ), ldq , w ( k + 1 ), w ) end if else if ( j < i ) then c shift columns call scopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call scopy ( k , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call scopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( j < k ) then jj = min ( j + 1 , n ) kk = min ( k , i ) c eliminate the introduced spike. call sqrtv1 ( kk + 1 - j , R ( j , j ), w ( k + 1 )) c apply rotations to R call sqrqh ( kk + 1 - j , n - j , R ( j , jj ), ldr , w ( k + 1 ), R ( j + 1 , j )) c apply rotations to Q call sqrot ( 'B' , m , kk + 1 - j , Q ( 1 , j ), ldq , w ( k + 1 ), R ( j + 1 , j )) c zero spike. do l = j + 1 , kk R ( l , j ) = 0e0 end do end if end if end subroutine","tags":"","loc":"sourcefile\\sqrshc.f.html"},{"title":"sqrtv1.f – LINALG","text":"Contents Subroutines sqrtv1 Source Code sqrtv1.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine sqrtv1 ( n , u , w ) c purpose:      generates a sequence of n-1 Givens rotations that c               eliminate all but the first element of a vector u. c arguments: c n (in)        the length of the vector u c u (io)        on entry, the vector u. c               on exit, u(2:n) contains the rotation sines, u(1) c               contains the remaining element. c w (o)         on exit, w contains the rotation cosines. c integer n real u ( * ), w ( * ) external slartg real rr , t integer i c quick return if possible. if ( n <= 0 ) return rr = u ( n ) do i = n - 1 , 1 , - 1 call slartg ( u ( i ), rr , w ( i ), u ( i + 1 ), t ) rr = t end do u ( 1 ) = rr end subroutine","tags":"","loc":"sourcefile\\sqrtv1.f.html"},{"title":"zaxcpy.f – LINALG","text":"Contents Subroutines zaxcpy Source Code zaxcpy.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zaxcpy ( n , a , x , incx , y , incy ) c purpose:      constant times a conjugated vector plus a vector. c arguments: c n (in)        vector length c a (in)        complex factor c x (in)        added vector c incx (in)     x increments c y (io)        accumulator vector c incy (in)     y increments c integer n , incx , incy double complex a , x ( * ), y ( * ) integer i , ix , iy c quick return if possible. if ( n <= 0 ) return if ( incx /= 1 . or . incy /= 1 ) then c code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n y ( iy ) = y ( iy ) + a * conjg ( x ( ix )) ix = ix + incx iy = iy + incy end do else c code for both increments equal to 1 do i = 1 , n y ( i ) = y ( i ) + a * conjg ( x ( i )) end do end if end subroutine","tags":"","loc":"sourcefile\\zaxcpy.f.html"},{"title":"zch1dn.f – LINALG","text":"Contents Subroutines zch1dn Source Code zch1dn.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zch1dn ( n , R , ldr , u , rw , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine downdates R -> R1 so that c               R1'*R1 = A - u*u' c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the reflector sines c               used to transform R to R1. c rw (out)      cosine parts of reflectors. c c info (out)    on exit, error code: c                info = 0: success. c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c integer n , ldr double complex R ( ldr , * ), u ( * ) double precision rw ( * ) integer info external ztrsv , zlartg , dznrm2 double complex crho , rr , ui , t double precision dznrm2 , rho integer i , j c quick return if possible. if ( n == 0 ) return c check arguments. info = 0 if ( n < 0 ) then info = - 1 else if ( ldr < n ) then info = - 3 end if if ( info /= 0 ) then call xerbla ( 'ZCH1DN' , - info ) return end if c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0 d0 ) goto 20 end do c form R' \\ u call ztrsv ( 'U' , 'C' , 'N' , n , R , ldr , u , 1 ) rho = dznrm2 ( n , u , 1 ) c check positive definiteness rho = 1 - rho ** 2 if ( rho <= 0 d0 ) goto 10 crho = sqrt ( rho ) c eliminate R' \\ u do i = n , 1 , - 1 ui = u ( i ) c generate next rotation call zlartg ( crho , ui , rw ( i ), u ( i ), rr ) crho = rr end do c apply rotations do i = n , 1 , - 1 ui = 0 d0 do j = i , 1 , - 1 t = rw ( j ) * ui + u ( j ) * R ( j , i ) R ( j , i ) = rw ( j ) * R ( j , i ) - conjg ( u ( j )) * ui ui = t end do end do c normal return return c error returns 10 info = 1 return 20 info = 2 return end subroutine","tags":"","loc":"sourcefile\\zch1dn.f.html"},{"title":"zch1up.f – LINALG","text":"Contents Subroutines zch1up Source Code zch1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zch1up ( n , R , ldr , u , w ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A + u*u' c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c u (io)        the vector determining the rank-1 update c               on exit, u contains the rotation sines c               used to transform R to R1. c w (out)       cosine parts of rotations. c integer n , ldr double complex R ( ldr , * ), u ( * ) double precision w ( * ) external zlartg double complex rr , ui , t integer i , j do i = 1 , n c apply stored rotations, column-wise ui = conjg ( u ( i )) do j = 1 , i - 1 t = w ( j ) * R ( j , i ) + u ( j ) * ui ui = w ( j ) * ui - conjg ( u ( j )) * R ( j , i ) R ( j , i ) = t end do c generate next rotation call zlartg ( R ( i , i ), ui , w ( i ), u ( i ), rr ) R ( i , i ) = rr end do end subroutine","tags":"","loc":"sourcefile\\zch1up.f.html"},{"title":"zchdex.f – LINALG","text":"Contents Subroutines zchdex Source Code zchdex.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zchdex ( n , R , ldr , j , rw ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(jj,jj), where jj = [1:j-1,j+1:n+1]. c               (complex version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n. c j (in)        the position of the deleted row/column. c rw (out)      a real workspace vector of size n. c integer n , ldr , j double complex R ( ldr , * ) double precision rw ( * ) integer info , i external xerbla , zcopy , zqhqr c quick return if possible if ( n == 1 ) return c check arguments info = 0 if ( n < 0 ) then info = 1 else if ( j < 1 . or . j > n ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'ZCHDEX' , info ) return end if c delete the j-th column. do i = j , n - 1 call zcopy ( n , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < n ) then call zqhqr ( n + 1 - j , n - j , R ( j , j ), ldr , rw , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\zchdex.f.html"},{"title":"zchinx.f – LINALG","text":"Contents Subroutines zchinx Source Code zchinx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zchinx ( n , R , ldr , j , u , rw , info ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a hermitian positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A1, A1(jj,jj) = A, A(j,:) = u', A(:,j) = u, c               jj = [1:j-1,j+1:n+1]. c               (complex version) c arguments: c n (in)        the order of matrix R. c R (io)        on entry, the original upper trapezoidal matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= n+1. c j (in)        the position of the inserted row/column c u (io)        on entry, the inserted row/column. c               on exit, u is destroyed. c rw (out)      real workspace vector of size n+1. c info (out)    on exit, error code: c                info = 1: update violates positive-definiteness. c                info = 2: R is singular. c                info = 3: diagonal element of u is not real. c integer n , j , ldr , info double complex R ( ldr , * ), u ( * ), rw ( * ) external xerbla , zcopy , dznrm2 , ztrsv , zqrtv1 , zqrqh double complex t double precision dznrm2 , rho integer i c check arguments info = 0 if ( n < 0 ) then info = - 1 else if ( j < 1 . or . j > n + 1 ) then info = - 4 end if if ( info /= 0 ) then call xerbla ( 'ZCHINX' , info ) return end if c shift vector. t = u ( j ) do i = j , n u ( i ) = u ( i + 1 ) end do c the diagonal element must be real. if ( imag ( t ) /= 0 d0 ) goto 30 c check for singularity of R. do i = 1 , n if ( R ( i , i ) == 0 d0 ) goto 20 end do c form R' \\ u call ztrsv ( 'U' , 'C' , 'N' , n , R , ldr , u , 1 ) rho = dznrm2 ( n , u , 1 ) c check positive definiteness. rho = t - rho ** 2 if ( rho <= 0 d0 ) goto 10 c shift columns do i = n , j , - 1 call zcopy ( i , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) R ( i + 1 , i + 1 ) = 0 d0 end do call zcopy ( n , u , 1 , R ( 1 , j ), 1 ) R ( n + 1 , j ) = sqrt ( rho ) c retriangularize if ( j < n + 1 ) then c eliminate the introduced spike. call zqrtv1 ( n + 2 - j , R ( j , j ), rw ) c apply rotations to R call zqrqh ( n + 2 - j , n + 1 - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c zero spike. do i = j + 1 , n + 1 R ( i , j ) = 0 d0 end do end if c normal return. return c error returns. 10 info = 1 return 20 info = 2 return 30 info = 3 return end subroutine","tags":"","loc":"sourcefile\\zchinx.f.html"},{"title":"zchshx.f – LINALG","text":"Contents Subroutines zchshx Source Code zchshx.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zchshx ( n , R , ldr , i , j , w , rw ) c purpose:      given an upper triangular matrix R that is a Cholesky c               factor of a symmetric positive definite matrix A, i.e. c               A = R'*R, this subroutine updates R -> R1 so that c               R1'*R1 = A(p,p), where p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (complex version) c arguments: c n (in)        the order of matrix R c R (io)        on entry, the upper triangular matrix R c               on exit, the updated matrix R1 c ldr (in)      leading dimension of R. ldr >= n. c i (in)        the first index determining the range (see above). c j (in)        the second index determining the range (see above). c w (o)         a workspace vector of size n. c rw (o)        a real workspace vector of size n. c integer n , ldr , i , j double complex R ( ldr , * ), w ( * ) double precision rw ( * ) external xerbla , zcopy , zqrtv1 , zqrqh , zqhqr integer info , l c quick return if possible. if ( n == 0 . or . n == 1 ) return info = 0 c check arguments. if ( n < 0 ) then info = 1 else if ( i < 1 . or . i > n ) then info = 4 else if ( j < 1 . or . j > n ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'ZCHSHX' , info ) return end if if ( i < j ) then c shift columns call zcopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call zcopy ( n , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call zcopy ( n , w , 1 , R ( 1 , j ), 1 ) c retriangularize call zqhqr ( n + 1 - i , n + 1 - i , R ( i , i ), ldr , rw , w ) else if ( j < i ) then c shift columns call zcopy ( n , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call zcopy ( n , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call zcopy ( n , w , 1 , R ( 1 , j ), 1 ) c eliminate the introduced spike. call zqrtv1 ( n + 1 - j , R ( j , j ), rw ) c apply rotations to R call zqrqh ( n + 1 - j , n - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c zero spike. do l = j + 1 , n R ( l , j ) = 0 d0 end do end if end subroutine","tags":"","loc":"sourcefile\\zchshx.f.html"},{"title":"zgqvec.f – LINALG","text":"Contents Subroutines zgqvec Source Code zgqvec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zgqvec ( m , n , Q , ldq , u ) c purpose:      given an unitary m-by-n matrix Q, n < m, generates c               a vector u such that Q'*u = 0 and norm(u) = 1. c arguments: c m (in)        number of rows of matrix Q. c n (in)        number of columns of matrix Q. c Q (in)        the unitary matrix Q. c ldq (in)      leading dimension of Q. c u (out)       the generated vector. c integer m , n , ldq double complex Q ( ldq , * ), u ( * ) external zdotu , zaxpy , dznrm2 , zdscal real zdotu double precision dznrm2 , r integer info , i , j c quick return if possible. if ( m == 0 ) return if ( n == 0 ) then u ( 1 ) = 1 d0 do i = 2 , m u ( i ) = 0 d0 end do return end if c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldq < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'ZGQVEC' , info ) return end if j = 1 10 continue c probe j-th canonical unit vector. do i = 1 , m u ( i ) = 0 d0 end do u ( j ) = 1 d0 c form u - Q*Q'*u do i = 1 , n r = zdotu ( m , Q ( 1 , i ), 1 , u , 1 ) call zaxpy ( m , - r , Q ( 1 , i ), 1 , u , 1 ) end do r = dznrm2 ( m , u , 1 ) if ( r == 0 d0 ) then j = j + 1 if ( j > n ) then c this is fatal, and in theory, it can't happen. stop 'fatal: impossible condition in ZGQVEC' else j = j + 1 goto 10 end if end if call zdscal ( m , 1 d0 / r , u , 1 ) end subroutine","tags":"","loc":"sourcefile\\zgqvec.f.html"},{"title":"zlu1up.f – LINALG","text":"Contents Subroutines zlu1up Source Code zlu1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zlu1up ( m , n , L , ldl , R , ldr , u , v ) c purpose:      updates an LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal and a k-by-n upper-trapezoidal matrix R, c               where k = min(m,n), c               this subroutine updates L -> L1 and R -> R1 so that c               L is again lower unit triangular, R upper trapezoidal, c               and L1*R1 = L*R + u*v.'. c               (complex version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c c REMARK:       Algorithm is due to c               J. Bennett: Triangular factors of modified matrices, c                           Numerische Mathematik, 7 (1965) c integer m , n , ldl , ldr double complex L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ) double complex ui , vi integer k , info , i , j external xerbla c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'ZLU1UP' , info ) return end if c The Bennett algorithm, modified for column-major access. c The leading part. do i = 1 , k c prefetch ui = u ( i ) vi = v ( i ) c delayed R update do j = 1 , i - 1 R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do c diagonal update R ( i , i ) = R ( i , i ) + ui * vi vi = vi / R ( i , i ) c L update do j = i + 1 , m u ( j ) = u ( j ) - ui * L ( j , i ) L ( j , i ) = L ( j , i ) + u ( j ) * vi end do u ( i ) = ui v ( i ) = vi end do c Finish the trailing part of R if needed. do i = k + 1 , n vi = v ( i ) do j = 1 , k R ( j , i ) = R ( j , i ) + u ( j ) * vi vi = vi - v ( j ) * R ( j , i ) end do v ( i ) = vi end do end subroutine","tags":"","loc":"sourcefile\\zlu1up.f.html"},{"title":"zlup1up.f – LINALG","text":"Contents Subroutines zlup1up Source Code zlup1up.f Source Code c Copyright (C) 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zlup1up ( m , n , L , ldl , R , ldr , p , u , v , w ) c purpose:      updates a row-pivoted LU factorization after rank-1 modification c               i.e., given an m-by-k lower-triangular matrix L with unit c               diagonal, a k-by-n upper-trapezoidal matrix R, and a c               permutation matrix P, where k = min(m,n), c               this subroutine updates L -> L1, R -> R1 and P -> P1 so that c               L is again lower unit triangular, R upper trapezoidal, c               P permutation and P1'*L1*R1 = P'*L*R + u*v.'. c               (real version) c arguments: c m (in)        order of the matrix L. c n (in)        number of columns of the matrix U. c L (io)        on entry, the unit lower triangular matrix L. c               on exit, the updated matrix L1. c ldl (in)      the leading dimension of L. ldl >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= min(m,n). c p (in)        the permutation vector representing P c u (in)        the left m-vector. c v (in)        the right n-vector. c w (work)      a workspace vector of size m. c c REMARK:       Algorithm is due to c               A. Kielbasinski, H. Schwetlick, Numerische Lineare c               Algebra, Verlag Harri Deutsch, 1988 c integer m , n , ldl , ldr , p ( * ) double complex L ( ldl , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) double complex one , tmp double precision tau parameter ( one = 1 d0 , tau = 1 d - 1 ) integer k , info , i , j , itmp external xerbla , zcopy , zaxpy , ztrsv , zgeru , zgemv c quick return if possible. k = min ( m , n ) if ( k == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldl < m ) then info = 4 else if ( ldr < k ) then info = 6 endif if ( info /= 0 ) then call xerbla ( 'ZLU1UP' , info ) return end if c form L \\ P*u. do i = 1 , m w ( i ) = u ( p ( i )) end do call ztrsv ( 'L' , 'N' , 'U' , k , L , ldl , w , 1 ) c if m > k = n, subtract the trailing part. if ( m > k ) then call zgemv ( 'N' , m - k , k , - one , L ( k + 1 , 1 ), ldl , w , 1 , one , w ( k + 1 ), 1 ) end if c work from bottom to top do j = k - 1 , 1 , - 1 if ( abs ( w ( j )) < tau * abs ( L ( j + 1 , j ) * w ( j ) + w ( j + 1 ))) then c need pivoting. swap j and j+1 tmp = w ( j ) w ( j ) = w ( j + 1 ) w ( j + 1 ) = tmp c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call zswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call zswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call zswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call zaxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call zaxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) c update w w ( j ) = w ( j ) - tmp * w ( j + 1 ) end if c eliminate w(j+1) tmp = w ( j + 1 ) / w ( j ) w ( j + 1 ) = 0 c update R. call zaxpy ( n - j + 1 , - tmp , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c update L. call zaxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c add a multiple of v to R call zaxpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c forward sweep do j = 1 , k - 1 if ( abs ( R ( j , j )) < tau * abs ( L ( j + 1 , j ) * R ( j , j ) + R ( j + 1 , j ))) then c need pivoting. swap j and j+1 c update p itmp = p ( j ) p ( j ) = p ( j + 1 ) p ( j + 1 ) = itmp c update L call zswap ( m - j + 1 , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) call zswap ( j + 1 , L ( j , 1 ), ldl , L ( j + 1 , 1 ), ldl ) c update R call zswap ( n - j + 1 , R ( j , j ), ldr , R ( j + 1 , j ), ldr ) c make L lower triangular again tmp = - L ( j , j + 1 ) call zaxpy ( m - j + 1 , tmp , L ( j , j ), 1 , L ( j , j + 1 ), 1 ) c update R call zaxpy ( n - j + 1 , - tmp , R ( j + 1 , j ), ldr , R ( j , j ), ldr ) end if c eliminate R(j+1,j) tmp = R ( j + 1 , j ) / R ( j , j ) c update R. R ( j + 1 , j ) = 0 d0 call zaxpy ( n - j , - tmp , R ( j , j + 1 ), ldr , R ( j + 1 , j + 1 ), ldr ) c update L. call zaxpy ( m - j , tmp , L ( j + 1 , j + 1 ), 1 , L ( j + 1 , j ), 1 ) end do c if m > k = n, complete the update by updating the lower part of L. if ( m > k ) then call zcopy ( k , v , 1 , w , 1 ) call ztrsv ( 'U' , 'T' , 'N' , k , R , ldr , w , 1 ) call zgeru ( m - k , k , one , w ( k + 1 ), 1 , w , 1 , L ( k + 1 , 1 ), ldl ) endif end subroutine","tags":"","loc":"sourcefile\\zlup1up.f.html"},{"title":"zqhqr.f – LINALG","text":"Contents Subroutines zqhqr Source Code zqhqr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqhqr ( m , n , R , ldr , c , s ) c purpose:      given an m-by-n upper Hessenberg matrix R, this c               subroutine updates R to upper trapezoidal form c               using min(m-1,n) Givens rotations. c               (complex version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(out)        rotation cosines, size at least min(m-1,n) c s(out)        rotation sines, size at least min(m-1,n) c integer m , n , ldr double complex R ( ldr , * ), s ( * ) double precision c ( * ) external xerbla , zlartg double complex t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'ZQHQR' , info ) return end if do i = 1 , n c apply stored rotations, column-wise t = R ( 1 , i ) ii = min ( m , i ) do j = 1 , ii - 1 R ( j , i ) = c ( j ) * t + s ( j ) * R ( j + 1 , i ) t = c ( j ) * R ( j + 1 , i ) - conjg ( s ( j )) * t end do if ( ii < m ) then c generate next rotation call zlartg ( t , R ( ii + 1 , i ), c ( i ), s ( i ), R ( ii , i )) R ( ii + 1 , i ) = 0 d0 else R ( ii , i ) = t end if end do end subroutine","tags":"","loc":"sourcefile\\zqhqr.f.html"},{"title":"zqr1up.f – LINALG","text":"Contents Subroutines zqr1up Source Code zqr1up.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqr1up ( m , n , k , Q , ldq , R , ldr , u , v , w , rw ) c purpose:      updates a QR factorization after rank-1 modification c               i.e., given a m-by-k unitary Q and m-by-n upper c               trapezoidal R, an m-vector u and n-vector v, c               this subroutine updates Q -> Q1 and R -> R1 so that c               Q1*R1 = Q*R + u*v', and Q1 is again unitary c               and R1 upper trapezoidal. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      the leading dimension of Q. ldq >= m. c R (io)        on entry, the upper trapezoidal m-by-n matrix R.. c               on exit, the updated matrix R1. c ldr (in)      the leading dimension of R. ldr >= k. c u (io)        the left m-vector. On exit, if k < m, u is destroyed. c v (io)        the right n-vector. On exit, v is destroyed. c w (out)       a workspace vector of size k. c rw (out)      a real workspace vector of size k. c integer m , n , k , ldq , ldr double complex Q ( ldq , * ), R ( ldr , * ), u ( * ), v ( * ), w ( * ) double precision rw ( * ) external zqrqh , zqhqr , zqrot , zqrtv1 , zaxcpy external zdotc , dznrm2 , dlamch , zdscal , zrot double complex zdotc double precision dznrm2 , dlamch , ru , ruu integer info , i , j logical full c quick return if possible. if ( k == 0 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 endif if ( info /= 0 ) then call xerbla ( 'ZQR1UP' , info ) return end if full = k == m c in the non-full case, we shall need the norm of u. if (. not . full ) ru = dznrm2 ( m , u , 1 ) c form Q'*u. In the non-full case, form also u - Q*Q'u. do i = 1 , k !   w(i) = zdotc(m,Q(1,i),1,u,1) ! SEGFAULT on MacOS & GFortran w ( i ) = ( 0.0d0 , 0.0d0 ) do j = 1 , m w ( i ) = w ( i ) + conjg ( Q ( j , i )) * u ( j ) end do if (. not . full ) call zaxpy ( m , - w ( i ), Q ( 1 , i ), 1 , u , 1 ) end do c generate rotations to eliminate Q'*u. call zqrtv1 ( k , w , rw ) c apply rotations to R. call zqrqh ( k , n , R , ldr , rw , w ( 2 )) c apply rotations to Q. call zqrot ( 'B' , m , k , Q , ldq , rw , w ( 2 )) c update the first row of R. call zaxcpy ( n , w ( 1 ), v , 1 , R ( 1 , 1 ), ldr ) c retriangularize R. call zqhqr ( k , n , R , ldr , rw , w ) c apply rotations to Q. call zqrot ( 'F' , m , min ( k , n + 1 ), Q , ldq , rw , w ) c in the full case, we're finished if ( full ) return c compute relative residual norm ruu = dznrm2 ( m , u , 1 ) ru = ru * dlamch ( 'e' ) if ( ruu <= ru ) return c update the orthogonal basis. call zdscal ( n , ruu , v , 1 ) call zdscal ( m , 1 d0 / ruu , u , 1 ) call zch1up ( n , R , ldr , v , rw ) do i = 1 , n call zrot ( m , Q ( 1 , i ), 1 , u , 1 , rw ( i ), conjg ( v ( i ))) end do end subroutine","tags":"","loc":"sourcefile\\zqr1up.f.html"},{"title":"zqrdec.f – LINALG","text":"Contents Subroutines zqrdec Source Code zqrdec.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrdec ( m , n , k , Q , ldq , R , ldr , j , rw ) c purpose:      updates a QR factorization after deleting c               a column. c               i.e., given an m-by-k unitary matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 remains unitary, R1 is upper c               trapezoidal, and Q1*R1 = [A(:,1:j-1) A(:,j+1:n)], c               where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n < m (economical form, c               basis dimension will decrease). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c j (in)        the position of the deleted column in R. c               1 <= j <= n. c rw (o)        a real workspace vector of size k-j. c integer m , n , k , ldq , ldr , j double complex Q ( ldq , * ), R ( ldr , * ) double precision rw ( * ) external xerbla , zcopy , zqhqr , zqrot integer info , i c quick return if possible. if ( m == 0 . or . n == 0 . or . j == n ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < k ) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'ZQRDEC' , info ) return end if c delete the j-th column. do i = j , n - 1 call zcopy ( k , R ( 1 , i + 1 ), 1 , R ( 1 , i ), 1 ) end do c retriangularize. if ( j < k ) then call zqhqr ( k + 1 - j , n - j , R ( j , j ), ldr , rw , R ( 1 , n )) c apply rotations to Q. call zqrot ( 'F' , m , min ( k , n ) + 1 - j , Q ( 1 , j ), ldq , rw , R ( 1 , n )) end if end subroutine","tags":"","loc":"sourcefile\\zqrdec.f.html"},{"title":"zqrder.f – LINALG","text":"Contents Subroutines zqrder Source Code zqrder.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrder ( m , n , Q , ldq , R , ldr , j , w , rw ) c purpose:      updates a QR factorization after deleting a row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m, this subroutine updates Q ->Q1 and an R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); A(j+1:m,:)], where A = Q*R. c               (complex version) c c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m. c j (in)        the position of the deleted row. c w (out)       a workspace vector of size m. c rw (out)      a real workspace vector of size m. c integer m , n , j , ldq , ldr double complex Q ( ldq , * ), R ( ldr , * ), w ( * ) double precision rw ( * ) external xerbla , zcopy , zqrtv1 , zqrot , zqrqh integer info , i , k c quick return if possible if ( m == 1 ) return c check arguments info = 0 if ( m < 1 ) then info = 1 else if ( j < 1 . or . j > m ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'ZQRDER' , info ) return end if c eliminate Q(j,2:m). do k = 1 , m w ( k ) = conjg ( Q ( j , k )) end do call zqrtv1 ( m , w , rw ) c apply rotations to Q. call zqrot ( 'B' , m , m , Q , ldq , rw , w ( 2 )) c form Q1. do k = 1 , m - 1 if ( j > 1 ) call zcopy ( j - 1 , Q ( 1 , k + 1 ), 1 , Q ( 1 , k ), 1 ) if ( j < m ) call zcopy ( m - j , Q ( j + 1 , k + 1 ), 1 , Q ( j , k ), 1 ) end do c apply rotations to R. call zqrqh ( m , n , R , ldr , rw , w ( 2 )) c form R1. do k = 1 , n do i = 1 , m - 1 R ( i , k ) = R ( i + 1 , k ) end do end do end subroutine","tags":"","loc":"sourcefile\\zqrder.f.html"},{"title":"zqrinc.f – LINALG","text":"Contents Subroutines zqrinc Source Code zqrinc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrinc ( m , n , k , Q , ldq , R , ldr , j , x , rw ) c purpose:      updates a QR factorization after inserting a new c               column. c               i.e., given an m-by-k unitary matrix Q, an m-by-n upper c               trapezoidal matrix R and index j in the range 1:n+1, c               this subroutine updates the matrix Q -> Q1 and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, and c               Q1*R1 = [A(:,1:j-1); x; A(:,j:n)], where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q, and rows of R. Must be c               either k = m (full Q) or k = n <= m (economical form, c               basis dimension will increase). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= min(m,n+1). c j (in)        the position of the new column in R1 c x (in)        the column being inserted c rw (out)      a real workspace vector of size k. c integer m , n , k , ldq , ldr , j double complex Q ( ldq , * ), R ( ldr , * ), x ( * ) double precision rw ( * ) external zqrtv1 , zqrqh , zqrot external xerbla , zcopy , zdotc , zaxpy , zdscal , dznrm2 double complex zdotc double precision dznrm2 , rx integer info , i , k1 logical full c quick return if possible. if ( m == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n >= m )) then info = 3 else if ( ldq < m ) then info = 5 else if ( ldr < min ( m , k + 1 )) then info = 7 else if ( j < 1 . or . j > n + 1 ) then info = 8 end if if ( info /= 0 ) then call xerbla ( 'ZQRINC' , info ) return end if full = k == m c insert empty column at j-th position do i = n , j , - 1 call zcopy ( k , R ( 1 , i ), 1 , R ( 1 , i + 1 ), 1 ) end do c insert Q'*u into R. In the nonfull case, form also u-Q*Q'*u. if ( full ) then k1 = k do i = 1 , k R ( i , j ) = zdotc ( m , Q ( 1 , i ), 1 , x , 1 ) end do else k1 = k + 1 c zero last row of R do i = 1 , n + 1 R ( k1 , i ) = 0 d0 end do call zcopy ( m , x , 1 , Q ( 1 , k1 ), 1 ) do i = 1 , k R ( i , j ) = zdotc ( m , Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) call zaxpy ( m , - R ( i , j ), Q ( 1 , i ), 1 , Q ( 1 , k1 ), 1 ) end do c get norm of the inserted column rx = dznrm2 ( m , Q ( 1 , k1 ), 1 ) R ( k1 , j ) = rx if ( rx == 0 d0 ) then c in the rare case when rx is exact zero, we still need to provide c a valid orthogonal unit vector. The details are boring, so handle c that elsewhere. call zgqvec ( m , k , Q , ldq , Q ( 1 , k1 )) else c otherwise, just normalize the added column. call zdscal ( m , 1 d0 / rx , Q ( 1 , k1 ), 1 ) end if end if c maybe we're finished. if ( j > k ) return c eliminate the spike. call zqrtv1 ( k1 + 1 - j , R ( j , j ), rw ) c apply rotations to R(j:k,j:n). if ( j <= n ) call zqrqh ( k1 + 1 - j , n + 1 - j , R ( j , j + 1 ), ldr , rw , R ( j + 1 , j )) c apply rotations to Q(:,j:k). call zqrot ( 'B' , m , k1 + 1 - j , Q ( 1 , j ), ldq , rw , R ( j + 1 , j )) c zero spike. do i = j + 1 , k1 R ( i , j ) = 0 d0 end do end subroutine","tags":"","loc":"sourcefile\\zqrinc.f.html"},{"title":"zqrinr.f – LINALG","text":"Contents Subroutines zqrinr Source Code zqrinr.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrinr ( m , n , Q , ldq , R , ldr , j , x , rw ) c purpose:      updates a QR factorization after inserting a new c               row. c               i.e., given an m-by-m unitary matrix Q, an m-by-n c               upper trapezoidal matrix R and index j in the range c               1:m+1, this subroutine updates Q -> Q1  and R -> R1 c               so that Q1 is again unitary, R1 upper trapezoidal, c               and Q1*R1 = [A(1:j-1,:); x; A(j:m,:)], where A = Q*R. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c Q (io)        on entry, the unitary matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m+1. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= m+1. c j (in)        the position of the new row in R1 c x (io)        on entry, the row being added c               on exit, x is destroyed. c rw (out)      a real workspace vector of size min(m,n). c integer m , n , j , ldq , ldr double complex Q ( ldq , * ), R ( ldr , * ), x ( * ) double precision rw ( * ) external xerbla , zcopy , zqhqr , zqrot integer info , i , k c check arguments info = 0 if ( n < 0 ) then info = 2 else if ( j < 1 . or . j > m + 1 ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'ZQRINR' , info ) return end if c permute the columns of Q1 and rows of R1 so that c the new row ends c up being the topmost row of R1. do i = m , 1 , - 1 if ( j > 1 ) then call zcopy ( j - 1 , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 ) end if Q ( j , i + 1 ) = 0 d0 if ( j <= m ) then call zcopy ( m + 1 - j , Q ( j , i ), 1 , Q ( j + 1 , i + 1 ), 1 ) end if end do c set up the 1st column do i = 1 , j - 1 Q ( i , 1 ) = 0 d0 end do Q ( j , 1 ) = 1 d0 do i = j + 1 , m + 1 Q ( i , 1 ) = 0 d0 end do c set up the new matrix R1 do k = 1 , n if ( k < m ) R ( m + 1 , k ) = 0 d0 do i = min ( m , k ), 1 , - 1 R ( i + 1 , k ) = R ( i , k ) end do R ( 1 , k ) = x ( k ) end do c retriangularize R call zqhqr ( m + 1 , n , R , ldr , rw , x ) c apply rotations to Q call zqrot ( 'F' , m + 1 , min ( m , n ) + 1 , Q , ldq , rw , x ) end subroutine","tags":"","loc":"sourcefile\\zqrinr.f.html"},{"title":"zqrot.f – LINALG","text":"Contents Subroutines zqrot Source Code zqrot.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrot ( dir , m , n , Q , ldq , c , s ) c purpose:      Apply a sequence of inv. rotations from right c c arguments: c dir (in)      if 'B' or 'b', rotations are applied from backwards c               if 'F' or 'f', from forwards. c m (in)        number of rows of matrix Q c n (in)        number of columns of the matrix Q c Q (io)        on entry, the matrix Q c               on exit, the updated matrix Q1 c ldq (in)      the leading dimension of Q c c (in)        n-1 rotation cosines c s (in)        n-1 rotation sines c character dir integer m , n , ldq double complex Q ( ldq , * ), s ( * ) double precision c ( * ) external zrot , lsame logical lsame , fwd integer info , i c quick return if possible if ( m == 0 . or . n == 0 . or . n == 1 ) return c check arguments. info = 0 fwd = lsame ( dir , 'F' ) if (. not .( fwd . or . lsame ( dir , 'B' ))) then info = 1 else if ( m < 0 ) then info = 2 else if ( n < 0 ) then info = 3 else if ( ldq < m ) then info = 5 end if if ( info /= 0 ) then call xerbla ( 'ZQROT' , info ) return end if if ( fwd ) then do i = 1 , n - 1 call zrot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), conjg ( s ( i ))) end do else do i = n - 1 , 1 , - 1 call zrot ( m , Q ( 1 , i ), 1 , Q ( 1 , i + 1 ), 1 , c ( i ), conjg ( s ( i ))) end do end if end subroutine","tags":"","loc":"sourcefile\\zqrot.f.html"},{"title":"zqrqh.f – LINALG","text":"Contents Subroutines zqrqh Source Code zqrqh.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrqh ( m , n , R , ldr , c , s ) c purpose:      brings an upper trapezoidal matrix R into upper c               Hessenberg form using min(m-1,n) Givens rotations. c               (complex version) c arguments: c m (in)        number of rows of the matrix R c n (in)        number of columns of the matrix R c R (io)        on entry, the upper Hessenberg matrix R c               on exit, the updated upper trapezoidal matrix c ldr (in)      leading dimension of R, >= m c c(in)         rotation cosines, size at least min(m-1,n) c s(in)         rotation sines, size at least min(m-1,n) c integer m , n , ldr double complex R ( ldr , * ), s ( * ) double precision c ( * ) external xerbla double complex t integer info , i , ii , j c quick return if possible. if ( m == 0 . or . m == 1 . or . n == 0 ) return c check arguments. info = 0 if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( ldr < m ) then info = 4 end if if ( info /= 0 ) then call xerbla ( 'ZQRQH' , info ) return end if do i = 1 , n c apply stored rotations, column-wise ii = min ( m - 1 , i ) t = R ( ii + 1 , i ) do j = ii , 1 , - 1 R ( j + 1 , i ) = c ( j ) * t - conjg ( s ( j )) * R ( j , i ) t = c ( j ) * R ( j , i ) + s ( j ) * t end do R ( 1 , i ) = t end do end subroutine","tags":"","loc":"sourcefile\\zqrqh.f.html"},{"title":"zqrshc.f – LINALG","text":"Contents Subroutines zqrshc Source Code zqrshc.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrshc ( m , n , k , Q , ldq , R , ldr , i , j , w , rw ) c purpose:      updates a QR factorization after circular shift of c               columns. c               i.e., given an m-by-k unitary matrix Q, an k-by-n c               upper trapezoidal matrix R and index j in the range c               1:n+1, this subroutine updates the matrix Q -> Q1 and c               R -> R1 so that Q1 is again unitary, R1 upper c               trapezoidal, and c               Q1*R1 = A(:,p), where A = Q*R and p is the permutation c               [1:i-1,shift(i:j,-1),j+1:n] if i < j  or c               [1:j-1,shift(j:i,+1),i+1:n] if j < i. c               (complex version) c arguments: c m (in)        number of rows of the matrix Q. c n (in)        number of columns of the matrix R. c k (in)        number of columns of Q1, and rows of R1. Must be c               either k = m (full Q) or k = n <= m (economical form). c Q (io)        on entry, the unitary m-by-k matrix Q. c               on exit, the updated matrix Q1. c ldq (in)      leading dimension of Q. ldq >= m. c R (io)        on entry, the original matrix R. c               on exit, the updated matrix R1. c ldr (in)      leading dimension of R. ldr >= k. c i (in)        the first index determining the range (see above) c j (in)        the second index determining the range (see above) c w (o)         a workspace vector of size k. c rw (o)        a real workspace vector of size k. c integer m , n , k , ldq , ldr , i , j double complex Q ( ldq , * ), R ( ldr , * ), w ( * ) double precision rw ( * ) external xerbla , zcopy , zqrtv1 , zqrqh , zqhqr integer info , jj , kk , l c quick return if possible. if ( m == 0 . or . n == 1 ) return info = 0 c check arguments. if ( m < 0 ) then info = 1 else if ( n < 0 ) then info = 2 else if ( k /= m . and . ( k /= n . or . n > m )) then info = 3 else if ( i < 1 . or . i > n ) then info = 6 else if ( j < 1 . or . j > n ) then info = 7 end if if ( info /= 0 ) then call xerbla ( 'ZQRSHC' , info ) return end if if ( i < j ) then c shift columns call zcopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j - 1 call zcopy ( k , R ( 1 , l + 1 ), 1 , R ( 1 , l ), 1 ) end do call zcopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( i < k ) then kk = min ( k , j ) call zqhqr ( kk + 1 - i , n + 1 - i , R ( i , i ), ldr , rw , w ) c apply rotations to Q. call zqrot ( 'F' , m , kk + 1 - i , Q ( 1 , i ), ldq , rw , w ) end if else if ( j < i ) then c shift columns call zcopy ( k , R ( 1 , i ), 1 , w , 1 ) do l = i , j + 1 , - 1 call zcopy ( k , R ( 1 , l - 1 ), 1 , R ( 1 , l ), 1 ) end do call zcopy ( k , w , 1 , R ( 1 , j ), 1 ) c retriangularize if ( j < k ) then jj = min ( j + 1 , n ) kk = min ( k , i ) c eliminate the introduced spike. call zqrtv1 ( kk + 1 - j , R ( j , j ), rw ) c apply rotations to R call zqrqh ( kk + 1 - j , n - j , R ( j , jj ), ldr , rw , R ( j + 1 , j )) c apply rotations to Q call zqrot ( 'B' , m , kk + 1 - j , Q ( 1 , j ), ldq , rw , R ( j + 1 , j )) c zero spike. do l = j + 1 , kk R ( l , j ) = 0 d0 end do end if end if end subroutine","tags":"","loc":"sourcefile\\zqrshc.f.html"},{"title":"zqrtv1.f – LINALG","text":"Contents Subroutines zqrtv1 Source Code zqrtv1.f Source Code c Copyright (C) 2008, 2009  VZLU Prague, a.s., Czech Republic c c Author: Jaroslav Hajek <highegg@gmail.com> c c This file is part of qrupdate. c c qrupdate is free software; you can redistribute it and/or modify c it under the terms of the GNU General Public License as published by c the Free Software Foundation; either version 3 of the License, or c (at your option) any later version. c c This program is distributed in the hope that it will be useful, c but WITHOUT ANY WARRANTY; without even the implied warranty of c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the c GNU General Public License for more details. c c You should have received a copy of the GNU General Public License c along with this software; see the file COPYING.  If not, see c <http://www.gnu.org/licenses/>. c subroutine zqrtv1 ( n , u , w ) c purpose:      generates a sequence of n-1 Givens rotations that c               eliminate all but the first element of a vector u. c arguments: c n (in)        the length of the vector u c u (io)        on entry, the vector u. c               on exit, u(2:n) contains the rotation sines, u(1) c               contains the remaining element. c w (o)         on exit, w contains the rotation cosines. c integer n double complex u ( * ) double precision w ( * ) external zlartg double complex rr , t integer i c quick return if possible. if ( n <= 0 ) return rr = u ( n ) do i = n - 1 , 1 , - 1 call zlartg ( u ( i ), rr , w ( i ), u ( i + 1 ), t ) rr = t end do u ( 1 ) = rr end subroutine","tags":"","loc":"sourcefile\\zqrtv1.f.html"},{"title":"blassm.f – LINALG","text":"Contents Subroutines amub aplb aplb1 aplsb aplsb1 apmbt aplsbt diamua amudia aplsca apldia Source Code blassm.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c        BASIC LINEAR ALGEBRA FOR SPARSE MATRICES. BLASSM MODULE       c c----------------------------------------------------------------------c c amub   :   computes     C = A*B                                      c c aplb   :   computes     C = A+B                                      c c aplb1  :   computes     C = A+B  [Sorted version: A, B, C sorted]    c c aplsb  :   computes     C = A + s B                                  c c aplsb1 :   computes     C = A+sB  [Sorted version: A, B, C sorted]   c c apmbt  :   Computes     C = A +/- transp(B)                          c c aplsbt :   Computes     C = A + s * transp(B)                        c c diamua :   Computes     C = Diag * A                                 c c amudia :   Computes     C = A* Diag                                  c c aplsca :   Computes     A:= A + s I    (s = scalar)                  c c apldia :   Computes     C = A + Diag.                                c c----------------------------------------------------------------------c c Note: this module still incomplete.                                  c c----------------------------------------------------------------------c subroutine amub ( nrow , ncol , job , a , ja , ia , b , jb , ib , * c , jc , ic , nzmax , iw , ierr ) implicit none integer nrow , ncol , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ) integer job , ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( * ), ic ( * ), iw ( ncol ) c----------------------------------------------------------------------- c performs the matrix by matrix product C = A B c----------------------------------------------------------------------- c on entry: c --------- c nrow  = integer. The row dimension of A = row dimension of C c ncol  = integer. The column dimension of B = column dimension of C c job   = integer. Job indicator. When job = 0, only the structure c                  (i.e. the arrays jc, ic) is computed and the c                  real values are ignored c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c b, c jb, c ib    =  Matrix B in compressed sparse row format. c c nzmax = integer. The  length of the arrays c and jc. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic    = resulting matrix C in compressed sparse row sparse format. c c ierr  = integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c work arrays: c------------ c iw    = integer work array of length equal to the number of c         columns in A. c Note: c------- c   The row dimension of B is not needed. However there is no checking c   on the condition that ncol(A) = nrow(B). c c----------------------------------------------------------------------- real * 8 scal logical values integer len , ii , j , ka , kb , jj , jcol , jpos , k values = ( job . ne . 0 ) len = 0 ic ( 1 ) = 1 ierr = 0 c     initialize array iw. do 1 j = 1 , ncol iw ( j ) = 0 1 continue c do 500 ii = 1 , nrow c     row i do 200 ka = ia ( ii ), ia ( ii + 1 ) - 1 if ( values ) scal = a ( ka ) jj = ja ( ka ) do 100 kb = ib ( jj ), ib ( jj + 1 ) - 1 jcol = jb ( kb ) jpos = iw ( jcol ) if ( jpos . eq . 0 ) then len = len + 1 if ( len . gt . nzmax ) then ierr = ii return endif jc ( len ) = jcol iw ( jcol ) = len if ( values ) c ( len ) = scal * b ( kb ) else if ( values ) c ( jpos ) = c ( jpos ) + scal * b ( kb ) endif 100 continue 200 continue do 201 k = ic ( ii ), len iw ( jc ( k )) = 0 201 continue ic ( ii + 1 ) = len + 1 500 continue return c-------------end-of-amub----------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplb ( nrow , ncol , job , a , ja , ia , b , jb , ib , * c , jc , ic , nzmax , iw , ierr ) implicit none integer nrow , ncol , ierr , job , nzmax real * 8 a ( * ), b ( * ), c ( * ) integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ic ( nrow + 1 ), * iw ( ncol ) c----------------------------------------------------------------------- c performs the matrix sum  C = A+B. c----------------------------------------------------------------------- c on entry: c --------- c nrow     = integer. The row dimension of A and B c ncol  = integer. The column dimension of A and B. c job   = integer. Job indicator. When job = 0, only the structure c                  (i.e. the arrays jc, ic) is computed and the c                  real values are ignored. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c b, c jb, c ib     =  Matrix B in compressed sparse row format. c c nzmax\t= integer. The  length of the arrays c and jc. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row sparse format. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c work arrays: c------------ c iw\t= integer work array of length equal to the number of c         columns in A. c c----------------------------------------------------------------------- logical values integer len , j , ii , ka , jcol , kb , jpos , k values = ( job . ne . 0 ) ierr = 0 len = 0 ic ( 1 ) = 1 do 1 j = 1 , ncol iw ( j ) = 0 1 continue c do 500 ii = 1 , nrow c     row i do 200 ka = ia ( ii ), ia ( ii + 1 ) - 1 len = len + 1 jcol = ja ( ka ) if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol if ( values ) c ( len ) = a ( ka ) iw ( jcol ) = len 200 continue c do 300 kb = ib ( ii ), ib ( ii + 1 ) - 1 jcol = jb ( kb ) jpos = iw ( jcol ) if ( jpos . eq . 0 ) then len = len + 1 if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol if ( values ) c ( len ) = b ( kb ) iw ( jcol ) = len else if ( values ) c ( jpos ) = c ( jpos ) + b ( kb ) endif 300 continue do 301 k = ic ( ii ), len iw ( jc ( k )) = 0 301 continue ic ( ii + 1 ) = len + 1 500 continue return 999 ierr = ii return c------------end of aplb ----------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplb1 ( nrow , ncol , job , a , ja , ia , b , jb , ib , c , jc , ic , nzmax , ierr ) implicit none integer nrow , ncol , job , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ) integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ic ( nrow + 1 ) c----------------------------------------------------------------------- c performs the matrix sum  C = A+B for matrices in sorted CSR format. c the difference with aplb  is that the resulting matrix is such that c the elements of each row are sorted with increasing column indices in c each row, provided the original matrices are sorted in the same way. c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A and B c ncol  = integer. The column dimension of A and B. c job   = integer. Job indicator. When job = 0, only the structure c                  (i.e. the arrays jc, ic) is computed and the c                  real values are ignored. c c a, c ja, c ia   = Matrix A in compressed sparse row format with entries sorted c c b, c jb, c ib\t=  Matrix B in compressed sparse row format with entries sorted c        ascendly in each row c c nzmax\t= integer. The  length of the arrays c and jc. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row sparse format c         with entries sorted ascendly in each row. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c Notes: c------- c     this will not work if any of the two input matrices is not sorted c----------------------------------------------------------------------- logical values integer i , ka , kb , kc , kamax , kbmax , j1 , j2 values = ( job . ne . 0 ) ierr = 0 kc = 1 ic ( 1 ) = kc c do 6 i = 1 , nrow ka = ia ( i ) kb = ib ( i ) kamax = ia ( i + 1 ) - 1 kbmax = ib ( i + 1 ) - 1 5 continue if ( ka . le . kamax ) then j1 = ja ( ka ) else j1 = ncol + 1 endif if ( kb . le . kbmax ) then j2 = jb ( kb ) else j2 = ncol + 1 endif c c     three cases c if ( kc . gt . nzmax ) goto 999 if ( j1 . eq . j2 ) then if ( values ) c ( kc ) = a ( ka ) + b ( kb ) jc ( kc ) = j1 ka = ka + 1 kb = kb + 1 kc = kc + 1 else if ( j1 . lt . j2 ) then jc ( kc ) = j1 if ( values ) c ( kc ) = a ( ka ) ka = ka + 1 kc = kc + 1 else if ( j1 . gt . j2 ) then jc ( kc ) = j2 if ( values ) c ( kc ) = b ( kb ) kb = kb + 1 kc = kc + 1 endif if ( ka . le . kamax . or . kb . le . kbmax ) goto 5 ic ( i + 1 ) = kc 6 continue return 999 ierr = i return c------------end-of-aplb1----------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplsb ( nrow , ncol , a , ja , ia , s , b , jb , ib , c , jc , ic , nzmax , * iw , ierr ) implicit none integer nrow , ncol , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ), s integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ic ( nrow + 1 ), * iw ( ncol ) c----------------------------------------------------------------------- c performs the matrix sum  C = A+s*B. c----------------------------------------------------------------------- c on entry: c --------- c nrow     = integer. The row dimension of A and B c ncol  = integer. The column dimension of A and B. c job   = integer. Job indicator. When job = 0, only the structure c                  (i.e. the arrays jc, ic) is computed and the c                  real values are ignored. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c s    = real*8 - coefficient that multiplies B. c b, c jb, c ib     =  Matrix B in compressed sparse row format. c c nzmax\t= integer. The  length of the arrays c and jc. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row sparse format. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that aplsb1 stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c work arrays: c------------ c iw\t= integer work array of length equal to the number of c         columns in A. c note: expanded  row implementation. Does not require column indices to c       be sorted. c----------------------------------------------------------------------- integer len , j , ii , ka , jcol , kb , jpos , k ierr = 0 len = 0 ic ( 1 ) = 1 do 1 j = 1 , ncol iw ( j ) = 0 1 continue c do 500 ii = 1 , nrow c     copy row ii  to C do 200 ka = ia ( ii ), ia ( ii + 1 ) - 1 len = len + 1 jcol = ja ( ka ) if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol c ( len ) = a ( ka ) iw ( jcol ) = len 200 continue c do 300 kb = ib ( ii ), ib ( ii + 1 ) - 1 jcol = jb ( kb ) jpos = iw ( jcol ) if ( jpos . eq . 0 ) then len = len + 1 if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol c ( len ) = s * b ( kb ) iw ( jcol ) = len else c ( jpos ) = c ( jpos ) + s * b ( kb ) endif 300 continue do 301 k = ic ( ii ), len iw ( jc ( k )) = 0 301 continue ic ( ii + 1 ) = len + 1 500 continue return 999 ierr = ii return c------------end of aplsb ---------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplsb1 ( nrow , ncol , a , ja , ia , s , b , jb , ib , c , jc , ic , * nzmax , ierr ) implicit none integer nrow , ncol , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ), s integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ic ( nrow + 1 ) c----------------------------------------------------------------------- c performs the operation C = A+s B for matrices in sorted CSR format. c the difference with aplsb is that the resulting matrix is such that c the elements of each row are sorted with increasing column indices in c each row, provided the original matrices are sorted in the same way. c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A and B c ncol  = integer. The column dimension of A and B. c c a, c ja, c ia   = Matrix A in compressed sparse row format with entries sorted c c s\t= real. scalar factor for B. c c b, c jb, c ib\t=  Matrix B in compressed sparse row format with entries sorted c        ascendly in each row c c nzmax\t= integer. The  length of the arrays c and jc. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row sparse format c         with entries sorted ascendly in each row. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c Notes: c------- c     this will not work if any of the two input matrices is not sorted c----------------------------------------------------------------------- integer i , ka , kb , kc , kamax , kbmax , j1 , j2 ierr = 0 kc = 1 ic ( 1 ) = kc c c     the following loop does a merge of two sparse rows + adds  them. c do 6 i = 1 , nrow ka = ia ( i ) kb = ib ( i ) kamax = ia ( i + 1 ) - 1 kbmax = ib ( i + 1 ) - 1 5 continue c c     this is a while  -- do loop -- c if ( ka . le . kamax . or . kb . le . kbmax ) then c if ( ka . le . kamax ) then j1 = ja ( ka ) else c     take j1 large enough  that always j2 .lt. j1 j1 = ncol + 1 endif if ( kb . le . kbmax ) then j2 = jb ( kb ) else c     similarly take j2 large enough  that always j1 .lt. j2 j2 = ncol + 1 endif c c     three cases c if ( j1 . eq . j2 ) then c ( kc ) = a ( ka ) + s * b ( kb ) jc ( kc ) = j1 ka = ka + 1 kb = kb + 1 kc = kc + 1 else if ( j1 . lt . j2 ) then jc ( kc ) = j1 c ( kc ) = a ( ka ) ka = ka + 1 kc = kc + 1 else if ( j1 . gt . j2 ) then jc ( kc ) = j2 c ( kc ) = s * b ( kb ) kb = kb + 1 kc = kc + 1 endif if ( kc . gt . nzmax ) goto 999 goto 5 c c     end while loop c endif ic ( i + 1 ) = kc 6 continue return 999 ierr = i return c------------end-of-aplsb1 --------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine apmbt ( nrow , ncol , job , a , ja , ia , b , jb , ib , * c , jc , ic , nzmax , iw , ierr ) implicit none integer nrow , ncol , job , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ) integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( ncol + 1 ), ic ( * ), iw ( * ) c----------------------------------------------------------------------- c performs the matrix sum  C = A + transp(B) or C = A - transp(B) c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A and transp(B) c ncol  = integer. The column dimension of A. Also the row c                  dimension of B. c c job\t= integer. if job = -1, apmbt will compute C= A - transp(B) c         (structure + values) c         if (job .eq. 1)  it will compute C=A+transp(A) c         (structure+ values) c         if (job .eq. 0) it will compute the structure of c         C= A+/-transp(B) only (ignoring all real values). c         any other value of job will be treated as  job=1 c a, c ja, c ia    = Matrix A in compressed sparse row format. c c b, c jb, c ib\t=  Matrix B in compressed sparse row format. c c nzmax\t= integer. The  length of the arrays c, jc, and ic. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row format. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return. c         ierr = -1 means that nzmax was .lt. either the number of c         nonzero elements of A or the number of nonzero elements in B. c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c work arrays: c------------ c iw\t= integer work array of length at least max(ncol,nrow) c c Notes: c------- It is important to note that here all of three arrays c, ic, c        and jc are assumed to be of length nnz(c). This is because c        the matrix is internally converted in coordinate format. c c----------------------------------------------------------------------- logical values integer j , nnza , nnzb , len , ljob , ipos , k , ii , ka , jcol , jpos , i values = ( job . ne . 0 ) c ierr = 0 do 1 j = 1 , ncol iw ( j ) = 0 1 continue c nnza = ia ( nrow + 1 ) - 1 nnzb = ib ( ncol + 1 ) - 1 len = nnzb if ( nzmax . lt . nnzb . or . nzmax . lt . nnza ) then ierr = - 1 return endif c c trasnpose matrix b into c c ljob = 0 if ( values ) ljob = 1 ipos = 1 call csrcsc ( ncol , ljob , ipos , b , jb , ib , c , jc , ic ) c----------------------------------------------------------------------- if ( job . eq . - 1 ) then do 2 k = 1 , len c ( k ) = - c ( k ) 2 continue endif c c--------------- main loop -------------------------------------------- c do 500 ii = 1 , nrow do 200 k = ic ( ii ), ic ( ii + 1 ) - 1 iw ( jc ( k )) = k 200 continue c----------------------------------------------------------------------- do 300 ka = ia ( ii ), ia ( ii + 1 ) - 1 jcol = ja ( ka ) jpos = iw ( jcol ) if ( jpos . eq . 0 ) then c c     if fill-in append in coordinate format to matrix. c len = len + 1 if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol ic ( len ) = ii if ( values ) c ( len ) = a ( ka ) else c     else do addition. if ( values ) c ( jpos ) = c ( jpos ) + a ( ka ) endif 300 continue do 301 k = ic ( ii ), ic ( ii + 1 ) - 1 iw ( jc ( k )) = 0 301 continue 500 continue c c     convert first part of matrix (without fill-ins) into coo format c ljob = 2 if ( values ) ljob = 3 do 501 i = 1 , nrow + 1 iw ( i ) = ic ( i ) 501 continue call csrcoo ( nrow , ljob , nnzb , c , jc , iw , nnzb , c , ic , jc , ierr ) c c     convert the whole thing back to csr format. c ljob = 0 if ( values ) ljob = 1 call coicsr ( nrow , len , ljob , c , jc , ic , iw ) return 999 ierr = ii return c--------end-of-apmbt--------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplsbt ( nrow , ncol , a , ja , ia , s , b , jb , ib , * c , jc , ic , nzmax , iw , ierr ) implicit none integer nrow , ncol , nzmax , ierr real * 8 a ( * ), b ( * ), c ( * ), s integer ja ( * ), jb ( * ), jc ( * ), ia ( nrow + 1 ), ib ( ncol + 1 ), ic ( * ), iw ( * ) c----------------------------------------------------------------------- c performs the matrix sum  C = A + transp(B). c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A and transp(B) c ncol  = integer. The column dimension of A. Also the row c                  dimension of B. c c a, c ja, c ia    = Matrix A in compressed sparse row format. c c s\t= real. scalar factor for B. c c c b, c jb, c ib\t=  Matrix B in compressed sparse row format. c c nzmax\t= integer. The  length of the arrays c, jc, and ic. c         amub will stop if the result matrix C  has a number c         of elements that exceeds exceeds nzmax. See ierr. c c on return: c---------- c c, c jc, c ic\t= resulting matrix C in compressed sparse row format. c c ierr\t= integer. serving as error message. c         ierr = 0 means normal return. c         ierr = -1 means that nzmax was .lt. either the number of c         nonzero elements of A or the number of nonzero elements in B. c         ierr .gt. 0 means that amub stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c work arrays: c------------ c iw\t= integer work array of length at least max(nrow,ncol) c c Notes: c------- It is important to note that here all of three arrays c, ic, c        and jc are assumed to be of length nnz(c). This is because c        the matrix is internally converted in coordinate format. c c----------------------------------------------------------------------- integer j , nnza , nnzb , len , ljob , ipos , k , ii , ka , jcol , jpos , i ierr = 0 do 1 j = 1 , ncol iw ( j ) = 0 1 continue c nnza = ia ( nrow + 1 ) - 1 nnzb = ib ( ncol + 1 ) - 1 len = nnzb if ( nzmax . lt . nnzb . or . nzmax . lt . nnza ) then ierr = - 1 return endif c c     transpose matrix b into c c ljob = 1 ipos = 1 call csrcsc ( ncol , ljob , ipos , b , jb , ib , c , jc , ic ) do 2 k = 1 , len 2 c ( k ) = c ( k ) * s c c     main loop. add rows from ii = 1 to nrow. c do 500 ii = 1 , nrow c     iw is used as a system to recognize whether there c     was a nonzero element in c. do 200 k = ic ( ii ), ic ( ii + 1 ) - 1 iw ( jc ( k )) = k 200 continue c do 300 ka = ia ( ii ), ia ( ii + 1 ) - 1 jcol = ja ( ka ) jpos = iw ( jcol ) if ( jpos . eq . 0 ) then c c     if fill-in append in coordinate format to matrix. c len = len + 1 if ( len . gt . nzmax ) goto 999 jc ( len ) = jcol ic ( len ) = ii c ( len ) = a ( ka ) else c     else do addition. c ( jpos ) = c ( jpos ) + a ( ka ) endif 300 continue do 301 k = ic ( ii ), ic ( ii + 1 ) - 1 iw ( jc ( k )) = 0 301 continue 500 continue c c     convert first part of matrix (without fill-ins) into coo format c ljob = 3 do 501 i = 1 , nrow + 1 iw ( i ) = ic ( i ) 501 continue call csrcoo ( nrow , ljob , nnzb , c , jc , iw , nnzb , c , ic , jc , ierr ) c c     convert the whole thing back to csr format. c ljob = 1 call coicsr ( nrow , len , ljob , c , jc , ic , iw ) return 999 ierr = ii return c--------end-of-aplsbt-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine diamua ( nrow , job , a , ja , ia , diag , b , jb , ib ) implicit none integer nrow , job real * 8 a ( * ), b ( * ), diag ( nrow ), scal integer ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ) c----------------------------------------------------------------------- c performs the matrix by matrix product B = Diag * A  (in place) c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c job   = integer. job indicator. Job=0 means get array b only c         job = 1 means get b, and the integer arrays ib, jb. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c diag = diagonal matrix stored as a vector dig(1:n) c c on return: c---------- c c b, c jb, c ib\t= resulting matrix B in compressed sparse row sparse format. c c Notes: c------- c 1)        The column dimension of A is not needed. c 2)        algorithm in place (B can take the place of A). c           in this case use job=0. c----------------------------------------------------------------- integer ii , k1 , k2 , k do 1 ii = 1 , nrow c c     normalize each row c k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 scal = diag ( ii ) do 2 k = k1 , k2 b ( k ) = a ( k ) * scal 2 continue 1 continue c if ( job . eq . 0 ) return c do 3 ii = 1 , nrow + 1 ib ( ii ) = ia ( ii ) 3 continue do 31 k = ia ( 1 ), ia ( nrow + 1 ) - 1 jb ( k ) = ja ( k ) 31 continue return c----------end-of-diamua------------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amudia ( nrow , job , a , ja , ia , diag , b , jb , ib ) implicit none integer nrow , job real * 8 a ( * ), b ( * ), diag ( nrow ) integer ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ) c----------------------------------------------------------------------- c performs the matrix by matrix product B = A * Diag  (in place) c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c job   = integer. job indicator. Job=0 means get array b only c         job = 1 means get b, and the integer arrays ib, jb. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c diag = diagonal matrix stored as a vector dig(1:n) c c on return: c---------- c c b, c jb, c ib\t= resulting matrix B in compressed sparse row sparse format. c c Notes: c------- c 1)        The column dimension of A is not needed. c 2)        algorithm in place (B can take the place of A). c----------------------------------------------------------------- integer ii , k1 , k2 , k do 1 ii = 1 , nrow c c     scale each element c k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 do 2 k = k1 , k2 b ( k ) = a ( k ) * diag ( ja ( k )) 2 continue 1 continue c if ( job . eq . 0 ) return c do 3 ii = 1 , nrow + 1 ib ( ii ) = ia ( ii ) 3 continue do 31 k = ia ( 1 ), ia ( nrow + 1 ) - 1 jb ( k ) = ja ( k ) 31 continue return c----------------------------------------------------------------------- c-----------end-of-amudiag---------------------------------------------- end c----------------------------------------------------------------------- subroutine aplsca ( nrow , a , ja , ia , scal , iw ) implicit none integer nrow real * 8 a ( * ), scal integer ja ( * ), ia ( nrow + 1 ), iw ( * ) c----------------------------------------------------------------------- c Adds a scalar to the diagonal entries of a sparse matrix A :=A + s I c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c a, c ja, c ia    = Matrix A in compressed sparse row format. c c scal  = real. scalar to add to the diagonal entries. c c on return: c---------- c c a, c ja, c ia\t= matrix A with diagonal elements shifted (or created). c c iw    = integer work array of length n. On return iw will c         contain  the positions of the diagonal entries in the c         output matrix. (i.e., a(iw(k)), ja(iw(k)), k=1,...n, c         are the values/column indices of the diagonal elements c         of the output matrix. ). c c Notes: c------- c     The column dimension of A is not needed. c     important: the matrix a may be expanded slightly to allow for c     additions of nonzero elements to previously nonexisting diagonals. c     The is no checking as to whether there is enough space appended c     to the arrays a and ja. if not sure allow for n additional c     elemnts. c     coded by Y. Saad. Latest version July, 19, 1990 c----------------------------------------------------------------------- logical test integer j , icount , ko , ii , k , k1 , k2 c call diapos ( nrow , ja , ia , iw ) icount = 0 do 1 j = 1 , nrow if ( iw ( j ) . eq . 0 ) then icount = icount + 1 else a ( iw ( j )) = a ( iw ( j )) + scal endif 1 continue c c     if no diagonal elements to insert in data structure return. c if ( icount . eq . 0 ) return c c shift the nonzero elements if needed, to allow for created c diagonal elements. c ko = ia ( nrow + 1 ) + icount c c     copy rows backward c do 5 ii = nrow , 1 , - 1 c c     go through  row ii c k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 ia ( ii + 1 ) = ko test = ( iw ( ii ) . eq . 0 ) do 4 k = k2 , k1 , - 1 j = ja ( k ) if ( test . and . ( j . lt . ii )) then test = . false . ko = ko - 1 a ( ko ) = scal ja ( ko ) = ii iw ( ii ) = ko endif ko = ko - 1 a ( ko ) = a ( k ) ja ( ko ) = j 4 continue c     diagonal element has not been added yet. if ( test ) then ko = ko - 1 a ( ko ) = scal ja ( ko ) = ii iw ( ii ) = ko endif 5 continue ia ( 1 ) = ko return c----------------------------------------------------------------------- c----------end-of-aplsca------------------------------------------------ end c----------------------------------------------------------------------- subroutine apldia ( nrow , job , a , ja , ia , diag , b , jb , ib , iw ) implicit none integer nrow , job real * 8 a ( * ), b ( * ), diag ( nrow ) integer ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), iw ( * ) c----------------------------------------------------------------------- c Adds a diagonal matrix to a general sparse matrix:  B = A + Diag c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c job   = integer. job indicator. Job=0 means get array b only c         (i.e. assume that a has already been copied into array b, c         or that algorithm is used in place. ) For all practical c         purposes enter job=0 for an in-place call and job=1 otherwise c c         Note: in case there are missing diagonal elements in A, c         then the option job =0 will be ignored, since the algorithm c         must modify the data structure (i.e. jb, ib) in this c         situation. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c diag = diagonal matrix stored as a vector dig(1:n) c c on return: c---------- c c b, c jb, c ib\t= resulting matrix B in compressed sparse row sparse format. c c c iw    = integer work array of length n. On return iw will c         contain  the positions of the diagonal entries in the c         output matrix. (i.e., a(iw(k)), ja(iw(k)), k=1,...n, c         are the values/column indices of the diagonal elements c         of the output matrix. ). c c Notes: c------- c 1)        The column dimension of A is not needed. c 2)        algorithm in place (b, jb, ib, can be the same as c           a, ja, ia, on entry). See comments for parameter job. c c coded by Y. Saad. Latest version July, 19, 1990 c----------------------------------------------------------------- logical test integer nnz , k , icount , j , ko , ii , k1 , k2 c c     copy integer arrays into b's data structure if required c if ( job . ne . 0 ) then nnz = ia ( nrow + 1 ) - 1 do 2 k = 1 , nnz jb ( k ) = ja ( k ) b ( k ) = a ( k ) 2 continue do 3 k = 1 , nrow + 1 ib ( k ) = ia ( k ) 3 continue endif c c     get positions of diagonal elements in data structure. c call diapos ( nrow , ja , ia , iw ) c c     count number of holes in diagonal and add diag(*) elements to c     valid diagonal entries. c icount = 0 do 1 j = 1 , nrow if ( iw ( j ) . eq . 0 ) then icount = icount + 1 else b ( iw ( j )) = a ( iw ( j )) + diag ( j ) endif 1 continue c c     if no diagonal elements to insert return c if ( icount . eq . 0 ) return c c     shift the nonzero elements if needed, to allow for created c     diagonal elements. c ko = ib ( nrow + 1 ) + icount c c     copy rows backward c do 5 ii = nrow , 1 , - 1 c c     go through  row ii c k1 = ib ( ii ) k2 = ib ( ii + 1 ) - 1 ib ( ii + 1 ) = ko test = ( iw ( ii ) . eq . 0 ) do 4 k = k2 , k1 , - 1 j = jb ( k ) if ( test . and . ( j . lt . ii )) then test = . false . ko = ko - 1 b ( ko ) = diag ( ii ) jb ( ko ) = ii iw ( ii ) = ko endif ko = ko - 1 b ( ko ) = a ( k ) jb ( ko ) = j 4 continue c     diagonal element has not been added yet. if ( test ) then ko = ko - 1 b ( ko ) = diag ( ii ) jb ( ko ) = ii iw ( ii ) = ko endif 5 continue ib ( 1 ) = ko return c----------------------------------------------------------------------- c------------end-of-apldiag--------------------------------------------- end","tags":"","loc":"sourcefile\\blassm.f.html"},{"title":"distdot.f – LINALG","text":"Contents Functions distdot Source Code distdot.f Source Code C DISDOT - Re-implementation of DDOT required for ITERS.F solvers. double precision function distdot ( n , x , ix , y , iy ) implicit none integer n , ix , iy real * 8 x ( * ), y ( * ) real * 8 ddot external ddot distdot = ddot ( n , x , ix , y , iy ) end function","tags":"","loc":"sourcefile\\distdot.f.html"},{"title":"formats.f – LINALG","text":"Contents Subroutines csrdns dnscsr coocsr coicsr csrcoo csrssr ssrcsr xssrcsr csrell ellcsr csrmsr msrcsr csrcsc csrcsc2 csrlnk lnkcsr csrdia diacsr bsrcsr csrbsr csrbnd bndcsr csrssk sskssr csrjad jadcsr dcsort cooell xcooell csruss usscsr csrsss ssscsr csrvbr vbrcsr csorted Source Code formats.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c                    FORMAT CONVERSION MODULE                          c c----------------------------------------------------------------------c c contents:                                                            c c----------                                                            c c csrdns  : converts a row-stored sparse matrix into the dense format. c c dnscsr  : converts a dense matrix to a sparse storage format.        c c coocsr  : converts coordinate to  to csr format                      c c coicsr  : in-place conversion of coordinate to csr format            c c csrcoo  : converts compressed sparse row to coordinate.              c c csrssr  : converts compressed sparse row to symmetric sparse row     c c ssrcsr  : converts symmetric sparse row to compressed sparse row     c c csrell  : converts compressed sparse row to ellpack format           c c ellcsr  : converts ellpack format to compressed sparse row format    c c csrmsr  : converts compressed sparse row format to modified sparse   c c           row format                                                 c c msrcsr  : converts modified sparse row format to compressed sparse   c c           row format.                                                c c csrcsc  : converts compressed sparse row format to compressed sparse c c           column format (transposition)                              c c csrcsc2 : rectangular version of csrcsc                              c c csrlnk  : converts compressed sparse row to linked list format       c c lnkcsr  : converts linked list format to compressed sparse row fmt   c c csrdia  : converts a compressed sparse row format into a diagonal    c c           format.                                                    c c diacsr  : converts a diagonal format into a compressed sparse row    c c           format.                                                    c c bsrcsr  : converts a block-row sparse format into a compressed       c c           sparse row format.                                         c c csrbsr  : converts a compressed sparse row format into a block-row   c c           sparse format.                                             c c csrbnd  : converts a compressed sparse row format into a banded      c c           format (linpack style).                                    c c bndcsr  : converts a banded format (linpack style) into a compressed c c           sparse row storage.                                        c c csrssk  : converts the compressed sparse row format to the symmetric c c           skyline format                                             c c sskssr  : converts symmetric skyline format to symmetric  sparse row c c           format.                                                    c c csrjad  : converts the csr format into the jagged diagonal format    c c jadcsr  : converts the jagged-diagonal format into the csr format    c c csruss  : Compressed Sparse Row to Unsymmetric Sparse Skyline        c c           format                                                     c c usscsr  : Unsymmetric Sparse Skyline format to Compressed Sparse Row c c csrsss  : Compressed Sparse Row to Symmetric Sparse Skyline format   c c ssscsr  : Symmetric Sparse Skyline format to Compressed Sparse Row   c c csrvbr  : Converts compressed sparse row to var block row format     c c vbrcsr  : Converts var block row to compressed sparse row format     c c csorted : Checks if matrix in CSR format is sorted by columns        c c--------- miscalleneous additions not involving the csr format--------c c cooell  : converts coordinate to Ellpack/Itpack format               c c dcsort  : sorting routine used by crsjad                             c c----------------------------------------------------------------------c subroutine csrdns ( nrow , ncol , a , ja , ia , dns , ndns , ierr ) implicit none integer nrow , ncol , ndns , ja ( * ), ia ( * ), ierr real * 8 dns ( ndns , * ), a ( * ) c----------------------------------------------------------------------- c Compressed Sparse Row    to    Dense c----------------------------------------------------------------------- c c converts a row-stored sparse matrix into a densely stored one c c On entry: c---------- c c nrow\t= row-dimension of a c ncol\t= column dimension of a c a, c ja, c ia    = input matrix in compressed sparse row format. c         (a=value array, ja=column array, ia=pointer array) c dns   = array where to store dense matrix c ndns\t= first dimension of array dns c c on return: c----------- c dns   = the sparse matrix a, ja, ia has been stored in dns(ndns,*) c c ierr  = integer error indicator. c         ierr .eq. 0  means normal return c         ierr .eq. i  means that the code has stopped when processing c         row number i, because it found a column number .gt. ncol. c c----------------------------------------------------------------------- integer i , j , k ierr = 0 do 1 i = 1 , nrow do 2 j = 1 , ncol dns ( i , j ) = 0.0d0 2 continue 1 continue c do 4 i = 1 , nrow do 3 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) if ( j . gt . ncol ) then ierr = i return endif dns ( i , j ) = a ( k ) 3 continue 4 continue return c---- end of csrdns ---------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine dnscsr ( nrow , ncol , nzmax , dns , ndns , a , ja , ia , ierr ) implicit none integer nrow , ncol , nzmax , ndns , ierr real * 8 dns ( ndns , * ), a ( * ) integer ia ( * ), ja ( * ) c----------------------------------------------------------------------- c Dense\t\tto    Compressed Row Sparse c----------------------------------------------------------------------- c c converts a densely stored matrix into a row orientied c compactly sparse matrix. ( reverse of csrdns ) c Note: this routine does not check whether an element c is small. It considers that a(i,j) is zero if it is exactly c equal to zero: see test below. c----------------------------------------------------------------------- c on entry: c--------- c c nrow\t= row-dimension of a c ncol\t= column dimension of a c nzmax = maximum number of nonzero elements allowed. This c         should be set to be the lengths of the arrays a and ja. c dns   = input nrow x ncol (dense) matrix. c ndns\t= first dimension of dns. c c on return: c---------- c c a, ja, ia = value, column, pointer  arrays for output matrix c c ierr\t= integer error indicator: c         ierr .eq. 0 means normal retur c         ierr .eq. i means that the the code stopped while c         processing row number i, because there was no space left in c         a, and ja (as defined by parameter nzmax). c----------------------------------------------------------------------- integer next , i , j ierr = 0 next = 1 ia ( 1 ) = 1 do 4 i = 1 , nrow do 3 j = 1 , ncol if ( dns ( i , j ) . eq . 0.0d0 ) goto 3 if ( next . gt . nzmax ) then ierr = i return endif ja ( next ) = j a ( next ) = dns ( i , j ) next = next + 1 3 continue ia ( i + 1 ) = next 4 continue return c---- end of dnscsr ---------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine coocsr ( nrow , nnz , a , ir , jc , ao , jao , iao ) c----------------------------------------------------------------------- implicit none integer nrow , nnz real * 8 a ( * ), ao ( * ), x integer ir ( * ), jc ( * ), jao ( * ), iao ( * ) c----------------------------------------------------------------------- c  Coordinate     to   Compressed Sparse Row c----------------------------------------------------------------------- c converts a matrix that is stored in coordinate format c  a, ir, jc into a row general sparse ao, jao, iao format. c c on entry: c--------- c nrow\t= dimension of the matrix c nnz\t= number of nonzero elements in matrix c a, c ir, c jc    = matrix in coordinate format. a(k), ir(k), jc(k) store the nnz c         nonzero elements of the matrix with a(k) = actual real value of c \t  the elements, ir(k) = its row number and jc(k) = its column c\t  number. The order of the elements is arbitrary. c c on return: c----------- c ir \tis destroyed c c ao, jao, iao = matrix in general sparse matrix format with ao c \tcontinung the real values, jao containing the column indices, c\tand iao being the pointer to the beginning of the row, c\tin arrays ao, jao. c c Notes: c------ This routine is NOT in place.  See coicsr c       On return the entries  of each row are NOT sorted by increasing c       column number c c------------------------------------------------------------------------ integer k , j , k0 , i , iad do 1 k = 1 , nrow + 1 iao ( k ) = 0 1 continue c determine row-lengths. do 2 k = 1 , nnz iao ( ir ( k )) = iao ( ir ( k )) + 1 2 continue c starting position of each row.. k = 1 do 3 j = 1 , nrow + 1 k0 = iao ( j ) iao ( j ) = k k = k + k0 3 continue c go through the structure  once more. Fill in output matrix. do 4 k = 1 , nnz i = ir ( k ) j = jc ( k ) x = a ( k ) iad = iao ( i ) ao ( iad ) = x jao ( iad ) = j iao ( i ) = iad + 1 4 continue c shift back iao do 5 j = nrow , 1 , - 1 iao ( j + 1 ) = iao ( j ) 5 continue iao ( 1 ) = 1 return c------------- end of coocsr ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine coicsr ( n , nnz , job , a , ja , ia , iwk ) implicit none integer n , nnz , ia ( * ), ja ( nnz ), iwk ( n + 1 ), job real * 8 a ( * ) c------------------------------------------------------------------------ c IN-PLACE coo-csr conversion routine. c------------------------------------------------------------------------ c this subroutine converts a matrix stored in coordinate format into c the csr format. The conversion is done in place in that the arrays c a,ja,ia of the result are overwritten onto the original arrays. c------------------------------------------------------------------------ c on entry: c--------- c n\t= integer. row dimension of A. c nnz\t= integer. number of nonzero elements in A. c job   = integer. Job indicator. when job=1, the real values in a are c         filled. Otherwise a is not touched and the structure of the c         array only (i.e. ja, ia)  is obtained. c a\t= real array of size nnz (number of nonzero elements in A) c         containing the nonzero elements c ja\t= integer array of length nnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer array of length max(nnz,n+1) containing the row c \t  positions of the corresponding elements in a. c iwk\t= integer work array of length n+1 c on return: c---------- c a c ja c ia\t= contains the compressed sparse row data structure for the c         resulting matrix. c Note: c------- c         the entries of the output matrix are not sorted (the column c         indices in each are not in increasing order) use coocsr c         if you want them sorted. Note also that ia has to have at c         least n+1 locations c----------------------------------------------------------------------c c  Coded by Y. Saad, Sep. 26 1989                                      c c----------------------------------------------------------------------c real * 8 t , tnext logical values integer i , k , init , j , ipos , inext , jnext c----------------------------------------------------------------------- t = 0.0 tnext = 0.0 values = ( job . eq . 1 ) c find pointer array for resulting matrix. do 35 i = 1 , n + 1 iwk ( i ) = 0 35 continue do 4 k = 1 , nnz i = ia ( k ) iwk ( i + 1 ) = iwk ( i + 1 ) + 1 4 continue c------------------------------------------------------------------------ iwk ( 1 ) = 1 do 44 i = 2 , n iwk ( i ) = iwk ( i - 1 ) + iwk ( i ) 44 continue c c     loop for a cycle in chasing process. c init = 1 k = 0 5 if ( values ) t = a ( init ) i = ia ( init ) j = ja ( init ) ia ( init ) = - 1 c------------------------------------------------------------------------ 6 k = k + 1 c     current row number is i.  determine  where to go. ipos = iwk ( i ) c     save the chased element. if ( values ) tnext = a ( ipos ) inext = ia ( ipos ) jnext = ja ( ipos ) c     then occupy its location. if ( values ) a ( ipos ) = t ja ( ipos ) = j c     update pointer information for next element to come in row i. iwk ( i ) = ipos + 1 c     determine  next element to be chased, if ( ia ( ipos ) . lt . 0 ) goto 65 t = tnext i = inext j = jnext ia ( ipos ) = - 1 if ( k . lt . nnz ) goto 6 goto 70 65 init = init + 1 if ( init . gt . nnz ) goto 70 if ( ia ( init ) . lt . 0 ) goto 65 c     restart chasing -- goto 5 70 do 80 i = 1 , n ia ( i + 1 ) = iwk ( i ) 80 continue ia ( 1 ) = 1 return c----------------- end of coicsr ---------------------------------------- c------------------------------------------------------------------------ end c----------------------------------------------------------------------- subroutine csrcoo ( nrow , job , nzmax , a , ja , ia , nnz , ao , ir , jc , ierr ) c----------------------------------------------------------------------- implicit none integer nrow , job , nzmax , nnz , ierr real * 8 a ( * ), ao ( * ) integer ir ( * ), jc ( * ), ja ( * ), ia ( nrow + 1 ) c----------------------------------------------------------------------- c  Compressed Sparse Row      to      Coordinate c----------------------------------------------------------------------- c converts a matrix that is stored in coordinate format c  a, ir, jc into a row general sparse ao, jao, iao format. c c on entry: c--------- c nrow\t= dimension of the matrix. c job   = integer serving as a job indicator. c         if job = 1 fill in only the array ir, ignore jc, and ao. c         if job = 2 fill in ir, and jc but not ao c         if job = 3 fill in everything. c         The reason why these options are provided is that on return c         ao and jc are the same as a, ja. So when job = 3, a and ja are c         simply copied into ao, jc.  When job=2, only jc and ir are c         returned. With job=1 only the array ir is returned. Moreover, c         the algorithm is in place: c\t     call csrcoo (nrow,1,nzmax,a,ja,ia,nnz,a,ia,ja,ierr) c         will write the output matrix in coordinate format on a, ja,ia. c c a, c ja, c ia    = matrix in compressed sparse row format. c nzmax = length of space available in ao, ir, jc. c         the code will stop immediatly if the number of c         nonzero elements found in input matrix exceeds nzmax. c c on return: c----------- c ao, ir, jc = matrix in coordinate format. c c nnz        = number of nonzero elements in matrix. c ierr       = integer error indicator. c         ierr .eq. 0 means normal retur c         ierr .eq. 1 means that the the code stopped c         because there was no space in ao, ir, jc c         (according to the value of  nzmax). c c NOTES: 1)This routine is PARTIALLY in place: csrcoo can be called with c         ao being the same array as as a, and jc the same array as ja. c         but ir CANNOT be the same as ia. c         2) note the order in the output arrays, c------------------------------------------------------------------------ integer k , i , k1 , k2 ierr = 0 nnz = ia ( nrow + 1 ) - 1 if ( nnz . gt . nzmax ) then ierr = 1 return endif c------------------------------------------------------------------------ goto ( 3 , 2 , 1 ) job 1 do 10 k = 1 , nnz ao ( k ) = a ( k ) 10 continue 2 do 11 k = 1 , nnz jc ( k ) = ja ( k ) 11 continue c c     copy backward to allow for in-place processing. c 3 do 13 i = nrow , 1 , - 1 k1 = ia ( i + 1 ) - 1 k2 = ia ( i ) do 12 k = k1 , k2 , - 1 ir ( k ) = i 12 continue 13 continue return c------------- end-of-csrcoo ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrssr ( nrow , a , ja , ia , nzmax , ao , jao , iao , ierr ) implicit none integer nrow , nzmax , ierr real * 8 a ( * ), ao ( * ), t integer ia ( * ), ja ( * ), iao ( * ), jao ( * ) c----------------------------------------------------------------------- c Compressed Sparse Row     to     Symmetric Sparse Row c----------------------------------------------------------------------- c this subroutine extracts the lower triangular part of a matrix. c It can used as a means for converting a symmetric matrix for c which all the entries are stored in sparse format into one c in which only the lower part is stored. The routine is in place in c that the output matrix ao, jao, iao can be overwritten on c the  input matrix  a, ja, ia if desired. Csrssr has been coded to c put the diagonal elements of the matrix in the last position in c each row (i.e. in position  ao(ia(i+1)-1   of ao and jao) c----------------------------------------------------------------------- c On entry c----------- c nrow  = dimension of the matrix a. c a, ja, c    ia = matrix stored in compressed row sparse format c c nzmax = length of arrays ao,  and jao. c c On return: c----------- c ao, jao, c     iao = lower part of input matrix (a,ja,ia) stored in compressed sparse c          row format format. c c ierr   = integer error indicator. c          ierr .eq. 0  means normal return c          ierr .eq. i  means that the code has stopped when processing c          row number i, because there is not enough space in ao, jao c          (according to the value of nzmax) c c----------------------------------------------------------------------- integer i , ko , kold , kdiag , k ierr = 0 ko = 0 c----------------------------------------------------------------------- do 7 i = 1 , nrow kold = ko kdiag = 0 do 71 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) . gt . i ) goto 71 ko = ko + 1 if ( ko . gt . nzmax ) then ierr = i return endif ao ( ko ) = a ( k ) jao ( ko ) = ja ( k ) if ( ja ( k ) . eq . i ) kdiag = ko 71 continue if ( kdiag . eq . 0 . or . kdiag . eq . ko ) goto 72 c c     exchange c t = ao ( kdiag ) ao ( kdiag ) = ao ( ko ) ao ( ko ) = t c k = jao ( kdiag ) jao ( kdiag ) = jao ( ko ) jao ( ko ) = k 72 iao ( i ) = kold + 1 7 continue c     redefine iao(n+1) iao ( nrow + 1 ) = ko + 1 return c--------- end of csrssr ----------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ssrcsr ( job , value2 , nrow , a , ja , ia , nzmax , & ao , jao , iao , indu , iwk , ierr ) implicit none c     .. Scalar Arguments .. integer ierr , job , nrow , nzmax , value2 c     .. c     .. Array Arguments .. integer ia ( nrow + 1 ), iao ( nrow + 1 ), indu ( nrow ), & iwk ( nrow + 1 ), ja ( * ), jao ( nzmax ) real * 8 a ( * ), ao ( nzmax ) c     .. c----------------------------------------------------------------------- c     Symmetric Sparse Row to Compressed Sparse Row format c----------------------------------------------------------------------- c     This subroutine converts a given matrix in SSR format to regular c     CSR format by computing Ao = A + A' - diag(A), where A' is A c     transpose. c c     Typically this routine is used to expand the SSR matrix of c     Harwell Boeing matrices, or to obtain a symmetrized graph of c     unsymmetric matrices. c c     This routine is inplace, i.e., (Ao,jao,iao) may be same as c     (a,ja,ia). c c     It is possible to input an arbitrary CSR matrix to this routine, c     since there is no syntactical difference between CSR and SSR c     format. It also removes duplicate entries and perform a partial c     ordering. The output matrix has an order of lower half, main c     diagonal and upper half after the partial ordering. c----------------------------------------------------------------------- c on entry: c--------- c c job   = options c         0 -- duplicate entries are not removed. If the input matrix is c              SSR (not an arbitary CSR) matrix, no duplicate entry should c              arise from this routine. c         1 -- eliminate duplicate entries, zero entries. c         2 -- eliminate duplicate entries and perform partial ordering. c         3 -- eliminate duplicate entries, sort the entries in the c              increasing order of clumn indices. c c value2= will the values of A be copied? c         0 -- only expand the graph (a, ao are not touched) c         1 -- expand the matrix with the values. c c nrow  = column dimension of inout matrix c a, c ia, c ja    = matrix in compressed sparse row format. c c nzmax = size of arrays ao and jao. SSRCSR will abort if the storage c          provided in ao, jao is not sufficient to store A. See ierr. c c on return: c---------- c ao, jao, iao c       = output matrix in compressed sparse row format. The resulting c         matrix is symmetric and is equal to A+A'-D. ao, jao, iao, c         can be the same as a, ja, ia in the calling sequence. c c indu  = integer array of length nrow. INDU will contain pointers c         to the beginning of upper traigular part if job > 1. c         Otherwise it is also used as a work array (size nrow). c c iwk   = integer work space (size nrow+1). c c ierr  = integer. Serving as error message. If the length of the arrays c         ao, jao exceeds nzmax, ierr returns the minimum value c         needed for nzmax. otherwise ierr=0 (normal return). c c----------------------------------------------------------------------- c     .. Local Scalars .. integer i , ipos , j , k , kfirst , klast , ko , kosav , nnz real * 8 tmp c     .. c     .. Executable Statements .. ierr = 0 do 10 i = 1 , nrow indu ( i ) = 0 iwk ( i ) = 0 10 continue iwk ( nrow + 1 ) = 0 c c     .. compute number of elements in each row of (A'-D) c     put result in iwk(i+1)  for row i. c do 30 i = 1 , nrow do 20 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) if ( j . ne . i ) & iwk ( j + 1 ) = iwk ( j + 1 ) + 1 20 continue 30 continue c c     .. find addresses of first elements of ouput matrix. result in iwk c iwk ( 1 ) = 1 do 40 i = 1 , nrow indu ( i ) = iwk ( i ) + ia ( i + 1 ) - ia ( i ) iwk ( i + 1 ) = iwk ( i + 1 ) + indu ( i ) indu ( i ) = indu ( i ) - 1 40 continue c.....Have we been given enough storage in ao, jao ? nnz = iwk ( nrow + 1 ) - 1 if ( nnz . gt . nzmax ) then ierr = nnz return endif c c     .. copy the existing matrix (backwards). c kosav = iwk ( nrow + 1 ) do 60 i = nrow , 1 , - 1 klast = ia ( i + 1 ) - 1 kfirst = ia ( i ) iao ( i + 1 ) = kosav kosav = iwk ( i ) ko = iwk ( i ) - kfirst iwk ( i ) = ko + klast + 1 do 50 k = klast , kfirst , - 1 if ( value2 . ne . 0 ) & ao ( k + ko ) = a ( k ) jao ( k + ko ) = ja ( k ) 50 continue 60 continue iao ( 1 ) = 1 c c     now copy (A'-D). Go through the structure of ao, jao, iao c     that has already been copied. iwk(i) is the address c     of the next free location in row i for ao, jao. c do 80 i = 1 , nrow do 70 k = iao ( i ), indu ( i ) j = jao ( k ) if ( j . ne . i ) then ipos = iwk ( j ) if ( value2 . ne . 0 ) & ao ( ipos ) = ao ( k ) jao ( ipos ) = i iwk ( j ) = ipos + 1 endif 70 continue 80 continue if ( job . le . 0 ) return c c     .. eliminate duplicate entries -- c     array INDU is used as marker for existing indices, it is also the c     location of the entry. c     IWK is used to stored the old IAO array. c     matrix is copied to squeeze out the space taken by the duplicated c     entries. c do 90 i = 1 , nrow indu ( i ) = 0 iwk ( i ) = iao ( i ) 90 continue iwk ( nrow + 1 ) = iao ( nrow + 1 ) k = 1 do 120 i = 1 , nrow iao ( i ) = k ipos = iwk ( i ) klast = iwk ( i + 1 ) 100 if ( ipos . lt . klast ) then j = jao ( ipos ) if ( indu ( j ). eq . 0 ) then c     .. new entry .. if ( value2 . ne . 0 ) then if ( ao ( ipos ) . ne . 0.0D0 ) then indu ( j ) = k jao ( k ) = jao ( ipos ) ao ( k ) = ao ( ipos ) k = k + 1 endif else indu ( j ) = k jao ( k ) = jao ( ipos ) k = k + 1 endif else if ( value2 . ne . 0 ) then c     .. duplicate entry .. ao ( indu ( j )) = ao ( indu ( j )) + ao ( ipos ) endif ipos = ipos + 1 go to 100 endif c     .. remove marks before working on the next row .. do 110 ipos = iao ( i ), k - 1 indu ( jao ( ipos )) = 0 110 continue 120 continue iao ( nrow + 1 ) = k if ( job . le . 1 ) return c c     .. partial ordering .. c     split the matrix into strict upper/lower triangular c     parts, INDU points to the the beginning of the strict upper part. c do 140 i = 1 , nrow klast = iao ( i + 1 ) - 1 kfirst = iao ( i ) 130 if ( klast . gt . kfirst ) then if ( jao ( klast ). lt . i . and . jao ( kfirst ). ge . i ) then c     .. swap klast with kfirst .. j = jao ( klast ) jao ( klast ) = jao ( kfirst ) jao ( kfirst ) = j if ( value2 . ne . 0 ) then tmp = ao ( klast ) ao ( klast ) = ao ( kfirst ) ao ( kfirst ) = tmp endif endif if ( jao ( klast ). ge . i ) & klast = klast - 1 if ( jao ( kfirst ). lt . i ) & kfirst = kfirst + 1 go to 130 endif c if ( jao ( klast ). lt . i ) then indu ( i ) = klast + 1 else indu ( i ) = klast endif 140 continue if ( job . le . 2 ) return c c     .. order the entries according to column indices c     bubble-sort is used c do 190 i = 1 , nrow do 160 ipos = iao ( i ), indu ( i ) - 1 do 150 j = indu ( i ) - 1 , ipos + 1 , - 1 k = j - 1 if ( jao ( k ). gt . jao ( j )) then ko = jao ( k ) jao ( k ) = jao ( j ) jao ( j ) = ko if ( value2 . ne . 0 ) then tmp = ao ( k ) ao ( k ) = ao ( j ) ao ( j ) = tmp endif endif 150 continue 160 continue do 180 ipos = indu ( i ), iao ( i + 1 ) - 1 do 170 j = iao ( i + 1 ) - 1 , ipos + 1 , - 1 k = j - 1 if ( jao ( k ). gt . jao ( j )) then ko = jao ( k ) jao ( k ) = jao ( j ) jao ( j ) = ko if ( value2 . ne . 0 ) then tmp = ao ( k ) ao ( k ) = ao ( j ) ao ( j ) = tmp endif endif 170 continue 180 continue 190 continue c return c---- end of ssrcsr ---------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine xssrcsr ( nrow , a , ja , ia , nzmax , ao , jao , iao , indu , ierr ) implicit none integer nrow , nzmax , ierr integer ia ( nrow + 1 ), iao ( nrow + 1 ), ja ( * ), jao ( nzmax ), indu ( nrow + 1 ) real * 8 a ( * ), ao ( nzmax ) c----------------------------------------------------------------------- c Symmetric Sparse Row   to    (regular) Compressed Sparse Row c----------------------------------------------------------------------- c this subroutine converts  a symmetric  matrix in which only the lower c part is  stored in compressed sparse row format, i.e., c a matrix stored in symmetric sparse format, into a fully stored matrix c i.e., a matrix where both the lower and upper parts are stored in c compressed sparse row format. the algorithm is in place (i.e. result c may be overwritten onto the input matrix a, ja, ia ----- ). c the output matrix delivered by ssrcsr is such that each row starts with c the elements of the lower part followed by those of the upper part. c----------------------------------------------------------------------- c on entry: c--------- c c nrow  = row dimension of inout matrix c a, c ia, c ja    = matrix in compressed sparse row format. This is assumed to be c         a lower triangular matrix. c c nzmax\t= size of arrays ao and jao. ssrcsr will abort if the storage c\t   provided in a, ja is not sufficient to store A. See ierr. c c on return: c---------- c ao, iao, c   jao = output matrix in compressed sparse row format. The resulting c         matrix is symmetric and is equal to A+A**T - D, if c         A is the original lower triangular matrix. ao, jao, iao, c         can be the same as a, ja, ia in the calling sequence. c c indu  = integer array of length nrow+1. If the input matrix is such c         that the last element in each row is its diagonal element then c         on return, indu will contain the pointers to the diagonal c         element in each row of the output matrix. Otherwise used as c         work array. c ierr  = integer. Serving as error message. If the length of the arrays c         ao, jao exceeds nzmax, ierr returns the minimum value c         needed for nzmax. otherwise ierr=0 (normal return). c c----------------------------------------------------------------------- integer i , j , k , lenrow , nnz , kosav , klast , kfirst , ko , ipos ierr = 0 do 1 i = 1 , nrow + 1 indu ( i ) = 0 1 continue c c     compute  number of elements in each row of strict upper part. c     put result in indu(i+1)  for row i. c do 3 i = 1 , nrow do 2 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) if ( j . lt . i ) indu ( j + 1 ) = indu ( j + 1 ) + 1 2 continue 3 continue c----------- c     find addresses of first elements of ouput matrix. result in indu c----------- indu ( 1 ) = 1 do 4 i = 1 , nrow lenrow = ia ( i + 1 ) - ia ( i ) indu ( i + 1 ) = indu ( i ) + indu ( i + 1 ) + lenrow 4 continue c--------------------- enough storage in a, ja ? -------- nnz = indu ( nrow + 1 ) - 1 if ( nnz . gt . nzmax ) then ierr = nnz return endif c c     now copy lower part (backwards). c kosav = indu ( nrow + 1 ) do 6 i = nrow , 1 , - 1 klast = ia ( i + 1 ) - 1 kfirst = ia ( i ) iao ( i + 1 ) = kosav ko = indu ( i ) kosav = ko do 5 k = kfirst , klast ao ( ko ) = a ( k ) jao ( ko ) = ja ( k ) ko = ko + 1 5 continue indu ( i ) = ko 6 continue iao ( 1 ) = 1 c c     now copy upper part. Go through the structure of ao, jao, iao c     that has already been copied (lower part). indu(i) is the address c     of the next free location in row i for ao, jao. c do 8 i = 1 , nrow c     i-th row is now in ao, jao, iao structure -- lower half part do 9 k = iao ( i ), iao ( i + 1 ) - 1 j = jao ( k ) if ( j . ge . i ) goto 8 ipos = indu ( j ) ao ( ipos ) = ao ( k ) jao ( ipos ) = i indu ( j ) = indu ( j ) + 1 9 continue 8 continue return c----- end of xssrcsr -------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrell ( nrow , a , ja , ia , maxcol , coef , jcoef , ncoef , * ndiag , ierr ) implicit none integer nrow , maxcol , ierr , ncoef , ndiag integer ia ( nrow + 1 ), ja ( * ), jcoef ( ncoef , 1 ) real * 8 a ( * ), coef ( ncoef , 1 ) c----------------------------------------------------------------------- c Compressed Sparse Row\t    to    Ellpack - Itpack format c----------------------------------------------------------------------- c this subroutine converts  matrix stored in the general a, ja, ia c format into the coef, jcoef itpack format. c c----------------------------------------------------------------------- c on entry: c---------- c nrow \t  = row dimension of the matrix A. c c a, c ia, c ja      = input matrix in compressed sparse row format. c c ncoef  = first dimension of arrays coef, and jcoef. c c maxcol = integer equal to the number of columns available in coef. c c on return: c---------- c coef\t= real array containing the values of the matrix A in c         itpack-ellpack format. c jcoef = integer array containing the column indices of coef(i,j) c         in A. c ndiag = number of active 'diagonals' found. c c ierr \t= error message. 0 = correct return. If ierr .ne. 0 on c\t  return this means that the number of diagonals found c         (ndiag) exceeds maxcol. c c----------------------------------------------------------------------- integer i , k , j , k1 , k2 c first determine the length of each row of lower-part-of(A) ierr = 0 ndiag = 0 do 3 i = 1 , nrow k = ia ( i + 1 ) - ia ( i ) ndiag = max0 ( ndiag , k ) 3 continue c----- check whether sufficient columns are available. ----------------- if ( ndiag . gt . maxcol ) then ierr = 1 return endif c c fill coef with zero elements and jcoef with row numbers.------------ c do 4 j = 1 , ndiag do 41 i = 1 , nrow coef ( i , j ) = 0.0d0 jcoef ( i , j ) = i 41 continue 4 continue c c------- copy elements row by row.-------------------------------------- c do 6 i = 1 , nrow k1 = ia ( i ) k2 = ia ( i + 1 ) - 1 do 5 k = k1 , k2 coef ( i , k - k1 + 1 ) = a ( k ) jcoef ( i , k - k1 + 1 ) = ja ( k ) 5 continue 6 continue return c--- end of csrell------------------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ellcsr ( nrow , coef , jcoef , ncoef , ndiag , a , ja , ia , nzmax , ierr ) implicit none integer nrow , ncoef , ndiag , nzmax , ierr integer ia ( nrow + 1 ), ja ( * ), jcoef ( ncoef , 1 ) real * 8 a ( * ), coef ( ncoef , 1 ) integer i , k , kpos c----------------------------------------------------------------------- c  Ellpack - Itpack format  to  Compressed Sparse Row c----------------------------------------------------------------------- c this subroutine converts a matrix stored in ellpack-itpack format c coef-jcoef into the compressed sparse row format. It actually checks c whether an entry in the input matrix is a nonzero element before c putting it in the output matrix. The test does not account for small c values but only for exact zeros. c----------------------------------------------------------------------- c on entry: c---------- c c nrow \t= row dimension of the matrix A. c coef\t= array containing the values of the matrix A in ellpack format. c jcoef = integer arraycontains the column indices of coef(i,j) in A. c ncoef = first dimension of arrays coef, and jcoef. c ndiag = number of active columns in coef, jcoef. c c ndiag = on entry the number of columns made available in coef. c c on return: c---------- c a, ia, c    ja = matrix in a, ia, ja format where. c c nzmax\t= size of arrays a and ja. ellcsr will abort if the storage c\t   provided in a, ja is not sufficient to store A. See ierr. c c ierr \t= integer. serves are output error message. c         ierr = 0 means normal return. c         ierr = 1 means that there is not enough space in c         a and ja to store output matrix. c----------------------------------------------------------------------- c first determine the length of each row of lower-part-of(A) ierr = 0 c-----check whether sufficient columns are available. ----------------- c c------- copy elements row by row.-------------------------------------- kpos = 1 ia ( 1 ) = kpos do 6 i = 1 , nrow do 5 k = 1 , ndiag if ( coef ( i , k ) . ne . 0.0d0 ) then if ( kpos . gt . nzmax ) then ierr = kpos return endif a ( kpos ) = coef ( i , k ) ja ( kpos ) = jcoef ( i , k ) kpos = kpos + 1 endif 5 continue ia ( i + 1 ) = kpos 6 continue return c--- end of ellcsr ----------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrmsr ( n , a , ja , ia , ao , jao , wk , iwk ) implicit none integer n real * 8 a ( * ), ao ( * ), wk ( n ) integer ia ( n + 1 ), ja ( * ), jao ( * ), iwk ( n + 1 ) c----------------------------------------------------------------------- c Compressed Sparse Row   to      Modified - Sparse Row c                                 Sparse row with separate main diagonal c----------------------------------------------------------------------- c converts a general sparse matrix a, ja, ia into c a compressed matrix using a separated diagonal (referred to as c the bell-labs format as it is used by bell labs semi conductor c group. We refer to it here as the modified sparse row format. c Note: this has been coded in such a way that one can overwrite c the output matrix onto the input matrix if desired by a call of c the form c c     call csrmsr (n, a, ja, ia, a, ja, wk,iwk) c c In case ao, jao, are different from a, ja, then one can c use ao, jao as the work arrays in the calling sequence: c c     call csrmsr (n, a, ja, ia, ao, jao, ao,jao) c c----------------------------------------------------------------------- c c on entry : c--------- c a, ja, ia = matrix in csr format. note that the c\t     algorithm is in place: ao, jao can be the same c            as a, ja, in which case it will be overwritten on it c            upon return. c c on return : c----------- c c ao, jao  = sparse matrix in modified sparse row storage format: c\t   +  ao(1:n) contains the diagonal of the matrix. c\t   +  ao(n+2:nnz) contains the nondiagonal elements of the c             matrix, stored rowwise. c\t   +  jao(n+2:nnz) : their column indices c\t   +  jao(1:n+1) contains the pointer array for the nondiagonal c             elements in ao(n+1:nnz) and jao(n+2:nnz). c             i.e., for i .le. n+1 jao(i) points to beginning of row i c\t      in arrays ao, jao. c\t       here nnz = number of nonzero elements+1 c work arrays: c------------ c wk\t= real work array of length n c iwk   = integer work array of length n+1 c c notes: c------- c        Algorithm is in place.  i.e. both: c c          call csrmsr (n, a, ja, ia, ao, jao, ao,jao) c          (in which  ao, jao, are different from a, ja) c           and c          call csrmsr (n, a, ja, ia, a, ja, wk,iwk) c          (in which  wk, jwk, are different from a, ja) c        are OK. c-------- c coded by Y. Saad Sep. 1989. Rechecked Feb 27, 1990. c----------------------------------------------------------------------- integer icount , i , k , iptr , ii , j icount = 0 c c store away diagonal elements and count nonzero diagonal elements. c do 1 i = 1 , n wk ( i ) = 0.0d0 iwk ( i + 1 ) = ia ( i + 1 ) - ia ( i ) do 2 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) . eq . i ) then wk ( i ) = a ( k ) icount = icount + 1 iwk ( i + 1 ) = iwk ( i + 1 ) - 1 endif 2 continue 1 continue c c compute total length c iptr = n + ia ( n + 1 ) - icount c c     copy backwards (to avoid collisions) c do 500 ii = n , 1 , - 1 do 100 k = ia ( ii + 1 ) - 1 , ia ( ii ), - 1 j = ja ( k ) if ( j . ne . ii ) then ao ( iptr ) = a ( k ) jao ( iptr ) = j iptr = iptr - 1 endif 100 continue 500 continue c c compute pointer values and copy wk(*) c jao ( 1 ) = n + 2 do 600 i = 1 , n ao ( i ) = wk ( i ) jao ( i + 1 ) = jao ( i ) + iwk ( i + 1 ) 600 continue return c------------ end of subroutine csrmsr --------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine msrcsr ( n , a , ja , ao , jao , iao , wk , iwk ) implicit none integer n real * 8 a ( * ), ao ( * ), wk ( n ) integer ja ( * ), jao ( * ), iao ( n + 1 ), iwk ( n + 1 ) c----------------------------------------------------------------------- c       Modified - Sparse Row  to   Compressed Sparse Row c c----------------------------------------------------------------------- c converts a compressed matrix using a separated diagonal c (modified sparse row format) in the Compressed Sparse Row c format. c does not check for zero elements in the diagonal. c c c on entry : c--------- c n          = row dimension of matrix c a, ja      = sparse matrix in msr sparse storage format c              see routine csrmsr for details on data structure c c on return : c----------- c c ao,jao,iao = output matrix in csr format. c c work arrays: c------------ c wk       = real work array of length n c iwk      = integer work array of length n+1 c c notes: c   The original version of this was NOT in place, but has c   been modified by adding the vector iwk to be in place. c   The original version had ja instead of iwk everywhere in c   loop 500.  Modified  Sun 29 May 1994 by R. Bramley (Indiana). c c----------------------------------------------------------------------- integer i , iptr , ii , idiag , k , j logical added do 1 i = 1 , n wk ( i ) = a ( i ) iwk ( i ) = ja ( i ) 1 continue iwk ( n + 1 ) = ja ( n + 1 ) iao ( 1 ) = 1 iptr = 1 c--------- do 500 ii = 1 , n added = . false . idiag = iptr + ( iwk ( ii + 1 ) - iwk ( ii )) do 100 k = iwk ( ii ), iwk ( ii + 1 ) - 1 j = ja ( k ) if ( j . lt . ii ) then ao ( iptr ) = a ( k ) jao ( iptr ) = j iptr = iptr + 1 elseif ( added ) then ao ( iptr ) = a ( k ) jao ( iptr ) = j iptr = iptr + 1 else c add diag element - only reserve a position for it. idiag = iptr iptr = iptr + 1 added = . true . c     then other element ao ( iptr ) = a ( k ) jao ( iptr ) = j iptr = iptr + 1 endif 100 continue ao ( idiag ) = wk ( ii ) jao ( idiag ) = ii if (. not . added ) iptr = iptr + 1 iao ( ii + 1 ) = iptr 500 continue return c------------ end of subroutine msrcsr --------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrcsc ( n , job , ipos , a , ja , ia , ao , jao , iao ) implicit none integer n , job , ipos integer ia ( n + 1 ), iao ( n + 1 ), ja ( * ), jao ( * ) real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c Compressed Sparse Row     to      Compressed Sparse Column c c (transposition operation)   Not in place. c----------------------------------------------------------------------- c -- not in place -- c this subroutine transposes a matrix stored in a, ja, ia format. c --------------- c on entry: c---------- c n\t= dimension of A. c job\t= integer to indicate whether to fill the values (job.eq.1) of the c         matrix ao or only the pattern., i.e.,ia, and ja (job .ne.1) c c ipos  = starting position in ao, jao of the transposed matrix. c         the iao array takes this into account (thus iao(1) is set to ipos.) c         Note: this may be useful if one needs to append the data structure c         of the transpose to that of A. In this case use for example c                call csrcsc (n,1,ia(n+1),a,ja,ia,a,ja,ia(n+2)) c\t  for any other normal usage, enter ipos=1. c a\t= real array of length nnz (nnz=number of nonzero elements in input c         matrix) containing the nonzero elements. c ja\t= integer array of length nnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer of size n+1. ia(k) contains the position in a, ja of c\t  the beginning of the k-th row. c c on return: c ---------- c output arguments: c ao\t= real array of size nzz containing the \"a\" part of the transpose c jao\t= integer array of size nnz containing the column indices. c iao\t= integer array of size n+1 containing the \"ia\" index array of c\t  the transpose. c c----------------------------------------------------------------------- call csrcsc2 ( n , n , job , ipos , a , ja , ia , ao , jao , iao ) end c----------------------------------------------------------------------- subroutine csrcsc2 ( n , n2 , job , ipos , a , ja , ia , ao , jao , iao ) implicit none integer n , n2 , job , ipos integer ia ( n + 1 ), iao ( n2 + 1 ), ja ( * ), jao ( * ) real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c Compressed Sparse Row     to      Compressed Sparse Column c c (transposition operation)   Not in place. c----------------------------------------------------------------------- c Rectangular version.  n is number of rows of CSR matrix, c                       n2 (input) is number of columns of CSC matrix. c----------------------------------------------------------------------- c -- not in place -- c this subroutine transposes a matrix stored in a, ja, ia format. c --------------- c on entry: c---------- c n\t= number of rows of CSR matrix. c n2    = number of columns of CSC matrix. c job\t= integer to indicate whether to fill the values (job.eq.1) of the c         matrix ao or only the pattern., i.e.,ia, and ja (job .ne.1) c c ipos  = starting position in ao, jao of the transposed matrix. c         the iao array takes this into account (thus iao(1) is set to ipos.) c         Note: this may be useful if one needs to append the data structure c         of the transpose to that of A. In this case use for example c                call csrcsc2 (n,n,1,ia(n+1),a,ja,ia,a,ja,ia(n+2)) c\t  for any other normal usage, enter ipos=1. c a\t= real array of length nnz (nnz=number of nonzero elements in input c         matrix) containing the nonzero elements. c ja\t= integer array of length nnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer of size n+1. ia(k) contains the position in a, ja of c\t  the beginning of the k-th row. c c on return: c ---------- c output arguments: c ao\t= real array of size nzz containing the \"a\" part of the transpose c jao\t= integer array of size nnz containing the column indices. c iao\t= integer array of size n+1 containing the \"ia\" index array of c\t  the transpose. c c----------------------------------------------------------------------- integer i , j , k , next c----------------- compute lengths of rows of transp(A) ---------------- do 1 i = 1 , n2 + 1 iao ( i ) = 0 1 continue do 3 i = 1 , n do 2 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) + 1 iao ( j ) = iao ( j ) + 1 2 continue 3 continue c---------- compute pointers from lengths ------------------------------ iao ( 1 ) = ipos do 4 i = 1 , n2 iao ( i + 1 ) = iao ( i ) + iao ( i + 1 ) 4 continue c--------------- now do the actual copying ----------------------------- do 6 i = 1 , n do 62 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) next = iao ( j ) if ( job . eq . 1 ) ao ( next ) = a ( k ) jao ( next ) = i iao ( j ) = next + 1 62 continue 6 continue c-------------------------- reshift iao and leave ---------------------- do 7 i = n2 , 1 , - 1 iao ( i + 1 ) = iao ( i ) 7 continue iao ( 1 ) = ipos c--------------- end of csrcsc2 ---------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrlnk ( n , ia , link ) implicit none integer n , ia ( n + 1 ), link ( * ) c----------------------------------------------------------------------- c      Compressed Sparse Row         to    Linked storage format. c----------------------------------------------------------------------- c this subroutine translates a matrix stored in compressed sparse c row into one with a linked list storage format. Only the link c array needs to be obtained since the arrays a, ja, and ia may c be unchanged and  carry the same meaning for the output matrix. c in  other words a, ja, ia, link   is the output linked list data c structure with a, ja, unchanged from input, and ia possibly c altered (in case therea re null rows in matrix). Details on c the output array link are given below. c----------------------------------------------------------------------- c Coded by Y. Saad, Feb 21, 1991. c----------------------------------------------------------------------- c c on entry: c---------- c n\t= integer equal to the dimension of A. c a, ja, ia == matrix in CSR format  -- only ia is used. c a\t= real array of size nna containing the nonzero elements c ja\t= integer array of size\tnnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer of size n+1 containing the pointers to the beginning c         of each row. ia(k) contains the position in a, ja of the c         beginning of the k-th row. c c on return: c---------- c a, ja, are not changed. c ia    may be changed if there are null rows. c c a     = nonzero elements. c ja    = column positions. c ia    = ia(i) points to the first element of row i in linked structure. c link\t= integer array of size containing the linked list information. c         link(k) points to the next element of the row after element c         a(k), ja(k). if link(k) = 0, then there is no next element, c         i.e., a(k), jcol(k) is the last element of the current row. c c  Thus row number i can be accessed as follows: c     next = ia(i) c     while(next .ne. 0) do c          value = a(next)      ! value a(i,j) c          jcol  = ja(next)     ! column index j c          next  = link(next)   ! address of next element in row c     endwhile c notes: c ------ ia may be altered on return. c----------------------------------------------------------------------- c local variables integer i , k , istart , iend c c loop through all rows c do 100 i = 1 , n istart = ia ( i ) iend = ia ( i + 1 ) - 1 if ( iend . gt . istart ) then do 99 k = istart , iend - 1 link ( k ) = k + 1 99 continue link ( iend ) = 0 else ia ( i ) = 0 endif 100 continue c return c-------------end-of-csrlnk -------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine lnkcsr ( n , a , jcol , istart , link , ao , jao , iao ) implicit none real * 8 a ( * ), ao ( * ) integer n , jcol ( * ), istart ( n ), link ( * ), jao ( * ), iao ( * ) c----------------------------------------------------------------------- c     Linked list storage format   to      Compressed Sparse Row  format c----------------------------------------------------------------------- c this subroutine translates a matrix stored in linked list storage c format into the compressed sparse row format. c----------------------------------------------------------------------- c Coded by Y. Saad, Feb 21, 1991. c----------------------------------------------------------------------- c c on entry: c---------- c n\t= integer equal to the dimension of A. c c a\t= real array of size nna containing the nonzero elements c jcol\t= integer array of size\tnnz containing the column positions c \t  of the corresponding elements in a. c istart= integer array of size n poiting to the beginning of the rows. c         istart(i) contains the position of the first element of c         row i in data structure. (a, jcol, link). c         if a row is empty istart(i) must be zero. c link\t= integer array of size nnz containing the links in the linked c         list data structure. link(k) points to the next element c         of the row after element ao(k), jcol(k). if link(k) = 0, c         then there is no next element, i.e., ao(k), jcol(k) is c         the last element of the current row. c c on return: c----------- c ao, jao, iao = matrix stored in csr format: c c ao    = real array containing the values of the nonzero elements of c         the matrix stored row-wise. c jao\t= integer array of size nnz containing the column indices. c iao\t= integer array of size n+1 containing the pointers array to the c         beginning of each row. iao(i) is the address in ao,jao of c         first element of row i. c c----------------------------------------------------------------------- c first determine individial bandwidths and pointers. c----------------------------------------------------------------------- c local variables integer irow , ipos , next c----------------------------------------------------------------------- ipos = 1 iao ( 1 ) = ipos c c     loop through all rows c do 100 irow = 1 , n c c     unroll i-th row. c next = istart ( irow ) 10 if ( next . eq . 0 ) goto 99 jao ( ipos ) = jcol ( next ) ao ( ipos ) = a ( next ) ipos = ipos + 1 next = link ( next ) goto 10 99 iao ( irow + 1 ) = ipos 100 continue c return c-------------end-of-lnkcsr ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrdia ( n , idiag , job , a , ja , ia , ndiag , * diag , ioff , ao , jao , iao , ind ) implicit none integer n , ndiag , idiag , job real * 8 diag ( ndiag , idiag ), a ( * ), ao ( * ) integer ia ( * ), ind ( * ), ja ( * ), jao ( * ), iao ( * ), ioff ( * ) c----------------------------------------------------------------------- c Compressed sparse row     to    diagonal format c----------------------------------------------------------------------- c this subroutine extracts  idiag diagonals  from the  input matrix a, c a, ia, and puts the rest of  the matrix  in the  output matrix ao, c jao, iao.  The diagonals to be extracted depend  on the  value of job c (see below for details.)  In  the first  case, the  diagonals to be c extracted are simply identified by  their offsets  provided in ioff c by the caller.  In the second case, the  code internally determines c the idiag most significant diagonals, i.e., those  diagonals of the c matrix which  have  the  largest  number  of  nonzero elements, and c extracts them. c----------------------------------------------------------------------- c on entry: c---------- c n\t= dimension of the matrix a. c idiag = integer equal to the number of diagonals to be extracted. c         Note: on return idiag may be modified. c a, ja, c    ia = matrix stored in a, ja, ia, format c job\t= integer. serves as a job indicator.  Job is better thought c         of as a two-digit number job=xy. If the first (x) digit c         is one on entry then the diagonals to be extracted are c         internally determined. In this case csrdia exctracts the c         idiag most important diagonals, i.e. those having the largest c         number on nonzero elements. If the first digit is zero c         then csrdia assumes that ioff(*) contains the offsets c         of the diagonals to be extracted. there is no verification c         that ioff(*) contains valid entries. c         The second (y) digit of job determines whether or not c         the remainder of the matrix is to be written on ao,jao,iao. c         If it is zero  then ao, jao, iao is not filled, i.e., c         the diagonals are found  and put in array diag and the rest is c         is discarded. if it is one, ao, jao, iao contains matrix c         of the remaining elements. c         Thus: c         job= 0 means do not select diagonals internally (pick those c                defined by ioff) and do not fill ao,jao,iao c         job= 1 means do not select diagonals internally c                      and fill ao,jao,iao c         job=10 means  select diagonals internally c                      and do not fill ao,jao,iao c         job=11 means select diagonals internally c                      and fill ao,jao,iao c c ndiag = integer equal to the first dimension of array diag. c c on return: c----------- c c idiag = number of diagonals found. This may be smaller than its value c         on entry. c diag  = real array of size (ndiag x idiag) containing the diagonals c         of A on return c c ioff  = integer array of length idiag, containing the offsets of the c   \t  diagonals to be extracted. c ao, jao c  iao  = remainder of the matrix in a, ja, ia format. c work arrays: c------------ c ind   = integer array of length 2*n-1 used as integer work space. c         needed only when job.ge.10 i.e., in case the diagonals are to c         be selected internally. c c Notes: c------- c    1) The algorithm is in place: ao, jao, iao can be overwritten on c       a, ja, ia if desired c    2) When the code is required to select the diagonals (job .ge. 10) c       the selection of the diagonals is done from left to right c       as a result if several diagonals have the same weight (number c       of nonzero elemnts) the leftmost one is selected first. c----------------------------------------------------------------------- integer job1 , job2 , n2 , idum , ii , k , j , i , ko , l , jmax job1 = job / 10 job2 = job - job1 * 10 if ( job1 . eq . 0 ) goto 50 n2 = n + n - 1 call infdia ( n , ja , ia , ind , idum ) c----------- determine diagonals to  accept.---------------------------- c----------------------------------------------------------------------- ii = 0 4 ii = ii + 1 jmax = 0 do 41 k = 1 , n2 j = ind ( k ) if ( j . le . jmax ) goto 41 i = k jmax = j 41 continue if ( jmax . le . 0 ) then ii = ii - 1 goto 42 endif ioff ( ii ) = i - n ind ( i ) = - jmax if ( ii . lt . idiag ) goto 4 42 idiag = ii c---------------- initialize diago to zero ----------------------------- 50 continue do 55 j = 1 , idiag do 54 i = 1 , n diag ( i , j ) = 0.0d0 54 continue 55 continue c----------------------------------------------------------------------- ko = 1 c----------------------------------------------------------------------- c extract diagonals and accumulate remaining matrix. c----------------------------------------------------------------------- do 6 i = 1 , n do 51 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) do 52 l = 1 , idiag if ( j - i . ne . ioff ( l )) goto 52 diag ( i , l ) = a ( k ) goto 51 52 continue c--------------- append element not in any diagonal to ao,jao,iao ----- if ( job2 . eq . 0 ) goto 51 ao ( ko ) = a ( k ) jao ( ko ) = j ko = ko + 1 51 continue if ( job2 . ne . 0 ) ind ( i + 1 ) = ko 6 continue if ( job2 . eq . 0 ) return c     finish with iao iao ( 1 ) = 1 do 7 i = 2 , n + 1 iao ( i ) = ind ( i ) 7 continue return c----------- end of csrdia --------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine diacsr ( n , job , idiag , diag , ndiag , ioff , a , ja , ia ) implicit none integer n , job , ndiag , idiag real * 8 diag ( ndiag , idiag ), a ( * ), t integer ia ( * ), ja ( * ), ioff ( * ) c----------------------------------------------------------------------- c    diagonal format     to     compressed sparse row c----------------------------------------------------------------------- c this subroutine extract the idiag most important diagonals from the c input matrix a, ja, ia, i.e, those diagonals of the matrix which have c the largest number of nonzero elements. If requested (see job), c the rest of the matrix is put in a the output matrix ao, jao, iao c----------------------------------------------------------------------- c on entry: c---------- c n\t= integer. dimension of the matrix a. c job\t= integer. job indicator with the following meaning. c         if (job .eq. 0) then check for each entry in diag c         whether this entry is zero. If it is then do not include c         in the output matrix. Note that the test is a test for c         an exact arithmetic zero. Be sure that the zeros are c         actual zeros in double precision otherwise this would not c         work. c c idiag = integer equal to the number of diagonals to be extracted. c         Note: on return idiag may be modified. c c diag  = real array of size (ndiag x idiag) containing the diagonals c         of A on return. c c ndiag = integer equal to the first dimension of array diag. c c ioff  = integer array of length idiag, containing the offsets of the c   \t  diagonals to be extracted. c c on return: c----------- c a, c ja, c ia    = matrix stored in a, ja, ia, format c c Note: c ----- the arrays a and ja should be of length n*idiag. c c----------------------------------------------------------------------- integer ko , i , jj , j ia ( 1 ) = 1 ko = 1 do 80 i = 1 , n do 70 jj = 1 , idiag j = i + ioff ( jj ) if ( j . lt . 1 . or . j . gt . n ) goto 70 t = diag ( i , jj ) if ( job . eq . 0 . and . t . eq . 0.0d0 ) goto 70 a ( ko ) = t ja ( ko ) = j ko = ko + 1 70 continue ia ( i + 1 ) = ko 80 continue return c----------- end of diacsr --------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine bsrcsr ( job , n , m , na , a , ja , ia , ao , jao , iao ) implicit none integer job , n , m , na , ia ( * ), ja ( * ), jao ( * ), iao ( n + 1 ) real * 8 a ( na , * ), ao ( * ) c----------------------------------------------------------------------- c             Block Sparse Row  to Compressed Sparse Row. c----------------------------------------------------------------------- c NOTE: ** meanings of parameters may have changed wrt earlier versions c FORMAT DEFINITION HAS CHANGED WRT TO EARLIER VERSIONS... c----------------------------------------------------------------------- c c converts a  matrix stored in block-reduced   a, ja, ia  format to the c general  sparse row a,  ja, ia  format.  A matrix   that has  a block c structure is a matrix whose entries are blocks  of the same size m c (e.g.  3 x 3).   Then it is often preferred  to work with the reduced c graph of the matrix. Instead of storing one element at a time one can c store a whole block at a time.  In this storage scheme  an entry is a c square array holding the m**2 elements of a block. c c----------------------------------------------------------------------- c on entry: c---------- c job   = if job.eq.0 on entry, values are not copied (pattern only) c c n\t= the block row dimension of the matrix. c c m     = the dimension of each block. Thus, the actual row dimension c         of A is n x m. c c na\t= first dimension of array a as declared in calling program. c         This should be .ge. m**2. c c a\t= real array containing the real entries of the matrix. Recall c         that each entry is in fact an m x m block. These entries c         are stored column-wise in locations a(1:m*m,k) for each k-th c         entry. See details below. c c ja\t= integer array of length n. ja(k) contains the column index c         of the leading element, i.e., the element (1,1) of the block c         that is held in the column a(*,k) of the value array. c c ia    = integer array of length n+1. ia(i) points to the beginning c         of block row number i in the arrays a and ja. c c on return: c----------- c ao, jao, c iao   = matrix stored in compressed sparse row format. The number of c         rows in the new matrix is n x m. c c Notes: THIS CODE IS NOT IN PLACE. c c----------------------------------------------------------------------- c BSR FORMAT. c---------- c Each row of A contains the m x m block matrix unpacked column- c wise (this allows the user to declare the array a as a(m,m,*) on entry c if desired). The block rows are stored in sequence just as for the c compressed sparse row format. c c----------------------------------------------------------------------- c     example  with m = 2: c                                                       1  2 3 c    +-------|--------|--------+                       +-------+ c    | 1   2 |  0   0 |  3   4 |     Block             | x 0 x | 1 c    | 5   6 |  0   0 |  7   8 |     Representation:   | 0 x x | 2 c    +-------+--------+--------+                       | x 0 0 | 3 c    | 0   0 |  9  10 | 11  12 |                       +-------+ c    | 0   0 | 13  14 | 15  16 | c    +-------+--------+--------+ c    | 17 18 |  0   0 |  0   0 | c    | 22 23 |  0   0 |  0   0 | c    +-------+--------+--------+ c c    For this matrix:     n    = 3 c                         m    = 2 c                         nnz  = 5 c----------------------------------------------------------------------- c Data structure in Block Sparse Row format: c------------------------------------------- c Array A: c------------------------- c     1   3   9   11   17   <<--each m x m block is stored column-wise c     5   7   13  15   22       in a  column of the array A. c     2   4   10  12   18 c     6   8   14  16   23 c------------------------- c JA  1   3   2    3    1   <<-- column indices for each block. Note that c-------------------------       these indices are wrt block matrix. c IA  1   3   5    6        <<-- pointers to beginning of each block row c-------------------------       in arrays A and JA. c----------------------------------------------------------------------- c locals c integer i , i1 , i2 , ij , ii , irow , j , jstart , k , krow logical val c val = ( job . ne . 0 ) irow = 1 krow = 1 iao ( irow ) = 1 c----------------------------------------------------------------------- do 2 ii = 1 , n c c     recall: n is the block-row dimension c i1 = ia ( ii ) i2 = ia ( ii + 1 ) - 1 c c     create m rows for each block row -- i.e., each k. c do 23 i = 1 , m do 21 k = i1 , i2 jstart = m * ( ja ( k ) - 1 ) do 22 j = 1 , m ij = ( j - 1 ) * m + i if ( val ) ao ( krow ) = a ( ij , k ) jao ( krow ) = jstart + j krow = krow + 1 22 continue 21 continue irow = irow + 1 iao ( irow ) = krow 23 continue 2 continue return c-------------end-of-bsrcsr -------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrbsr ( job , nrow , m , na , a , ja , ia , ao , jao , iao , iw , ierr ) implicit none integer job , ierr , nrow , m , na , ia ( nrow + 1 ), ja ( * ), jao ( na ), iao ( * ), iw ( * ) real * 8 a ( * ), ao ( na , * ) c----------------------------------------------------------------------- c     Compressed Sparse Row  to    Block Sparse Row c----------------------------------------------------------------------- c c This  subroutine converts a matrix stored  in a general compressed a, c ja, ia format into a a block  sparse row format a(m,m,*),ja(*),ia(*). c See routine  bsrcsr  for more  details on  data   structure for block c matrices. c c NOTES: 1) the initial matrix does not have to have a block structure. c zero padding is done for general sparse matrices. c        2) For most practical purposes, na should be the same as m*m. c c----------------------------------------------------------------------- c c In what follows nr=1+(nrow-1)/m = block-row dimension of output matrix c c on entry: c---------- c c job   =  job indicator. c          job =  0 -> only the pattern of output matrix is generated c          job >  0 -> both pattern and values are generated. c          job = -1 -> iao(1) will return the number of nonzero blocks, c            in the output matrix. In this case jao(1:nr) is used as c            workspace, ao is untouched, iao is untouched except iao(1) c c nrow\t= integer, the actual row dimension of the matrix. c c m     = integer equal to the dimension of each block. m should be > 0. c c na\t= first dimension of array ao as declared in calling program. c         na should be .ge. m*m. c c a, ja, c    ia = input matrix stored in compressed sparse row format. c c on return: c----------- c c ao    = real  array containing the  values of the matrix. For details c         on the format  see below. Each  row of  a contains the  m x m c         block matrix  unpacked column-wise (this  allows the  user to c         declare the  array a as ao(m,m,*) on  entry if desired).  The c         block rows are stored in sequence  just as for the compressed c         sparse row format. The block  dimension  of the output matrix c         is  nr = 1 + (nrow-1) / m. c c jao   = integer array. containing the block-column indices of the c         block-matrix. Each jao(k) is an integer between 1 and nr c         containing the block column index of the block ao(*,k). c c iao   = integer array of length nr+1. iao(i) points to the beginning c         of block row number i in the arrays ao and jao. When job=-1 c         iao(1) contains the number of nonzero blocks of the output c         matrix and the rest of iao is unused. This is useful for c         determining the lengths of ao and jao. c c ierr  = integer, error code. c              0 -- normal termination c              1 -- m is equal to zero c              2 -- NA too small to hold the blocks (should be .ge. m**2) c c Work arrays: c------------- c iw    = integer work array of dimension  nr = 1 + (nrow-1) / m c c NOTES: c------- c     1) this code is not in place. c     2) see routine bsrcsr for details on data sctructure for block c        sparse row format. c c----------------------------------------------------------------------- c     nr is the block-dimension of the output matrix. c integer nr , m2 , io , ko , ii , len , k , jpos , j , i , ij , jr , irow logical vals c----- ierr = 0 if ( m * m . gt . na ) ierr = 2 if ( m . eq . 0 ) ierr = 1 if ( ierr . ne . 0 ) return c----------------------------------------------------------------------- vals = ( job . gt . 0 ) nr = 1 + ( nrow - 1 ) / m m2 = m * m ko = 1 io = 1 iao ( io ) = 1 len = 0 c c     iw determines structure of block-row (nonzero indicator) c do j = 1 , nr iw ( j ) = 0 enddo c c     big loop -- leap by m rows each time. c do ii = 1 , nrow , m irow = 0 c c     go through next m rows -- make sure not to go beyond nrow. c do while ( ii + irow . le . nrow . and . irow . le . m - 1 ) do k = ia ( ii + irow ), ia ( ii + irow + 1 ) - 1 c c     block column index = (scalar column index -1) / m + 1 c j = ja ( k ) - 1 jr = j / m + 1 j = j - ( jr - 1 ) * m jpos = iw ( jr ) if ( jpos . eq . 0 ) then c c     create a new block c iw ( jr ) = ko jao ( ko ) = jr if ( vals ) then c c     initialize new block to zero -- then copy nonzero element c do i = 1 , m2 ao ( i , ko ) = 0.0d0 enddo ij = j * m + irow + 1 ao ( ij , ko ) = a ( k ) endif ko = ko + 1 else c c     copy column index and nonzero element c jao ( jpos ) = jr ij = j * m + irow + 1 if ( vals ) ao ( ij , jpos ) = a ( k ) endif enddo irow = irow + 1 enddo c c     refresh iw c do j = iao ( io ), ko - 1 iw ( jao ( j )) = 0 enddo if ( job . eq . - 1 ) then len = len + ko - 1 ko = 1 else io = io + 1 iao ( io ) = ko endif enddo if ( job . eq . - 1 ) iao ( 1 ) = len c return c--------------end-of-csrbsr-------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrbnd ( n , a , ja , ia , job , abd , nabd , lowd , ml , mu , ierr ) implicit none integer n , job , nabd , lowd , ml , mu , ierr real * 8 a ( * ), abd ( nabd , n ) integer ia ( n + 1 ), ja ( * ) c----------------------------------------------------------------------- c   Compressed Sparse Row  to  Banded (Linpack ) format. c----------------------------------------------------------------------- c this subroutine converts a general sparse matrix stored in c compressed sparse row format into the banded format. for the c banded format,the Linpack conventions are assumed (see below). c----------------------------------------------------------------------- c on entry: c---------- c n\t= integer,the actual row dimension of the matrix. c c a, c ja, c ia    = input matrix stored in compressed sparse row format. c c job\t= integer. if job=1 then the values of the lower bandwith ml c         and the upper bandwidth mu are determined internally. c         otherwise it is assumed that the values of ml and mu c         are the correct bandwidths on input. See ml and mu below. c c nabd  = integer. first dimension of array abd. c c lowd  = integer. this should be set to the row number in abd where c         the lowest diagonal (leftmost) of A is located. c         lowd should be  ( 1  .le.  lowd  .le. nabd). c         if it is not known in advance what lowd should be c         enter lowd = 0 and the default value lowd = ml+mu+1 c         will be chosen. Alternative: call routine getbwd from unary c         first to detrermione ml and mu then define lowd accordingly. c         (Note: the banded solvers in linpack use lowd=2*ml+mu+1. ) c c ml\t= integer. equal to the bandwidth of the strict lower part of A c mu\t= integer. equal to the bandwidth of the strict upper part of A c         thus the total bandwidth of A is ml+mu+1. c         if ml+mu+1 is found to be larger than lowd then an error c         flag is raised (unless lowd = 0). see ierr. c c note:   ml and mu are assumed to have\t the correct bandwidth values c         as defined above if job is set to zero on entry. c c on return: c----------- c c abd   = real array of dimension abd(nabd,n). c         on return contains the values of the matrix stored in c         banded form. The j-th column of abd contains the elements c         of the j-th column of  the original matrix comprised in the c         band ( i in (j-ml,j+mu) ) with the lowest diagonal at c         the bottom row (row lowd). See details below for this format. c c ml\t= integer. equal to the bandwidth of the strict lower part of A c mu\t= integer. equal to the bandwidth of the strict upper part of A c         if job=1 on entry then these two values are internally computed. c c lowd  = integer. row number in abd where the lowest diagonal c         (leftmost) of A is located on return. In case lowd = 0 c         on return, then it is defined to ml+mu+1 on return and the c         lowd will contain this value on return. ` c c ierr  = integer. used for error messages. On return: c         ierr .eq. 0  :means normal return c         ierr .eq. -1 : means invalid value for lowd. (either .lt. 0 c         or larger than nabd). c         ierr .eq. -2 : means that lowd is not large enough and as c         result the matrix cannot be stored in array abd. c         lowd should be at least ml+mu+1, where ml and mu are as c         provided on output. c c----------------------------------------------------------------------* c Additional details on banded format.  (this closely follows the      * c format used in linpack. may be useful for converting a matrix into   * c this storage format in order to use the linpack  banded solvers).    * c----------------------------------------------------------------------* c             ---  band storage format  for matrix abd ---             * c uses ml+mu+1 rows of abd(nabd,*) to store the diagonals of           * c a in rows of abd starting from the lowest (sub)-diagonal  which  is  * c stored in row number lowd of abd. the minimum number of rows needed  * c in abd is ml+mu+1, i.e., the minimum value for lowd is ml+mu+1. the  * c j-th  column  of  abd contains the elements of the j-th column of a, * c from bottom to top: the element a(j+ml,j) is stored in  position     * c abd(lowd,j), then a(j+ml-1,j) in position abd(lowd-1,j) and so on.   * c Generally, the element a(j+k,j) of original matrix a is stored in    * c position abd(lowd+k-ml,j), for k=ml,ml-1,..,0,-1, -mu.               * c The first dimension nabd of abd must be .ge. lowd                    * c                                                                      * c     example [from linpack ]:   if the original matrix is             * c                                                                      * c              11 12 13  0  0  0                                       * c              21 22 23 24  0  0                                       * c               0 32 33 34 35  0     original banded matrix            * c               0  0 43 44 45 46                                       * c               0  0  0 54 55 56                                       * c               0  0  0  0 65 66                                       * c                                                                      * c then  n = 6, ml = 1, mu = 2. lowd should be .ge. 4 (=ml+mu+1)  and   * c if lowd = 5 for example, abd  should be:                             * c                                                                      * c untouched --> x  x  x  x  x  x                                       * c               *  * 13 24 35 46                                       * c               * 12 23 34 45 56    resulting abd matrix in banded     * c              11 22 33 44 55 66    format                             * c  row lowd--> 21 32 43 54 65  *                                       * c                                                                      * c * = not used                                                         * c * c----------------------------------------------------------------------* c first determine ml and mu. c----------------------------------------------------------------------- integer m , i , ii , j , mdiag , k ierr = 0 c----------- if ( job . eq . 1 ) call getbwd ( n , ja , ia , ml , mu ) m = ml + mu + 1 if ( lowd . eq . 0 ) lowd = m if ( m . gt . lowd ) ierr = - 2 if ( lowd . gt . nabd . or . lowd . lt . 0 ) ierr = - 1 if ( ierr . lt . 0 ) return c------------ do 15 i = 1 , m ii = lowd - i + 1 do 10 j = 1 , n abd ( ii , j ) = 0.0d0 10 continue 15 continue c--------------------------------------------------------------------- mdiag = lowd - ml do 30 i = 1 , n do 20 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) abd ( i - j + mdiag , j ) = a ( k ) 20 continue 30 continue return c------------- end of csrbnd ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine bndcsr ( n , abd , nabd , lowd , ml , mu , a , ja , ia , len , ierr ) implicit none integer n , nabd , lowd , ml , mu , len , ierr real * 8 a ( * ), abd ( nabd , * ), t integer ia ( n + 1 ), ja ( * ) c----------------------------------------------------------------------- c Banded (Linpack ) format   to    Compressed Sparse Row  format. c----------------------------------------------------------------------- c on entry: c---------- c n\t= integer,the actual row dimension of the matrix. c c nabd  = first dimension of array abd. c c abd   = real array containing the values of the matrix stored in c         banded form. The j-th column of abd contains the elements c         of the j-th column of  the original matrix,comprised in the c         band ( i in (j-ml,j+mu) ) with the lowest diagonal located c         in row lowd (see below). c c lowd  = integer. this should be set to the row number in abd where c         the lowest diagonal (leftmost) of A is located. c         lowd should be s.t.  ( 1  .le.  lowd  .le. nabd). c         The subroutines dgbco, ... of linpack use lowd=2*ml+mu+1. c c ml\t= integer. equal to the bandwidth of the strict lower part of A c mu\t= integer. equal to the bandwidth of the strict upper part of A c         thus the total bandwidth of A is ml+mu+1. c         if ml+mu+1 is found to be larger than nabd then an error c         message is set. see ierr. c c len   = integer. length of arrays a and ja. bndcsr will stop if the c         length of the arrays a and ja is insufficient to store the c         matrix. see ierr. c c on return: c----------- c a, c ja, c ia    = input matrix stored in compressed sparse row format. c c lowd  = if on entry lowd was zero then lowd is reset to the default c         value ml+mu+l. c c ierr  = integer. used for error message output. c         ierr .eq. 0 :means normal return c         ierr .eq. -1 : means invalid value for lowd. c\t  ierr .gt. 0 : means that there was not enough storage in a and ja c         for storing the ourput matrix. The process ran out of space c         (as indicated by len) while trying to fill row number ierr. c         This should give an idea of much more storage might be required. c         Moreover, the first irow-1 rows are correctly filled. c c notes:  the values in abd found to be equal to zero c -----   (actual test: if (abd(...) .eq. 0.0d0) are removed. c         The resulting may not be identical to a csr matrix c         originally transformed to a bnd format. c c----------------------------------------------------------------------- integer k0 , irow , i , j , ko ierr = 0 c----------- if ( lowd . gt . nabd . or . lowd . le . 0 ) then ierr = - 1 return endif c----------- ko = 1 ia ( 1 ) = 1 do 30 irow = 1 , n c----------------------------------------------------------------------- i = lowd do 20 j = irow - ml , irow + mu if ( j . le . 0 ) goto 19 if ( j . gt . n ) goto 21 t = abd ( i , j ) if ( t . eq . 0.0d0 ) goto 19 if ( ko . gt . len ) then ierr = irow return endif a ( ko ) = t ja ( ko ) = j ko = ko + 1 19 i = i - 1 20 continue c     end for row irow 21 ia ( irow + 1 ) = ko 30 continue return c------------- end of bndcsr ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrssk ( n , imod , a , ja , ia , asky , isky , nzmax , ierr ) implicit none integer n , imod , nzmax , ierr , ia ( n + 1 ), isky ( n + 1 ), ja ( * ) real * 8 a ( * ), asky ( nzmax ) c----------------------------------------------------------------------- c      Compressed Sparse Row         to     Symmetric Skyline Format c  or  Symmetric Sparse Row c----------------------------------------------------------------------- c this subroutine translates a compressed sparse row or a symmetric c sparse row format into a symmetric skyline format. c the input matrix can be in either compressed sparse row or the c symmetric sparse row format. The output matrix is in a symmetric c skyline format: a real array containing the (active portions) of the c rows in  sequence and a pointer to the beginning of each row. c c This module is NOT  in place. c----------------------------------------------------------------------- c Coded by Y. Saad, Oct 5, 1989. Revised Feb. 18, 1991. c----------------------------------------------------------------------- c c on entry: c---------- c n\t= integer equal to the dimension of A. c imod  = integer indicating the variant of skyline format wanted: c         imod = 0 means the pointer isky points to the `zeroth' c         element of the row, i.e., to the position of the diagonal c         element of previous row (for i=1, isky(1)= 0) c         imod = 1 means that itpr points to the beginning of the row. c         imod = 2 means that isky points to the end of the row (diagonal c                  element) c c a\t= real array of size nna containing the nonzero elements c ja\t= integer array of size\tnnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer of size n+1. ia(k) contains the position in a, ja of c\t  the beginning of the k-th row. c nzmax = integer. must be set to the number of available locations c         in the output array asky. c c on return: c---------- c c asky    = real array containing the values of the matrix stored in skyline c         format. asky contains the sequence of active rows from c         i=1, to n, an active row being the row of elemnts of c         the matrix contained between the leftmost nonzero element c         and the diagonal element. c isky\t= integer array of size n+1 containing the pointer array to c         each row. The meaning of isky depends on the input value of c         imod (see above). c ierr  =  integer.  Error message. If the length of the c         output array asky exceeds nzmax. ierr returns the minimum value c         needed for nzmax. otherwise ierr=0 (normal return). c c Notes: c         1) This module is NOT  in place. c         2) even when imod = 2, length of  isky is  n+1, not n. c c----------------------------------------------------------------------- c first determine individial bandwidths and pointers. c----------------------------------------------------------------------- integer i , ml , k , nnz , j , kend ierr = 0 isky ( 1 ) = 0 do 3 i = 1 , n ml = 0 do 31 k = ia ( i ), ia ( i + 1 ) - 1 ml = max ( ml , i - ja ( k ) + 1 ) 31 continue isky ( i + 1 ) = isky ( i ) + ml 3 continue c c     test if there is enough space  asky to do the copying. c nnz = isky ( n + 1 ) if ( nnz . gt . nzmax ) then ierr = nnz return endif c c   fill asky with zeros. c do 1 k = 1 , nnz asky ( k ) = 0.0d0 1 continue c c     copy nonzero elements. c do 4 i = 1 , n kend = isky ( i + 1 ) do 41 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) if ( j . le . i ) asky ( kend + j - i ) = a ( k ) 41 continue 4 continue c c modify pointer according to imod if necessary. c if ( imod . eq . 0 ) return if ( imod . eq . 1 ) then do 50 k = 1 , n + 1 isky ( k ) = isky ( k ) + 1 50 continue endif if ( imod . eq . 2 ) then do 60 k = 1 , n isky ( k ) = isky ( k + 1 ) 60 continue endif c return c------------- end of csrssk ------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine sskssr ( n , imod , asky , isky , ao , jao , iao , nzmax , ierr ) implicit none integer n , imod , nzmax , ierr , isky ( n + 1 ), iao ( n + 1 ), jao ( nzmax ) real * 8 asky ( * ), ao ( nzmax ) c----------------------------------------------------------------------- c     Symmetric Skyline Format  to  Symmetric Sparse Row format. c----------------------------------------------------------------------- c  tests for exact zeros in skyline matrix (and ignores them in c  output matrix).  In place routine (a, isky :: ao, iao) c----------------------------------------------------------------------- c this subroutine translates a  symmetric skyline format into a c symmetric sparse row format. Each element is tested to see if it is c a zero element. Only the actual nonzero elements are retained. Note c that the test used is simple and does take into account the smallness c of a value. the subroutine filter (see unary module) can be used c for this purpose. c----------------------------------------------------------------------- c Coded by Y. Saad, Oct 5, 1989. Revised Feb 18, 1991./ c----------------------------------------------------------------------- c c on entry: c---------- c n\t= integer equal to the dimension of A. c imod  = integer indicating the variant of skyline format used: c         imod = 0 means the pointer iao points to the `zeroth' c         element of the row, i.e., to the position of the diagonal c         element of previous row (for i=1, iao(1)= 0) c         imod = 1 means that itpr points to the beginning of the row. c         imod = 2 means that iao points to the end of the row c                  (diagonal element) c asky  = real array containing the values of the matrix. asky contains c         the sequence of active rows from i=1, to n, an active row c         being the row of elemnts of the matrix contained between the c         leftmost nonzero element and the diagonal element. c isky \t= integer array of size n+1 containing the pointer array to c         each row. isky (k) contains the address of the beginning of the c         k-th active row in the array asky. c nzmax = integer. equal to the number of available locations in the c         output array ao. c c on return: c ---------- c ao\t= real array of size nna containing the nonzero elements c jao\t= integer array of size\tnnz containing the column positions c \t  of the corresponding elements in a. c iao\t= integer of size n+1. iao(k) contains the position in a, ja of c\t  the beginning of the k-th row. c ierr  = integer. Serving as error message. If the length of the c         output arrays ao, jao exceeds nzmax then ierr returns c         the row number where the algorithm stopped: rows c         i, to ierr-1 have been processed succesfully. c         ierr = 0 means normal return. c         ierr = -1  : illegal value for imod c Notes: c------- c This module is in place: ao and iao can be the same as asky, and isky. c----------------------------------------------------------------------- c local variables integer next , kend , kstart , i , j , k ierr = 0 c c check for validity of imod c if ( imod . ne . 0 . and . imod . ne . 1 . and . imod . ne . 2 ) then ierr =- 1 return endif c c next  = pointer to next available position in output matrix c kend  = pointer to end of current row in skyline matrix. c next = 1 c c set kend = start position -1 in  skyline matrix. c kend = 0 if ( imod . eq . 1 ) kend = isky ( 1 ) - 1 if ( imod . eq . 0 ) kend = isky ( 1 ) c c loop through all rows c do 50 i = 1 , n c c save value of pointer to ith row in output matrix c iao ( i ) = next c c get beginnning and end of skyline  row c kstart = kend + 1 if ( imod . eq . 0 ) kend = isky ( i + 1 ) if ( imod . eq . 1 ) kend = isky ( i + 1 ) - 1 if ( imod . eq . 2 ) kend = isky ( i ) c c copy element into output matrix unless it is a zero element. c do 40 k = kstart , kend if ( asky ( k ) . eq . 0.0d0 ) goto 40 j = i - ( kend - k ) jao ( next ) = j ao ( next ) = asky ( k ) next = next + 1 if ( next . gt . nzmax + 1 ) then ierr = i return endif 40 continue 50 continue iao ( n + 1 ) = next return c-------------end-of-sskssr -------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrjad ( nrow , a , ja , ia , idiag , iperm , ao , jao , iao ) implicit none integer idiag integer nrow , ja ( * ), jao ( * ), ia ( nrow + 1 ), iperm ( nrow ), iao ( nrow ) real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c    Compressed Sparse Row  to   JAgged Diagonal storage. c----------------------------------------------------------------------- c this subroutine converts  matrix stored in the compressed sparse c row format to the jagged diagonal format. The data structure c for the JAD (Jagged Diagonal storage) is as follows. The rows of c the matrix are (implicitly) permuted so that their lengths are in c decreasing order. The real entries ao(*) and their column indices c jao(*) are stored in succession. The number of such diagonals is idiag. c the lengths of each of these diagonals is stored in iao(*). c For more details see [E. Anderson and Y. Saad, c ``Solving sparse triangular systems on parallel computers'' in c Inter. J. of High Speed Computing, Vol 1, pp. 73-96 (1989).] c or  [Y. Saad, ``Krylov Subspace Methods on Supercomputers'' c SIAM J. on  Stat. Scient. Comput., volume 10, pp. 1200-1232 (1989).] c----------------------------------------------------------------------- c on entry: c---------- c nrow \t  = row dimension of the matrix A. c c a, c ia, c ja      = input matrix in compressed sparse row format. c c on return: c---------- c c idiag = integer. The number of jagged diagonals in the matrix. c c iperm = integer array of length nrow containing the permutation c         of the rows that leads to a decreasing order of the c         number of nonzero elements. c c ao    = real array containing the values of the matrix A in c         jagged diagonal storage. The j-diagonals are stored c         in ao in sequence. c c jao   = integer array containing the column indices of the c         entries in ao. c c iao   = integer array containing pointers to the beginning c         of each j-diagonal in ao, jao. iao is also used as c         a work array and it should be of length n at least. c c----------------------------------------------------------------------- c     ---- define initial iperm and get lengths of each row c     ---- jao is used a work vector to store tehse lengths c integer ilo , j , len , k , i , k1 , k0 , jj idiag = 0 ilo = nrow do 10 j = 1 , nrow iperm ( j ) = j len = ia ( j + 1 ) - ia ( j ) ilo = min ( ilo , len ) idiag = max ( idiag , len ) jao ( j ) = len 10 continue c c     call sorter to get permutation. use iao as work array. c call dcsort ( jao , nrow , iao , iperm , ilo , idiag ) c c     define output data structure. first lengths of j-diagonals c do 20 j = 1 , nrow iao ( j ) = 0 20 continue do 40 k = 1 , nrow len = jao ( iperm ( k )) do 30 i = 1 , len iao ( i ) = iao ( i ) + 1 30 continue 40 continue c c     get the output matrix itself c k1 = 1 k0 = k1 do 60 jj = 1 , idiag len = iao ( jj ) do 50 k = 1 , len i = ia ( iperm ( k )) + jj - 1 ao ( k1 ) = a ( i ) jao ( k1 ) = ja ( i ) k1 = k1 + 1 50 continue iao ( jj ) = k0 k0 = k1 60 continue iao ( idiag + 1 ) = k1 return c----------end-of-csrjad------------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine jadcsr ( nrow , idiag , a , ja , ia , iperm , ao , jao , iao ) implicit none integer nrow , idiag integer ja ( * ), jao ( * ), ia ( idiag + 1 ), iperm ( nrow ), iao ( nrow + 1 ) real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c     Jagged Diagonal Storage   to     Compressed Sparse Row c----------------------------------------------------------------------- c this subroutine converts a matrix stored in the jagged diagonal format c to the compressed sparse row format. c----------------------------------------------------------------------- c on entry: c---------- c nrow \t  = integer. the row dimension of the matrix A. c c idiag   = integer. The  number of jagged diagonals in the data c           structure a, ja, ia. c c a, c ja, c ia      = input matrix in jagged diagonal format. c c iperm   = permutation of the rows used to obtain the JAD ordering. c c on return: c---------- c c ao, jao, c iao     = matrix in CSR format. c----------------------------------------------------------------------- integer i , j , len , k , kpos , jj , k1 c determine first the pointers for output matrix. Go through the c structure once: c do 137 j = 1 , nrow jao ( j ) = 0 137 continue c c     compute the lengths of each row of output matrix - c do 140 i = 1 , idiag len = ia ( i + 1 ) - ia ( i ) do 138 k = 1 , len jao ( iperm ( k )) = jao ( iperm ( k )) + 1 138 continue 140 continue c c     remember to permute c kpos = 1 iao ( 1 ) = 1 do 141 i = 1 , nrow kpos = kpos + jao ( i ) iao ( i + 1 ) = kpos 141 continue c c     copy elemnts one at a time. c do 200 jj = 1 , idiag k1 = ia ( jj ) - 1 len = ia ( jj + 1 ) - k1 - 1 do 160 k = 1 , len kpos = iao ( iperm ( k )) ao ( kpos ) = a ( k1 + k ) jao ( kpos ) = ja ( k1 + k ) iao ( iperm ( k )) = kpos + 1 160 continue 200 continue c c     rewind pointers c do 5 j = nrow , 1 , - 1 iao ( j + 1 ) = iao ( j ) 5 continue iao ( 1 ) = 1 return c----------end-of-jadcsr------------------------------------------------ c----------------------------------------------------------------------- end subroutine dcsort ( ival , n , icnt , index , ilo , ihi ) c----------------------------------------------------------------------- c     Specifications for arguments: c     ---------------------------- implicit none integer n , ilo , ihi , ival ( n ), icnt ( ilo : ihi ), index ( n ) c----------------------------------------------------------------------- c    This routine computes a permutation which, when applied to the c    input vector ival, sorts the integers in ival in descending c    order.  The permutation is represented by the vector index.  The c    permuted ival can be interpreted as follows: c      ival(index(i-1)) .ge. ival(index(i)) .ge. ival(index(i+1)) c c    A specialized sort, the distribution counting sort, is used c    which takes advantage of the knowledge that c        1)  The values are in the (small) range [ ilo, ihi ] c        2)  Values are likely to be repeated often c c    contributed to SPARSKIT by Mike Heroux. (Cray Research) c    --------------------------------------- c----------------------------------------------------------------------- c Usage: c------ c     call dcsort( ival, n, icnt, index, ilo, ihi ) c c Arguments: c----------- c    ival  integer array (input) c          On entry, ia is an n dimensional array that contains c          the values to be sorted.  ival is unchanged on exit. c c    n     integer (input) c          On entry, n is the number of elements in ival and index. c c    icnt  integer (work) c          On entry, is an integer work vector of length c          (ihi - ilo + 1). c c    index integer array (output) c          On exit, index is an n-length integer vector containing c          the permutation which sorts the vector ival. c c    ilo   integer (input) c          On entry, ilo is .le. to the minimum value in ival. c c    ihi   integer (input) c          On entry, ihi is .ge. to the maximum value in ival. c c Remarks: c--------- c         The permutation is NOT applied to the vector ival. c c---------------------------------------------------------------- c c Local variables: c    Other integer values are temporary indices. c c Author: c-------- c    Michael Heroux c    Sandra Carney c       Mathematical Software Research Group c       Cray Research, Inc. c c References: c    Knuth, Donald E., \"The Art of Computer Programming, Volume 3: c    Sorting and Searching,\" Addison-Wesley, Reading, Massachusetts, c    1973, pp. 78-79. c c Revision history: c    05/09/90: Original implementation.  A variation of the c              Distribution Counting Sort recommended by c              Sandra Carney. (Mike Heroux) c c----------------------------------------------------------------- c     ---------------------------------- c     Specifications for local variables c     ---------------------------------- integer i , j , ivalj c c     -------------------------- c     First executable statement c     -------------------------- do 10 i = ilo , ihi icnt ( i ) = 0 10 continue c do 20 i = 1 , n icnt ( ival ( i )) = icnt ( ival ( i )) + 1 20 continue c do 30 i = ihi - 1 , ilo , - 1 icnt ( i ) = icnt ( i ) + icnt ( i + 1 ) 30 continue c do 40 j = n , 1 , - 1 ivalj = ival ( j ) index ( icnt ( ivalj )) = j icnt ( ivalj ) = icnt ( ivalj ) - 1 40 continue return end c-------end-of-dcsort--------------------------------------------------- c----------------------------------------------------------------------- subroutine cooell ( job , n , nnz , a , ja , ia , ao , jao , lda , ncmax , nc , ierr ) implicit none integer job , n , nnz , lda , ncmax , nc , ierr integer ja ( nnz ), ia ( nnz ), jao ( lda , ncmax ) real * 8 a ( nnz ), ao ( lda , ncmax ) c----------------------------------------------------------------------- c     COOrdinate format to ELLpack format c----------------------------------------------------------------------- c     On entry: c     job     -- 0 if only pattern is to be processed(AO is not touched) c     n       -- number of rows in the matrix c     a,ja,ia -- input matix in COO format c     lda     -- leading dimension of array AO and JAO c     ncmax   -- size of the second dimension of array AO and JAO c c     On exit: c     ao,jao  -- the matrix in ELL format c     nc      -- maximum number of nonzeros per row c     ierr    -- 0 if convertion succeeded c                -1 if LDA < N c                nc if NC > ncmax c c     NOTE: the last column of JAO is used as work space!! c----------------------------------------------------------------------- integer i , j , k , ip real * 8 zero logical copyval parameter ( zero = 0.0D0 ) c     .. first executable statement .. copyval = ( job . ne . 0 ) if ( lda . lt . n ) then ierr = - 1 return endif c     .. use the last column of JAO as workspace c     .. initialize the work space do i = 1 , n jao ( i , ncmax ) = 0 enddo nc = 0 c     .. go through ia and ja to find out number nonzero per row do k = 1 , nnz i = ia ( k ) jao ( i , ncmax ) = jao ( i , ncmax ) + 1 enddo c     .. maximum number of nonzero per row nc = 0 do i = 1 , n if ( nc . lt . jao ( i , ncmax )) nc = jao ( i , ncmax ) jao ( i , ncmax ) = 0 enddo c     .. if nc > ncmax retrun now if ( nc . gt . ncmax ) then ierr = nc return endif c     .. go through ia and ja to copy the matrix to AO and JAO do k = 1 , nnz i = ia ( k ) j = ja ( k ) jao ( i , ncmax ) = jao ( i , ncmax ) + 1 ip = jao ( i , ncmax ) if ( ip . gt . nc ) nc = ip if ( copyval ) ao ( i , ip ) = a ( k ) jao ( i , ip ) = j enddo c     .. fill the unspecified elements of AO and JAO with zero diagonals do i = 1 , n do j = ia ( i + 1 ) - ia ( i ) + 1 , nc jao ( i , j ) = i if ( copyval ) ao ( i , j ) = zero enddo enddo ierr = 0 c return end c-----end-of-cooell----------------------------------------------------- c----------------------------------------------------------------------- subroutine xcooell ( n , nnz , a , ja , ia , ac , jac , nac , ner , ncmax , ierr ) implicit none integer n , nnz , nac , ner , ncmax , ierr C----------------------------------------------------------------------- C   coordinate format to ellpack format. C----------------------------------------------------------------------- C C   DATE WRITTEN: June 4, 1989. C C   PURPOSE C   ------- C  This subroutine takes a sparse matrix in coordinate format and C  converts it into the Ellpack-Itpack storage. C C  Example: C  ------- C       (   11   0   13    0     0     0  ) C       |   21  22    0   24     0     0  | C       |    0  32   33    0    35     0  | C   A = |    0   0   43   44     0    46  | C       |   51   0    0   54    55     0  | C       (   61  62    0    0    65    66  ) C C   Coordinate storage scheme: C C    A  = (11,22,33,44,55,66,13,21,24,32,35,43,46,51,54,61,62,65) C    IA = (1, 2, 3, 4, 5, 6, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6 ) C    JA = ( 1, 2, 3, 4, 5, 6, 3, 1, 4, 2, 5, 3, 6, 1, 4, 1, 2, 5) C C   Ellpack-Itpack storage scheme: C C       (   11  13    0    0   )          (   1   3   *    *  ) C       |   22  21   24    0   |          |   2   1   4    *  | C  AC = |   33  32   35    0   |    JAC = |   3   2   5    *  | C       |   44  43   46    0   |          |   4   3   6    *  | C       |   55  51   54    0   |          |   5   1   4    *  | C       (   66  61   62   65   )          (   6   1   2    5  ) C C   Note: * means that you can store values from 1 to 6 (1 to n, where C         n is the order of the matrix) in that position in the array. C C   Contributed by: C   --------------- C   Ernest E. Rothman C   Cornell Thoery Center/Cornell National Supercomputer Facility C   e-mail address: BITNET:   EER@CORNELLF.BITNET C                   INTERNET: eer@cornellf.tn.cornell.edu C C   checked and modified  04/13/90 Y.Saad. C C   REFERENCES C   ---------- C   Kincaid, D. R.; Oppe, T. C.; Respess, J. R.; Young, D. M. 1984. C   ITPACKV 2C User's Guide, CNA-191. Center for Numerical Analysis, C   University of Texas at Austin. C C   \"Engineering and Scientific Subroutine Library; Guide and C   Reference; Release 3 (SC23-0184-3). Pp. 79-86. C C----------------------------------------------------------------------- C C   INPUT PARAMETERS C   ---------------- C  N       - Integer. The size of the square matrix. C C  NNZ     - Integer. Must be greater than or equal to the number of C            nonzero elements in the sparse matrix. Dimension of A, IA C            and JA. C C  NCA     - Integer. First dimension of output arrays ca and jac. C C  A(NNZ)  - Real array. (Double precision) C            Stored entries of the sparse matrix A. C            NNZ is the number of nonzeros. C C  IA(NNZ) - Integer array. C            Pointers to specify rows for the stored nonzero entries C            in A. C C  JA(NNZ) - Integer array. C            Pointers to specify columns for the stored nonzero C            entries in A. C C  NER     - Integer. Must be set greater than or equal to the maximum C            number of nonzeros in any row of the sparse matrix. C C  OUTPUT PARAMETERS C  ----------------- C  AC(NAC,*)  - Real array. (Double precision) C               Stored entries of the sparse matrix A in compressed C               storage mode. C C  JAC(NAC,*) - Integer array. C               Contains the column numbers of the sparse matrix C               elements stored in the corresponding positions in C               array AC. C C  NCMAX   -  Integer. Equals the maximum number of nonzeros in any C             row of the sparse matrix. C C  IERR    - Error parameter is returned as zero on successful C             execution of the subroutin<e. C             Error diagnostics are given by means of positive values C             of this parameter as follows: C C             IERR = -1   -  NER is too small and should be set equal C                            to NCMAX. The array AC may not be large C                            enough to accomodate all the non-zeros of C                            of the sparse matrix. C             IERR =  1   -  The array AC has a zero column. (Warning) C             IERR =  2   -  The array AC has a zero row.    (Warning) C C--------------------------------------------------------------------- real * 8 a ( nnz ), ac ( nac , ner ) integer ja ( nnz ), ia ( nnz ), jac ( nac , ner ), icount integer in , innz , is , k , ii , inn c c- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - c   Initial error parameter to zero: c ierr = 0 c c- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - c   Initial output arrays to zero: c do 4 in = 1 , ner do 4 innz = 1 , n jac ( innz , in ) = n ac ( innz , in ) = 0.0d0 4 continue c c- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - c c   Assign nonzero elements of the sparse matrix (stored in the one c   dimensional array A to the two dimensional array AC. c   Also, assign the correct values with information about their c   column indices to the two dimensional array KA. And at the same c   time count the number of nonzeros in each row so that the c   parameter NCMAX equals the maximum number of nonzeros in any row c   of the sparse matrix. c ncmax = 1 do 10 is = 1 , n k = 0 do 30 ii = 1 , nnz if ( ia ( ii ). eq . is ) then k = k + 1 if ( k . le . ner ) then ac ( is , k ) = a ( ii ) jac ( is , k ) = ja ( ii ) endif endif 30 continue if ( k . ge . ncmax ) ncmax = k 10 continue c- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - c c     Perform some simple error checks: c check maximum number of nonzeros in each row: if ( ncmax . eq . ner ) ierr = 0 if ( ncmax . gt . ner ) then ierr = - 1 return endif c check if there are any zero columns in AC: c do 45 in = 1 , ncmax icount = 0 do 44 inn = 1 , n if ( ac ( inn , in ). ne . 0.0d0 ) icount = 1 44 continue if ( icount . eq . 0 ) then ierr = 1 return endif 45 continue c check if there are any zero rows in AC: c do 55 inn = 1 , n icount = 0 do 54 in = 1 , ncmax if ( ac ( inn , in ). ne . 0.0d0 ) icount = 1 54 continue if ( icount . eq . 0 ) then ierr = 2 return endif 55 continue return c------------- end of xcooell ------------------------------------------- end c----------------------------------------------------------------------- subroutine csruss ( nrow , a , ja , ia , diag , al , jal , ial , au , jau , iau ) implicit none real * 8 a ( * ), al ( * ), diag ( * ), au ( * ) integer nrow , ja ( * ), ia ( nrow + 1 ), jal ( * ), ial ( nrow + 1 ), jau ( * ), * iau ( nrow + 1 ) c----------------------------------------------------------------------- c Compressed Sparse Row     to     Unsymmetric Sparse Skyline format c----------------------------------------------------------------------- c this subroutine converts a matrix stored in csr format into a nonsym. c sparse skyline format. This latter format does not assume c that the matrix has a symmetric pattern and consists of the following c * the diagonal of A stored separately in diag(*); c * The strict lower part of A is stored  in CSR format in al,jal,ial c * The strict upper part is stored in CSC format in au,jau,iau. c----------------------------------------------------------------------- c On entry c--------- c nrow  = dimension of the matrix a. c a     = real array containing the nonzero values of the matrix c         stored rowwise. c ja    = column indices of the values in array a c ia    = integer array of length n+1 containing the pointers to c         beginning of each row in arrays a, ja. c c On return c---------- c diag  = array containing the diagonal entries of A c al,jal,ial = matrix in CSR format storing the strict lower c              trangular part of A. c au,jau,iau = matrix in CSC format storing the strict upper c              triangular part of A. c----------------------------------------------------------------------- integer i , j , k , kl , ku c c determine U's data structure first c do 1 i = 1 , nrow + 1 iau ( i ) = 0 1 continue do 3 i = 1 , nrow do 2 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) if ( j . gt . i ) iau ( j + 1 ) = iau ( j + 1 ) + 1 2 continue 3 continue c c     compute pointers from lengths c iau ( 1 ) = 1 do 4 i = 1 , nrow iau ( i + 1 ) = iau ( i ) + iau ( i + 1 ) ial ( i + 1 ) = ial ( i ) + ial ( i + 1 ) 4 continue c c     now do the extractions. scan all rows. c kl = 1 ial ( 1 ) = kl do 7 i = 1 , nrow c c     scan all elements in a row c do 71 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) c c     if in upper part, store in row j (of transp(U) ) c if ( j . gt . i ) then ku = iau ( j ) au ( ku ) = a ( k ) jau ( ku ) = i iau ( j ) = ku + 1 elseif ( j . eq . i ) then diag ( i ) = a ( k ) elseif ( j . lt . i ) then al ( kl ) = a ( k ) jal ( kl ) = j kl = kl + 1 endif 71 continue ial ( i + 1 ) = kl 7 continue c c readjust iau c do 8 i = nrow , 1 , - 1 iau ( i + 1 ) = iau ( i ) 8 continue iau ( 1 ) = 1 c--------------- end-of-csruss ----------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine usscsr ( nrow , a , ja , ia , diag , al , jal , ial , au , jau , iau ) implicit none integer nrow real * 8 a ( * ), al ( * ), diag ( * ), au ( * ) integer ja ( * ), ia ( nrow + 1 ), jal ( * ), ial ( nrow + 1 ), jau ( * ), iau ( nrow + 1 ) c----------------------------------------------------------------------- c Unsymmetric Sparse Skyline   format   to Compressed Sparse Row c----------------------------------------------------------------------- c this subroutine converts a matrix stored in nonsymmetric sparse c skyline format into csr format. The sparse skyline format is c described in routine csruss. c----------------------------------------------------------------------- c----------------------------------------------------------------------- c On entry c----------------------------------------------------------------------- c nrow  = dimension of the matrix a. c diag  = array containing the diagonal entries of A c al,jal,ial = matrix in CSR format storing the strict lower c              trangular part of A. c au,jau,iau = matrix in CSC format storing the strict upper c              trangular part of A. c On return c --------- c a     = real array containing the nonzero values of the matrix c         stored rowwise. c ja    = column indices of the values in array a c ia    = integer array of length n+1 containing the pointers to c         beginning of each row in arrays a, ja. c c----------------------------------------------------------------------- integer i , j , k , ka , jak c c count elements in lower part + diagonal c do 1 i = 1 , nrow ia ( i + 1 ) = ial ( i + 1 ) - ial ( i ) + 1 1 continue c c count elements in upper part c do 3 i = 1 , nrow do 2 k = iau ( i ), iau ( i + 1 ) - 1 j = jau ( k ) ia ( j + 1 ) = ia ( j + 1 ) + 1 2 continue 3 continue c---------- compute pointers from lengths ------------------------------ ia ( 1 ) = 1 do 4 i = 1 , nrow ia ( i + 1 ) = ia ( i ) + ia ( i + 1 ) 4 continue c c copy lower part + diagonal c do 6 i = 1 , nrow ka = ia ( i ) do 5 k = ial ( i ), ial ( i + 1 ) - 1 a ( ka ) = al ( k ) ja ( ka ) = jal ( k ) ka = ka + 1 5 continue a ( ka ) = diag ( i ) ja ( ka ) = i ia ( i ) = ka + 1 6 continue c c     copy upper part c do 8 i = 1 , nrow do 7 k = iau ( i ), iau ( i + 1 ) - 1 c c row number c jak = jau ( k ) c c where element goes c ka = ia ( jak ) a ( ka ) = au ( k ) ja ( ka ) = i ia ( jak ) = ka + 1 7 continue 8 continue c c readjust ia c do 9 i = nrow , 1 , - 1 ia ( i + 1 ) = ia ( i ) 9 continue ia ( 1 ) = 1 c----------end-of-usscsr------------------------------------------------ end c----------------------------------------------------------------------- subroutine csrsss ( nrow , a , ja , ia , sorted , diag , al , jal , ial , au ) implicit none integer nrow , ja ( * ), ia ( nrow + 1 ), jal ( * ), ial ( nrow + 1 ) real * 8 a ( * ), al ( * ), diag ( * ), au ( * ) logical sorted c----------------------------------------------------------------------- c Compressed Sparse Row     to     Symmetric Sparse Skyline   format c----------------------------------------------------------------------- c this subroutine converts a matrix stored in csr format into the c Symmetric sparse skyline   format. This latter format assumes that c that the matrix has a symmetric pattern. It consists of the following c * the diagonal of A stored separately in diag(*); c * The strict lower part of A is stored  in csr format in al,jal,ial c * The values only of strict upper part as stored in csc format in au. c----------------------------------------------------------------------- c On entry c----------- c nrow  = dimension of the matrix a. c a     = real array containing the nonzero values of the matrix c         stored rowwise. c ja    = column indices of the values in array a c ia    = integer array of length n+1 containing the pointers to c         beginning of each row in arrays a, ja. c sorted= a logical indicating whether or not the elements in a,ja,ia c         are sorted. c c On return c --------- c diag  = array containing the diagonal entries of A c al,jal,ial = matrix in csr format storing the strict lower c              trangular part of A. c au    = values of the strict upper trangular part of A, column wise. c----------------------------------------------------------------------- integer kl , ku , i , k , jak c c     extract lower part and diagonal. c kl = 1 ial ( 1 ) = kl do 7 i = 1 , nrow c c scan all elements in a row c do 71 k = ia ( i ), ia ( i + 1 ) - 1 jak = ja ( k ) if ( jak . eq . i ) then diag ( i ) = a ( k ) elseif ( jak . lt . i ) then al ( kl ) = a ( k ) jal ( kl ) = jak kl = kl + 1 endif 71 continue ial ( i + 1 ) = kl 7 continue c c sort if not sorted c if (. not . sorted ) then c%%%%%---- incompatible arg list! call csort ( nrow , al , jal , ial , . true .) endif c c copy u c do 8 i = 1 , nrow c c scan all elements in a row c do 81 k = ia ( i ), ia ( i + 1 ) - 1 jak = ja ( k ) if ( jak . gt . i ) then ku = ial ( jak ) au ( ku ) = a ( k ) ial ( jak ) = ku + 1 endif 81 continue 8 continue c c readjust ial c do 9 i = nrow , 1 , - 1 ial ( i + 1 ) = ial ( i ) 9 continue ial ( 1 ) = 1 c--------------- end-of-csrsss ----------------------------------------- c----------------------------------------------------------------------- end c subroutine ssscsr ( nrow , a , ja , ia , diag , al , jal , ial , au ) implicit none integer nrow real * 8 a ( * ), al ( * ), diag ( * ), au ( * ) integer ja ( * ), ia ( nrow + 1 ), jal ( * ), ial ( nrow + 1 ) c----------------------------------------------------------------------- c Unsymmetric Sparse Skyline   format   to Compressed Sparse Row c----------------------------------------------------------------------- c this subroutine converts a matrix stored in nonsymmetric sparse c skyline format into csr format. The sparse skyline format is c described in routine csruss. c----------------------------------------------------------------------- c On entry c--------- c diag  = array containing the diagonal entries of A c al,jal,ial = matrix in csr format storing the strict lower c              trangular part of A. c au    = values of strict upper part. c c On return c --------- c nrow  = dimension of the matrix a. c a     = real array containing the nonzero values of the matrix c         stored rowwise. c ja    = column indices of the values in array a c ia    = integer array of length n+1 containing the pointers to c         beginning of each row in arrays a, ja. c c----------------------------------------------------------------------- integer i , j , k , ka , jak c c count elements in lower part + diagonal c do 1 i = 1 , nrow ia ( i + 1 ) = ial ( i + 1 ) - ial ( i ) + 1 1 continue c c count elements in upper part c do 3 i = 1 , nrow do 2 k = ial ( i ), ial ( i + 1 ) - 1 j = jal ( k ) ia ( j + 1 ) = ia ( j + 1 ) + 1 2 continue 3 continue c---------- compute pointers from lengths ------------------------------ ia ( 1 ) = 1 do 4 i = 1 , nrow ia ( i + 1 ) = ia ( i ) + ia ( i + 1 ) 4 continue c c copy lower part + diagonal c do 6 i = 1 , nrow ka = ia ( i ) do 5 k = ial ( i ), ial ( i + 1 ) - 1 a ( ka ) = al ( k ) ja ( ka ) = jal ( k ) ka = ka + 1 5 continue a ( ka ) = diag ( i ) ia ( i ) = ka + 1 6 continue c c     copy upper part c do 8 i = 1 , nrow do 7 k = ial ( i ), ial ( i + 1 ) - 1 c c row number c jak = jal ( k ) c c where element goes c ka = ia ( jak ) a ( ka ) = au ( k ) ja ( ka ) = i ia ( jak ) = ka + 1 7 continue 8 continue c c readjust ia c do 9 i = nrow , 1 , - 1 ia ( i + 1 ) = ia ( i ) 9 continue ia ( 1 ) = 1 c----------end-of-ssscsr------------------------------------------------ end c----------------------------------------------------------------------- subroutine csrvbr ( n , ia , ja , a , nr , nc , kvstr , kvstc , ib , jb , kb , & b , job , iwk , nkmax , nzmax , ierr ) c----------------------------------------------------------------------- implicit none integer kvstr ( * ), kvstc ( * ), job , iwk ( * ), nkmax , nzmax , ierr integer n , ia ( n + 1 ), ja ( * ), nr , nc , ib ( * ), jb ( nkmax - 1 ), kb ( nkmax ) real * 8 a ( * ), b ( nzmax ) c----------------------------------------------------------------------- c     Converts compressed sparse row to variable block row format. c----------------------------------------------------------------------- c     On entry: c-------------- c     n       = number of matrix rows c     ia,ja,a = input matrix in CSR format c c     job     = job indicator. c               If job=0, kvstr and kvstc are used as supplied. c               If job=1, kvstr and kvstc are determined by the code. c               If job=2, a conformal row/col partitioning is found and c               returned in both kvstr and kvstc.  In the latter two cases, c               an optimized algorithm can be used to perform the c               conversion because all blocks are full. c c     nkmax   = size of supplied jb and kb arrays c     nzmax   = size of supplied b array c c     If job=0 then the following are input: c     nr,nc   = matrix block row and block column dimension c     kvstr   = first row number for each block row c     kvstc   = first column number for each block column. c               (kvstr and kvstc may be the same array) c c     On return: c--------------- c c     ib,jb,kb,b = output matrix in VBR format c c     ierr    = error message c               ierr = 0 means normal return c               ierr = 1 out of space in jb and/or kb arrays c               ierr = 2 out of space in b array c               ierr = 3 nonsquare matrix used with job=2 c c     If job=1,2 then the following are output: c     nr,nc   = matrix block row and block column dimension c     kvstr   = first row number for each block row c     kvstc   = first column number for each block column c               If job=2, then kvstr and kvstc contain the same info. c c     Work space: c---------------- c     iwk(1:ncol) = inverse kvstc array.  If job=1,2 then we also need: c     iwk(ncol+1:ncol+nr) = used to help determine sparsity of each block row. c     The workspace is not assumed to be initialized to zero, nor is it c     left that way. c c     Algorithms: c---------------- c     There are two conversion codes in this routine.  The first assumes c     that all blocks are full (there is a nonzero in the CSR data c     structure for each entry in the block), and is used if the routine c     determines the block partitioning itself.  The second code makes c     no assumptions about the block partitioning, and is used if the c     caller provides the partitioning.  The second code is much less c     efficient than the first code. c c     In the first code, the CSR data structure is traversed sequentially c     and entries are placed into the VBR data structure with stride c     equal to the row dimension of the block row.  The columns of the c     CSR data structure are sorted first if necessary. c c     In the second code, the block sparsity pattern is first determined. c     This is done by traversing the CSR data structure and using an c     implied linked list to determine which blocks are nonzero.  Then c     the VBR data structure is filled by mapping each individual entry c     in the CSR data structure into the VBR data structure.  The columns c     of the CSR data structure are sorted first if necessary. c c----------------------------------------------------------------------- c     Local variables: c--------------------- integer ncol , nb , neqr , numc , a0 , b0 , b1 , k0 , i , ii , j , jj , jnew logical sorted c c     ncol = number of scalar columns in matrix c     nb = number of blocks in conformal row/col partitioning c     neqr = number of rows in block row c     numc = number of nonzero columns in row c     a0 = index for entries in CSR a array c     b0 = index for entries in VBR b array c     b1 = temp c     k0 = index for entries in VBR kb array c     i  = loop index for block rows c     ii = loop index for scalar rows in block row c     j  = loop index for block columns c     jj = loop index for scalar columns in block column c     jnew = block column number c     sorted = used to indicate if matrix already sorted by columns c c----------------------------------------------------------------------- ierr = 0 c-----sort matrix by column indices call csorted ( n , ia , ja , sorted ) if (. not . sorted ) then call csort ( n , a , ja , ia , . true .) endif if ( job . eq . 1 . or . job . eq . 2 ) then c--------need to zero workspace; first find ncol ncol = 0 do i = 2 , n ncol = max0 ( ncol , ja ( ia ( i ) - 1 )) enddo do i = 1 , ncol iwk ( i ) = 0 enddo call csrkvstr ( n , ia , ja , nr , kvstr ) call csrkvstc ( n , ia , ja , nc , kvstc , iwk ) endif c-----check if want conformal partitioning if ( job . eq . 2 ) then if ( kvstr ( nr + 1 ) . ne . kvstc ( nc + 1 )) then ierr = 3 return endif c        use iwk temporarily call kvstmerge ( nr , kvstr , nc , kvstc , nb , iwk ) nr = nb nc = nb do i = 1 , nb + 1 kvstr ( i ) = iwk ( i ) kvstc ( i ) = iwk ( i ) enddo endif c----------------------------------------------------------------------- c     inverse kvst (scalar col number) = block col number c     stored in iwk(1:n) c----------------------------------------------------------------------- do i = 1 , nc do j = kvstc ( i ), kvstc ( i + 1 ) - 1 iwk ( j ) = i enddo enddo ncol = kvstc ( nc + 1 ) - 1 c-----jump to conversion routine if ( job . eq . 0 ) goto 400 c----------------------------------------------------------------------- c     Fast conversion for computed block partitioning c----------------------------------------------------------------------- a0 = 1 b0 = 1 k0 = 1 kb ( 1 ) = 1 c-----loop on block rows do i = 1 , nr neqr = kvstr ( i + 1 ) - kvstr ( i ) numc = ia ( kvstr ( i ) + 1 ) - ia ( kvstr ( i )) ib ( i ) = k0 c--------loop on first row in block row to determine block sparsity j = 0 do jj = ia ( kvstr ( i )), ia ( kvstr ( i ) + 1 ) - 1 jnew = iwk ( ja ( jj )) if ( jnew . ne . j ) then c--------------check there is enough space in kb and jb arrays if ( k0 + 1 . gt . nkmax ) then ierr = 1 write ( * , * ) 'csrvbr: no space in kb for block row ' , i return endif c--------------set entries for this block j = jnew b0 = b0 + neqr * ( kvstc ( j + 1 ) - kvstc ( j )) kb ( k0 + 1 ) = b0 jb ( k0 ) = j k0 = k0 + 1 endif enddo c--------loop on scalar rows in block row do ii = 0 , neqr - 1 b1 = kb ( ib ( i )) + ii c-----------loop on elements in a scalar row do jj = 1 , numc c--------------check there is enough space in b array if ( b1 . gt . nzmax ) then ierr = 2 write ( * , * ) 'csrvbr: no space in b for block row ' , i return endif b ( b1 ) = a ( a0 ) b1 = b1 + neqr a0 = a0 + 1 enddo enddo enddo ib ( nr + 1 ) = k0 return c----------------------------------------------------------------------- c     Conversion for user supplied block partitioning c----------------------------------------------------------------------- 400 continue c-----initialize workspace for sparsity indicator do i = ncol + 1 , ncol + nc iwk ( i ) = 0 enddo k0 = 1 kb ( 1 ) = 1 c-----find sparsity of block rows do i = 1 , nr neqr = kvstr ( i + 1 ) - kvstr ( i ) numc = ia ( kvstr ( i ) + 1 ) - ia ( kvstr ( i )) ib ( i ) = k0 c--------loop on all the elements in the block row to determine block sparsity do jj = ia ( kvstr ( i )), ia ( kvstr ( i + 1 )) - 1 iwk ( iwk ( ja ( jj )) + ncol ) = 1 enddo c--------use sparsity to set jb and kb arrays do j = 1 , nc if ( iwk ( j + ncol ) . ne . 0 ) then c--------------check there is enough space in kb and jb arrays if ( k0 + 1 . gt . nkmax ) then ierr = 1 write ( * , * ) 'csrvbr: no space in kb for block row ' , i return endif kb ( k0 + 1 ) = kb ( k0 ) + neqr * ( kvstc ( j + 1 ) - kvstc ( j )) jb ( k0 ) = j k0 = k0 + 1 iwk ( j + ncol ) = 0 endif enddo enddo ib ( nr + 1 ) = k0 c-----Fill b with entries from a by traversing VBR data structure. a0 = 1 c-----loop on block rows do i = 1 , nr neqr = kvstr ( i + 1 ) - kvstr ( i ) c--------loop on scalar rows in block row do ii = 0 , neqr - 1 b0 = kb ( ib ( i )) + ii c-----------loop on block columns do j = ib ( i ), ib ( i + 1 ) - 1 c--------------loop on scalar columns within block column do jj = kvstc ( jb ( j )), kvstc ( jb ( j ) + 1 ) - 1 c-----------------check there is enough space in b array if ( b0 . gt . nzmax ) then ierr = 2 write ( * , * ) 'csrvbr: no space in b for blk row' , i return endif if ( a0 . ge . ia ( kvstr ( i ) + ii + 1 )) then b ( b0 ) = 0.d0 else if ( jj . eq . ja ( a0 )) then b ( b0 ) = a ( a0 ) a0 = a0 + 1 else b ( b0 ) = 0.d0 endif endif b0 = b0 + neqr c--------------endloop on scalar columns enddo c-----------endloop on block columns enddo continue enddo enddo return end c----------------------------------------------------------------------- c----------------------------end-of-csrvbr------------------------------ c----------------------------------------------------------------------c subroutine vbrcsr ( ia , ja , a , nr , kvstr , kvstc , ib , jb , kb , & b , nzmax , ierr ) c----------------------------------------------------------------------- implicit none integer ia ( * ), ja ( * ), nr , ib ( nr + 1 ), jb ( * ), kb ( * ) integer kvstr ( nr + 1 ), kvstc ( * ), nzmax , ierr real * 8 a ( * ), b ( nzmax ) c----------------------------------------------------------------------- c     Converts variable block row to compressed sparse row format. c----------------------------------------------------------------------- c     On entry: c-------------- c     nr      = number of block rows c     kvstr   = first row number for each block row c     kvstc   = first column number for each block column c     ib,jb,kb,b = input matrix in VBR format c     nzmax   = size of supplied ja and a arrays c c     On return: c--------------- c     ia,ja,a = output matrix in CSR format c c     ierr    = error message c               ierr = 0 means normal return c               ierr = negative row number when out of space in c                      ja and a arrays c c     Work space: c---------------- c     None c c     Algorithm: c--------------- c     The VBR data structure is traversed in the order that is required c     to fill the CSR data structure.  In a given block row, consecutive c     entries in the CSR data structure are entries in the VBR data c     structure with stride equal to the row dimension of the block. c     The VBR data structure is assumed to be sorted by block columns. c c----------------------------------------------------------------------- c     Local variables: c--------------------- integer neqr , numc , a0 , b0 , i , ii , j , jj c c     neqr = number of rows in block row c     numc = number of nonzero columns in row c     a0 = index for entries in CSR a array c     b0 = index for entries in VBR b array c     i  = loop index for block rows c     ii = loop index for scalar rows in block row c     j  = loop index for block columns c     jj = loop index for scalar columns in block column c c----------------------------------------------------------------------- ierr = 0 a0 = 1 b0 = 1 c-----loop on block rows do i = 1 , nr c--------set num of rows in block row, and num of nonzero cols in row neqr = kvstr ( i + 1 ) - kvstr ( i ) numc = ( kb ( ib ( i + 1 )) - kb ( ib ( i )) ) / neqr c--------construct ja for a scalar row do j = ib ( i ), ib ( i + 1 ) - 1 do jj = kvstc ( jb ( j )), kvstc ( jb ( j ) + 1 ) - 1 ja ( a0 ) = jj a0 = a0 + 1 enddo enddo c--------construct neqr-1 additional copies of ja for the block row do ii = 1 , neqr - 1 do j = 1 , numc ja ( a0 ) = ja ( a0 - numc ) a0 = a0 + 1 enddo enddo c--------reset a0 back to beginning of block row a0 = kb ( ib ( i )) c--------loop on scalar rows in block row do ii = 0 , neqr - 1 ia ( kvstr ( i ) + ii ) = a0 b0 = kb ( ib ( i )) + ii c-----------loop on elements in a scalar row do jj = 1 , numc c--------------check there is enough space in a array if ( a0 . gt . nzmax ) then ierr = - ( kvstr ( i ) + ii ) write ( * , * ) 'vbrcsr: no space for row ' , - ierr return endif a ( a0 ) = b ( b0 ) a0 = a0 + 1 b0 = b0 + neqr enddo enddo c-----endloop on block rows enddo ia ( kvstr ( nr + 1 )) = a0 return end c----------------------------------------------------------------------- c---------------------------end-of-vbrcsr------------------------------- c----------------------------------------------------------------------- c----------------------------------------------------------------------- subroutine csorted ( n , ia , ja , sorted ) c----------------------------------------------------------------------- implicit none integer n , ia ( n + 1 ), ja ( * ) logical sorted c----------------------------------------------------------------------- c     Checks if matrix in CSR format is sorted by columns. c----------------------------------------------------------------------- c     On entry: c-------------- c     n       = number of rows in matrix c     ia, ja  = sparsity structure of matrix in CSR format c c     On return: c--------------- c     sorted  = indicates if matrix is sorted by columns c c----------------------------------------------------------------------- c-----local variables integer i , j c--------------------------------- do i = 1 , n do j = ia ( i ) + 1 , ia ( i + 1 ) - 1 if ( ja ( j - 1 ) . ge . ja ( j )) then sorted = . false . return endif enddo enddo sorted = . true . return end c----------------------------------------------------------------------- c------------------------end-of-csorted---------------------------------","tags":"","loc":"sourcefile\\formats.f.html"},{"title":"ilut.f – LINALG","text":"Contents Subroutines ilut ilutp ilud iludp iluk ilu0 milu0 pgmres lusol lutsol qsplit Source Code ilut.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c                   ITERATIVE SOLVERS MODULE                           c c----------------------------------------------------------------------c c This Version Dated: August 13, 1996. Warning: meaning of some        c c ============ arguments have changed w.r.t. earlier versions. Some    c c              Calling sequences may also have changed                 c c----------------------------------------------------------------------c c Contents:                                                            c c-------------------------preconditioners------------------------------c c                                                                      c c ILUT    : Incomplete LU factorization with dual truncation strategy  c c ILUTP   : ILUT with column  pivoting                                 c c ILUD    : ILU with single dropping + diagonal compensation (~MILUT)  c c ILUDP   : ILUD with column pivoting                                  c c ILUK    : level-k ILU                                                c c ILU0    : simple ILU(0) preconditioning                              c c MILU0   : MILU(0) preconditioning                                    c c                                                                      c c----------sample-accelerator-and-LU-solvers---------------------------c c                                                                      c c PGMRES  : preconditioned GMRES solver                                c c LUSOL   : forward followed by backward triangular solve (Precond.)   c c LUTSOL  : solving v = (LU)&#94;{-T} u (used for preconditioning)         c c                                                                      c c-------------------------utility-routine------------------------------c c                                                                      c c QSPLIT  : quick split routine used by ilut to sort out the k largest c c           elements in absolute value                                 c c                                                                      c c----------------------------------------------------------------------c c                                                                      c c Note: all preconditioners are preprocessors to pgmres.               c c usage: call preconditioner then call pgmres                          c c                                                                      c c----------------------------------------------------------------------c subroutine ilut ( n , a , ja , ia , lfil , droptol , alu , jlu , ju , iwk , w , jw , ierr ) c----------------------------------------------------------------------- implicit none integer n real * 8 a ( * ), alu ( * ), w ( n + 1 ), droptol integer ja ( * ), ia ( n + 1 ), jlu ( * ), ju ( n ), jw ( 2 * n ), lfil , iwk , ierr c----------------------------------------------------------------------* c                      *** ILUT preconditioner ***                     * c      incomplete LU factorization with dual truncation mechanism      * c----------------------------------------------------------------------* c     Author: Yousef Saad *May, 5, 1990, Latest revision, August 1996  * c----------------------------------------------------------------------* c PARAMETERS c----------- c c on entry: c========== c n       = integer. The row dimension of the matrix A. The matrix c c a,ja,ia = matrix stored in Compressed Sparse Row format. c c lfil    = integer. The fill-in parameter. Each row of L and each row c           of U will have a maximum of lfil elements (excluding the c           diagonal element). lfil must be .ge. 0. c           ** WARNING: THE MEANING OF LFIL HAS CHANGED WITH RESPECT TO c           EARLIER VERSIONS. c c droptol = real*8. Sets the threshold for dropping small terms in the c           factorization. See below for details on dropping strategy. c c c iwk     = integer. The lengths of arrays alu and jlu. If the arrays c           are not big enough to store the ILU factorizations, ilut c           will stop with an error message. c c On return: c=========== c c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju      = integer array of length n containing the pointers to c           the beginning of each row of U in the matrix alu,jlu. c c ierr    = integer. Error message with the following meaning. c           ierr  = 0    --> successful return. c           ierr .gt. 0  --> zero pivot encountered at step number ierr. c           ierr  = -1   --> Error. input matrix may be wrong. c                            (The elimination process has generated a c                            row in L or U whose length is .gt.  n.) c           ierr  = -2   --> The matrix L overflows the array al. c           ierr  = -3   --> The matrix U overflows the array alu. c           ierr  = -4   --> Illegal value for lfil. c           ierr  = -5   --> zero row encountered. c c work arrays: c============= c jw      = integer work array of length 2*n. c w       = real work array of length n+1. c c---------------------------------------------------------------------- c w, ju (1:n) store the working array [1:ii-1 = L-part, ii:n = u] c jw(n+1:2n)  stores nonzero indicators c c Notes: c ------ c The diagonal elements of the input matrix must be  nonzero (at least c 'structurally'). c c----------------------------------------------------------------------* c---- Dual drop strategy works as follows.                             * c                                                                      * c     1) Theresholding in L and U as set by droptol. Any element whose * c        magnitude is less than some tolerance (relative to the abs    * c        value of diagonal element in u) is dropped.                   * c                                                                      * c     2) Keeping only the largest lfil elements in the i-th row of L   * c        and the largest lfil elements in the i-th row of U (excluding * c        diagonal elements).                                           * c                                                                      * c Flexibility: one  can use  droptol=0  to get  a strategy  based on   * c keeping  the largest  elements in  each row  of L  and U.   Taking   * c droptol .ne.  0 but lfil=n will give  the usual threshold strategy   * c (however, fill-in is then mpredictible).                             * c----------------------------------------------------------------------* c     locals integer ju0 , k , j1 , j2 , j , ii , i , lenl , lenu , jj , jrow , jpos , len real * 8 tnorm , t , abs , s , fact if ( lfil . lt . 0 ) goto 998 c----------------------------------------------------------------------- c     initialize ju0 (points to next element to be added to alu,jlu) c     and pointer array. c----------------------------------------------------------------------- ju0 = n + 2 jlu ( 1 ) = ju0 c c     initialize nonzero indicator array. c do 1 j = 1 , n jw ( n + j ) = 0 1 continue c----------------------------------------------------------------------- c     beginning of main loop. c----------------------------------------------------------------------- do 500 ii = 1 , n j1 = ia ( ii ) j2 = ia ( ii + 1 ) - 1 tnorm = 0.0d0 do 501 k = j1 , j2 tnorm = tnorm + abs ( a ( k )) 501 continue if ( tnorm . eq . 0.0 ) goto 999 tnorm = tnorm / real ( j2 - j1 + 1 ) c c     unpack L-part and U-part of row of A in arrays w c lenu = 1 lenl = 0 jw ( ii ) = ii w ( ii ) = 0.0 jw ( n + ii ) = ii c do 170 j = j1 , j2 k = ja ( j ) t = a ( j ) if ( k . lt . ii ) then lenl = lenl + 1 jw ( lenl ) = k w ( lenl ) = t jw ( n + k ) = lenl else if ( k . eq . ii ) then w ( ii ) = t else lenu = lenu + 1 jpos = ii + lenu - 1 jw ( jpos ) = k w ( jpos ) = t jw ( n + k ) = jpos endif 170 continue jj = 0 len = 0 c c     eliminate previous rows c 150 jj = jj + 1 if ( jj . gt . lenl ) goto 160 c----------------------------------------------------------------------- c     in order to do the elimination in the correct order we must select c     the smallest column index among jw(k), k=jj+1, ..., lenl. c----------------------------------------------------------------------- jrow = jw ( jj ) k = jj c c     determine smallest column index c do 151 j = jj + 1 , lenl if ( jw ( j ) . lt . jrow ) then jrow = jw ( j ) k = j endif 151 continue c if ( k . ne . jj ) then c     exchange in jw j = jw ( jj ) jw ( jj ) = jw ( k ) jw ( k ) = j c     exchange in jr jw ( n + jrow ) = jj jw ( n + j ) = k c     exchange in w s = w ( jj ) w ( jj ) = w ( k ) w ( k ) = s endif c c     zero out element in row by setting jw(n+jrow) to zero. c jw ( n + jrow ) = 0 c c     get the multiplier for row to be eliminated (jrow). c fact = w ( jj ) * alu ( jrow ) if ( abs ( fact ) . le . droptol ) goto 150 c c     combine current row and row jrow c do 203 k = ju ( jrow ), jlu ( jrow + 1 ) - 1 s = fact * alu ( k ) j = jlu ( k ) jpos = jw ( n + j ) if ( j . ge . ii ) then c c     dealing with upper part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenu = lenu + 1 if ( lenu . gt . n ) goto 995 i = ii + lenu - 1 jw ( i ) = j jw ( n + j ) = i w ( i ) = - s else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s endif else c c     dealing  with lower part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenl = lenl + 1 if ( lenl . gt . n ) goto 995 jw ( lenl ) = j jw ( n + j ) = lenl w ( lenl ) = - s else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s endif endif 203 continue c c     store this pivot element -- (from left to right -- no danger of c     overlap with the working elements in L (pivots). c len = len + 1 w ( len ) = fact jw ( len ) = jrow goto 150 160 continue c c     reset double-pointer to zero (U-part) c do 308 k = 1 , lenu jw ( n + jw ( ii + k - 1 )) = 0 308 continue c c     update L-matrix c lenl = len len = min0 ( lenl , lfil ) c c     sort by quick-split c call qsplit ( w , jw , lenl , len ) c c     store L-part c do 204 k = 1 , len if ( ju0 . gt . iwk ) goto 996 alu ( ju0 ) = w ( k ) jlu ( ju0 ) = jw ( k ) ju0 = ju0 + 1 204 continue c c     save pointer to beginning of row ii of U c ju ( ii ) = ju0 c c     update U-matrix -- first apply dropping strategy c len = 0 do k = 1 , lenu - 1 if ( abs ( w ( ii + k )) . gt . droptol * tnorm ) then len = len + 1 w ( ii + len ) = w ( ii + k ) jw ( ii + len ) = jw ( ii + k ) endif enddo lenu = len + 1 len = min0 ( lenu , lfil ) c call qsplit ( w ( ii + 1 ), jw ( ii + 1 ), lenu - 1 , len ) c c     copy c t = abs ( w ( ii )) if ( len + ju0 . gt . iwk ) goto 997 do 302 k = ii + 1 , ii + len - 1 jlu ( ju0 ) = jw ( k ) alu ( ju0 ) = w ( k ) t = t + abs ( w ( k ) ) ju0 = ju0 + 1 302 continue c c     store inverse of diagonal element of u c if ( w ( ii ) . eq . 0.0 ) w ( ii ) = ( 0.0001 + droptol ) * tnorm c alu ( ii ) = 1.0d0 / w ( ii ) c c     update pointer to beginning of next row of U. c jlu ( ii + 1 ) = ju0 c----------------------------------------------------------------------- c     end main loop c----------------------------------------------------------------------- 500 continue ierr = 0 return c c     incomprehensible error. Matrix must be wrong. c 995 ierr = - 1 return c c     insufficient storage in L. c 996 ierr = - 2 return c c     insufficient storage in U. c 997 ierr = - 3 return c c     illegal lfil entered. c 998 ierr = - 4 return c c     zero row encountered c 999 ierr = - 5 return c----------------end-of-ilut-------------------------------------------- c----------------------------------------------------------------------- end c---------------------------------------------------------------------- subroutine ilutp ( n , a , ja , ia , lfil , droptol , permtol , mbloc , alu , * jlu , ju , iwk , w , jw , iperm , ierr ) c----------------------------------------------------------------------- implicit none integer n , ja ( * ), ia ( n + 1 ), lfil , jlu ( * ), ju ( n ), jw ( 2 * n ), iwk , * iperm ( 2 * n ), ierr real * 8 a ( * ), alu ( * ), w ( n + 1 ), droptol c----------------------------------------------------------------------* c       *** ILUTP preconditioner -- ILUT with pivoting  ***            * c      incomplete LU factorization with dual truncation mechanism      * c----------------------------------------------------------------------* c author Yousef Saad *Sep 8, 1993 -- Latest revision, August 1996.     * c----------------------------------------------------------------------* c on entry: c========== c n       = integer. The dimension of the matrix A. c c a,ja,ia = matrix stored in Compressed Sparse Row format. c           ON RETURN THE COLUMNS OF A ARE PERMUTED. SEE BELOW FOR c           DETAILS. c c lfil    = integer. The fill-in parameter. Each row of L and each row c           of U will have a maximum of lfil elements (excluding the c           diagonal element). lfil must be .ge. 0. c           ** WARNING: THE MEANING OF LFIL HAS CHANGED WITH RESPECT TO c           EARLIER VERSIONS. c c droptol = real*8. Sets the threshold for dropping small terms in the c           factorization. See below for details on dropping strategy. c c lfil    = integer. The fill-in parameter. Each row of L and c           each row of U will have a maximum of lfil elements. c           WARNING: THE MEANING OF LFIL HAS CHANGED WITH RESPECT TO c           EARLIER VERSIONS. c           lfil must be .ge. 0. c c permtol = tolerance ratio used to  determne whether or not to permute c           two columns.  At step i columns i and j are permuted when c c                     abs(a(i,j))*permtol .gt. abs(a(i,i)) c c           [0 --> never permute; good values 0.1 to 0.01] c c mbloc   = if desired, permuting can be done only within the diagonal c           blocks of size mbloc. Useful for PDE problems with several c           degrees of freedom.. If feature not wanted take mbloc=n. c c c iwk     = integer. The lengths of arrays alu and jlu. If the arrays c           are not big enough to store the ILU factorizations, ilut c           will stop with an error message. c c On return: c=========== c c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju      = integer array of length n containing the pointers to c           the beginning of each row of U in the matrix alu,jlu. c c iperm   = contains the permutation arrays. c           iperm(1:n) = old numbers of unknowns c           iperm(n+1:2*n) = reverse permutation = new unknowns. c c ierr    = integer. Error message with the following meaning. c           ierr  = 0    --> successful return. c           ierr .gt. 0  --> zero pivot encountered at step number ierr. c           ierr  = -1   --> Error. input matrix may be wrong. c                            (The elimination process has generated a c                            row in L or U whose length is .gt.  n.) c           ierr  = -2   --> The matrix L overflows the array al. c           ierr  = -3   --> The matrix U overflows the array alu. c           ierr  = -4   --> Illegal value for lfil. c           ierr  = -5   --> zero row encountered. c c work arrays: c============= c jw      = integer work array of length 2*n. c w       = real work array of length n c c IMPORTANR NOTE: c -------------- c TO AVOID PERMUTING THE SOLUTION VECTORS ARRAYS FOR EACH LU-SOLVE, C THE MATRIX A IS PERMUTED ON RETURN. [all column indices are c changed]. SIMILARLY FOR THE U MATRIX. c To permute the matrix back to its original state use the loop: c c      do k=ia(1), ia(n+1)-1 c         ja(k) = iperm(ja(k)) c      enddo c c----------------------------------------------------------------------- c     local variables c integer k , i , j , jrow , ju0 , ii , j1 , j2 , jpos , len , imax , lenu , lenl , jj , mbloc , * icut real * 8 s , tmp , tnorm , xmax , xmax0 , fact , abs , t , permtol c if ( lfil . lt . 0 ) goto 998 c----------------------------------------------------------------------- c     initialize ju0 (points to next element to be added to alu,jlu) c     and pointer array. c----------------------------------------------------------------------- ju0 = n + 2 jlu ( 1 ) = ju0 c c  integer double pointer array. c do 1 j = 1 , n jw ( n + j ) = 0 iperm ( j ) = j iperm ( n + j ) = j 1 continue c----------------------------------------------------------------------- c     beginning of main loop. c----------------------------------------------------------------------- do 500 ii = 1 , n j1 = ia ( ii ) j2 = ia ( ii + 1 ) - 1 tnorm = 0.0d0 do 501 k = j1 , j2 tnorm = tnorm + abs ( a ( k )) 501 continue if ( tnorm . eq . 0.0 ) goto 999 tnorm = tnorm / ( j2 - j1 + 1 ) c c     unpack L-part and U-part of row of A in arrays  w  -- c lenu = 1 lenl = 0 jw ( ii ) = ii w ( ii ) = 0.0 jw ( n + ii ) = ii c do 170 j = j1 , j2 k = iperm ( n + ja ( j )) t = a ( j ) if ( k . lt . ii ) then lenl = lenl + 1 jw ( lenl ) = k w ( lenl ) = t jw ( n + k ) = lenl else if ( k . eq . ii ) then w ( ii ) = t else lenu = lenu + 1 jpos = ii + lenu - 1 jw ( jpos ) = k w ( jpos ) = t jw ( n + k ) = jpos endif 170 continue jj = 0 len = 0 c c     eliminate previous rows c 150 jj = jj + 1 if ( jj . gt . lenl ) goto 160 c----------------------------------------------------------------------- c     in order to do the elimination in the correct order we must select c     the smallest column index among jw(k), k=jj+1, ..., lenl. c----------------------------------------------------------------------- jrow = jw ( jj ) k = jj c c     determine smallest column index c do 151 j = jj + 1 , lenl if ( jw ( j ) . lt . jrow ) then jrow = jw ( j ) k = j endif 151 continue c if ( k . ne . jj ) then c     exchange in jw j = jw ( jj ) jw ( jj ) = jw ( k ) jw ( k ) = j c     exchange in jr jw ( n + jrow ) = jj jw ( n + j ) = k c     exchange in w s = w ( jj ) w ( jj ) = w ( k ) w ( k ) = s endif c c     zero out element in row by resetting jw(n+jrow) to zero. c jw ( n + jrow ) = 0 c c     get the multiplier for row to be eliminated: jrow c fact = w ( jj ) * alu ( jrow ) c c     drop term if small c if ( abs ( fact ) . le . droptol ) goto 150 c c     combine current row and row jrow c do 203 k = ju ( jrow ), jlu ( jrow + 1 ) - 1 s = fact * alu ( k ) c     new column number j = iperm ( n + jlu ( k )) jpos = jw ( n + j ) if ( j . ge . ii ) then c c     dealing with upper part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenu = lenu + 1 i = ii + lenu - 1 if ( lenu . gt . n ) goto 995 jw ( i ) = j jw ( n + j ) = i w ( i ) = - s else c     no fill-in element -- w ( jpos ) = w ( jpos ) - s endif else c c     dealing with lower part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenl = lenl + 1 if ( lenl . gt . n ) goto 995 jw ( lenl ) = j jw ( n + j ) = lenl w ( lenl ) = - s else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s endif endif 203 continue c c     store this pivot element -- (from left to right -- no danger of c     overlap with the working elements in L (pivots). c len = len + 1 w ( len ) = fact jw ( len ) = jrow goto 150 160 continue c c     reset double-pointer to zero (U-part) c do 308 k = 1 , lenu jw ( n + jw ( ii + k - 1 )) = 0 308 continue c c     update L-matrix c lenl = len len = min0 ( lenl , lfil ) c c     sort by quick-split c call qsplit ( w , jw , lenl , len ) c c     store L-part -- in original coordinates .. c do 204 k = 1 , len if ( ju0 . gt . iwk ) goto 996 alu ( ju0 ) = w ( k ) jlu ( ju0 ) = iperm ( jw ( k )) ju0 = ju0 + 1 204 continue c c     save pointer to beginning of row ii of U c ju ( ii ) = ju0 c c     update U-matrix -- first apply dropping strategy c len = 0 do k = 1 , lenu - 1 if ( abs ( w ( ii + k )) . gt . droptol * tnorm ) then len = len + 1 w ( ii + len ) = w ( ii + k ) jw ( ii + len ) = jw ( ii + k ) endif enddo lenu = len + 1 len = min0 ( lenu , lfil ) call qsplit ( w ( ii + 1 ), jw ( ii + 1 ), lenu - 1 , len ) c c     determine next pivot -- c imax = ii xmax = abs ( w ( imax )) xmax0 = xmax icut = ii - 1 + mbloc - mod ( ii - 1 , mbloc ) do k = ii + 1 , ii + len - 1 t = abs ( w ( k )) if ( t . gt . xmax . and . t * permtol . gt . xmax0 . and . * jw ( k ) . le . icut ) then imax = k xmax = t endif enddo c c     exchange w's c tmp = w ( ii ) w ( ii ) = w ( imax ) w ( imax ) = tmp c c     update iperm and reverse iperm c j = jw ( imax ) i = iperm ( ii ) iperm ( ii ) = iperm ( j ) iperm ( j ) = i c c     reverse iperm c iperm ( n + iperm ( ii )) = ii iperm ( n + iperm ( j )) = j c----------------------------------------------------------------------- c if ( len + ju0 . gt . iwk ) goto 997 c c     copy U-part in original coordinates c do 302 k = ii + 1 , ii + len - 1 jlu ( ju0 ) = iperm ( jw ( k )) alu ( ju0 ) = w ( k ) ju0 = ju0 + 1 302 continue c c     store inverse of diagonal element of u c if ( w ( ii ) . eq . 0.0 ) w ( ii ) = ( 1.0D-4 + droptol ) * tnorm alu ( ii ) = 1.0d0 / w ( ii ) c c     update pointer to beginning of next row of U. c jlu ( ii + 1 ) = ju0 c----------------------------------------------------------------------- c     end main loop c----------------------------------------------------------------------- 500 continue c c     permute all column indices of LU ... c do k = jlu ( 1 ), jlu ( n + 1 ) - 1 jlu ( k ) = iperm ( n + jlu ( k )) enddo c c     ...and of A c do k = ia ( 1 ), ia ( n + 1 ) - 1 ja ( k ) = iperm ( n + ja ( k )) enddo c ierr = 0 return c c     incomprehensible error. Matrix must be wrong. c 995 ierr = - 1 return c c     insufficient storage in L. c 996 ierr = - 2 return c c     insufficient storage in U. c 997 ierr = - 3 return c c     illegal lfil entered. c 998 ierr = - 4 return c c     zero row encountered c 999 ierr = - 5 return c----------------end-of-ilutp------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ilud ( n , a , ja , ia , alph , tol , alu , jlu , ju , iwk , w , jw , ierr ) c----------------------------------------------------------------------- implicit none integer n real * 8 a ( * ), alu ( * ), w ( 2 * n ), tol , alph integer ja ( * ), ia ( n + 1 ), jlu ( * ), ju ( n ), jw ( 2 * n ), iwk , ierr c----------------------------------------------------------------------* c                     *** ILUD preconditioner ***                      * c    incomplete LU factorization with standard droppoing strategy      * c----------------------------------------------------------------------* c Author: Yousef Saad * Aug. 1995 --                                   * c----------------------------------------------------------------------* c This routine computes the ILU factorization with standard threshold  * c dropping: at i-th step of elimination, an element a(i,j) in row i is * c dropped  if it satisfies the criterion:                              * c                                                                      * c  abs(a(i,j)) < tol * [average magnitude of elements in row i of A]   * c                                                                      * c There is no control on memory size required for the factors as is    * c done in ILUT. This routines computes also various diagonal compensa- * c tion ILU's such MILU. These are defined through the parameter alph   * c----------------------------------------------------------------------* c on entry: c========== c n       = integer. The row dimension of the matrix A. The matrix c c a,ja,ia = matrix stored in Compressed Sparse Row format c c alph    = diagonal compensation parameter -- the term: c c           alph*(sum of all dropped out elements in a given row) c c           is added to the diagonal element of U of the factorization c           Thus: alph = 0 ---> ~ ILU with threshold, c                 alph = 1 ---> ~ MILU with threshold. c c tol     = Threshold parameter for dropping small terms in the c           factorization. During the elimination, a term a(i,j) is c           dropped whenever abs(a(i,j)) .lt. tol * [weighted norm of c           row i]. Here weighted norm = 1-norm / number of nnz c           elements in the row. c c iwk     = The length of arrays alu and jlu -- this routine will stop c           if storage for the factors L and U is not sufficient c c On return: c=========== c c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju      = integer array of length n containing the pointers to c           the beginning of each row of U in the matrix alu,jlu. c c ierr    = integer. Error message with the following meaning. c           ierr  = 0    --> successful return. c           ierr .gt. 0  --> zero pivot encountered at step number ierr. c           ierr  = -1   --> Error. input matrix may be wrong. c                            (The elimination process has generated a c                            row in L or U whose length is .gt.  n.) c           ierr  = -2   --> Insufficient storage for the LU factors -- c                            arrays alu/ jalu are  overflowed. c           ierr  = -3   --> Zero row encountered. c c Work Arrays: c============= c jw      = integer work array of length 2*n. c w       = real work array of length n c c---------------------------------------------------------------------- c c w, ju (1:n) store the working array [1:ii-1 = L-part, ii:n = u] c jw(n+1:2n)  stores the nonzero indicator. c c Notes: c ------ c All diagonal elements of the input matrix must be  nonzero. c c----------------------------------------------------------------------- c     locals integer ju0 , k , j1 , j2 , j , ii , i , lenl , lenu , jj , jrow , jpos , len real * 8 tnorm , t , abs , s , fact , dropsum c----------------------------------------------------------------------- c     initialize ju0 (points to next element to be added to alu,jlu) c     and pointer array. c----------------------------------------------------------------------- ju0 = n + 2 jlu ( 1 ) = ju0 c c     initialize nonzero indicator array. c do 1 j = 1 , n jw ( n + j ) = 0 1 continue c----------------------------------------------------------------------- c     beginning of main loop. c----------------------------------------------------------------------- do 500 ii = 1 , n j1 = ia ( ii ) j2 = ia ( ii + 1 ) - 1 dropsum = 0.0d0 tnorm = 0.0d0 do 501 k = j1 , j2 tnorm = tnorm + abs ( a ( k )) 501 continue if ( tnorm . eq . 0.0 ) goto 997 tnorm = tnorm / real ( j2 - j1 + 1 ) c c     unpack L-part and U-part of row of A in arrays w c lenu = 1 lenl = 0 jw ( ii ) = ii w ( ii ) = 0.0 jw ( n + ii ) = ii c do 170 j = j1 , j2 k = ja ( j ) t = a ( j ) if ( k . lt . ii ) then lenl = lenl + 1 jw ( lenl ) = k w ( lenl ) = t jw ( n + k ) = lenl else if ( k . eq . ii ) then w ( ii ) = t else lenu = lenu + 1 jpos = ii + lenu - 1 jw ( jpos ) = k w ( jpos ) = t jw ( n + k ) = jpos endif 170 continue jj = 0 len = 0 c c     eliminate previous rows c 150 jj = jj + 1 if ( jj . gt . lenl ) goto 160 c----------------------------------------------------------------------- c     in order to do the elimination in the correct order we must select c     the smallest column index among jw(k), k=jj+1, ..., lenl. c----------------------------------------------------------------------- jrow = jw ( jj ) k = jj c c     determine smallest column index c do 151 j = jj + 1 , lenl if ( jw ( j ) . lt . jrow ) then jrow = jw ( j ) k = j endif 151 continue c if ( k . ne . jj ) then c     exchange in jw j = jw ( jj ) jw ( jj ) = jw ( k ) jw ( k ) = j c     exchange in jr jw ( n + jrow ) = jj jw ( n + j ) = k c     exchange in w s = w ( jj ) w ( jj ) = w ( k ) w ( k ) = s endif c c     zero out element in row by setting resetting jw(n+jrow) to zero. c jw ( n + jrow ) = 0 c c     drop term if small c c         if (abs(w(jj)) .le. tol*tnorm) then c            dropsum = dropsum + w(jj) c            goto 150 c         endif c c     get the multiplier for row to be eliminated (jrow). c fact = w ( jj ) * alu ( jrow ) c c     drop term if small c if ( abs ( fact ) . le . tol ) then dropsum = dropsum + w ( jj ) goto 150 endif c c     combine current row and row jrow c do 203 k = ju ( jrow ), jlu ( jrow + 1 ) - 1 s = fact * alu ( k ) j = jlu ( k ) jpos = jw ( n + j ) if ( j . ge . ii ) then c c     dealing with upper part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenu = lenu + 1 if ( lenu . gt . n ) goto 995 i = ii + lenu - 1 jw ( i ) = j jw ( n + j ) = i w ( i ) = - s else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s endif else c c     dealing with lower part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenl = lenl + 1 if ( lenl . gt . n ) goto 995 jw ( lenl ) = j jw ( n + j ) = lenl w ( lenl ) = - s else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s endif endif 203 continue len = len + 1 w ( len ) = fact jw ( len ) = jrow goto 150 160 continue c c     reset double-pointer to zero (For U-part only) c do 308 k = 1 , lenu jw ( n + jw ( ii + k - 1 )) = 0 308 continue c c     update l-matrix c do 204 k = 1 , len if ( ju0 . gt . iwk ) goto 996 alu ( ju0 ) = w ( k ) jlu ( ju0 ) = jw ( k ) ju0 = ju0 + 1 204 continue c c     save pointer to beginning of row ii of U c ju ( ii ) = ju0 c c     go through elements in U-part of w to determine elements to keep c len = 0 do k = 1 , lenu - 1 c            if (abs(w(ii+k)) .gt. tnorm*tol) then if ( abs ( w ( ii + k )) . gt . abs ( w ( ii )) * tol ) then len = len + 1 w ( ii + len ) = w ( ii + k ) jw ( ii + len ) = jw ( ii + k ) else dropsum = dropsum + w ( ii + k ) endif enddo c c     now update u-matrix c if ( ju0 + len - 1 . gt . iwk ) goto 996 do 302 k = ii + 1 , ii + len jlu ( ju0 ) = jw ( k ) alu ( ju0 ) = w ( k ) ju0 = ju0 + 1 302 continue c c     define diagonal element c w ( ii ) = w ( ii ) + alph * dropsum c c     store inverse of diagonal element of u c if ( w ( ii ) . eq . 0.0 ) w ( ii ) = ( 0.0001 + tol ) * tnorm c alu ( ii ) = 1.0d0 / w ( ii ) c c     update pointer to beginning of next row of U. c jlu ( ii + 1 ) = ju0 c----------------------------------------------------------------------- c     end main loop c----------------------------------------------------------------------- 500 continue ierr = 0 return c c     incomprehensible error. Matrix must be wrong. c 995 ierr = - 1 return c c     insufficient storage in alu/ jlu arrays for  L / U factors c 996 ierr = - 2 return c c     zero row encountered c 997 ierr = - 3 return c----------------end-of-ilud  ------------------------------------------ c----------------------------------------------------------------------- end c---------------------------------------------------------------------- subroutine iludp ( n , a , ja , ia , alph , droptol , permtol , mbloc , alu , * jlu , ju , iwk , w , jw , iperm , ierr ) c----------------------------------------------------------------------- implicit none integer n , ja ( * ), ia ( n + 1 ), mbloc , jlu ( * ), ju ( n ), jw ( 2 * n ), iwk , * iperm ( 2 * n ), ierr real * 8 a ( * ), alu ( * ), w ( 2 * n ), alph , droptol , permtol c----------------------------------------------------------------------* c                     *** ILUDP preconditioner ***                     * c    incomplete LU factorization with standard droppoing strategy      * c    and column pivoting                                               * c----------------------------------------------------------------------* c author Yousef Saad -- Aug 1995.                                      * c----------------------------------------------------------------------* c on entry: c========== c n       = integer. The dimension of the matrix A. c c a,ja,ia = matrix stored in Compressed Sparse Row format. c           ON RETURN THE COLUMNS OF A ARE PERMUTED. c c alph    = diagonal compensation parameter -- the term: c c           alph*(sum of all dropped out elements in a given row) c c           is added to the diagonal element of U of the factorization c           Thus: alph = 0 ---> ~ ILU with threshold, c                 alph = 1 ---> ~ MILU with threshold. c c droptol = tolerance used for dropping elements in L and U. c           elements are dropped if they are .lt. norm(row) x droptol c           row = row being eliminated c c permtol = tolerance ratio used for determning whether to permute c           two columns.  Two columns are permuted only when c           abs(a(i,j))*permtol .gt. abs(a(i,i)) c           [0 --> never permute; good values 0.1 to 0.01] c c mbloc   = if desired, permuting can be done only within the diagonal c           blocks of size mbloc. Useful for PDE problems with several c           degrees of freedom.. If feature not wanted take mbloc=n. c c iwk     = integer. The declared lengths of arrays alu and jlu c           if iwk is not large enough the code will stop prematurely c           with ierr = -2 or ierr = -3 (see below). c c On return: c=========== c c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju      = integer array of length n containing the pointers to c           the beginning of each row of U in the matrix alu,jlu. c iperm   = contains the permutation arrays .. c           iperm(1:n) = old numbers of unknowns c           iperm(n+1:2*n) = reverse permutation = new unknowns. c c ierr    = integer. Error message with the following meaning. c           ierr  = 0    --> successful return. c           ierr .gt. 0  --> zero pivot encountered at step number ierr. c           ierr  = -1   --> Error. input matrix may be wrong. c                            (The elimination process has generated a c                            row in L or U whose length is .gt.  n.) c           ierr  = -2   --> The L/U matrix overflows the arrays alu,jlu c           ierr  = -3   --> zero row encountered. c c work arrays: c============= c jw      = integer work array of length 2*n. c w       = real work array of length 2*n c c Notes: c ------ c IMPORTANT: TO AVOID PERMUTING THE SOLUTION VECTORS ARRAYS FOR EACH c LU-SOLVE, THE MATRIX A IS PERMUTED ON RETURN. [all column indices are c changed]. SIMILARLY FOR THE U MATRIX. c To permute the matrix back to its original state use the loop: c c      do k=ia(1), ia(n+1)-1 c         ja(k) = perm(ja(k)) c      enddo c c----------------------------------------------------------------------- c     local variables c integer k , i , j , jrow , ju0 , ii , j1 , j2 , jpos , len , imax , lenu , lenl , jj , icut real * 8 s , tmp , tnorm , xmax , xmax0 , fact , abs , t , dropsum c----------------------------------------------------------------------- c     initialize ju0 (points to next element to be added to alu,jlu) c     and pointer array. c----------------------------------------------------------------------- ju0 = n + 2 jlu ( 1 ) = ju0 c c  integer double pointer array. c do 1 j = 1 , n jw ( n + j ) = 0 iperm ( j ) = j iperm ( n + j ) = j 1 continue c----------------------------------------------------------------------- c     beginning of main loop. c----------------------------------------------------------------------- do 500 ii = 1 , n j1 = ia ( ii ) j2 = ia ( ii + 1 ) - 1 dropsum = 0.0d0 tnorm = 0.0d0 do 501 k = j1 , j2 tnorm = tnorm + abs ( a ( k )) 501 continue if ( tnorm . eq . 0.0 ) goto 997 tnorm = tnorm / ( j2 - j1 + 1 ) c c     unpack L-part and U-part of row of A in arrays  w  -- c lenu = 1 lenl = 0 jw ( ii ) = ii w ( ii ) = 0.0 jw ( n + ii ) = ii c do 170 j = j1 , j2 k = iperm ( n + ja ( j )) t = a ( j ) if ( k . lt . ii ) then lenl = lenl + 1 jw ( lenl ) = k w ( lenl ) = t jw ( n + k ) = lenl else if ( k . eq . ii ) then w ( ii ) = t else lenu = lenu + 1 jpos = ii + lenu - 1 jw ( jpos ) = k w ( jpos ) = t jw ( n + k ) = jpos endif 170 continue jj = 0 len = 0 c c     eliminate previous rows c 150 jj = jj + 1 if ( jj . gt . lenl ) goto 160 c----------------------------------------------------------------------- c     in order to do the elimination in the correct order we must select c     the smallest column index among jw(k), k=jj+1, ..., lenl. c----------------------------------------------------------------------- jrow = jw ( jj ) k = jj c c     determine smallest column index c do 151 j = jj + 1 , lenl if ( jw ( j ) . lt . jrow ) then jrow = jw ( j ) k = j endif 151 continue c if ( k . ne . jj ) then c     exchange in jw j = jw ( jj ) jw ( jj ) = jw ( k ) jw ( k ) = j c     exchange in jr jw ( n + jrow ) = jj jw ( n + j ) = k c     exchange in w s = w ( jj ) w ( jj ) = w ( k ) w ( k ) = s endif c c     zero out element in row by resetting jw(n+jrow) to zero. c jw ( n + jrow ) = 0 c c     drop term if small c if ( abs ( w ( jj )) . le . droptol * tnorm ) then dropsum = dropsum + w ( jj ) goto 150 endif c c     get the multiplier for row to be eliminated: jrow c fact = w ( jj ) * alu ( jrow ) c c     combine current row and row jrow c do 203 k = ju ( jrow ), jlu ( jrow + 1 ) - 1 s = fact * alu ( k ) c     new column number j = iperm ( n + jlu ( k )) jpos = jw ( n + j ) c c     if fill-in element is small then disregard: c if ( j . ge . ii ) then c c     dealing with upper part. c if ( jpos . eq . 0 ) then c     this is a fill-in element lenu = lenu + 1 i = ii + lenu - 1 if ( lenu . gt . n ) goto 995 jw ( i ) = j jw ( n + j ) = i w ( i ) = - s else c     no fill-in element -- w ( jpos ) = w ( jpos ) - s endif else c c     dealing with lower part. c if ( jpos . eq . 0 ) then c     this is a fill-in element lenl = lenl + 1 if ( lenl . gt . n ) goto 995 jw ( lenl ) = j jw ( n + j ) = lenl w ( lenl ) = - s else c     no fill-in element -- w ( jpos ) = w ( jpos ) - s endif endif 203 continue len = len + 1 w ( len ) = fact jw ( len ) = jrow goto 150 160 continue c c     reset double-pointer to zero (U-part) c do 308 k = 1 , lenu jw ( n + jw ( ii + k - 1 )) = 0 308 continue c c     update L-matrix c do 204 k = 1 , len if ( ju0 . gt . iwk ) goto 996 alu ( ju0 ) = w ( k ) jlu ( ju0 ) = iperm ( jw ( k )) ju0 = ju0 + 1 204 continue c c     save pointer to beginning of row ii of U c ju ( ii ) = ju0 c c     update u-matrix -- first apply dropping strategy c len = 0 do k = 1 , lenu - 1 if ( abs ( w ( ii + k )) . gt . tnorm * droptol ) then len = len + 1 w ( ii + len ) = w ( ii + k ) jw ( ii + len ) = jw ( ii + k ) else dropsum = dropsum + w ( ii + k ) endif enddo c imax = ii xmax = abs ( w ( imax )) xmax0 = xmax icut = ii - 1 + mbloc - mod ( ii - 1 , mbloc ) c c     determine next pivot -- c do k = ii + 1 , ii + len t = abs ( w ( k )) if ( t . gt . xmax . and . t * permtol . gt . xmax0 . and . * jw ( k ) . le . icut ) then imax = k xmax = t endif enddo c c     exchange w's c tmp = w ( ii ) w ( ii ) = w ( imax ) w ( imax ) = tmp c c     update iperm and reverse iperm c j = jw ( imax ) i = iperm ( ii ) iperm ( ii ) = iperm ( j ) iperm ( j ) = i c     reverse iperm iperm ( n + iperm ( ii )) = ii iperm ( n + iperm ( j )) = j c----------------------------------------------------------------------- if ( len + ju0 - 1 . gt . iwk ) goto 996 c c     copy U-part in original coordinates c do 302 k = ii + 1 , ii + len jlu ( ju0 ) = iperm ( jw ( k )) alu ( ju0 ) = w ( k ) ju0 = ju0 + 1 302 continue c c     define diagonal element c w ( ii ) = w ( ii ) + alph * dropsum c c     store inverse of diagonal element of u c if ( w ( ii ) . eq . 0.0 ) w ( ii ) = ( 1.0D-4 + droptol ) * tnorm c alu ( ii ) = 1.0d0 / w ( ii ) c c     update pointer to beginning of next row of U. c jlu ( ii + 1 ) = ju0 c----------------------------------------------------------------------- c     end main loop c----------------------------------------------------------------------- 500 continue c c     permute all column indices of LU ... c do k = jlu ( 1 ), jlu ( n + 1 ) - 1 jlu ( k ) = iperm ( n + jlu ( k )) enddo c c     ...and of A c do k = ia ( 1 ), ia ( n + 1 ) - 1 ja ( k ) = iperm ( n + ja ( k )) enddo c ierr = 0 return c c     incomprehensible error. Matrix must be wrong. c 995 ierr = - 1 return c c     insufficient storage in arrays alu, jlu to store factors c 996 ierr = - 2 return c c     zero row encountered c 997 ierr = - 3 return c----------------end-of-iludp---------------------------!---------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine iluk ( n , a , ja , ia , lfil , alu , jlu , ju , levs , iwk , w , jw , ierr ) implicit none integer n real * 8 a ( * ), alu ( * ), w ( n ) integer ja ( * ), ia ( n + 1 ), jlu ( * ), ju ( n ), levs ( * ), jw ( 3 * n ), lfil , iwk , ierr c----------------------------------------------------------------------* c     SPARSKIT ROUTINE ILUK -- ILU WITH LEVEL OF FILL-IN OF K (ILU(k)) * c----------------------------------------------------------------------* c c on entry: c========== c n       = integer. The row dimension of the matrix A. The matrix c c a,ja,ia = matrix stored in Compressed Sparse Row format. c c lfil    = integer. The fill-in parameter. Each element whose c           leve-of-fill exceeds lfil during the ILU process is dropped. c           lfil must be .ge. 0 c c tol     = real*8. Sets the threshold for dropping small terms in the c           factorization. See below for details on dropping strategy. c c iwk     = integer. The minimum length of arrays alu, jlu, and levs. c c On return: c=========== c c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju      = integer array of length n containing the pointers to c           the beginning of each row of U in the matrix alu,jlu. c c levs    = integer (work) array of size iwk -- which contains the c           levels of each element in alu, jlu. c c ierr    = integer. Error message with the following meaning. c           ierr  = 0    --> successful return. c           ierr .gt. 0  --> zero pivot encountered at step number ierr. c           ierr  = -1   --> Error. input matrix may be wrong. c                            (The elimination process has generated a c                            row in L or U whose length is .gt.  n.) c           ierr  = -2   --> The matrix L overflows the array al. c           ierr  = -3   --> The matrix U overflows the array alu. c           ierr  = -4   --> Illegal value for lfil. c           ierr  = -5   --> zero row encountered in A or U. c c work arrays: c============= c jw      = integer work array of length 3*n. c w       = real work array of length n c c Notes/known bugs: This is not implemented efficiently storage-wise. c       For example: Only the part of the array levs(*) associated with c       the U-matrix is needed in the routine.. So some storage can c       be saved if needed. The levels of fills in the LU matrix are c       output for information only -- they are not needed by LU-solve. c c---------------------------------------------------------------------- c w, ju (1:n) store the working array [1:ii-1 = L-part, ii:n = u] c jw(n+1:2n)  stores the nonzero indicator. c c Notes: c ------ c All the diagonal elements of the input matrix must be  nonzero. c c----------------------------------------------------------------------* c     locals integer ju0 , k , j1 , j2 , j , ii , i , lenl , lenu , jj , jrow , jpos , n2 , * jlev , min real * 8 t , s , fact if ( lfil . lt . 0 ) goto 998 c----------------------------------------------------------------------- c     initialize ju0 (points to next element to be added to alu,jlu) c     and pointer array. c----------------------------------------------------------------------- n2 = n + n ju0 = n + 2 jlu ( 1 ) = ju0 c c     initialize nonzero indicator array + levs array -- c do 1 j = 1 , 2 * n jw ( j ) = 0 1 continue c----------------------------------------------------------------------- c     beginning of main loop. c----------------------------------------------------------------------- do 500 ii = 1 , n j1 = ia ( ii ) j2 = ia ( ii + 1 ) - 1 c c     unpack L-part and U-part of row of A in arrays w c lenu = 1 lenl = 0 jw ( ii ) = ii w ( ii ) = 0.0 jw ( n + ii ) = ii c do 170 j = j1 , j2 k = ja ( j ) t = a ( j ) if ( t . eq . 0.0 ) goto 170 if ( k . lt . ii ) then lenl = lenl + 1 jw ( lenl ) = k w ( lenl ) = t jw ( n2 + lenl ) = 0 jw ( n + k ) = lenl else if ( k . eq . ii ) then w ( ii ) = t jw ( n2 + ii ) = 0 else lenu = lenu + 1 jpos = ii + lenu - 1 jw ( jpos ) = k w ( jpos ) = t jw ( n2 + jpos ) = 0 jw ( n + k ) = jpos endif 170 continue c jj = 0 c c     eliminate previous rows c 150 jj = jj + 1 if ( jj . gt . lenl ) goto 160 c----------------------------------------------------------------------- c     in order to do the elimination in the correct order we must select c     the smallest column index among jw(k), k=jj+1, ..., lenl. c----------------------------------------------------------------------- jrow = jw ( jj ) k = jj c c     determine smallest column index c do 151 j = jj + 1 , lenl if ( jw ( j ) . lt . jrow ) then jrow = jw ( j ) k = j endif 151 continue c if ( k . ne . jj ) then c     exchange in jw j = jw ( jj ) jw ( jj ) = jw ( k ) jw ( k ) = j c     exchange in jw(n+  (pointers/ nonzero indicator). jw ( n + jrow ) = jj jw ( n + j ) = k c     exchange in jw(n2+  (levels) j = jw ( n2 + jj ) jw ( n2 + jj ) = jw ( n2 + k ) jw ( n2 + k ) = j c     exchange in w s = w ( jj ) w ( jj ) = w ( k ) w ( k ) = s endif c c     zero out element in row by resetting jw(n+jrow) to zero. c jw ( n + jrow ) = 0 c c     get the multiplier for row to be eliminated (jrow) + its level c fact = w ( jj ) * alu ( jrow ) jlev = jw ( n2 + jj ) if ( jlev . gt . lfil ) goto 150 c c     combine current row and row jrow c do 203 k = ju ( jrow ), jlu ( jrow + 1 ) - 1 s = fact * alu ( k ) j = jlu ( k ) jpos = jw ( n + j ) if ( j . ge . ii ) then c c     dealing with upper part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenu = lenu + 1 if ( lenu . gt . n ) goto 995 i = ii + lenu - 1 jw ( i ) = j jw ( n + j ) = i w ( i ) = - s jw ( n2 + i ) = jlev + levs ( k ) + 1 else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s jw ( n2 + jpos ) = min ( jw ( n2 + jpos ), jlev + levs ( k ) + 1 ) endif else c c     dealing with lower part. c if ( jpos . eq . 0 ) then c c     this is a fill-in element c lenl = lenl + 1 if ( lenl . gt . n ) goto 995 jw ( lenl ) = j jw ( n + j ) = lenl w ( lenl ) = - s jw ( n2 + lenl ) = jlev + levs ( k ) + 1 else c c     this is not a fill-in element c w ( jpos ) = w ( jpos ) - s jw ( n2 + jpos ) = min ( jw ( n2 + jpos ), jlev + levs ( k ) + 1 ) endif endif 203 continue w ( jj ) = fact jw ( jj ) = jrow goto 150 160 continue c c     reset double-pointer to zero (U-part) c do 308 k = 1 , lenu jw ( n + jw ( ii + k - 1 )) = 0 308 continue c c     update l-matrix c do 204 k = 1 , lenl if ( ju0 . gt . iwk ) goto 996 if ( jw ( n2 + k ) . le . lfil ) then alu ( ju0 ) = w ( k ) jlu ( ju0 ) = jw ( k ) ju0 = ju0 + 1 endif 204 continue c c     save pointer to beginning of row ii of U c ju ( ii ) = ju0 c c     update u-matrix c do 302 k = ii + 1 , ii + lenu - 1 if ( ju0 . gt . iwk ) goto 997 if ( jw ( n2 + k ) . le . lfil ) then jlu ( ju0 ) = jw ( k ) alu ( ju0 ) = w ( k ) levs ( ju0 ) = jw ( n2 + k ) ju0 = ju0 + 1 endif 302 continue if ( w ( ii ) . eq . 0.0 ) goto 999 c alu ( ii ) = 1.0d0 / w ( ii ) c c     update pointer to beginning of next row of U. c jlu ( ii + 1 ) = ju0 c----------------------------------------------------------------------- c     end main loop c----------------------------------------------------------------------- 500 continue ierr = 0 return c c     incomprehensible error. Matrix must be wrong. c 995 ierr = - 1 return c c     insufficient storage in L. c 996 ierr = - 2 return c c     insufficient storage in U. c 997 ierr = - 3 return c c     illegal lfil entered. c 998 ierr = - 4 return c c     zero row encountered in A or U. c 999 ierr = - 5 return c----------------end-of-iluk-------------------------------------------- c----------------------------------------------------------------------- end c---------------------------------------------------------------------- subroutine ilu0 ( n , a , ja , ia , alu , jlu , ju , iw , ierr ) c       implicit real*8 (a-h,o-z) implicit none real * 8 a ( * ), alu ( * ) integer ja ( * ), ia ( * ), ju ( * ), jlu ( * ), iw ( * ), n , ierr c------------------ right preconditioner ------------------------------* c                    ***   ilu(0) preconditioner.   ***                * c----------------------------------------------------------------------* c Note that this has been coded in such a way that it can be used c with pgmres. Normally, since the data structure of the L+U matrix is c the same as that the A matrix, savings can be made. In fact with c some definitions (not correct for general sparse matrices) all we c need in addition to a, ja, ia is an additional diagonal. c ILU0 is not recommended for serious problems. It is only provided c here for comparison purposes. c----------------------------------------------------------------------- c c on entry: c--------- c n       = dimension of matrix c a, ja, c ia      = original matrix in compressed sparse row storage. c c on return: c----------- c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju         = pointer to the diagonal elements in alu, jlu. c c ierr         = integer indicating error code on return c            ierr = 0 --> normal return c            ierr = k --> code encountered a zero pivot at step k. c work arrays: c------------- c iw           = integer work array of length n. c------------ c IMPORTANT c----------- c it is assumed that the the elements in the input matrix are stored c    in such a way that in each row the lower part comes first and c    then the upper part. To get the correct ILU factorization, it is c    also necessary to have the elements of L sorted by increasing c    column number. It may therefore be necessary to sort the c    elements of a, ja, ia prior to calling ilu0. This can be c    achieved by transposing the matrix twice using csrcsc. c c----------------------------------------------------------------------- integer ju0 , i , j , ii , js , jcol , jf , jm , jj , jrow , jw real * 8 tl ju0 = n + 2 jlu ( 1 ) = ju0 c c initialize work vector to zero's c do 31 i = 1 , n iw ( i ) = 0 31 continue c c main loop c do 500 ii = 1 , n js = ju0 c c generating row number ii of L and U. c do 100 j = ia ( ii ), ia ( ii + 1 ) - 1 c c     copy row ii of a, ja, ia into row ii of alu, jlu (L/U) matrix. c jcol = ja ( j ) if ( jcol . eq . ii ) then alu ( ii ) = a ( j ) iw ( jcol ) = ii ju ( ii ) = ju0 else alu ( ju0 ) = a ( j ) jlu ( ju0 ) = ja ( j ) iw ( jcol ) = ju0 ju0 = ju0 + 1 endif 100 continue jlu ( ii + 1 ) = ju0 jf = ju0 - 1 jm = ju ( ii ) - 1 c c     exit if diagonal element is reached. c do 150 j = js , jm jrow = jlu ( j ) tl = alu ( j ) * alu ( jrow ) alu ( j ) = tl c c     perform  linear combination c do 140 jj = ju ( jrow ), jlu ( jrow + 1 ) - 1 jw = iw ( jlu ( jj )) if ( jw . ne . 0 ) alu ( jw ) = alu ( jw ) - tl * alu ( jj ) 140 continue 150 continue c c     invert  and store diagonal element. c if ( alu ( ii ) . eq . 0.0d0 ) goto 600 alu ( ii ) = 1.0d0 / alu ( ii ) c c     reset pointer iw to zero c iw ( ii ) = 0 do 201 i = js , jf 201 iw ( jlu ( i )) = 0 500 continue ierr = 0 return c c     zero pivot : c 600 ierr = ii c return c------- end-of-ilu0 --------------------------------------------------- c----------------------------------------------------------------------- end c---------------------------------------------------------------------- subroutine milu0 ( n , a , ja , ia , alu , jlu , ju , iw , ierr ) c       implicit real*8 (a-h,o-z) implicit none real * 8 a ( * ), alu ( * ) integer n , ja ( * ), ia ( * ), ju ( * ), jlu ( * ), iw ( * ), ierr c----------------------------------------------------------------------* c                *** simple milu(0) preconditioner. ***                * c----------------------------------------------------------------------* c Note that this has been coded in such a way that it can be used c with pgmres. Normally, since the data structure of a, ja, ia is c the same as that of a, ja, ia, savings can be made. In fact with c some definitions (not correct for general sparse matrices) all we c need in addition to a, ja, ia is an additional diagonal. c Ilu0 is not recommended for serious problems. It is only provided c here for comparison purposes. c----------------------------------------------------------------------- c c on entry: c---------- c n       = dimension of matrix c a, ja, c ia      = original matrix in compressed sparse row storage. c c on return: c---------- c alu,jlu = matrix stored in Modified Sparse Row (MSR) format containing c           the L and U factors together. The diagonal (stored in c           alu(1:n) ) is inverted. Each i-th row of the alu,jlu matrix c           contains the i-th row of L (excluding the diagonal entry=1) c           followed by the i-th row of U. c c ju         = pointer to the diagonal elements in alu, jlu. c c ierr         = integer indicating error code on return c            ierr = 0 --> normal return c            ierr = k --> code encountered a zero pivot at step k. c work arrays: c------------- c iw           = integer work array of length n. c------------ c Note (IMPORTANT): c----------- C it is assumed that the the elements in the input matrix are ordered c    in such a way that in each row the lower part comes first and c    then the upper part. To get the correct ILU factorization, it is c    also necessary to have the elements of L ordered by increasing c    column number. It may therefore be necessary to sort the c    elements of a, ja, ia prior to calling milu0. This can be c    achieved by transposing the matrix twice using csrcsc. c----------------------------------------------------------- integer ju0 , i , ii , j , js , jcol , jf , jm , jrow , jj , jw real * 8 s , tl ju0 = n + 2 jlu ( 1 ) = ju0 c initialize work vector to zero's do 31 i = 1 , n 31 iw ( i ) = 0 c c-------------- MAIN LOOP ---------------------------------- c do 500 ii = 1 , n js = ju0 c c generating row number ii or L and U. c do 100 j = ia ( ii ), ia ( ii + 1 ) - 1 c c     copy row ii of a, ja, ia into row ii of alu, jlu (L/U) matrix. c jcol = ja ( j ) if ( jcol . eq . ii ) then alu ( ii ) = a ( j ) iw ( jcol ) = ii ju ( ii ) = ju0 else alu ( ju0 ) = a ( j ) jlu ( ju0 ) = ja ( j ) iw ( jcol ) = ju0 ju0 = ju0 + 1 endif 100 continue jlu ( ii + 1 ) = ju0 jf = ju0 - 1 jm = ju ( ii ) - 1 c     s accumulates fill-in values s = 0.0d0 do 150 j = js , jm jrow = jlu ( j ) tl = alu ( j ) * alu ( jrow ) alu ( j ) = tl c-----------------------perform linear combination -------- do 140 jj = ju ( jrow ), jlu ( jrow + 1 ) - 1 jw = iw ( jlu ( jj )) if ( jw . ne . 0 ) then alu ( jw ) = alu ( jw ) - tl * alu ( jj ) else s = s + tl * alu ( jj ) endif 140 continue 150 continue c----------------------- invert and store diagonal element. alu ( ii ) = alu ( ii ) - s if ( alu ( ii ) . eq . 0.0d0 ) goto 600 alu ( ii ) = 1.0d0 / alu ( ii ) c----------------------- reset pointer iw to zero iw ( ii ) = 0 do 201 i = js , jf 201 iw ( jlu ( i )) = 0 500 continue ierr = 0 return c     zero pivot : 600 ierr = ii return c------- end-of-milu0 -------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine pgmres ( n , im , rhs , sol , vv , eps , maxits , iout , * aa , ja , ia , alu , jlu , ju , ierr ) c----------------------------------------------------------------------- c       implicit real*8 (a-h,o-z) implicit none integer n , im , maxits , iout , ierr , ja ( * ), ia ( n + 1 ), jlu ( * ), ju ( n ) real * 8 vv ( n , * ), rhs ( n ), sol ( n ), aa ( * ), alu ( * ), eps c----------------------------------------------------------------------* c                                                                      * c                 *** ILUT - Preconditioned GMRES ***                  * c                                                                      * c----------------------------------------------------------------------* c This is a simple version of the ILUT preconditioned GMRES algorithm. * c The ILUT preconditioner uses a dual strategy for dropping elements   * c instead  of the usual level of-fill-in approach. See details in ILUT * c subroutine documentation. PGMRES uses the L and U matrices generated * c from the subroutine ILUT to precondition the GMRES algorithm.        * c The preconditioning is applied to the right. The stopping criterion  * c utilized is based simply on reducing the residual norm by epsilon.   * c This preconditioning is more reliable than ilu0 but requires more    * c storage. It seems to be much less prone to difficulties related to   * c strong nonsymmetries in the matrix. We recommend using a nonzero tol * c (tol=.005 or .001 usually give good results) in ILUT. Use a large    * c lfil whenever possible (e.g. lfil = 5 to 10). The higher lfil the    * c more reliable the code is. Efficiency may also be much improved.     * c Note that lfil=n and tol=0.0 in ILUT  will yield the same factors as * c Gaussian elimination without pivoting.                               * c                                                                      * c ILU(0) and MILU(0) are also provided for comparison purposes         * c USAGE: first call ILUT or ILU0 or MILU0 to set up preconditioner and * c then call pgmres.                                                    * c----------------------------------------------------------------------* c Coded by Y. Saad - This version dated May, 7, 1990.                  * c----------------------------------------------------------------------* c parameters                                                           * c-----------                                                           * c on entry:                                                            * c==========                                                            * c                                                                      * c n     == integer. The dimension of the matrix.                       * c im    == size of krylov subspace:  should not exceed 50 in this      * c          version (can be reset by changing parameter command for     * c          kmax below)                                                 * c rhs   == real vector of length n containing the right hand side.     * c          Destroyed on return.                                        * c sol   == real vector of length n containing an initial guess to the  * c          solution on input. approximate solution on output           * c eps   == tolerance for stopping criterion. process is stopped        * c          as soon as ( ||.|| is the euclidean norm):                  * c          || current residual||/||initial residual|| <= eps           * c maxits== maximum number of iterations allowed                        * c iout  == output unit number number for printing intermediate results * c          if (iout .le. 0) nothing is printed out.                    * c                                                                      * c aa, ja,                                                              * c ia    == the input matrix in compressed sparse row format:           * c          aa(1:nnz)  = nonzero elements of A stored row-wise in order * c          ja(1:nnz) = corresponding column indices.                   * c          ia(1:n+1) = pointer to beginning of each row in aa and ja.  * c          here nnz = number of nonzero elements in A = ia(n+1)-ia(1)  * c                                                                      * c alu,jlu== A matrix stored in Modified Sparse Row format containing   * c           the L and U factors, as computed by subroutine ilut.       * c                                                                      * c ju     == integer array of length n containing the pointers to       * c           the beginning of each row of U in alu, jlu as computed     * c           by subroutine ILUT.                                        * c                                                                      * c on return:                                                           * c==========                                                            * c sol   == contains an approximate solution (upon successful return).  * c ierr  == integer. Error message with the following meaning.          * c          ierr = 0 --> successful return.                             * c          ierr = 1 --> convergence not achieved in itmax iterations.  * c          ierr =-1 --> the initial guess seems to be the exact        * c                       solution (initial residual computed was zero)  * c                                                                      * c----------------------------------------------------------------------* c                                                                      * c work arrays:                                                         * c=============                                                         * c vv    == work array of length  n x (im+1) (used to store the Arnoli  * c          basis)                                                      * c----------------------------------------------------------------------* c subroutines called :                                                 * c amux   : SPARSKIT routine to do the matrix by vector multiplication  * c          delivers y=Ax, given x  -- see SPARSKIT/BLASSM/amux         * c lusol : combined forward and backward solves (Preconditioning ope.) * c BLAS1  routines.                                                     * c----------------------------------------------------------------------* integer kmax , its , j , i , i1 , k1 , k , ii , jj parameter ( kmax = 50 ) real * 8 hh ( kmax + 1 , kmax ), c ( kmax ), s ( kmax ), rs ( kmax + 1 ), t real * 8 epsmac , eps1 , ro , gam , dnrm2 , ddot external dnrm2 external ddot c------------------------------------------------------------- c arnoldi size should not exceed kmax=50 in this version.. c to reset modify paramter kmax accordingly. c------------------------------------------------------------- data epsmac / 1.d-16 / eps1 = 0.0 its = 0 c------------------------------------------------------------- c outer loop starts here.. c-------------- compute initial residual vector -------------- call amux ( n , sol , vv , aa , ja , ia ) do 21 j = 1 , n vv ( j , 1 ) = rhs ( j ) - vv ( j , 1 ) 21 continue c------------------------------------------------------------- 20 ro = dnrm2 ( n , vv , 1 ) if ( iout . gt . 0 . and . its . eq . 0 ) * write ( iout , 199 ) its , ro if ( ro . eq . 0.0d0 ) goto 999 t = 1.0d0 / ro do 210 j = 1 , n vv ( j , 1 ) = vv ( j , 1 ) * t 210 continue if ( its . eq . 0 ) eps1 = eps * ro c     ** initialize 1-st term  of rhs of hessenberg system.. rs ( 1 ) = ro i = 0 4 i = i + 1 its = its + 1 i1 = i + 1 call lusol ( n , vv ( 1 , i ), rhs , alu , jlu , ju ) call amux ( n , rhs , vv ( 1 , i1 ), aa , ja , ia ) c----------------------------------------- c     modified gram - schmidt... c----------------------------------------- do 55 j = 1 , i t = ddot ( n , vv ( 1 , j ), 1 , vv ( 1 , i1 ), 1 ) hh ( j , i ) = t call daxpy ( n , - t , vv ( 1 , j ), 1 , vv ( 1 , i1 ), 1 ) 55 continue t = dnrm2 ( n , vv ( 1 , i1 ), 1 ) hh ( i1 , i ) = t if ( t . eq . 0.0d0 ) goto 58 t = 1.0d0 / t do 57 k = 1 , n vv ( k , i1 ) = vv ( k , i1 ) * t 57 continue c c     done with modified gram schimd and arnoldi step.. c     now  update factorization of hh c 58 if ( i . eq . 1 ) goto 121 c--------perfrom previous transformations  on i-th column of h do 66 k = 2 , i k1 = k - 1 t = hh ( k1 , i ) hh ( k1 , i ) = c ( k1 ) * t + s ( k1 ) * hh ( k , i ) hh ( k , i ) = - s ( k1 ) * t + c ( k1 ) * hh ( k , i ) 66 continue 121 gam = sqrt ( hh ( i , i ) ** 2 + hh ( i1 , i ) ** 2 ) c c     if gamma is zero then any small value will do... c     will affect only residual estimate c if ( gam . eq . 0.0d0 ) gam = epsmac c c     get  next plane rotation c c ( i ) = hh ( i , i ) / gam s ( i ) = hh ( i1 , i ) / gam rs ( i1 ) = - s ( i ) * rs ( i ) rs ( i ) = c ( i ) * rs ( i ) c c     detrermine residual norm and test for convergence- c hh ( i , i ) = c ( i ) * hh ( i , i ) + s ( i ) * hh ( i1 , i ) ro = abs ( rs ( i1 )) c 131   format(1h ,2e14.4) if ( iout . gt . 0 ) * write ( iout , 199 ) its , ro if ( i . lt . im . and . ( ro . gt . eps1 )) goto 4 c c     now compute solution. first solve upper triangular system. c rs ( i ) = rs ( i ) / hh ( i , i ) do 30 ii = 2 , i k = i - ii + 1 k1 = k + 1 t = rs ( k ) do 40 j = k1 , i t = t - hh ( k , j ) * rs ( j ) 40 continue rs ( k ) = t / hh ( k , k ) 30 continue c c     form linear combination of v(*,i)'s to get solution c t = rs ( 1 ) do 15 k = 1 , n rhs ( k ) = vv ( k , 1 ) * t 15 continue do 16 j = 2 , i t = rs ( j ) do 161 k = 1 , n rhs ( k ) = rhs ( k ) + t * vv ( k , j ) 161 continue 16 continue c c     call preconditioner. c call lusol ( n , rhs , rhs , alu , jlu , ju ) do 17 k = 1 , n sol ( k ) = sol ( k ) + rhs ( k ) 17 continue c c     restart outer loop  when necessary c if ( ro . le . eps1 ) goto 990 if ( its . ge . maxits ) goto 991 c c     else compute residual vector and continue.. c do 24 j = 1 , i jj = i1 - j + 1 rs ( jj - 1 ) = - s ( jj - 1 ) * rs ( jj ) rs ( jj ) = c ( jj - 1 ) * rs ( jj ) 24 continue do 25 j = 1 , i1 t = rs ( j ) if ( j . eq . 1 ) t = t - 1.0d0 call daxpy ( n , t , vv ( 1 , j ), 1 , vv , 1 ) 25 continue 199 format ( '   its =' , i4 , ' res. norm =' , d20 . 6 ) c     restart outer loop. goto 20 990 ierr = 0 return 991 ierr = 1 return 999 continue ierr = - 1 return c-----------------end of pgmres --------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine lusol ( n , y , x , alu , jlu , ju ) real * 8 x ( n ), y ( n ), alu ( * ) integer n , jlu ( * ), ju ( * ) c----------------------------------------------------------------------- c c This routine solves the system (LU) x = y, c given an LU decomposition of a matrix stored in (alu, jlu, ju) c modified sparse row format c c----------------------------------------------------------------------- c on entry: c n   = dimension of system c y   = the right-hand-side vector c alu, jlu, ju c     = the LU matrix as provided from the ILU routines. c c on return c x   = solution of LU x = y. c----------------------------------------------------------------------- c c Note: routine is in place: call lusol (n, x, x, alu, jlu, ju) c       will solve the system with rhs x and overwrite the result on x . c c----------------------------------------------------------------------- c local variables c integer i , k c c forward solve c do 40 i = 1 , n x ( i ) = y ( i ) do 41 k = jlu ( i ), ju ( i ) - 1 x ( i ) = x ( i ) - alu ( k ) * x ( jlu ( k )) 41 continue 40 continue c c     backward solve. c do 90 i = n , 1 , - 1 do 91 k = ju ( i ), jlu ( i + 1 ) - 1 x ( i ) = x ( i ) - alu ( k ) * x ( jlu ( k )) 91 continue x ( i ) = alu ( i ) * x ( i ) 90 continue c return c----------------end of lusol ------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine lutsol ( n , y , x , alu , jlu , ju ) implicit none real * 8 x ( n ), y ( n ), alu ( * ) integer n , jlu ( * ), ju ( * ) c----------------------------------------------------------------------- c c This routine solves the system  Transp(LU) x = y, c given an LU decomposition of a matrix stored in (alu, jlu, ju) c modified sparse row format. Transp(M) is the transpose of M. c----------------------------------------------------------------------- c on entry: c n   = dimension of system c y   = the right-hand-side vector c alu, jlu, ju c     = the LU matrix as provided from the ILU routines. c c on return c x   = solution of transp(LU) x = y. c----------------------------------------------------------------------- c c Note: routine is in place: call lutsol (n, x, x, alu, jlu, ju) c       will solve the system with rhs x and overwrite the result on x . c c----------------------------------------------------------------------- c local variables c integer i , k c do 10 i = 1 , n x ( i ) = y ( i ) 10 continue c c forward solve (with U&#94;T) c do 20 i = 1 , n x ( i ) = x ( i ) * alu ( i ) do 30 k = ju ( i ), jlu ( i + 1 ) - 1 x ( jlu ( k )) = x ( jlu ( k )) - alu ( k ) * x ( i ) 30 continue 20 continue c c     backward solve (with L&#94;T) c do 40 i = n , 1 , - 1 do 50 k = jlu ( i ), ju ( i ) - 1 x ( jlu ( k )) = x ( jlu ( k )) - alu ( k ) * x ( i ) 50 continue 40 continue c return c----------------end of lutsol ----------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine qsplit ( a , ind , n , ncut ) implicit none real * 8 a ( n ) integer ind ( n ), n , ncut c----------------------------------------------------------------------- c     does a quick-sort split of a real array. c     on input a(1:n). is a real array c     on output a(1:n) is permuted such that its elements satisfy: c c     abs(a(i)) .ge. abs(a(ncut)) for i .lt. ncut and c     abs(a(i)) .le. abs(a(ncut)) for i .gt. ncut c c     ind(1:n) is an integer array which permuted in the same way as a(*). c----------------------------------------------------------------------- real * 8 tmp , abskey integer itmp , first , last , j , mid c----- first = 1 last = n if ( ncut . lt . first . or . ncut . gt . last ) return c c     outer loop -- while mid .ne. ncut do c 1 mid = first abskey = abs ( a ( mid )) do 2 j = first + 1 , last if ( abs ( a ( j )) . gt . abskey ) then mid = mid + 1 c     interchange tmp = a ( mid ) itmp = ind ( mid ) a ( mid ) = a ( j ) ind ( mid ) = ind ( j ) a ( j ) = tmp ind ( j ) = itmp endif 2 continue c c     interchange c tmp = a ( mid ) a ( mid ) = a ( first ) a ( first ) = tmp c itmp = ind ( mid ) ind ( mid ) = ind ( first ) ind ( first ) = itmp c c     test for while loop c if ( mid . eq . ncut ) return if ( mid . gt . ncut ) then last = mid - 1 else first = mid + 1 endif goto 1 c----------------end-of-qsplit------------------------------------------ c----------------------------------------------------------------------- end","tags":"","loc":"sourcefile\\ilut.f.html"},{"title":"iters.f – LINALG","text":"Contents Functions stopbis brkdn Subroutines cg cgnr bcg bcgstab tfqmr fom gmres dqgmres fgmres dbcg implu uppdir givens tidycg bisinit mgsro Source Code iters.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c         Basic Iterative Solvers with Reverse Communication           c c----------------------------------------------------------------------c c     This file currently has several basic iterative linear system    c c     solvers. They are:                                               c c     CG       -- Conjugate Gradient Method                            c c     CGNR     -- Conjugate Gradient Method (Normal Residual equation) c c     BCG      -- Bi-Conjugate Gradient Method                         c c     DBCG     -- BCG with partial pivoting                            c c     BCGSTAB  -- BCG stabilized                                       c c     TFQMR    -- Transpose-Free Quasi-Minimum Residual method         c c     FOM      -- Full Orthogonalization Method                        c c     GMRES    -- Generalized Minimum RESidual method                  c c     FGMRES   -- Flexible version of Generalized Minimum              c c                 RESidual method                                      c c     DQGMRES  -- Direct versions of Quasi Generalize Minimum          c c                 Residual method                                      c c----------------------------------------------------------------------c c     They all have the following calling sequence: c      subroutine solver(n, rhs, sol, ipar, fpar, w) c      integer n, ipar(16) c      real*8 rhs(n), sol(n), fpar(16), w(*) c     Where c     (1) 'n' is the size of the linear system, c     (2) 'rhs' is the right-hand side of the linear system, c     (3) 'sol' is the solution to the linear system, c     (4) 'ipar' is an integer parameter array for the reverse c     communication protocol, c     (5) 'fpar' is an floating-point parameter array storing c     information to and from the iterative solvers. c     (6) 'w' is the work space (size is specified in ipar) c c     They are preconditioned iterative solvers with reverse c     communication. The preconditioners can be applied from either c     from left or right or both (specified by ipar(2), see below). c c     Author: Kesheng John Wu (kewu@mail.cs.umn.edu) 1993 c c     NOTES: c c     (1) Work space required by each of the iterative solver c     routines is as follows: c       CG      == 5 * n c       CGNR    == 5 * n c       BCG     == 7 * n c       DBCG    == 11 * n c       BCGSTAB == 8 * n c       TFQMR   == 11 * n c       FOM     == (n+3)*(m+2) + (m+1)*m/2 (m = ipar(5), default m=15) c       GMRES   == (n+3)*(m+2) + (m+1)*m/2 (m = ipar(5), default m=15) c       FGMRES  == 2*n*(m+1) + (m+1)*m/2 + 3*m + 2 (m = ipar(5), c                  default m=15) c       DQGMRES == n + lb * (2*n+4) (lb=ipar(5)+1, default lb = 16) c c     (2) ALL iterative solvers require a user-supplied DOT-product c     routine named DISTDOT. The prototype of DISTDOT is c c     real*8 function distdot(n,x,ix,y,iy) c     integer n, ix, iy c     real*8 x(1+(n-1)*ix), y(1+(n-1)*iy) c c     This interface of DISTDOT is exactly the same as that of c     DDOT (or SDOT if real == real*8) from BLAS-1. It should have c     same functionality as DDOT on a single processor machine. On a c     parallel/distributed environment, each processor can perform c     DDOT on the data it has, then perform a summation on all the c     partial results. c c     (3) To use this set of routines under SPMD/MIMD program paradigm, c     several things are to be noted: (a) 'n' should be the number of c     vector elements of 'rhs' that is present on the local processor. c     (b) if RHS(i) is on processor j, it is expected that SOL(i) c     will be on the same processor, i.e. the vectors are distributed c     to each processor in the same way. (c) the preconditioning and c     stopping criteria specifications have to be the same on all c     processor involved, ipar and fpar have to be the same on each c     processor. (d) DISTDOT should be replaced by a distributed c     dot-product function. c c     .................................................................. c     Reverse Communication Protocols c c     When a reverse-communication routine returns, it could be either c     that the routine has terminated or it simply requires the caller c     to perform one matrix-vector multiplication. The possible matrices c     that involve in the matrix-vector multiplications are: c     A       (the matrix of the linear system), c     A&#94;T     (A transposed), c     Ml&#94;{-1} (inverse of the left preconditioner), c     Ml&#94;{-T} (inverse of the left preconditioner transposed), c     Mr&#94;{-1} (inverse of the right preconditioner), c     Mr&#94;{-T} (inverse of the right preconditioner transposed). c     For all the matrix vector multiplication, v = A u. The input and c     output vectors are supposed to be part of the work space 'w', and c     the starting positions of them are stored in ipar(8:9), see below. c c     The array 'ipar' is used to store the information about the solver. c     Here is the list of what each element represents: c c     ipar(1) -- status of the call/return. c     A call to the solver with ipar(1) == 0 will initialize the c     iterative solver. On return from the iterative solver, ipar(1) c     carries the status flag which indicates the condition of the c     return. The status information is divided into two categories, c     (1) a positive value indicates the solver requires a matrix-vector c     multiplication, c     (2) a non-positive value indicates termination of the solver. c     Here is the current definition: c       1 == request a matvec with A, c       2 == request a matvec with A&#94;T, c       3 == request a left preconditioner solve (Ml&#94;{-1}), c       4 == request a left preconditioner transposed solve (Ml&#94;{-T}), c       5 == request a right preconditioner solve (Mr&#94;{-1}), c       6 == request a right preconditioner transposed solve (Mr&#94;{-T}), c      10 == request the caller to perform stopping test, c       0 == normal termination of the solver, satisfied the stopping c            criteria, c      -1 == termination because iteration number is greater than the c            preset limit, c      -2 == return due to insufficient work space, c      -3 == return due to anticipated break-down / divide by zero, c            in the case where Arnoldi procedure is used, additional c            error code can be found in ipar(12), where ipar(12) is c            the error code of orthogonalization procedure MGSRO: c               -1: zero input vector c               -2: input vector contains abnormal numbers c               -3: input vector is a linear combination of others c               -4: trianguler system in GMRES/FOM/etc. has nul rank c      -4 == the values of fpar(1) and fpar(2) are both <= 0, the valid c            ranges are 0 <= fpar(1) < 1, 0 <= fpar(2), and they can c            not be zero at the same time c      -9 == while trying to detect a break-down, an abnormal number is c            detected. c     -10 == return due to some non-numerical reasons, e.g. invalid c            floating-point numbers etc. c c     ipar(2) -- status of the preconditioning: c       0 == no preconditioning c       1 == left preconditioning only c       2 == right preconditioning only c       3 == both left and right preconditioning c c     ipar(3) -- stopping criteria (details of this will be c     discussed later). c c     ipar(4) -- number of elements in the array 'w'. if this is less c     than the desired size, it will be over-written with the minimum c     requirement. In which case the status flag ipar(1) = -2. c c     ipar(5) -- size of the Krylov subspace (used by GMRES and its c     variants), e.g. GMRES(ipar(5)), FGMRES(ipar(5)), c     DQGMRES(ipar(5)). c c     ipar(6) -- maximum number of matrix-vector multiplies, if not a c     positive number the iterative solver will run till convergence c     test is satisfied. c c     ipar(7) -- current number of matrix-vector multiplies. It is c     incremented after each matrix-vector multiplication. If there c     is preconditioning, the counter is incremented after the c     preconditioning associated with each matrix-vector multiplication. c c     ipar(8) -- pointer to the input vector to the requested matrix- c     vector multiplication. c c     ipar(9) -- pointer to the output vector of the requested matrix- c     vector multiplication. c c     To perform v = A * u, it is assumed that u is w(ipar(8):ipar(8)+n-1) c     and v is stored as w(ipar(9):ipar(9)+n-1). c c     ipar(10) -- the return address (used to determine where to go to c     inside the iterative solvers after the caller has performed the c     requested services). c c     ipar(11) -- the result of the external convergence test c     On final return from the iterative solvers, this value c     will be reflected by ipar(1) = 0 (details discussed later) c c     ipar(12) -- error code of MGSRO, it is c                  1 if the input vector to MGSRO is linear combination c                    of others, c                  0 if MGSRO was successful, c                 -1 if the input vector to MGSRO is zero, c                 -2 if the input vector contains invalid number. c c     ipar(13) -- number of initializations. During each initilization c                 residual norm is computed directly from M_l(b - A x). c c     ipar(14) to ipar(16) are NOT defined, they are NOT USED by c     any iterative solver at this time. c c     Information about the error and tolerance are stored in the array c     FPAR. So are some internal variables that need to be saved from c     one iteration to the next one. Since the internal variables are c     not the same for each routine, we only define the common ones. c c     The first two are input parameters: c     fpar(1) -- the relative tolerance, c     fpar(2) -- the absolute tolerance (details discussed later), c c     When the iterative solver terminates, c     fpar(3) -- initial residual/error norm, c     fpar(4) -- target residual/error norm, c     fpar(5) -- current residual norm (if available), c     fpar(6) -- current residual/error norm, c     fpar(7) -- convergence rate, c c     fpar(8:10) are used by some of the iterative solvers to save some c     internal information. c c     fpar(11) -- number of floating-point operations. The iterative c     solvers will add the number of FLOPS they used to this variable, c     but they do NOT initialize it, nor add the number of FLOPS due to c     matrix-vector multiplications (since matvec is outside of the c     iterative solvers). To insure the correct FLOPS count, the c     caller should set fpar(11) = 0 before invoking the iterative c     solvers and account for the number of FLOPS from matrix-vector c     multiplications and preconditioners. c c     fpar(12:16) are not used in current implementation. c c     Whether the content of fpar(3), fpar(4) and fpar(6) are residual c     norms or error norms depends on ipar(3). If the requested c     convergence test is based on the residual norm, they will be c     residual norms. If the caller want to test convergence based the c     error norms (estimated by the norm of the modifications applied c     to the approximate solution), they will be error norms. c     Convergence rate is defined by (Fortran 77 statement) c     fpar(7) = log10(fpar(3) / fpar(6)) / (ipar(7)-ipar(13)) c     If fpar(7) = 0.5, it means that approximately every 2 (= 1/0.5) c     steps the residual/error norm decrease by a factor of 10. c c     .................................................................. c     Stopping criteria, c c     An iterative solver may be terminated due to (1) satisfying c     convergence test; (2) exceeding iteration limit; (3) insufficient c     work space; (4) break-down. Checking of the work space is c     only done in the initialization stage, i.e. when it is called with c     ipar(1) == 0. A complete convergence test is done after each c     update of the solutions. Other conditions are monitored c     continuously. c c     With regard to the number of iteration, when ipar(6) is positive, c     the current iteration number will be checked against it. If c     current iteration number is greater the ipar(6) than the solver c     will return with status -1. If ipar(6) is not positive, the c     iteration will continue until convergence test is satisfied. c c     Two things may be used in the convergence tests, one is the c     residual 2-norm, the other one is 2-norm of the change in the c     approximate solution. The residual and the change in approximate c     solution are from the preconditioned system (if preconditioning c     is applied). The DQGMRES and TFQMR use two estimates for the c     residual norms. The estimates are not accurate, but they are c     acceptable in most of the cases. Generally speaking, the error c     of the TFQMR's estimate is less accurate. c c     The convergence test type is indicated by ipar(3). There are four c     type convergence tests: (1) tests based on the residual norm; c     (2) tests based on change in approximate solution; (3) caller c     does not care, the solver choose one from above two on its own; c     (4) caller will perform the test, the solver should simply continue. c     Here is the complete definition: c      -2 == || dx(i) || <= rtol * || rhs || + atol c      -1 == || dx(i) || <= rtol * || dx(1) || + atol c       0 == solver will choose test 1 (next) c       1 == || residual || <= rtol * || initial residual || + atol c       2 == || residual || <= rtol * || rhs || + atol c     999 == caller will perform the test c     where dx(i) denote the change in the solution at the ith update. c     ||.|| denotes 2-norm. rtol = fpar(1) and atol = fpar(2). c c     If the caller is to perform the convergence test, the outcome c     should be stored in ipar(11). c     ipar(11) = 0 -- failed the convergence test, iterative solver c     should continue c     ipar(11) = 1 -- satisfied convergence test, iterative solver c     should perform the clean up job and stop. c c     Upon return with ipar(1) = 10, c     ipar(8)  points to the starting position of the change in c              solution Sx, where the actual solution of the step is c              x_j = x_0 + M_r&#94;{-1} Sx. c              Exception: ipar(8) < 0, Sx = 0. It is mostly used by c              GMRES and variants to indicate (1) Sx was not necessary, c              (2) intermediate result of Sx is not computed. c     ipar(9)  points to the starting position of a work vector that c              can be used by the caller. c c     NOTE: the caller should allow the iterative solver to perform c     clean up job after the external convergence test is satisfied, c     since some of the iterative solvers do not directly c     update the 'sol' array. A typical clean-up stage includes c     performing the final update of the approximate solution and c     computing the convergence information (e.g. values of fpar(3:7)). c c     NOTE: fpar(4) and fpar(6) are not set by the accelerators (the c     routines implemented here) if ipar(3) = 999. c c     .................................................................. c     Usage: c c     To start solving a linear system, the user needs to specify c     first 6 elements of the ipar, and first 2 elements of fpar. c     The user may optionally set fpar(11) = 0 if one wants to count c     the number of floating-point operations. (Note: the iterative c     solvers will only add the floating-point operations inside c     themselves, the caller will have to add the FLOPS from the c     matrix-vector multiplication routines and the preconditioning c     routines in order to account for all the arithmetic operations.) c c     Here is an example: c     ipar(1) = 0\t! always 0 to start an iterative solver c     ipar(2) = 2\t! right preconditioning c     ipar(3) = 1\t! use convergence test scheme 1 c     ipar(4) = 10000\t! the 'w' has 10,000 elements c     ipar(5) = 10\t! use *GMRES(10) (e.g. FGMRES(10)) c     ipar(6) = 100\t! use at most 100 matvec's c     fpar(1) = 1.0E-6\t! relative tolerance 1.0E-6 c     fpar(2) = 1.0E-10 ! absolute tolerance 1.0E-10 c     fpar(11) = 0.0\t! clearing the FLOPS counter c c     After the above specifications, one can start to call an iterative c     solver, say BCG. Here is a piece of pseudo-code showing how it can c     be done, c c 10   call bcg(n,rhs,sol,ipar,fpar,w) c      if (ipar(1).eq.1) then c         call amux(n,w(ipar(8)),w(ipar(9)),a,ja,ia) c         goto 10 c      else if (ipar(1).eq.2) then c         call atmux(n,w(ipar(8)),w(ipar(9)),a,ja,ia) c         goto 10 c      else if (ipar(1).eq.3) then c         left preconditioner solver c         goto 10 c      else if (ipar(1).eq.4) then c         left preconditioner transposed solve c         goto 10 c      else if (ipar(1).eq.5) then c         right preconditioner solve c         goto 10 c      else if (ipar(1).eq.6) then c         right preconditioner transposed solve c         goto 10 c      else if (ipar(1).eq.10) then c         call my own stopping test routine c         goto 10 c      else if (ipar(1).gt.0) then c         ipar(1) is an unspecified code c      else c         the iterative solver terminated with code = ipar(1) c      endif c c     This segment of pseudo-code assumes the matrix is in CSR format, c     AMUX and ATMUX are two routines from the SPARSKIT MATVEC module. c     They perform matrix-vector multiplications for CSR matrices, c     where w(ipar(8)) is the first element of the input vectors to the c     two routines, and w(ipar(9)) is the first element of the output c     vectors from them. For simplicity, we did not show the name of c     the routine that performs the preconditioning operations or the c     convergence tests. c----------------------------------------------------------------------- subroutine cg ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( n , * ) c----------------------------------------------------------------------- c     This is a implementation of the Conjugate Gradient (CG) method c     for solving linear system. c c     NOTE: This is not the PCG algorithm. It is a regular CG algorithm. c     To be consistent with the other solvers, the preconditioners are c     applied by performing Ml&#94;{-1} A Mr&#94;{-1} P in place of A P in the c     CG algorithm.  PCG uses the preconditioner differently. c c     fpar(7) is used here internally to store <r, r>. c     w(:,1) -- residual vector c     w(:,2) -- P, the conjugate direction c     w(:,3) -- A P, matrix multiply the conjugate direction c     w(:,4) -- temporary storage for results of preconditioning c     w(:,5) -- change in the solution (sol) is stored here until c               termination of this solver c----------------------------------------------------------------------- c     external functions used c real * 8 distdot logical stopbis , brkdn external distdot , stopbis , brkdn , bisinit c c     local variables c integer i real * 8 alpha logical lp , rp save c c     check the status of the call c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 40 , 50 , 60 , 70 , 80 ), ipar ( 10 ) c c     initialization c call bisinit ( ipar , fpar , 5 * n , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     request for matrix vector multiplication A*x in the initialization c ipar ( 1 ) = 1 ipar ( 8 ) = n + 1 ipar ( 9 ) = ipar ( 8 ) + n ipar ( 10 ) = 1 do i = 1 , n w ( i , 2 ) = sol ( i ) enddo return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = 1 do i = 1 , n w ( i , 2 ) = rhs ( i ) - w ( i , 3 ) enddo fpar ( 11 ) = fpar ( 11 ) + n c c     if left preconditioned c if ( lp ) then ipar ( 1 ) = 3 ipar ( 9 ) = 1 ipar ( 10 ) = 2 return endif c 20 if ( lp ) then do i = 1 , n w ( i , 2 ) = w ( i , 1 ) enddo else do i = 1 , n w ( i , 1 ) = w ( i , 2 ) enddo endif c fpar ( 7 ) = distdot ( n , w , 1 , w , 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n fpar ( 3 ) = sqrt ( fpar ( 7 )) fpar ( 5 ) = fpar ( 3 ) if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif c c     before iteration can continue, we need to compute A * p, which c     includes the preconditioning operations c 30 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = n + 1 if ( lp ) then ipar ( 9 ) = ipar ( 8 ) + n else ipar ( 9 ) = 3 * n + 1 endif ipar ( 10 ) = 3 return endif c 40 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = n + 1 endif if ( lp ) then ipar ( 9 ) = 3 * n + 1 else ipar ( 9 ) = n + n + 1 endif ipar ( 10 ) = 4 return c 50 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = n + n + 1 ipar ( 10 ) = 5 return endif c c     continuing with the iterations c 60 ipar ( 7 ) = ipar ( 7 ) + 1 alpha = distdot ( n , w ( 1 , 2 ), 1 , w ( 1 , 3 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( brkdn ( alpha , ipar )) goto 900 alpha = fpar ( 7 ) / alpha do i = 1 , n w ( i , 5 ) = w ( i , 5 ) + alpha * w ( i , 2 ) w ( i , 1 ) = w ( i , 1 ) - alpha * w ( i , 3 ) enddo fpar ( 11 ) = fpar ( 11 ) + 4 * n c c     are we ready to terminate ? c if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 4 * n + 1 ipar ( 9 ) = 3 * n + 1 ipar ( 10 ) = 6 return endif 70 if ( ipar ( 3 ). eq . 999 ) then if ( ipar ( 11 ). eq . 1 ) goto 900 else if ( stopbis ( n , ipar , 1 , fpar , w , w ( 1 , 2 ), alpha )) then goto 900 endif c c     continue the iterations c alpha = fpar ( 5 ) * fpar ( 5 ) / fpar ( 7 ) fpar ( 7 ) = fpar ( 5 ) * fpar ( 5 ) do i = 1 , n w ( i , 2 ) = w ( i , 1 ) + alpha * w ( i , 2 ) enddo fpar ( 11 ) = fpar ( 11 ) + 2 * n goto 30 c c     clean up -- necessary to accommodate the right-preconditioning c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 4 * n + 1 ipar ( 9 ) = ipar ( 8 ) - n ipar ( 10 ) = 7 return endif 80 if ( rp ) then call tidycg ( n , ipar , fpar , sol , w ( 1 , 4 )) else call tidycg ( n , ipar , fpar , sol , w ( 1 , 5 )) endif c return end c-----end-of-cg c----------------------------------------------------------------------- subroutine cgnr ( n , rhs , sol , ipar , fpar , wk ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), wk ( n , * ) c----------------------------------------------------------------------- c     CGNR -- Using CG algorithm solving A x = b by solving c     Normal Residual equation: A&#94;T A x = A&#94;T b c     As long as the matrix is not singular, A&#94;T A is symmetric c     positive definite, therefore CG (CGNR) will converge. c c     Usage of the work space: c     wk(:,1) == residual vector R c     wk(:,2) == the conjugate direction vector P c     wk(:,3) == a scratch vector holds A P, or A&#94;T R c     wk(:,4) == a scratch vector holds intermediate results of the c                preconditioning c     wk(:,5) == a place to hold the modification to SOL c c     size of the work space WK is required = 5*n c----------------------------------------------------------------------- c     external functions used c real * 8 distdot logical stopbis , brkdn external distdot , stopbis , brkdn , bisinit c c     local variables c integer i real * 8 alpha , zz , zzm1 logical lp , rp save c c     check the status of the call c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 ), ipar ( 10 ) c c     initialization c call bisinit ( ipar , fpar , 5 * n , 1 , lp , rp , wk ) if ( ipar ( 1 ). lt . 0 ) return c c     request for matrix vector multiplication A*x in the initialization c ipar ( 1 ) = 1 ipar ( 8 ) = 1 ipar ( 9 ) = 1 + n ipar ( 10 ) = 1 do i = 1 , n wk ( i , 1 ) = sol ( i ) enddo return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 do i = 1 , n wk ( i , 1 ) = rhs ( i ) - wk ( i , 2 ) enddo fpar ( 11 ) = fpar ( 11 ) + n c c     if left preconditioned, precondition the initial residual c if ( lp ) then ipar ( 1 ) = 3 ipar ( 10 ) = 2 return endif c 20 if ( lp ) then do i = 1 , n wk ( i , 1 ) = wk ( i , 2 ) enddo endif c zz = distdot ( n , wk , 1 , wk , 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n fpar ( 3 ) = sqrt ( zz ) fpar ( 5 ) = fpar ( 3 ) if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif c c     normal iteration begins here, first half of the iteration c     computes the conjugate direction c 30 continue c c     request the caller to perform a A&#94;T r --> wk(:,3) c if ( lp ) then ipar ( 1 ) = 4 ipar ( 8 ) = 1 if ( rp ) then ipar ( 9 ) = n + n + 1 else ipar ( 9 ) = 3 * n + 1 endif ipar ( 10 ) = 3 return endif c 40 ipar ( 1 ) = 2 if ( lp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = 1 endif if ( rp ) then ipar ( 9 ) = 3 * n + 1 else ipar ( 9 ) = n + n + 1 endif ipar ( 10 ) = 4 return c 50 if ( rp ) then ipar ( 1 ) = 6 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = n + n + 1 ipar ( 10 ) = 5 return endif c 60 ipar ( 7 ) = ipar ( 7 ) + 1 zzm1 = zz zz = distdot ( n , wk ( 1 , 3 ), 1 , wk ( 1 , 3 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( brkdn ( zz , ipar )) goto 900 if ( ipar ( 7 ). gt . 3 ) then alpha = zz / zzm1 do i = 1 , n wk ( i , 2 ) = wk ( i , 3 ) + alpha * wk ( i , 2 ) enddo fpar ( 11 ) = fpar ( 11 ) + 2 * n else do i = 1 , n wk ( i , 2 ) = wk ( i , 3 ) enddo endif c c     before iteration can continue, we need to compute A * p c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = n + 1 if ( lp ) then ipar ( 9 ) = ipar ( 8 ) + n else ipar ( 9 ) = 3 * n + 1 endif ipar ( 10 ) = 6 return endif c 70 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = n + 1 endif if ( lp ) then ipar ( 9 ) = 3 * n + 1 else ipar ( 9 ) = n + n + 1 endif ipar ( 10 ) = 7 return c 80 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = n + n + 1 ipar ( 10 ) = 8 return endif c c     update the solution -- accumulate the changes in w(:,5) c 90 ipar ( 7 ) = ipar ( 7 ) + 1 alpha = distdot ( n , wk ( 1 , 3 ), 1 , wk ( 1 , 3 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( brkdn ( alpha , ipar )) goto 900 alpha = zz / alpha do i = 1 , n wk ( i , 5 ) = wk ( i , 5 ) + alpha * wk ( i , 2 ) wk ( i , 1 ) = wk ( i , 1 ) - alpha * wk ( i , 3 ) enddo fpar ( 11 ) = fpar ( 11 ) + 4 * n c c     are we ready to terminate ? c if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 4 * n + 1 ipar ( 9 ) = 3 * n + 1 ipar ( 10 ) = 9 return endif 100 if ( ipar ( 3 ). eq . 999 ) then if ( ipar ( 11 ). eq . 1 ) goto 900 else if ( stopbis ( n , ipar , 1 , fpar , wk , wk ( 1 , 2 ), alpha )) then goto 900 endif c c     continue the iterations c goto 30 c c     clean up -- necessary to accommodate the right-preconditioning c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 4 * n + 1 ipar ( 9 ) = ipar ( 8 ) - n ipar ( 10 ) = 10 return endif 110 if ( rp ) then call tidycg ( n , ipar , fpar , sol , wk ( 1 , 4 )) else call tidycg ( n , ipar , fpar , sol , wk ( 1 , 5 )) endif return end c-----end-of-cgnr c----------------------------------------------------------------------- subroutine bcg ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 fpar ( 16 ), rhs ( n ), sol ( n ), w ( n , * ) c----------------------------------------------------------------------- c     BCG: Bi Conjugate Gradient method. Programmed with reverse c     communication, see the header for detailed specifications c     of the protocol. c c     in this routine, before successful return, the fpar's are c     fpar(3) == initial residual norm c     fpar(4) == target residual norm c     fpar(5) == current residual norm c     fpar(7) == current rho (rhok = <r, s>) c     fpar(8) == previous rho (rhokm1) c c     w(:,1) -- r, the residual c     w(:,2) -- s, the dual of the 'r' c     w(:,3) -- p, the projection direction c     w(:,4) -- q, the dual of the 'p' c     w(:,5) -- v, a scratch vector to store A*p, or A*q. c     w(:,6) -- a scratch vector to store intermediate results c     w(:,7) -- changes in the solution c----------------------------------------------------------------------- c     external routines used c real * 8 distdot logical stopbis , brkdn external distdot , stopbis , brkdn c real * 8 one parameter ( one = 1.0D0 ) c c     local variables c integer i real * 8 alpha logical rp , lp save c c     status of the program c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 ), ipar ( 10 ) c c     initialization, initial residual c call bisinit ( ipar , fpar , 7 * n , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     compute initial residual, request a matvecc c ipar ( 1 ) = 1 ipar ( 8 ) = 3 * n + 1 ipar ( 9 ) = ipar ( 8 ) + n do i = 1 , n w ( i , 4 ) = sol ( i ) enddo ipar ( 10 ) = 1 return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 do i = 1 , n w ( i , 1 ) = rhs ( i ) - w ( i , 5 ) enddo fpar ( 11 ) = fpar ( 11 ) + n if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = 1 ipar ( 9 ) = n + 1 ipar ( 10 ) = 2 return endif c 20 if ( lp ) then do i = 1 , n w ( i , 1 ) = w ( i , 2 ) w ( i , 3 ) = w ( i , 2 ) w ( i , 4 ) = w ( i , 2 ) enddo else do i = 1 , n w ( i , 2 ) = w ( i , 1 ) w ( i , 3 ) = w ( i , 1 ) w ( i , 4 ) = w ( i , 1 ) enddo endif c fpar ( 7 ) = distdot ( n , w , 1 , w , 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n fpar ( 3 ) = sqrt ( fpar ( 7 )) fpar ( 5 ) = fpar ( 3 ) fpar ( 8 ) = one if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif if ( ipar ( 3 ). ge . 0. and . fpar ( 5 ). le . fpar ( 4 )) then fpar ( 6 ) = fpar ( 5 ) goto 900 endif c c     end of initialization, begin iteration, v = A p c 30 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = n + n + 1 if ( lp ) then ipar ( 9 ) = 4 * n + 1 else ipar ( 9 ) = 5 * n + 1 endif ipar ( 10 ) = 3 return endif c 40 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = n + n + 1 endif if ( lp ) then ipar ( 9 ) = 5 * n + 1 else ipar ( 9 ) = 4 * n + 1 endif ipar ( 10 ) = 4 return c 50 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 4 * n + 1 ipar ( 10 ) = 5 return endif c 60 ipar ( 7 ) = ipar ( 7 ) + 1 alpha = distdot ( n , w ( 1 , 4 ), 1 , w ( 1 , 5 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( brkdn ( alpha , ipar )) goto 900 alpha = fpar ( 7 ) / alpha do i = 1 , n w ( i , 7 ) = w ( i , 7 ) + alpha * w ( i , 3 ) w ( i , 1 ) = w ( i , 1 ) - alpha * w ( i , 5 ) enddo fpar ( 11 ) = fpar ( 11 ) + 4 * n if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 6 * n + 1 ipar ( 9 ) = 5 * n + 1 ipar ( 10 ) = 6 return endif 70 if ( ipar ( 3 ). eq . 999 ) then if ( ipar ( 11 ). eq . 1 ) goto 900 else if ( stopbis ( n , ipar , 1 , fpar , w , w ( 1 , 3 ), alpha )) then goto 900 endif c c     A&#94;t * x c if ( lp ) then ipar ( 1 ) = 4 ipar ( 8 ) = 3 * n + 1 if ( rp ) then ipar ( 9 ) = 4 * n + 1 else ipar ( 9 ) = 5 * n + 1 endif ipar ( 10 ) = 7 return endif c 80 ipar ( 1 ) = 2 if ( lp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = 3 * n + 1 endif if ( rp ) then ipar ( 9 ) = 5 * n + 1 else ipar ( 9 ) = 4 * n + 1 endif ipar ( 10 ) = 8 return c 90 if ( rp ) then ipar ( 1 ) = 6 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 4 * n + 1 ipar ( 10 ) = 9 return endif c 100 ipar ( 7 ) = ipar ( 7 ) + 1 do i = 1 , n w ( i , 2 ) = w ( i , 2 ) - alpha * w ( i , 5 ) enddo fpar ( 8 ) = fpar ( 7 ) fpar ( 7 ) = distdot ( n , w , 1 , w ( 1 , 2 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 4 * n if ( brkdn ( fpar ( 7 ), ipar )) return alpha = fpar ( 7 ) / fpar ( 8 ) do i = 1 , n w ( i , 3 ) = w ( i , 1 ) + alpha * w ( i , 3 ) w ( i , 4 ) = w ( i , 2 ) + alpha * w ( i , 4 ) enddo fpar ( 11 ) = fpar ( 11 ) + 4 * n c c     end of the iterations c goto 30 c c     some clean up job to do c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 6 * n + 1 ipar ( 9 ) = ipar ( 8 ) - n ipar ( 10 ) = 10 return endif 110 if ( rp ) then call tidycg ( n , ipar , fpar , sol , w ( 1 , 6 )) else call tidycg ( n , ipar , fpar , sol , w ( 1 , 7 )) endif return c-----end-of-bcg end c----------------------------------------------------------------------- subroutine bcgstab ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( n , 8 ) c----------------------------------------------------------------------- c     BCGSTAB --- Bi Conjugate Gradient stabilized (BCGSTAB) c     This is an improved BCG routine. (1) no matrix transpose is c     involved. (2) the convergence is smoother. c c c     Algorithm: c     Initialization - r = b - A x, r0 = r, p = r, rho = (r0, r), c     Iterate - c     (1) v = A p c     (2) alpha = rho / (r0, v) c     (3) s = r - alpha v c     (4) t = A s c     (5) omega = (t, s) / (t, t) c     (6) x = x + alpha * p + omega * s c     (7) r = s - omega * t c     convergence test goes here c     (8) beta = rho, rho = (r0, r), beta = rho * alpha / (beta * omega) c         p = r + beta * (p - omega * v) c c     in this routine, before successful return, the fpar's are c     fpar(3) == initial (preconditionied-)residual norm c     fpar(4) == target (preconditionied-)residual norm c     fpar(5) == current (preconditionied-)residual norm c     fpar(6) == current residual norm or error c     fpar(7) == current rho (rhok = <r, r0>) c     fpar(8) == alpha c     fpar(9) == omega c c     Usage of the work space W c     w(:, 1) = r0, the initial residual vector c     w(:, 2) = r, current residual vector c     w(:, 3) = s c     w(:, 4) = t c     w(:, 5) = v c     w(:, 6) = p c     w(:, 7) = tmp, used in preconditioning, etc. c     w(:, 8) = delta x, the correction to the answer is accumulated c               here, so that the right-preconditioning may be applied c               at the end c----------------------------------------------------------------------- c     external routines used c real * 8 distdot logical stopbis , brkdn external distdot , stopbis , brkdn c real * 8 one parameter ( one = 1.0D0 ) c c     local variables c integer i real * 8 alpha , beta , rho , omega logical lp , rp save lp , rp c c     where to go c if ( ipar ( 1 ). gt . 0 ) then goto ( 10 , 20 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 ) ipar ( 10 ) else if ( ipar ( 1 ). lt . 0 ) then goto 900 endif c c     call the initialization routine c call bisinit ( ipar , fpar , 8 * n , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     perform a matvec to compute the initial residual c ipar ( 1 ) = 1 ipar ( 8 ) = 1 ipar ( 9 ) = 1 + n do i = 1 , n w ( i , 1 ) = sol ( i ) enddo ipar ( 10 ) = 1 return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 do i = 1 , n w ( i , 1 ) = rhs ( i ) - w ( i , 2 ) enddo fpar ( 11 ) = fpar ( 11 ) + n if ( lp ) then ipar ( 1 ) = 3 ipar ( 10 ) = 2 return endif c 20 if ( lp ) then do i = 1 , n w ( i , 1 ) = w ( i , 2 ) w ( i , 6 ) = w ( i , 2 ) enddo else do i = 1 , n w ( i , 2 ) = w ( i , 1 ) w ( i , 6 ) = w ( i , 1 ) enddo endif c fpar ( 7 ) = distdot ( n , w , 1 , w , 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n fpar ( 5 ) = sqrt ( fpar ( 7 )) fpar ( 3 ) = fpar ( 5 ) if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif if ( ipar ( 3 ). ge . 0 ) fpar ( 6 ) = fpar ( 5 ) if ( ipar ( 3 ). ge . 0 . and . fpar ( 5 ). le . fpar ( 4 ) . and . + ipar ( 3 ). ne . 999 ) then goto 900 endif c c     beginning of the iterations c c     Step (1), v = A p 30 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = 5 * n + 1 if ( lp ) then ipar ( 9 ) = 4 * n + 1 else ipar ( 9 ) = 6 * n + 1 endif ipar ( 10 ) = 3 return endif c 40 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = 5 * n + 1 endif if ( lp ) then ipar ( 9 ) = 6 * n + 1 else ipar ( 9 ) = 4 * n + 1 endif ipar ( 10 ) = 4 return 50 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 4 * n + 1 ipar ( 10 ) = 5 return endif c 60 ipar ( 7 ) = ipar ( 7 ) + 1 c c     step (2) alpha = distdot ( n , w ( 1 , 1 ), 1 , w ( 1 , 5 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( brkdn ( alpha , ipar )) goto 900 alpha = fpar ( 7 ) / alpha fpar ( 8 ) = alpha c c     step (3) do i = 1 , n w ( i , 3 ) = w ( i , 2 ) - alpha * w ( i , 5 ) enddo fpar ( 11 ) = fpar ( 11 ) + 2 * n c c     Step (4): the second matvec -- t = A s c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = n + n + 1 if ( lp ) then ipar ( 9 ) = ipar ( 8 ) + n else ipar ( 9 ) = 6 * n + 1 endif ipar ( 10 ) = 6 return endif c 70 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = n + n + 1 endif if ( lp ) then ipar ( 9 ) = 6 * n + 1 else ipar ( 9 ) = 3 * n + 1 endif ipar ( 10 ) = 7 return 80 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 3 * n + 1 ipar ( 10 ) = 8 return endif 90 ipar ( 7 ) = ipar ( 7 ) + 1 c c     step (5) omega = distdot ( n , w ( 1 , 4 ), 1 , w ( 1 , 4 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + n + n if ( brkdn ( omega , ipar )) goto 900 omega = distdot ( n , w ( 1 , 4 ), 1 , w ( 1 , 3 ), 1 ) / omega fpar ( 11 ) = fpar ( 11 ) + n + n if ( brkdn ( omega , ipar )) goto 900 fpar ( 9 ) = omega alpha = fpar ( 8 ) c c     step (6) and (7) do i = 1 , n w ( i , 7 ) = alpha * w ( i , 6 ) + omega * w ( i , 3 ) w ( i , 8 ) = w ( i , 8 ) + w ( i , 7 ) w ( i , 2 ) = w ( i , 3 ) - omega * w ( i , 4 ) enddo fpar ( 11 ) = fpar ( 11 ) + 6 * n + 1 c c     convergence test if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 7 * n + 1 ipar ( 9 ) = 6 * n + 1 ipar ( 10 ) = 9 return endif if ( stopbis ( n , ipar , 2 , fpar , w ( 1 , 2 ), w ( 1 , 7 ), one )) goto 900 100 if ( ipar ( 3 ). eq . 99 9. and . ipar ( 11 ). eq . 1 ) goto 900 c c     step (8): computing new p and rho rho = fpar ( 7 ) fpar ( 7 ) = distdot ( n , w ( 1 , 2 ), 1 , w ( 1 , 1 ), 1 ) omega = fpar ( 9 ) beta = fpar ( 7 ) * fpar ( 8 ) / ( fpar ( 9 ) * rho ) do i = 1 , n w ( i , 6 ) = w ( i , 2 ) + beta * ( w ( i , 6 ) - omega * w ( i , 5 )) enddo fpar ( 11 ) = fpar ( 11 ) + 6 * n + 3 if ( brkdn ( fpar ( 7 ), ipar )) goto 900 c c     end of an iteration c goto 30 c c     some clean up job to do c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 7 * n + 1 ipar ( 9 ) = ipar ( 8 ) - n ipar ( 10 ) = 10 return endif 110 if ( rp ) then call tidycg ( n , ipar , fpar , sol , w ( 1 , 7 )) else call tidycg ( n , ipar , fpar , sol , w ( 1 , 8 )) endif c return c-----end-of-bcgstab end c----------------------------------------------------------------------- subroutine tfqmr ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( n , * ) c----------------------------------------------------------------------- c     TFQMR --- transpose-free Quasi-Minimum Residual method c     This is developed from BCG based on the principle of Quasi-Minimum c     Residual, and it is transpose-free. c c     It uses approximate residual norm. c c     Internally, the fpar's are used as following: c     fpar(3) --- initial residual norm squared c     fpar(4) --- target residual norm squared c     fpar(5) --- current residual norm squared c c     w(:,1) -- R, residual c     w(:,2) -- R0, the initial residual c     w(:,3) -- W c     w(:,4) -- Y c     w(:,5) -- Z c     w(:,6) -- A * Y c     w(:,7) -- A * Z c     w(:,8) -- V c     w(:,9) -- D c     w(:,10) -- intermediate results of preconditioning c     w(:,11) -- changes in the solution c----------------------------------------------------------------------- c     external functions c real * 8 distdot logical brkdn external brkdn , distdot c real * 8 one , zero parameter ( one = 1.0D0 , zero = 0.0D0 ) c c     local variables c integer i logical lp , rp real * 8 eta , sigma , theta , te , alpha , rho , tao save c c     status of the call (where to go) c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 ), ipar ( 10 ) c c     initializations c call bisinit ( ipar , fpar , 11 * n , 2 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return ipar ( 1 ) = 1 ipar ( 8 ) = 1 ipar ( 9 ) = 1 + 6 * n do i = 1 , n w ( i , 1 ) = sol ( i ) enddo ipar ( 10 ) = 1 return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 do i = 1 , n w ( i , 1 ) = rhs ( i ) - w ( i , 7 ) w ( i , 9 ) = zero enddo fpar ( 11 ) = fpar ( 11 ) + n c if ( lp ) then ipar ( 1 ) = 3 ipar ( 9 ) = n + 1 ipar ( 10 ) = 2 return endif 20 continue if ( lp ) then do i = 1 , n w ( i , 1 ) = w ( i , 2 ) w ( i , 3 ) = w ( i , 2 ) enddo else do i = 1 , n w ( i , 2 ) = w ( i , 1 ) w ( i , 3 ) = w ( i , 1 ) enddo endif c fpar ( 5 ) = sqrt ( distdot ( n , w , 1 , w , 1 )) fpar ( 3 ) = fpar ( 5 ) tao = fpar ( 5 ) fpar ( 11 ) = fpar ( 11 ) + n + n if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + n + n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * tao + fpar ( 2 ) endif te = zero rho = zero c c     begin iteration c 30 sigma = rho rho = distdot ( n , w ( 1 , 2 ), 1 , w ( 1 , 3 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + n + n if ( brkdn ( rho , ipar )) goto 900 if ( ipar ( 7 ). eq . 1 ) then alpha = zero else alpha = rho / sigma endif do i = 1 , n w ( i , 4 ) = w ( i , 3 ) + alpha * w ( i , 5 ) enddo fpar ( 11 ) = fpar ( 11 ) + n + n c c     A * x -- with preconditioning c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = 3 * n + 1 if ( lp ) then ipar ( 9 ) = 5 * n + 1 else ipar ( 9 ) = 9 * n + 1 endif ipar ( 10 ) = 3 return endif c 40 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = 3 * n + 1 endif if ( lp ) then ipar ( 9 ) = 9 * n + 1 else ipar ( 9 ) = 5 * n + 1 endif ipar ( 10 ) = 4 return c 50 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 5 * n + 1 ipar ( 10 ) = 5 return endif 60 ipar ( 7 ) = ipar ( 7 ) + 1 do i = 1 , n w ( i , 8 ) = w ( i , 6 ) + alpha * ( w ( i , 7 ) + alpha * w ( i , 8 )) enddo sigma = distdot ( n , w ( 1 , 2 ), 1 , w ( 1 , 8 ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 6 * n if ( brkdn ( sigma , ipar )) goto 900 alpha = rho / sigma do i = 1 , n w ( i , 5 ) = w ( i , 4 ) - alpha * w ( i , 8 ) enddo fpar ( 11 ) = fpar ( 11 ) + 2 * n c c     the second A * x c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = 4 * n + 1 if ( lp ) then ipar ( 9 ) = 6 * n + 1 else ipar ( 9 ) = 9 * n + 1 endif ipar ( 10 ) = 6 return endif c 70 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = 4 * n + 1 endif if ( lp ) then ipar ( 9 ) = 9 * n + 1 else ipar ( 9 ) = 6 * n + 1 endif ipar ( 10 ) = 7 return c 80 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 6 * n + 1 ipar ( 10 ) = 8 return endif 90 ipar ( 7 ) = ipar ( 7 ) + 1 do i = 1 , n w ( i , 3 ) = w ( i , 3 ) - alpha * w ( i , 6 ) enddo c c     update I c theta = distdot ( n , w ( 1 , 3 ), 1 , w ( 1 , 3 ), 1 ) / ( tao * tao ) sigma = one / ( one + theta ) tao = tao * sqrt ( sigma * theta ) fpar ( 11 ) = fpar ( 11 ) + 4 * n + 6 if ( brkdn ( tao , ipar )) goto 900 eta = sigma * alpha sigma = te / alpha te = theta * eta do i = 1 , n w ( i , 9 ) = w ( i , 4 ) + sigma * w ( i , 9 ) w ( i , 11 ) = w ( i , 11 ) + eta * w ( i , 9 ) w ( i , 3 ) = w ( i , 3 ) - alpha * w ( i , 7 ) enddo fpar ( 11 ) = fpar ( 11 ) + 6 * n + 6 if ( ipar ( 7 ). eq . 1 ) then if ( ipar ( 3 ). eq . - 1 ) then fpar ( 3 ) = eta * sqrt ( distdot ( n , w ( 1 , 9 ), 1 , w ( 1 , 9 ), 1 )) fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + n + n + 4 endif endif c c     update II c theta = distdot ( n , w ( 1 , 3 ), 1 , w ( 1 , 3 ), 1 ) / ( tao * tao ) sigma = one / ( one + theta ) tao = tao * sqrt ( sigma * theta ) fpar ( 11 ) = fpar ( 11 ) + 8 + 2 * n if ( brkdn ( tao , ipar )) goto 900 eta = sigma * alpha sigma = te / alpha te = theta * eta do i = 1 , n w ( i , 9 ) = w ( i , 5 ) + sigma * w ( i , 9 ) w ( i , 11 ) = w ( i , 11 ) + eta * w ( i , 9 ) enddo fpar ( 11 ) = fpar ( 11 ) + 4 * n + 3 c c     this is the correct over-estimate c      fpar(5) = sqrt(real(ipar(7)+1)) * tao c     this is an approximation fpar ( 5 ) = tao if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 10 * n + 1 ipar ( 9 ) = 9 * n + 1 ipar ( 10 ) = 9 return else if ( ipar ( 3 ). lt . 0 ) then fpar ( 6 ) = eta * sqrt ( distdot ( n , w ( 1 , 9 ), 1 , w ( 1 , 9 ), 1 )) fpar ( 11 ) = fpar ( 11 ) + n + n + 2 else fpar ( 6 ) = fpar ( 5 ) endif if ( fpar ( 6 ). gt . fpar ( 4 ) . and . ( ipar ( 7 ). lt . ipar ( 6 ) + . or . ipar ( 6 ). le . 0 )) goto 30 100 if ( ipar ( 3 ). eq . 99 9. and . ipar ( 11 ). eq . 0 ) goto 30 c c     clean up c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 10 * n + 1 ipar ( 9 ) = ipar ( 8 ) - n ipar ( 10 ) = 10 return endif 110 if ( rp ) then call tidycg ( n , ipar , fpar , sol , w ( 1 , 10 )) else call tidycg ( n , ipar , fpar , sol , w ( 1 , 11 )) endif c return end c-----end-of-tfqmr c----------------------------------------------------------------------- subroutine fom ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( * ) c----------------------------------------------------------------------- c     This a version of The Full Orthogonalization Method (FOM) c     implemented with reverse communication. It is a simple restart c     version of the FOM algorithm and is implemented with plane c     rotations similarly to GMRES. c c  parameters: c  ----------- c     ipar(5) == the dimension of the Krylov subspace c     after every ipar(5) iterations, the FOM will restart with c     the updated solution and recomputed residual vector. c c     the work space in `w' is used as follows: c     (1) the basis for the Krylov subspace, size n*(m+1); c     (2) the Hessenberg matrix, only the upper triangular c     portion of the matrix is stored, size (m+1)*m/2 + 1 c     (3) three vectors, all are of size m, they are c     the cosine and sine of the Givens rotations, the third one holds c     the residuals, it is of size m+1. c c     TOTAL SIZE REQUIRED == (n+3)*(m+2) + (m+1)*m/2 c     Note: m == ipar(5). The default value for this is 15 if c     ipar(5) <= 1. c----------------------------------------------------------------------- c     external functions used c real * 8 distdot external distdot c real * 8 one , zero parameter ( one = 1.0D0 , zero = 0.0D0 ) c c     local variables, ptr and p2 are temporary pointers, c     hes points to the Hessenberg matrix, c     vc, vs point to the cosines and sines of the Givens rotations c     vrn points to the vectors of residual norms, more precisely c     the right hand side of the least square problem solved. c integer i , ii , idx , k , m , ptr , p2 , prs , hes , vc , vs , vrn real * 8 alpha , c , s logical lp , rp save c c     check the status of the call c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 30 , 40 , 50 , 60 , 70 ) ipar ( 10 ) c c     initialization c if ( ipar ( 5 ). le . 1 ) then m = 15 else m = ipar ( 5 ) endif idx = n * ( m + 1 ) hes = idx + n vc = hes + ( m + 1 ) * m / 2 + 1 vs = vc + m vrn = vs + m i = vrn + m + 1 call bisinit ( ipar , fpar , i , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     request for matrix vector multiplication A*x in the initialization c 100 ipar ( 1 ) = 1 ipar ( 8 ) = n + 1 ipar ( 9 ) = 1 ipar ( 10 ) = 1 k = 0 do i = 1 , n w ( n + i ) = sol ( i ) enddo return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 if ( lp ) then do i = 1 , n w ( n + i ) = rhs ( i ) - w ( i ) enddo ipar ( 1 ) = 3 ipar ( 10 ) = 2 return else do i = 1 , n w ( i ) = rhs ( i ) - w ( i ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c 20 alpha = sqrt ( distdot ( n , w , 1 , w , 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n + 1 if ( ipar ( 7 ). eq . 1 . and . ipar ( 3 ). ne . 999 ) then if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else fpar ( 4 ) = fpar ( 1 ) * alpha + fpar ( 2 ) endif fpar ( 3 ) = alpha endif fpar ( 5 ) = alpha w ( vrn + 1 ) = alpha if ( alpha . le . fpar ( 4 ) . and . ipar ( 3 ). ge . 0 . and . ipar ( 3 ). ne . 999 ) then ipar ( 1 ) = 0 fpar ( 6 ) = alpha goto 300 endif alpha = one / alpha do ii = 1 , n w ( ii ) = alpha * w ( ii ) enddo fpar ( 11 ) = fpar ( 11 ) + n c c     request for (1) right preconditioning c     (2) matrix vector multiplication c     (3) left preconditioning c 110 k = k + 1 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = k * n - n + 1 if ( lp ) then ipar ( 9 ) = k * n + 1 else ipar ( 9 ) = idx + 1 endif ipar ( 10 ) = 3 return endif c 30 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ( k - 1 ) * n + 1 endif if ( lp ) then ipar ( 9 ) = idx + 1 else ipar ( 9 ) = 1 + k * n endif ipar ( 10 ) = 4 return c 40 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = k * n + 1 ipar ( 10 ) = 5 return endif c c     Modified Gram-Schmidt orthogonalization procedure c     temporary pointer 'ptr' is pointing to the current column of the c     Hessenberg matrix. 'p2' points to the new basis vector c 50 ipar ( 7 ) = ipar ( 7 ) + 1 ptr = k * ( k - 1 ) / 2 + hes p2 = ipar ( 9 ) call mgsro (. false ., n , n , k + 1 , k + 1 , fpar ( 11 ), w , w ( ptr + 1 ), $ ipar ( 12 )) if ( ipar ( 12 ). lt . 0 ) goto 200 c c     apply previous Givens rotations to column. c p2 = ptr + 1 do i = 1 , k - 1 ptr = p2 p2 = p2 + 1 alpha = w ( ptr ) c = w ( vc + i ) s = w ( vs + i ) w ( ptr ) = c * alpha + s * w ( p2 ) w ( p2 ) = c * w ( p2 ) - s * alpha enddo c c     end of one Arnoldi iteration, alpha will store the estimated c     residual norm at current stage c fpar ( 11 ) = fpar ( 11 ) + 6 * k prs = vrn + k alpha = fpar ( 5 ) if ( w ( p2 ) . ne . zero ) alpha = abs ( w ( p2 + 1 ) * w ( prs ) / w ( p2 )) fpar ( 5 ) = alpha c if (( k . ge . m ) . or . ( ipar ( 3 ). ge . 0 . and . alpha . le . fpar ( 4 )) + . or . ( ipar ( 6 ). gt . 0 . and . ipar ( 7 ). ge . ipar ( 6 ))) + goto 200 c call givens ( w ( p2 ), w ( p2 + 1 ), c , s ) w ( vc + k ) = c w ( vs + k ) = s alpha = - s * w ( prs ) w ( prs ) = c * w ( prs ) w ( prs + 1 ) = alpha c if ( w ( p2 ). ne . zero ) goto 110 c c     update the approximate solution, first solve the upper triangular c     system, temporary pointer ptr points to the Hessenberg matrix, c     prs points to the right-hand-side (also the solution) of the system. c 200 ptr = hes + k * ( k + 1 ) / 2 prs = vrn + k if ( w ( ptr ). eq . zero ) then c c     if the diagonal elements of the last column is zero, reduce k by 1 c     so that a smaller trianguler system is solved c k = k - 1 if ( k . gt . 0 ) then goto 200 else ipar ( 1 ) = - 3 ipar ( 12 ) = - 4 goto 300 endif endif w ( prs ) = w ( prs ) / w ( ptr ) do i = k - 1 , 1 , - 1 ptr = ptr - i - 1 do ii = 1 , i w ( vrn + ii ) = w ( vrn + ii ) - w ( prs ) * w ( ptr + ii ) enddo prs = prs - 1 w ( prs ) = w ( prs ) / w ( ptr ) enddo c do ii = 1 , n w ( ii ) = w ( ii ) * w ( prs ) enddo do i = 1 , k - 1 prs = prs + 1 ptr = i * n do ii = 1 , n w ( ii ) = w ( ii ) + w ( prs ) * w ( ptr + ii ) enddo enddo fpar ( 11 ) = fpar ( 11 ) + 2 * ( k - 1 ) * n + n + k * ( k + 1 ) c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = 1 ipar ( 9 ) = idx + 1 ipar ( 10 ) = 6 return endif c 60 if ( rp ) then do i = 1 , n sol ( i ) = sol ( i ) + w ( idx + i ) enddo else do i = 1 , n sol ( i ) = sol ( i ) + w ( i ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c c     process the complete stopping criteria c if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = - 1 ipar ( 9 ) = idx + 1 ipar ( 10 ) = 7 return else if ( ipar ( 3 ). lt . 0 ) then if ( ipar ( 7 ). le . m + 1 ) then fpar ( 3 ) = abs ( w ( vrn + 1 )) if ( ipar ( 3 ). eq . - 1 ) fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif alpha = abs ( w ( vrn + k )) endif fpar ( 6 ) = alpha c c     do we need to restart ? c 70 if ( ipar ( 12 ). ne . 0 ) then ipar ( 1 ) = - 3 goto 300 endif if ( ipar ( 7 ). lt . ipar ( 6 ) . or . ipar ( 6 ). le . 0 ) then if ( ipar ( 3 ). ne . 999 ) then if ( fpar ( 6 ). gt . fpar ( 4 )) goto 100 else if ( ipar ( 11 ). eq . 0 ) goto 100 endif endif c c     termination, set error code, compute convergence rate c if ( ipar ( 1 ). gt . 0 ) then if ( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). eq . 1 ) then ipar ( 1 ) = 0 else if ( ipar ( 3 ). ne . 999 . and . fpar ( 6 ). le . fpar ( 4 )) then ipar ( 1 ) = 0 else if ( ipar ( 7 ). ge . ipar ( 6 ) . and . ipar ( 6 ). gt . 0 ) then ipar ( 1 ) = - 1 else ipar ( 1 ) = - 10 endif endif 300 if ( fpar ( 3 ). ne . zero . and . fpar ( 6 ). ne . zero . and . + ipar ( 7 ). gt . ipar ( 13 )) then fpar ( 7 ) = log10 ( fpar ( 3 ) / fpar ( 6 )) / dble ( ipar ( 7 ) - ipar ( 13 )) else fpar ( 7 ) = zero endif return end c-----end-of-fom-------------------------------------------------------- c----------------------------------------------------------------------- subroutine gmres ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( * ) c----------------------------------------------------------------------- c     This a version of GMRES implemented with reverse communication. c     It is a simple restart version of the GMRES algorithm. c c     ipar(5) == the dimension of the Krylov subspace c     after every ipar(5) iterations, the GMRES will restart with c     the updated solution and recomputed residual vector. c c     the space of the `w' is used as follows: c     (1) the basis for the Krylov subspace, size n*(m+1); c     (2) the Hessenberg matrix, only the upper triangular c     portion of the matrix is stored, size (m+1)*m/2 + 1 c     (3) three vectors, all are of size m, they are c     the cosine and sine of the Givens rotations, the third one holds c     the residuals, it is of size m+1. c c     TOTAL SIZE REQUIRED == (n+3)*(m+2) + (m+1)*m/2 c     Note: m == ipar(5). The default value for this is 15 if c     ipar(5) <= 1. c----------------------------------------------------------------------- c     external functions used c real * 8 distdot external distdot c real * 8 one , zero parameter ( one = 1.0D0 , zero = 0.0D0 ) c c     local variables, ptr and p2 are temporary pointers, c     hess points to the Hessenberg matrix, c     vc, vs point to the cosines and sines of the Givens rotations c     vrn points to the vectors of residual norms, more precisely c     the right hand side of the least square problem solved. c integer i , ii , idx , k , m , ptr , p2 , hess , vc , vs , vrn real * 8 alpha , c , s logical lp , rp save c c     check the status of the call c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 30 , 40 , 50 , 60 , 70 ) ipar ( 10 ) c c     initialization c if ( ipar ( 5 ). le . 1 ) then m = 15 else m = ipar ( 5 ) endif idx = n * ( m + 1 ) hess = idx + n vc = hess + ( m + 1 ) * m / 2 + 1 vs = vc + m vrn = vs + m i = vrn + m + 1 call bisinit ( ipar , fpar , i , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     request for matrix vector multiplication A*x in the initialization c 100 ipar ( 1 ) = 1 ipar ( 8 ) = n + 1 ipar ( 9 ) = 1 ipar ( 10 ) = 1 k = 0 do i = 1 , n w ( n + i ) = sol ( i ) enddo return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 if ( lp ) then do i = 1 , n w ( n + i ) = rhs ( i ) - w ( i ) enddo ipar ( 1 ) = 3 ipar ( 10 ) = 2 return else do i = 1 , n w ( i ) = rhs ( i ) - w ( i ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c 20 alpha = sqrt ( distdot ( n , w , 1 , w , 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( ipar ( 7 ). eq . 1 . and . ipar ( 3 ). ne . 999 ) then if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else fpar ( 4 ) = fpar ( 1 ) * alpha + fpar ( 2 ) endif fpar ( 3 ) = alpha endif fpar ( 5 ) = alpha w ( vrn + 1 ) = alpha if ( alpha . le . fpar ( 4 ) . and . ipar ( 3 ). ge . 0 . and . ipar ( 3 ). ne . 999 ) then ipar ( 1 ) = 0 fpar ( 6 ) = alpha goto 300 endif alpha = one / alpha do ii = 1 , n w ( ii ) = alpha * w ( ii ) enddo fpar ( 11 ) = fpar ( 11 ) + n c c     request for (1) right preconditioning c     (2) matrix vector multiplication c     (3) left preconditioning c 110 k = k + 1 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = k * n - n + 1 if ( lp ) then ipar ( 9 ) = k * n + 1 else ipar ( 9 ) = idx + 1 endif ipar ( 10 ) = 3 return endif c 30 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ( k - 1 ) * n + 1 endif if ( lp ) then ipar ( 9 ) = idx + 1 else ipar ( 9 ) = 1 + k * n endif ipar ( 10 ) = 4 return c 40 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = k * n + 1 ipar ( 10 ) = 5 return endif c c     Modified Gram-Schmidt orthogonalization procedure c     temporary pointer 'ptr' is pointing to the current column of the c     Hessenberg matrix. 'p2' points to the new basis vector c 50 ipar ( 7 ) = ipar ( 7 ) + 1 ptr = k * ( k - 1 ) / 2 + hess p2 = ipar ( 9 ) call mgsro (. false ., n , n , k + 1 , k + 1 , fpar ( 11 ), w , w ( ptr + 1 ), $ ipar ( 12 )) if ( ipar ( 12 ). lt . 0 ) goto 200 c c     apply previous Givens rotations and generate a new one to eliminate c     the subdiagonal element. c p2 = ptr + 1 do i = 1 , k - 1 ptr = p2 p2 = p2 + 1 alpha = w ( ptr ) c = w ( vc + i ) s = w ( vs + i ) w ( ptr ) = c * alpha + s * w ( p2 ) w ( p2 ) = c * w ( p2 ) - s * alpha enddo call givens ( w ( p2 ), w ( p2 + 1 ), c , s ) w ( vc + k ) = c w ( vs + k ) = s p2 = vrn + k alpha = - s * w ( p2 ) w ( p2 ) = c * w ( p2 ) w ( p2 + 1 ) = alpha c c     end of one Arnoldi iteration, alpha will store the estimated c     residual norm at current stage c fpar ( 11 ) = fpar ( 11 ) + 6 * k + 2 alpha = abs ( alpha ) fpar ( 5 ) = alpha if ( k . lt . m . and . . not .( ipar ( 3 ). ge . 0 . and . alpha . le . fpar ( 4 )) + . and . ( ipar ( 6 ). le . 0 . or . ipar ( 7 ). lt . ipar ( 6 ))) goto 110 c c     update the approximate solution, first solve the upper triangular c     system, temporary pointer ptr points to the Hessenberg matrix, c     p2 points to the right-hand-side (also the solution) of the system. c 200 ptr = hess + k * ( k + 1 ) / 2 p2 = vrn + k if ( w ( ptr ). eq . zero ) then c c     if the diagonal elements of the last column is zero, reduce k by 1 c     so that a smaller trianguler system is solved [It should only c     happen when the matrix is singular, and at most once!] c k = k - 1 if ( k . gt . 0 ) then goto 200 else ipar ( 1 ) = - 3 ipar ( 12 ) = - 4 goto 300 endif endif w ( p2 ) = w ( p2 ) / w ( ptr ) do i = k - 1 , 1 , - 1 ptr = ptr - i - 1 do ii = 1 , i w ( vrn + ii ) = w ( vrn + ii ) - w ( p2 ) * w ( ptr + ii ) enddo p2 = p2 - 1 w ( p2 ) = w ( p2 ) / w ( ptr ) enddo c do ii = 1 , n w ( ii ) = w ( ii ) * w ( p2 ) enddo do i = 1 , k - 1 ptr = i * n p2 = p2 + 1 do ii = 1 , n w ( ii ) = w ( ii ) + w ( p2 ) * w ( ptr + ii ) enddo enddo fpar ( 11 ) = fpar ( 11 ) + 2 * k * n - n + k * ( k + 1 ) c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = 1 ipar ( 9 ) = idx + 1 ipar ( 10 ) = 6 return endif c 60 if ( rp ) then do i = 1 , n sol ( i ) = sol ( i ) + w ( idx + i ) enddo else do i = 1 , n sol ( i ) = sol ( i ) + w ( i ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c c     process the complete stopping criteria c if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = - 1 ipar ( 9 ) = idx + 1 ipar ( 10 ) = 7 return else if ( ipar ( 3 ). lt . 0 ) then if ( ipar ( 7 ). le . m + 1 ) then fpar ( 3 ) = abs ( w ( vrn + 1 )) if ( ipar ( 3 ). eq . - 1 ) fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif fpar ( 6 ) = abs ( w ( vrn + k )) else fpar ( 6 ) = fpar ( 5 ) endif c c     do we need to restart ? c 70 if ( ipar ( 12 ). ne . 0 ) then ipar ( 1 ) = - 3 goto 300 endif if (( ipar ( 7 ). lt . ipar ( 6 ) . or . ipar ( 6 ). le . 0 ) . and . + (( ipar ( 3 ). eq . 99 9. and . ipar ( 11 ). eq . 0 ) . or . + ( ipar ( 3 ). ne . 99 9. and . fpar ( 6 ). gt . fpar ( 4 )))) goto 100 c c     termination, set error code, compute convergence rate c if ( ipar ( 1 ). gt . 0 ) then if ( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). eq . 1 ) then ipar ( 1 ) = 0 else if ( ipar ( 3 ). ne . 999 . and . fpar ( 6 ). le . fpar ( 4 )) then ipar ( 1 ) = 0 else if ( ipar ( 7 ). ge . ipar ( 6 ) . and . ipar ( 6 ). gt . 0 ) then ipar ( 1 ) = - 1 else ipar ( 1 ) = - 10 endif endif 300 if ( fpar ( 3 ). ne . zero . and . fpar ( 6 ). ne . zero . and . + ipar ( 7 ). gt . ipar ( 13 )) then fpar ( 7 ) = log10 ( fpar ( 3 ) / fpar ( 6 )) / dble ( ipar ( 7 ) - ipar ( 13 )) else fpar ( 7 ) = zero endif return end c-----end-of-gmres c----------------------------------------------------------------------- subroutine dqgmres ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( * ) c----------------------------------------------------------------------- c     DQGMRES -- Flexible Direct version of Quasi-General Minimum c     Residual method. The right preconditioning can be varied from c     step to step. c c     Work space used = n + lb * (2*n+4) c     where lb = ipar(5) + 1 (default 16 if ipar(5) <= 1) c----------------------------------------------------------------------- c     local variables c real * 8 one , zero , deps parameter ( one = 1.0D0 , zero = 0.0D0 ) parameter ( deps = 1.0D-33 ) c integer i , ii , j , jp1 , j0 , k , ptrw , ptrv , iv , iw , ic , is , ihm , ihd , lb , ptr real * 8 alpha , beta , psi , c , s , distdot logical lp , rp , full external distdot , bisinit save c c     where to go c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 40 , 50 , 60 , 70 ) ipar ( 10 ) c c     locations of the work arrays. The arrangement is as follows: c     w(1:n) -- temporary storage for the results of the preconditioning c     w(iv+1:iw) -- the V's c     w(iw+1:ic) -- the W's c     w(ic+1:is) -- the COSINEs of the Givens rotations c     w(is+1:ihm) -- the SINEs of the Givens rotations c     w(ihm+1:ihd) -- the last column of the Hessenberg matrix c     w(ihd+1:i) -- the inverse of the diagonals of the Hessenberg matrix c if ( ipar ( 5 ). le . 1 ) then lb = 16 else lb = ipar ( 5 ) + 1 endif iv = n iw = iv + lb * n ic = iw + lb * n is = ic + lb ihm = is + lb ihd = ihm + lb i = ihd + lb c c     parameter check, initializations c full = . false . call bisinit ( ipar , fpar , i , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return ipar ( 1 ) = 1 if ( lp ) then do ii = 1 , n w ( iv + ii ) = sol ( ii ) enddo ipar ( 8 ) = iv + 1 ipar ( 9 ) = 1 else do ii = 1 , n w ( ii ) = sol ( ii ) enddo ipar ( 8 ) = 1 ipar ( 9 ) = iv + 1 endif ipar ( 10 ) = 1 return c 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 if ( lp ) then do i = 1 , n w ( i ) = rhs ( i ) - w ( i ) enddo ipar ( 1 ) = 3 ipar ( 8 ) = 1 ipar ( 9 ) = iv + 1 ipar ( 10 ) = 2 return else do i = 1 , n w ( iv + i ) = rhs ( i ) - w ( iv + i ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c 20 alpha = sqrt ( distdot ( n , w ( iv + 1 ), 1 , w ( iv + 1 ), 1 )) fpar ( 11 ) = fpar ( 11 ) + ( n + n ) if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * alpha + fpar ( 2 ) endif fpar ( 3 ) = alpha fpar ( 5 ) = alpha psi = alpha if ( alpha . le . fpar ( 4 )) then ipar ( 1 ) = 0 fpar ( 6 ) = alpha goto 80 endif alpha = one / alpha do i = 1 , n w ( iv + i ) = w ( iv + i ) * alpha enddo fpar ( 11 ) = fpar ( 11 ) + n j = 0 c c     iterations start here c 30 j = j + 1 if ( j . gt . lb ) j = j - lb jp1 = j + 1 if ( jp1 . gt . lb ) jp1 = jp1 - lb ptrv = iv + ( j - 1 ) * n + 1 ptrw = iv + ( jp1 - 1 ) * n + 1 if (. not . full ) then if ( j . gt . jp1 ) full = . true . endif if ( full ) then j0 = jp1 + 1 if ( j0 . gt . lb ) j0 = j0 - lb else j0 = 1 endif c c     request the caller to perform matrix-vector multiplication and c     preconditioning c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = ptrv ipar ( 9 ) = ptrv + iw - iv ipar ( 10 ) = 3 return else do i = 0 , n - 1 w ( ptrv + iw - iv + i ) = w ( ptrv + i ) enddo endif c 40 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ptrv endif if ( lp ) then ipar ( 9 ) = 1 else ipar ( 9 ) = ptrw endif ipar ( 10 ) = 4 return c 50 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = ptrw ipar ( 10 ) = 5 return endif c c     compute the last column of the Hessenberg matrix c     modified Gram-schmidt procedure, orthogonalize against (lb-1) c     previous vectors c 60 continue call mgsro ( full , n , n , lb , jp1 , fpar ( 11 ), w ( iv + 1 ), w ( ihm + 1 ), $ ipar ( 12 )) if ( ipar ( 12 ). lt . 0 ) then ipar ( 1 ) = - 3 goto 80 endif beta = w ( ihm + jp1 ) c c     incomplete factorization (QR factorization through Givens rotations) c     (1) apply previous rotations [(lb-1) of them] c     (2) generate a new rotation c if ( full ) then w ( ihm + jp1 ) = w ( ihm + j0 ) * w ( is + jp1 ) w ( ihm + j0 ) = w ( ihm + j0 ) * w ( ic + jp1 ) endif i = j0 do while ( i . ne . j ) k = i + 1 if ( k . gt . lb ) k = k - lb c = w ( ic + i ) s = w ( is + i ) alpha = w ( ihm + i ) w ( ihm + i ) = c * alpha + s * w ( ihm + k ) w ( ihm + k ) = c * w ( ihm + k ) - s * alpha i = k enddo call givens ( w ( ihm + j ), beta , c , s ) if ( full ) then fpar ( 11 ) = fpar ( 11 ) + 6 * lb else fpar ( 11 ) = fpar ( 11 ) + 6 * j endif c c     detect whether diagonal element of this column is zero c if ( abs ( w ( ihm + j )). lt . deps ) then ipar ( 1 ) = - 3 goto 80 endif w ( ihd + j ) = one / w ( ihm + j ) w ( ic + j ) = c w ( is + j ) = s c c     update the W's (the conjugate directions) -- essentially this is one c     step of triangular solve. c ptrw = iw + ( j - 1 ) * n + 1 if ( full ) then do i = j + 1 , lb alpha = - w ( ihm + i ) * w ( ihd + i ) ptr = iw + ( i - 1 ) * n + 1 do ii = 0 , n - 1 w ( ptrw + ii ) = w ( ptrw + ii ) + alpha * w ( ptr + ii ) enddo enddo endif do i = 1 , j - 1 alpha = - w ( ihm + i ) * w ( ihd + i ) ptr = iw + ( i - 1 ) * n + 1 do ii = 0 , n - 1 w ( ptrw + ii ) = w ( ptrw + ii ) + alpha * w ( ptr + ii ) enddo enddo c c     update the solution to the linear system c alpha = psi * c * w ( ihd + j ) psi = - s * psi do i = 1 , n sol ( i ) = sol ( i ) + alpha * w ( ptrw - 1 + i ) enddo if ( full ) then fpar ( 11 ) = fpar ( 11 ) + lb * ( n + n ) else fpar ( 11 ) = fpar ( 11 ) + j * ( n + n ) endif c c     determine whether to continue, c     compute the desired error/residual norm c ipar ( 7 ) = ipar ( 7 ) + 1 fpar ( 5 ) = abs ( psi ) if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = - 1 ipar ( 9 ) = 1 ipar ( 10 ) = 6 return endif if ( ipar ( 3 ). lt . 0 ) then alpha = abs ( alpha ) if ( ipar ( 7 ). eq . 2 . and . ipar ( 3 ). eq . - 1 ) then fpar ( 3 ) = alpha * sqrt ( distdot ( n , w ( ptrw ), 1 , w ( ptrw ), 1 )) fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) fpar ( 6 ) = fpar ( 3 ) else fpar ( 6 ) = alpha * sqrt ( distdot ( n , w ( ptrw ), 1 , w ( ptrw ), 1 )) endif fpar ( 11 ) = fpar ( 11 ) + 2 * n else fpar ( 6 ) = fpar ( 5 ) endif if ( ipar ( 1 ). ge . 0 . and . fpar ( 6 ). gt . fpar ( 4 ) . and . ( ipar ( 6 ). le . 0 + . or . ipar ( 7 ). lt . ipar ( 6 ))) goto 30 70 if ( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). eq . 0 ) goto 30 c c     clean up the iterative solver c 80 fpar ( 7 ) = zero if ( fpar ( 3 ). ne . zero . and . fpar ( 6 ). ne . zero . and . + ipar ( 7 ). gt . ipar ( 13 )) + fpar ( 7 ) = log10 ( fpar ( 3 ) / fpar ( 6 )) / dble ( ipar ( 7 ) - ipar ( 13 )) if ( ipar ( 1 ). gt . 0 ) then if ( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). ne . 0 ) then ipar ( 1 ) = 0 else if ( fpar ( 6 ). le . fpar ( 4 )) then ipar ( 1 ) = 0 else if ( ipar ( 6 ). gt . 0 . and . ipar ( 7 ). ge . ipar ( 6 )) then ipar ( 1 ) = - 1 else ipar ( 1 ) = - 10 endif endif return end c-----end-of-dqgmres c----------------------------------------------------------------------- subroutine fgmres ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( * ) c----------------------------------------------------------------------- c     This a version of FGMRES implemented with reverse communication. c c     ipar(5) == the dimension of the Krylov subspace c c     the space of the `w' is used as follows: c     >> V: the bases for the Krylov subspace, size n*(m+1); c     >> W: the above bases after (left-)multiplying with the c     right-preconditioner inverse, size m*n; c     >> a temporary vector of size n; c     >> the Hessenberg matrix, only the upper triangular portion c     of the matrix is stored, size (m+1)*m/2 + 1 c     >> three vectors, first two are of size m, they are the cosine c     and sine of the Givens rotations, the third one holds the c     residuals, it is of size m+1. c c     TOTAL SIZE REQUIRED == n*(2m+1) + (m+1)*m/2 + 3*m + 2 c     Note: m == ipar(5). The default value for this is 15 if c     ipar(5) <= 1. c----------------------------------------------------------------------- c     external functions used c real * 8 distdot external distdot c real * 8 one , zero parameter ( one = 1.0D0 , zero = 0.0D0 ) c c     local variables, ptr and p2 are temporary pointers, c     hess points to the Hessenberg matrix, c     vc, vs point to the cosines and sines of the Givens rotations c     vrn points to the vectors of residual norms, more precisely c     the right hand side of the least square problem solved. c integer i , ii , idx , iz , k , m , ptr , p2 , hess , vc , vs , vrn real * 8 alpha , c , s logical lp , rp save c c     check the status of the call c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 10 , 20 , 30 , 40 , 50 , 60 ) ipar ( 10 ) c c     initialization c if ( ipar ( 5 ). le . 1 ) then m = 15 else m = ipar ( 5 ) endif idx = n * ( m + 1 ) iz = idx + n hess = iz + n * m vc = hess + ( m + 1 ) * m / 2 + 1 vs = vc + m vrn = vs + m i = vrn + m + 1 call bisinit ( ipar , fpar , i , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return c c     request for matrix vector multiplication A*x in the initialization c 100 ipar ( 1 ) = 1 ipar ( 8 ) = n + 1 ipar ( 9 ) = 1 ipar ( 10 ) = 1 k = 0 do ii = 1 , n w ( ii + n ) = sol ( ii ) enddo return 10 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 fpar ( 11 ) = fpar ( 11 ) + n if ( lp ) then do i = 1 , n w ( n + i ) = rhs ( i ) - w ( i ) enddo ipar ( 1 ) = 3 ipar ( 10 ) = 2 return else do i = 1 , n w ( i ) = rhs ( i ) - w ( i ) enddo endif c 20 alpha = sqrt ( distdot ( n , w , 1 , w , 1 )) fpar ( 11 ) = fpar ( 11 ) + n + n if ( ipar ( 7 ). eq . 1 . and . ipar ( 3 ). ne . 999 ) then if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else fpar ( 4 ) = fpar ( 1 ) * alpha + fpar ( 2 ) endif fpar ( 3 ) = alpha endif fpar ( 5 ) = alpha w ( vrn + 1 ) = alpha if ( alpha . le . fpar ( 4 ) . and . ipar ( 3 ). ge . 0 . and . ipar ( 3 ). ne . 999 ) then ipar ( 1 ) = 0 fpar ( 6 ) = alpha goto 300 endif alpha = one / alpha do ii = 1 , n w ( ii ) = w ( ii ) * alpha enddo fpar ( 11 ) = fpar ( 11 ) + n c c     request for (1) right preconditioning c     (2) matrix vector multiplication c     (3) left preconditioning c 110 k = k + 1 if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = k * n - n + 1 ipar ( 9 ) = iz + ipar ( 8 ) ipar ( 10 ) = 3 return else do ii = 0 , n - 1 w ( iz + k * n - ii ) = w ( k * n - ii ) enddo endif c 30 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ( k - 1 ) * n + 1 endif if ( lp ) then ipar ( 9 ) = idx + 1 else ipar ( 9 ) = 1 + k * n endif ipar ( 10 ) = 4 return c 40 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = k * n + 1 ipar ( 10 ) = 5 return endif c c     Modified Gram-Schmidt orthogonalization procedure c     temporary pointer 'ptr' is pointing to the current column of the c     Hessenberg matrix. 'p2' points to the new basis vector c 50 ptr = k * ( k - 1 ) / 2 + hess p2 = ipar ( 9 ) ipar ( 7 ) = ipar ( 7 ) + 1 call mgsro (. false ., n , n , k + 1 , k + 1 , fpar ( 11 ), w , w ( ptr + 1 ), $ ipar ( 12 )) if ( ipar ( 12 ). lt . 0 ) goto 200 c c     apply previous Givens rotations and generate a new one to eliminate c     the subdiagonal element. c p2 = ptr + 1 do i = 1 , k - 1 ptr = p2 p2 = p2 + 1 alpha = w ( ptr ) c = w ( vc + i ) s = w ( vs + i ) w ( ptr ) = c * alpha + s * w ( p2 ) w ( p2 ) = c * w ( p2 ) - s * alpha enddo call givens ( w ( p2 ), w ( p2 + 1 ), c , s ) w ( vc + k ) = c w ( vs + k ) = s p2 = vrn + k alpha = - s * w ( p2 ) w ( p2 ) = c * w ( p2 ) w ( p2 + 1 ) = alpha fpar ( 11 ) = fpar ( 11 ) + 6 * k c c     end of one Arnoldi iteration, alpha will store the estimated c     residual norm at current stage c alpha = abs ( alpha ) fpar ( 5 ) = alpha if ( k . lt . m . and . . not .( ipar ( 3 ). ge . 0 . and . alpha . le . fpar ( 4 )) + . and . ( ipar ( 6 ). le . 0 . or . ipar ( 7 ). lt . ipar ( 6 ))) goto 110 c c     update the approximate solution, first solve the upper triangular c     system, temporary pointer ptr points to the Hessenberg matrix, c     p2 points to the right-hand-side (also the solution) of the system. c 200 ptr = hess + k * ( k + 1 ) / 2 p2 = vrn + k if ( w ( ptr ). eq . zero ) then c c     if the diagonal elements of the last column is zero, reduce k by 1 c     so that a smaller trianguler system is solved [It should only c     happen when the matrix is singular!] c k = k - 1 if ( k . gt . 0 ) then goto 200 else ipar ( 1 ) = - 3 ipar ( 12 ) = - 4 goto 300 endif endif w ( p2 ) = w ( p2 ) / w ( ptr ) do i = k - 1 , 1 , - 1 ptr = ptr - i - 1 do ii = 1 , i w ( vrn + ii ) = w ( vrn + ii ) - w ( p2 ) * w ( ptr + ii ) enddo p2 = p2 - 1 w ( p2 ) = w ( p2 ) / w ( ptr ) enddo c do i = 0 , k - 1 ptr = iz + i * n do ii = 1 , n sol ( ii ) = sol ( ii ) + w ( p2 ) * w ( ptr + ii ) enddo p2 = p2 + 1 enddo fpar ( 11 ) = fpar ( 11 ) + 2 * k * n + k * ( k + 1 ) c c     process the complete stopping criteria c if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = - 1 ipar ( 9 ) = idx + 1 ipar ( 10 ) = 6 return else if ( ipar ( 3 ). lt . 0 ) then if ( ipar ( 7 ). le . m + 1 ) then fpar ( 3 ) = abs ( w ( vrn + 1 )) if ( ipar ( 3 ). eq . - 1 ) fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif fpar ( 6 ) = abs ( w ( vrn + k )) else if ( ipar ( 3 ). ne . 999 ) then fpar ( 6 ) = fpar ( 5 ) endif c c     do we need to restart ? c 60 if ( ipar ( 12 ). ne . 0 ) then ipar ( 1 ) = - 3 goto 300 endif if (( ipar ( 7 ). lt . ipar ( 6 ) . or . ipar ( 6 ). le . 0 ). and . + (( ipar ( 3 ). eq . 99 9. and . ipar ( 11 ). eq . 0 ) . or . + ( ipar ( 3 ). ne . 99 9. and . fpar ( 6 ). gt . fpar ( 4 )))) goto 100 c c     termination, set error code, compute convergence rate c if ( ipar ( 1 ). gt . 0 ) then if ( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). eq . 1 ) then ipar ( 1 ) = 0 else if ( ipar ( 3 ). ne . 999 . and . fpar ( 6 ). le . fpar ( 4 )) then ipar ( 1 ) = 0 else if ( ipar ( 7 ). ge . ipar ( 6 ) . and . ipar ( 6 ). gt . 0 ) then ipar ( 1 ) = - 1 else ipar ( 1 ) = - 10 endif endif 300 if ( fpar ( 3 ). ne . zero . and . fpar ( 6 ). ne . zero . and . $ ipar ( 7 ). gt . ipar ( 13 )) then fpar ( 7 ) = log10 ( fpar ( 3 ) / fpar ( 6 )) / dble ( ipar ( 7 ) - ipar ( 13 )) else fpar ( 7 ) = zero endif return end c-----end-of-fgmres c----------------------------------------------------------------------- subroutine dbcg ( n , rhs , sol , ipar , fpar , w ) implicit none integer n , ipar ( 16 ) real * 8 rhs ( n ), sol ( n ), fpar ( 16 ), w ( n , * ) c----------------------------------------------------------------------- c Quasi GMRES method for solving a linear c system of equations a * sol = y.  double precision version. c this version is without restarting and without preconditioning. c parameters : c ----------- c n     = dimension of the problem c c y     = w(:,1) a temporary storage used for various operations c z     = w(:,2) a work vector of length n. c v     = w(:,3:4) size n x 2 c w     = w(:,5:6) size n x 2 c p     = w(:,7:9) work array of dimension n x 3 c del x = w(:,10)  accumulation of the changes in solution c tmp   = w(:,11)  a temporary vector used to hold intermediate result of c                  preconditioning, etc. c c sol   = the solution of the problem . at input sol must contain an c         initial guess to the solution. c    ***  note:   y is destroyed on return. c c----------------------------------------------------------------------- c subroutines and functions called: c 1) matrix vector multiplication and preconditioning through reverse c     communication c c 2) implu, uppdir, distdot (blas) c----------------------------------------------------------------------- c aug. 1983  version.    author youcef saad. yale university computer c science dept. some  changes made july 3, 1986. c references: siam j. sci. stat. comp., vol. 5, pp. 203-228 (1984) c----------------------------------------------------------------------- c     local variables c real * 8 one , zero parameter ( one = 1.0D0 , zero = 0.0D0 ) c real * 8 t , sqrt , distdot , ss , res , beta , ss1 , delta , x , zeta , umm integer k , j , i , i2 , ip2 , ju , lb , lbm1 , np , indp logical lp , rp , full , perm ( 3 ) real * 8 ypiv ( 3 ), u ( 3 ), usav ( 3 ) external tidycg save c c     where to go c if ( ipar ( 1 ). le . 0 ) ipar ( 10 ) = 0 goto ( 110 , 120 , 130 , 140 , 150 , 160 , 170 , 180 , 190 , 200 ) ipar ( 10 ) c c     initialization, parameter checking, clear the work arrays c call bisinit ( ipar , fpar , 11 * n , 1 , lp , rp , w ) if ( ipar ( 1 ). lt . 0 ) return perm ( 1 ) = . false . perm ( 2 ) = . false . perm ( 3 ) = . false . usav ( 1 ) = zero usav ( 2 ) = zero usav ( 3 ) = zero ypiv ( 1 ) = zero ypiv ( 2 ) = zero ypiv ( 3 ) = zero c----------------------------------------------------------------------- c     initialize constants for outer loop : c----------------------------------------------------------------------- lb = 3 lbm1 = 2 c c     get initial residual vector and norm c ipar ( 1 ) = 1 ipar ( 8 ) = 1 ipar ( 9 ) = 1 + n do i = 1 , n w ( i , 1 ) = sol ( i ) enddo ipar ( 10 ) = 1 return 110 ipar ( 7 ) = ipar ( 7 ) + 1 ipar ( 13 ) = ipar ( 13 ) + 1 if ( lp ) then do i = 1 , n w ( i , 1 ) = rhs ( i ) - w ( i , 2 ) enddo ipar ( 1 ) = 3 ipar ( 8 ) = 1 ipar ( 9 ) = n + n + 1 ipar ( 10 ) = 2 return else do i = 1 , n w ( i , 3 ) = rhs ( i ) - w ( i , 2 ) enddo endif fpar ( 11 ) = fpar ( 11 ) + n c 120 fpar ( 3 ) = sqrt ( distdot ( n , w ( 1 , 3 ), 1 , w ( 1 , 3 ), 1 )) fpar ( 11 ) = fpar ( 11 ) + n + n fpar ( 5 ) = fpar ( 3 ) fpar ( 7 ) = fpar ( 3 ) zeta = fpar ( 3 ) if ( abs ( ipar ( 3 )). eq . 2 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( distdot ( n , rhs , 1 , rhs , 1 )) + fpar ( 2 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n else if ( ipar ( 3 ). ne . 999 ) then fpar ( 4 ) = fpar ( 1 ) * zeta + fpar ( 2 ) endif if ( ipar ( 3 ). ge . 0. and . fpar ( 5 ). le . fpar ( 4 )) then fpar ( 6 ) = fpar ( 5 ) goto 900 endif c c     normalize first arnoldi vector c t = one / zeta do 22 k = 1 , n w ( k , 3 ) = w ( k , 3 ) * t w ( k , 5 ) = w ( k , 3 ) 22 continue fpar ( 11 ) = fpar ( 11 ) + n c c     initialize constants for main loop c beta = zero delta = zero i2 = 1 indp = 0 i = 0 c c     main loop: i = index of the loop. c c----------------------------------------------------------------------- 30 i = i + 1 c if ( rp ) then ipar ( 1 ) = 5 ipar ( 8 ) = ( 1 + i2 ) * n + 1 if ( lp ) then ipar ( 9 ) = 1 else ipar ( 9 ) = 10 * n + 1 endif ipar ( 10 ) = 3 return endif c 130 ipar ( 1 ) = 1 if ( rp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ( 1 + i2 ) * n + 1 endif if ( lp ) then ipar ( 9 ) = 10 * n + 1 else ipar ( 9 ) = 1 endif ipar ( 10 ) = 4 return c 140 if ( lp ) then ipar ( 1 ) = 3 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = 1 ipar ( 10 ) = 5 return endif c c     A&#94;t * x c 150 ipar ( 7 ) = ipar ( 7 ) + 1 if ( lp ) then ipar ( 1 ) = 4 ipar ( 8 ) = ( 3 + i2 ) * n + 1 if ( rp ) then ipar ( 9 ) = n + 1 else ipar ( 9 ) = 10 * n + 1 endif ipar ( 10 ) = 6 return endif c 160 ipar ( 1 ) = 2 if ( lp ) then ipar ( 8 ) = ipar ( 9 ) else ipar ( 8 ) = ( 3 + i2 ) * n + 1 endif if ( rp ) then ipar ( 9 ) = 10 * n + 1 else ipar ( 9 ) = n + 1 endif ipar ( 10 ) = 7 return c 170 if ( rp ) then ipar ( 1 ) = 6 ipar ( 8 ) = ipar ( 9 ) ipar ( 9 ) = n + 1 ipar ( 10 ) = 8 return endif c----------------------------------------------------------------------- c     orthogonalize current v against previous v's and c     determine relevant part of i-th column of u(.,.) the c     upper triangular matrix -- c----------------------------------------------------------------------- 180 ipar ( 7 ) = ipar ( 7 ) + 1 u ( 1 ) = zero ju = 1 k = i2 if ( i . le . lbm1 ) ju = 0 if ( i . lt . lb ) k = 0 31 if ( k . eq . lbm1 ) k = 0 k = k + 1 c if ( k . ne . i2 ) then ss = delta ss1 = beta ju = ju + 1 u ( ju ) = ss else ss = distdot ( n , w ( 1 , 1 ), 1 , w ( 1 , 4 + k ), 1 ) fpar ( 11 ) = fpar ( 11 ) + 2 * n ss1 = ss ju = ju + 1 u ( ju ) = ss endif c do 32 j = 1 , n w ( j , 1 ) = w ( j , 1 ) - ss * w ( j , k + 2 ) w ( j , 2 ) = w ( j , 2 ) - ss1 * w ( j , k + 4 ) 32 continue fpar ( 11 ) = fpar ( 11 ) + 4 * n c if ( k . ne . i2 ) goto 31 c c     end of Mod. Gram. Schmidt loop c t = distdot ( n , w ( 1 , 2 ), 1 , w ( 1 , 1 ), 1 ) c beta = sqrt ( abs ( t )) delta = t / beta c ss = one / beta ss1 = one / delta c c     normalize and insert new vectors c ip2 = i2 if ( i2 . eq . lbm1 ) i2 = 0 i2 = i2 + 1 c do 315 j = 1 , n w ( j , i2 + 2 ) = w ( j , 1 ) * ss w ( j , i2 + 4 ) = w ( j , 2 ) * ss1 315 continue fpar ( 11 ) = fpar ( 11 ) + 4 * n c----------------------------------------------------------------------- c     end of orthogonalization. c     now compute the coefficients u(k) of the last c     column of the  l . u  factorization of h . c----------------------------------------------------------------------- np = min0 ( i , lb ) full = ( i . ge . lb ) call implu ( np , umm , beta , ypiv , u , perm , full ) c----------------------------------------------------------------------- c     update conjugate directions and solution c----------------------------------------------------------------------- do 33 k = 1 , n w ( k , 1 ) = w ( k , ip2 + 2 ) 33 continue call uppdir ( n , w ( 1 , 7 ), np , lb , indp , w , u , usav , fpar ( 11 )) c----------------------------------------------------------------------- if ( i . eq . 1 ) goto 34 j = np - 1 if ( full ) j = j - 1 if (. not . perm ( j )) zeta = - zeta * ypiv ( j ) 34 x = zeta / u ( np ) if ( perm ( np )) goto 36 do 35 k = 1 , n w ( k , 10 ) = w ( k , 10 ) + x * w ( k , 1 ) 35 continue fpar ( 11 ) = fpar ( 11 ) + 2 * n c----------------------------------------------------------------------- 36 if ( ipar ( 3 ). eq . 999 ) then ipar ( 1 ) = 10 ipar ( 8 ) = 9 * n + 1 ipar ( 9 ) = 10 * n + 1 ipar ( 10 ) = 9 return endif res = abs ( beta * zeta / umm ) fpar ( 5 ) = res * sqrt ( distdot ( n , w ( 1 , i2 + 2 ), 1 , w ( 1 , i2 + 2 ), 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( ipar ( 3 ). lt . 0 ) then fpar ( 6 ) = x * sqrt ( distdot ( n , w , 1 , w , 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( ipar ( 7 ). le . 3 ) then fpar ( 3 ) = fpar ( 6 ) if ( ipar ( 3 ). eq . - 1 ) then fpar ( 4 ) = fpar ( 1 ) * sqrt ( fpar ( 3 )) + fpar ( 2 ) endif endif else fpar ( 6 ) = fpar ( 5 ) endif c---- convergence test ----------------------------------------------- 190 if ( ipar ( 3 ). eq . 99 9. and . ipar ( 11 ). eq . 0 ) then goto 30 else if ( fpar ( 6 ). gt . fpar ( 4 ) . and . ( ipar ( 6 ). gt . ipar ( 7 ) . or . + ipar ( 6 ). le . 0 )) then goto 30 endif c----------------------------------------------------------------------- c     here the fact that the last step is different is accounted for. c----------------------------------------------------------------------- if (. not . perm ( np )) goto 900 x = zeta / umm do 40 k = 1 , n w ( k , 10 ) = w ( k , 10 ) + x * w ( k , 1 ) 40 continue fpar ( 11 ) = fpar ( 11 ) + 2 * n c c     right preconditioning and clean-up jobs c 900 if ( rp ) then if ( ipar ( 1 ). lt . 0 ) ipar ( 12 ) = ipar ( 1 ) ipar ( 1 ) = 5 ipar ( 8 ) = 9 * n + 1 ipar ( 9 ) = ipar ( 8 ) + n ipar ( 10 ) = 10 return endif 200 if ( rp ) then call tidycg ( n , ipar , fpar , sol , w ( 1 , 11 )) else call tidycg ( n , ipar , fpar , sol , w ( 1 , 10 )) endif return end c-----end-of-dbcg------------------------------------------------------- c----------------------------------------------------------------------- subroutine implu ( np , umm , beta , ypiv , u , permut , full ) implicit none real * 8 umm , beta , ypiv ( * ), u ( * ), x , xpiv logical full , perm , permut ( * ) integer np , k , npm1 c----------------------------------------------------------------------- c     performs implicitly one step of the lu factorization of a c     banded hessenberg matrix. c----------------------------------------------------------------------- npm1 = 0 if ( np . le . 1 ) goto 12 npm1 = np - 1 c c     -- perform  previous step of the factorization- c do 6 k = 1 , npm1 if (. not . permut ( k )) goto 5 x = u ( k ) u ( k ) = u ( k + 1 ) u ( k + 1 ) = x 5 u ( k + 1 ) = u ( k + 1 ) - ypiv ( k ) * u ( k ) 6 continue c----------------------------------------------------------------------- c     now determine pivotal information to be used in the next call c----------------------------------------------------------------------- 12 umm = u ( np ) perm = ( beta . gt . abs ( umm )) if (. not . perm ) goto 4 xpiv = umm / beta u ( np ) = beta goto 8 4 xpiv = beta / umm 8 permut ( np ) = perm ypiv ( np ) = xpiv if (. not . full ) return c     shift everything up if full... do 7 k = 1 , npm1 ypiv ( k ) = ypiv ( k + 1 ) permut ( k ) = permut ( k + 1 ) 7 continue return c-----end-of-implu end c----------------------------------------------------------------------- subroutine uppdir ( n , p , np , lbp , indp , y , u , usav , flops ) implicit none real * 8 p ( n , lbp ), y ( * ), u ( * ), usav ( * ), x , flops integer k , np , n , npm1 , j , ju , indp , lbp c----------------------------------------------------------------------- c     updates the conjugate directions p given the upper part of the c     banded upper triangular matrix u.  u contains the non zero c     elements of the column of the triangular matrix.. c----------------------------------------------------------------------- real * 8 zero parameter ( zero = 0.0D0 ) c npm1 = np - 1 if ( np . le . 1 ) goto 12 j = indp ju = npm1 10 if ( j . le . 0 ) j = lbp x = u ( ju ) / usav ( j ) if ( x . eq . zero ) goto 115 do 11 k = 1 , n y ( k ) = y ( k ) - x * p ( k , j ) 11 continue flops = flops + 2 * n 115 j = j - 1 ju = ju - 1 if ( ju . ge . 1 ) goto 10 12 indp = indp + 1 if ( indp . gt . lbp ) indp = 1 usav ( indp ) = u ( np ) do 13 k = 1 , n p ( k , indp ) = y ( k ) 13 continue return c----------------------------------------------------------------------- c-------end-of-uppdir--------------------------------------------------- end subroutine givens ( x , y , c , s ) implicit none real * 8 x , y , c , s c----------------------------------------------------------------------- c     Given x and y, this subroutine generates a Givens' rotation c, s. c     And apply the rotation on (x,y) ==> (sqrt(x**2 + y**2), 0). c     (See P 202 of \"matrix computation\" by Golub and van Loan.) c----------------------------------------------------------------------- real * 8 t , one , zero parameter ( zero = 0.0D0 , one = 1.0D0 ) c if ( x . eq . zero . and . y . eq . zero ) then c = one s = zero else if ( abs ( y ). gt . abs ( x )) then t = x / y x = sqrt ( one + t * t ) s = sign ( one / x , y ) c = t * s else if ( abs ( y ). le . abs ( x )) then t = y / x y = sqrt ( one + t * t ) c = sign ( one / y , x ) s = t * c else c c     X or Y must be an invalid floating-point number, set both to zero c x = zero y = zero c = one s = zero endif x = abs ( x * y ) c c     end of givens c return end c-----end-of-givens c----------------------------------------------------------------------- logical function stopbis ( n , ipar , mvpi , fpar , r , delx , sx ) implicit none integer n , mvpi , ipar ( 16 ) real * 8 fpar ( 16 ), r ( n ), delx ( n ), sx , distdot external distdot c----------------------------------------------------------------------- c     function for determining the stopping criteria. return value of c     true if the stopbis criteria is satisfied. c----------------------------------------------------------------------- if ( ipar ( 11 ) . eq . 1 ) then stopbis = . true . else stopbis = . false . endif if ( ipar ( 6 ). gt . 0 . and . ipar ( 7 ). ge . ipar ( 6 )) then ipar ( 1 ) = - 1 stopbis = . true . endif if ( stopbis ) return c c     computes errors c fpar ( 5 ) = sqrt ( distdot ( n , r , 1 , r , 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( ipar ( 3 ). lt . 0 ) then c c     compute the change in the solution vector c fpar ( 6 ) = sx * sqrt ( distdot ( n , delx , 1 , delx , 1 )) fpar ( 11 ) = fpar ( 11 ) + 2 * n if ( ipar ( 7 ). lt . mvpi + mvpi + 1 ) then c c     if this is the end of the first iteration, set fpar(3:4) c fpar ( 3 ) = fpar ( 6 ) if ( ipar ( 3 ). eq . - 1 ) then fpar ( 4 ) = fpar ( 1 ) * fpar ( 3 ) + fpar ( 2 ) endif endif else fpar ( 6 ) = fpar ( 5 ) endif c c     .. the test is struct this way so that when the value in fpar(6) c       is not a valid number, STOPBIS is set to .true. c if ( fpar ( 6 ). gt . fpar ( 4 )) then stopbis = . false . ipar ( 11 ) = 0 else stopbis = . true . ipar ( 11 ) = 1 endif c return end c-----end-of-stopbis c----------------------------------------------------------------------- subroutine tidycg ( n , ipar , fpar , sol , delx ) implicit none integer i , n , ipar ( 16 ) real * 8 fpar ( 16 ), sol ( n ), delx ( n ) c----------------------------------------------------------------------- c     Some common operations required before terminating the CG routines c----------------------------------------------------------------------- real * 8 zero parameter ( zero = 0.0D0 ) c if ( ipar ( 12 ). ne . 0 ) then ipar ( 1 ) = ipar ( 12 ) else if ( ipar ( 1 ). gt . 0 ) then if (( ipar ( 3 ). eq . 999 . and . ipar ( 11 ). eq . 1 ) . or . + fpar ( 6 ). le . fpar ( 4 )) then ipar ( 1 ) = 0 else if ( ipar ( 7 ). ge . ipar ( 6 ) . and . ipar ( 6 ). gt . 0 ) then ipar ( 1 ) = - 1 else ipar ( 1 ) = - 10 endif endif if ( fpar ( 3 ). gt . zero . and . fpar ( 6 ). gt . zero . and . + ipar ( 7 ). gt . ipar ( 13 )) then fpar ( 7 ) = log10 ( fpar ( 3 ) / fpar ( 6 )) / dble ( ipar ( 7 ) - ipar ( 13 )) else fpar ( 7 ) = zero endif do i = 1 , n sol ( i ) = sol ( i ) + delx ( i ) enddo return end c-----end-of-tidycg c----------------------------------------------------------------------- logical function brkdn ( alpha , ipar ) implicit none integer ipar ( 16 ) real * 8 alpha , beta , zero , one parameter ( zero = 0.0D0 , one = 1.0D0 ) c----------------------------------------------------------------------- c     test whether alpha is zero or an abnormal number, if yes, c     this routine will return .true. c c     If alpha == 0, ipar(1) = -3, c     if alpha is an abnormal number, ipar(1) = -9. c----------------------------------------------------------------------- brkdn = . false . if ( alpha . gt . zero ) then beta = one / alpha if (. not . beta . gt . zero ) then brkdn = . true . ipar ( 1 ) = - 9 endif else if ( alpha . lt . zero ) then beta = one / alpha if (. not . beta . lt . zero ) then brkdn = . true . ipar ( 1 ) = - 9 endif else if ( alpha . eq . zero ) then brkdn = . true . ipar ( 1 ) = - 3 else brkdn = . true . ipar ( 1 ) = - 9 endif return end c-----end-of-brkdn c----------------------------------------------------------------------- subroutine bisinit ( ipar , fpar , wksize , dsc , lp , rp , wk ) implicit none integer i , ipar ( 16 ), wksize , dsc logical lp , rp real * 8 fpar ( 16 ), wk ( * ) c----------------------------------------------------------------------- c     some common initializations for the iterative solvers c----------------------------------------------------------------------- real * 8 zero , one parameter ( zero = 0.0D0 , one = 1.0D0 ) c c     ipar(1) = -2 inidcate that there are not enough space in the work c     array c if ( ipar ( 4 ). lt . wksize ) then ipar ( 1 ) = - 2 ipar ( 4 ) = wksize return endif c if ( ipar ( 2 ). gt . 2 ) then lp = . true . rp = . true . else if ( ipar ( 2 ). eq . 2 ) then lp = . false . rp = . true . else if ( ipar ( 2 ). eq . 1 ) then lp = . true . rp = . false . else lp = . false . rp = . false . endif if ( ipar ( 3 ). eq . 0 ) ipar ( 3 ) = dsc c     .. clear the ipar elements used ipar ( 7 ) = 0 ipar ( 8 ) = 0 ipar ( 9 ) = 0 ipar ( 10 ) = 0 ipar ( 11 ) = 0 ipar ( 12 ) = 0 ipar ( 13 ) = 0 c c     fpar(1) must be between (0, 1), fpar(2) must be positive, c     fpar(1) and fpar(2) can NOT both be zero c     Normally returns ipar(1) = -4 to indicate any of above error c if ( fpar ( 1 ). lt . zero . or . fpar ( 1 ). ge . one . or . fpar ( 2 ). lt . zero . or . & ( fpar ( 1 ). eq . zero . and . fpar ( 2 ). eq . zero )) then if ( ipar ( 1 ). eq . 0 ) then ipar ( 1 ) = - 4 return else fpar ( 1 ) = 1.0D-6 fpar ( 2 ) = 1.0D-16 endif endif c     .. clear the fpar elements do i = 3 , 10 fpar ( i ) = zero enddo if ( fpar ( 11 ). lt . zero ) fpar ( 11 ) = zero c     .. clear the used portion of the work array to zero do i = 1 , wksize wk ( i ) = zero enddo c return c-----end-of-bisinit end c----------------------------------------------------------------------- subroutine mgsro ( full , lda , n , m , ind , ops , vec , hh , ierr ) implicit none logical full integer lda , m , n , ind , ierr real * 8 ops , hh ( m ), vec ( lda , m ) c----------------------------------------------------------------------- c     MGSRO  -- Modified Gram-Schmidt procedure with Selective Re- c               Orthogonalization c     The ind'th vector of VEC is orthogonalized against the rest of c     the vectors. c c     The test for performing re-orthogonalization is performed for c     each indivadual vectors. If the cosine between the two vectors c     is greater than 0.99 (REORTH = 0.99**2), re-orthogonalization is c     performed. The norm of the 'new' vector is kept in variable NRM0, c     and updated after operating with each vector. c c     full   -- .ture. if it is necessary to orthogonalize the ind'th c               against all the vectors vec(:,1:ind-1), vec(:,ind+2:m) c               .false. only orthogonalize againt vec(:,1:ind-1) c     lda    -- the leading dimension of VEC c     n      -- length of the vector in VEC c     m      -- number of vectors can be stored in VEC c     ind    -- index to the vector to be changed c     ops    -- operation counts c     vec    -- vector of LDA X M storing the vectors c     hh     -- coefficient of the orthogonalization c     ierr   -- error code c               0 : successful return c               -1: zero input vector c               -2: input vector contains abnormal numbers c               -3: input vector is a linear combination of others c c     External routines used: real*8 distdot c----------------------------------------------------------------------- integer i , k real * 8 nrm0 , nrm1 , fct , thr , distdot , zero , one , reorth parameter ( zero = 0.0D0 , one = 1.0D0 , reorth = 0.98D0 ) external distdot c c     compute the norm of the input vector c nrm0 = distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , ind ), 1 ) ops = ops + n + n thr = nrm0 * reorth if ( nrm0 . le . zero ) then ierr = - 1 return else if ( nrm0 . gt . zero . and . one / nrm0 . gt . zero ) then ierr = 0 else ierr = - 2 return endif c c     Modified Gram-Schmidt loop c if ( full ) then do 40 i = ind + 1 , m fct = distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , i ), 1 ) hh ( i ) = fct do 20 k = 1 , n vec ( k , ind ) = vec ( k , ind ) - fct * vec ( k , i ) 20 continue ops = ops + 4 * n + 2 if ( fct * fct . gt . thr ) then fct = distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , i ), 1 ) hh ( i ) = hh ( i ) + fct do 30 k = 1 , n vec ( k , ind ) = vec ( k , ind ) - fct * vec ( k , i ) 30 continue ops = ops + 4 * n + 1 endif nrm0 = nrm0 - hh ( i ) * hh ( i ) if ( nrm0 . lt . zero ) nrm0 = zero thr = nrm0 * reorth 40 continue endif c do 70 i = 1 , ind - 1 fct = distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , i ), 1 ) hh ( i ) = fct do 50 k = 1 , n vec ( k , ind ) = vec ( k , ind ) - fct * vec ( k , i ) 50 continue ops = ops + 4 * n + 2 if ( fct * fct . gt . thr ) then fct = distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , i ), 1 ) hh ( i ) = hh ( i ) + fct do 60 k = 1 , n vec ( k , ind ) = vec ( k , ind ) - fct * vec ( k , i ) 60 continue ops = ops + 4 * n + 1 endif nrm0 = nrm0 - hh ( i ) * hh ( i ) if ( nrm0 . lt . zero ) nrm0 = zero thr = nrm0 * reorth 70 continue c c     test the resulting vector c nrm1 = sqrt ( distdot ( n , vec ( 1 , ind ), 1 , vec ( 1 , ind ), 1 )) ops = ops + n + n hh ( ind ) = nrm1 if ( nrm1 . le . zero ) then ierr = - 3 return endif c c     scale the resulting vector c fct = one / nrm1 do 80 k = 1 , n vec ( k , ind ) = vec ( k , ind ) * fct 80 continue ops = ops + n + 1 c c     normal return c ierr = 0 return c     end surbotine mgsro end","tags":"","loc":"sourcefile\\iters.f.html"},{"title":"matvec.f – LINALG","text":"Contents Subroutines amux amuxms atmux atmuxr amuxe amuxd amuxj vbrmv lsol ldsol lsolc ldsolc ldsoll usol udsol usolc udsolc Source Code matvec.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c          BASIC MATRIX-VECTOR OPERATIONS - MATVEC MODULE              c c         Matrix-vector Mulitiplications and Triang. Solves            c c----------------------------------------------------------------------c c contents: (as of Nov 18, 1991)                                       c c----------                                                            c c 1) Matrix-vector products:                                           c c---------------------------                                           c c amux  : A times a vector. Compressed Sparse Row (CSR) format.        c c amuxms: A times a vector. Modified Compress Sparse Row format.       c c atmux : Transp(A) times a vector. CSR format.                        c c atmuxr: Transp(A) times a vector. CSR format. A rectangular.         c c amuxe : A times a vector. Ellpack/Itpack (ELL) format.               c c amuxd : A times a vector. Diagonal (DIA) format.                     c c amuxj : A times a vector. Jagged Diagonal (JAD) format.              c c vbrmv : Sparse matrix-full vector product, in VBR format             c c                                                                      c c 2) Triangular system solutions:                                      c c-------------------------------                                       c c lsol  : Unit Lower Triang. solve. Compressed Sparse Row (CSR) format.c c ldsol : Lower Triang. solve.  Modified Sparse Row (MSR) format.      c c lsolc : Unit Lower Triang. solve. Comp. Sparse Column (CSC) format.  c c ldsolc: Lower Triang. solve. Modified Sparse Column (MSC) format.    c c ldsoll: Lower Triang. solve with level scheduling. MSR format.       c c usol  : Unit Upper Triang. solve. Compressed Sparse Row (CSR) format.c c udsol : Upper Triang. solve.  Modified Sparse Row (MSR) format.      c c usolc : Unit Upper Triang. solve. Comp. Sparse Column (CSC) format.  c c udsolc: Upper Triang. solve.  Modified Sparse Column (MSC) format.   c c----------------------------------------------------------------------c c 1)     M A T R I X    B Y    V E C T O R     P R O D U C T S         c c----------------------------------------------------------------------c subroutine amux ( n , x , y , a , ja , ia ) implicit none real * 8 x ( * ), y ( * ), a ( * ) integer n , ja ( * ), ia ( * ) c----------------------------------------------------------------------- c         A times a vector c----------------------------------------------------------------------- c multiplies a matrix by a vector using the dot product form c Matrix A is stored in compressed sparse row storage. c c on entry: c---------- c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c a, ja, c    ia = input matrix in compressed sparse row format. c c on return: c----------- c y     = real array of length n, containing the product y=Ax c c----------------------------------------------------------------------- c local variables c real * 8 t integer i , k c----------------------------------------------------------------------- do 100 i = 1 , n c c     compute the inner product of row i with vector x c t = 0.0d0 do 99 k = ia ( i ), ia ( i + 1 ) - 1 t = t + a ( k ) * x ( ja ( k )) 99 continue c c     store result in y(i) c y ( i ) = t 100 continue c return c---------end-of-amux--------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amuxms ( n , x , y , a , ja ) implicit none real * 8 x ( * ), y ( * ), a ( * ) integer n , ja ( * ) c----------------------------------------------------------------------- c         A times a vector in MSR format c----------------------------------------------------------------------- c multiplies a matrix by a vector using the dot product form c Matrix A is stored in Modified Sparse Row storage. c c on entry: c---------- c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c a, ja,= input matrix in modified compressed sparse row format. c c on return: c----------- c y     = real array of length n, containing the product y=Ax c c----------------------------------------------------------------------- c local variables c integer i , k c----------------------------------------------------------------------- do 10 i = 1 , n y ( i ) = a ( i ) * x ( i ) 10 continue do 100 i = 1 , n c c     compute the inner product of row i with vector x c do 99 k = ja ( i ), ja ( i + 1 ) - 1 y ( i ) = y ( i ) + a ( k ) * x ( ja ( k )) 99 continue 100 continue c return c---------end-of-amuxm-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine atmux ( n , x , y , a , ja , ia ) implicit none real * 8 x ( * ), y ( * ), a ( * ) integer n , ia ( * ), ja ( * ) c----------------------------------------------------------------------- c         transp( A ) times a vector c----------------------------------------------------------------------- c multiplies the transpose of a matrix by a vector when the original c matrix is stored in compressed sparse row storage. Can also be c viewed as the product of a matrix by a vector when the original c matrix is stored in the compressed sparse column format. c----------------------------------------------------------------------- c c on entry: c---------- c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c a, ja, c    ia = input matrix in compressed sparse row format. c c on return: c----------- c y     = real array of length n, containing the product y=transp(A)*x c c----------------------------------------------------------------------- c     local variables c integer i , k c----------------------------------------------------------------------- c c     zero out output vector c do 1 i = 1 , n y ( i ) = 0.0 1 continue c c loop over the rows c do 100 i = 1 , n do 99 k = ia ( i ), ia ( i + 1 ) - 1 y ( ja ( k )) = y ( ja ( k )) + x ( i ) * a ( k ) 99 continue 100 continue c return c-------------end-of-atmux---------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine atmuxr ( m , n , x , y , a , ja , ia ) implicit none real * 8 x ( * ), y ( * ), a ( * ) integer m , n , ia ( * ), ja ( * ) c----------------------------------------------------------------------- c         transp( A ) times a vector, A can be rectangular c----------------------------------------------------------------------- c See also atmux.  The essential difference is how the solution vector c is initially zeroed.  If using this to multiply rectangular CSC c matrices by a vector, m number of rows, n is number of columns. c----------------------------------------------------------------------- c c on entry: c---------- c m     = column dimension of A c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c a, ja, c    ia = input matrix in compressed sparse row format. c c on return: c----------- c y     = real array of length n, containing the product y=transp(A)*x c c----------------------------------------------------------------------- c     local variables c integer i , k c----------------------------------------------------------------------- c c     zero out output vector c do 1 i = 1 , m y ( i ) = 0.0 1 continue c c loop over the rows c do 100 i = 1 , n do 99 k = ia ( i ), ia ( i + 1 ) - 1 y ( ja ( k )) = y ( ja ( k )) + x ( i ) * a ( k ) 99 continue 100 continue c return c-------------end-of-atmuxr--------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amuxe ( n , x , y , na , ncol , a , ja ) implicit none real * 8 x ( n ), y ( n ), a ( na , * ) integer n , na , ncol , ja ( na , * ) c----------------------------------------------------------------------- c        A times a vector in Ellpack Itpack format (ELL) c----------------------------------------------------------------------- c multiplies a matrix by a vector when the original matrix is stored c in the ellpack-itpack sparse format. c----------------------------------------------------------------------- c c on entry: c---------- c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c na    = integer. The first dimension of arrays a and ja c         as declared by the calling program. c ncol  = integer. The number of active columns in array a. c         (i.e., the number of generalized diagonals in matrix.) c a, ja = the real and integer arrays of the itpack format c         (a(i,k),k=1,ncol contains the elements of row i in matrix c          ja(i,k),k=1,ncol contains their column numbers) c c on return: c----------- c y     = real array of length n, containing the product y=y=A*x c c----------------------------------------------------------------------- c local variables c integer i , j c----------------------------------------------------------------------- do 1 i = 1 , n y ( i ) = 0.0 1 continue do 10 j = 1 , ncol do 25 i = 1 , n y ( i ) = y ( i ) + a ( i , j ) * x ( ja ( i , j )) 25 continue 10 continue c return c--------end-of-amuxe--------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amuxd ( n , x , y , diag , ndiag , idiag , ioff ) implicit none integer n , ndiag , idiag , ioff ( idiag ) real * 8 x ( n ), y ( n ), diag ( ndiag , idiag ) c----------------------------------------------------------------------- c        A times a vector in Diagonal storage format (DIA) c----------------------------------------------------------------------- c multiplies a matrix by a vector when the original matrix is stored c in the diagonal storage format. c----------------------------------------------------------------------- c c on entry: c---------- c n     = row dimension of A c x     = real array of length equal to the column dimension of c         the A matrix. c ndiag  = integer. The first dimension of array adiag as declared in c         the calling program. c idiag  = integer. The number of diagonals in the matrix. c diag   = real array containing the diagonals stored of A. c idiag  = number of diagonals in matrix. c diag   = real array of size (ndiag x idiag) containing the diagonals c c ioff   = integer array of length idiag, containing the offsets of the c   \t   diagonals of the matrix: c          diag(i,k) contains the element a(i,i+ioff(k)) of the matrix. c c on return: c----------- c y     = real array of length n, containing the product y=A*x c c----------------------------------------------------------------------- c local variables c integer j , k , io , i1 , i2 c----------------------------------------------------------------------- do 1 j = 1 , n y ( j ) = 0.0d0 1 continue do 10 j = 1 , idiag io = ioff ( j ) i1 = max0 ( 1 , 1 - io ) i2 = min0 ( n , n - io ) do 9 k = i1 , i2 y ( k ) = y ( k ) + diag ( k , j ) * x ( k + io ) 9 continue 10 continue c return c----------end-of-amuxd------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amuxj ( n , x , y , jdiag , a , ja , ia ) implicit none integer n , jdiag , ja ( * ), ia ( * ) real * 8 x ( n ), y ( n ), a ( * ) c----------------------------------------------------------------------- c        A times a vector in Jagged-Diagonal storage format (JAD) c----------------------------------------------------------------------- c multiplies a matrix by a vector when the original matrix is stored c in the jagged diagonal storage format. c----------------------------------------------------------------------- c c on entry: c---------- c n      = row dimension of A c x      = real array of length equal to the column dimension of c         the A matrix. c jdiag  = integer. The number of jadded-diagonals in the data-structure. c a      = real array containing the jadded diagonals of A stored c          in succession (in decreasing lengths) c j      = integer array containing the colum indices of the c          corresponding elements in a. c ia     = integer array containing the lengths of the  jagged diagonals c c on return: c----------- c y      = real array of length n, containing the product y=A*x c c Note: c------- c Permutation related to the JAD format is not performed. c this can be done by: c     call permvec (n,y,y,iperm) c after the call to amuxj, where iperm is the permutation produced c by csrjad. c----------------------------------------------------------------------- c local variables c integer i , ii , k1 , len , j c----------------------------------------------------------------------- do 1 i = 1 , n y ( i ) = 0.0d0 1 continue do 70 ii = 1 , jdiag k1 = ia ( ii ) - 1 len = ia ( ii + 1 ) - k1 - 1 do 60 j = 1 , len y ( j ) = y ( j ) + a ( k1 + j ) * x ( ja ( k1 + j )) 60 continue 70 continue c return c----------end-of-amuxj------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine vbrmv ( nr , nc , ia , ja , a , kvstr , kvstc , x , b ) implicit none c----------------------------------------------------------------------- integer nr , nc , ia ( nr + 1 ), ja ( * ), kvstr ( nr + 1 ), kvstc ( * ) real * 8 a ( * ), x ( * ), b ( * ) c----------------------------------------------------------------------- c     Sparse matrix-full vector product, in VBR format. c----------------------------------------------------------------------- c     On entry: c-------------- c     nr, nc  = number of block rows and columns in matrix A c     ia,ja,(),a,kvstr,kvstc = matrix A in variable block row format c     x       = multiplier vector in full format c c     On return: c--------------- c     b = product of matrix A times vector x in full format c c     Algorithm: c--------------- c     Perform multiplication by traversing a in order. c c----------------------------------------------------------------------- c-----local variables integer n , i , j , ii , jj , k , istart , istop real * 8 xjj c--------------------------------- n = kvstc ( nc + 1 ) - 1 do i = 1 , n b ( i ) = 0.d0 enddo c--------------------------------- k = 1 do i = 1 , nr istart = kvstr ( i ) istop = kvstr ( i + 1 ) - 1 do j = ia ( i ), ia ( i + 1 ) - 1 do jj = kvstc ( ja ( j )), kvstc ( ja ( j ) + 1 ) - 1 xjj = x ( jj ) do ii = istart , istop b ( ii ) = b ( ii ) + xjj * a ( k ) k = k + 1 enddo enddo enddo enddo c--------------------------------- return end c----------------------------------------------------------------------- c----------------------end-of-vbrmv------------------------------------- c----------------------------------------------------------------------- c----------------------------------------------------------------------c c 2)     T R I A N G U L A R    S Y S T E M    S O L U T I O N S       c c----------------------------------------------------------------------c subroutine lsol ( n , x , y , al , jal , ial ) implicit none integer n , jal ( * ), ial ( n + 1 ) real * 8 x ( n ), y ( n ), al ( * ) c----------------------------------------------------------------------- c   solves    L x = y ; L = lower unit triang. /  CSR format c----------------------------------------------------------------------- c solves a unit lower triangular system by standard (sequential ) c forward elimination - matrix stored in CSR format. c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right side. c c al, c jal, c ial,    = Lower triangular matrix stored in compressed sparse row c          format. c c On return: c----------- c\tx  = The solution of  L x  = y. c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- x ( 1 ) = y ( 1 ) do 150 k = 2 , n t = y ( k ) do 100 j = ial ( k ), ial ( k + 1 ) - 1 t = t - al ( j ) * x ( jal ( j )) 100 continue x ( k ) = t 150 continue c return c----------end-of-lsol-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ldsol ( n , x , y , al , jal ) implicit none integer n , jal ( * ) real * 8 x ( n ), y ( n ), al ( * ) c----------------------------------------------------------------------- c     Solves L x = y    L = triangular. MSR format c----------------------------------------------------------------------- c solves a (non-unit) lower triangular system by standard (sequential) c forward elimination - matrix stored in MSR format c with diagonal elements already inverted (otherwise do inversion, c al(1:n) = 1.0/al(1:n),  before calling ldsol). c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right hand side. c c al, c jal,   = Lower triangular matrix stored in Modified Sparse Row c          format. c c On return: c----------- c\tx = The solution of  L x = y . c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- x ( 1 ) = y ( 1 ) * al ( 1 ) do 150 k = 2 , n t = y ( k ) do 100 j = jal ( k ), jal ( k + 1 ) - 1 t = t - al ( j ) * x ( jal ( j )) 100 continue x ( k ) = al ( k ) * t 150 continue return c----------end-of-ldsol------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine lsolc ( n , x , y , al , jal , ial ) implicit none integer n , jal ( * ), ial ( * ) real * 8 x ( n ), y ( n ), al ( * ) c----------------------------------------------------------------------- c       SOLVES     L x = y ;    where L = unit lower trang. CSC format c----------------------------------------------------------------------- c solves a unit lower triangular system by standard (sequential ) c forward elimination - matrix stored in CSC format. c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real*8 array containg the right side. c c al, c jal, c ial,    = Lower triangular matrix stored in compressed sparse column c          format. c c On return: c----------- c\tx  = The solution of  L x  = y. c----------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- do 140 k = 1 , n x ( k ) = y ( k ) 140 continue do 150 k = 1 , n - 1 t = x ( k ) do 100 j = ial ( k ), ial ( k + 1 ) - 1 x ( jal ( j )) = x ( jal ( j )) - t * al ( j ) 100 continue 150 continue c return c----------end-of-lsolc------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ldsolc ( n , x , y , al , jal ) implicit none integer n , jal ( * ) real * 8 x ( n ), y ( n ), al ( * ) c----------------------------------------------------------------------- c    Solves     L x = y ;    L = nonunit Low. Triang. MSC format c----------------------------------------------------------------------- c solves a (non-unit) lower triangular system by standard (sequential) c forward elimination - matrix stored in Modified Sparse Column format c with diagonal elements already inverted (otherwise do inversion, c al(1:n) = 1.0/al(1:n),  before calling ldsol). c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right hand side. c c al, c jal, c ial,    = Lower triangular matrix stored in Modified Sparse Column c           format. c c On return: c----------- c\tx = The solution of  L x = y . c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- do 140 k = 1 , n x ( k ) = y ( k ) 140 continue do 150 k = 1 , n x ( k ) = x ( k ) * al ( k ) t = x ( k ) do 100 j = jal ( k ), jal ( k + 1 ) - 1 x ( jal ( j )) = x ( jal ( j )) - t * al ( j ) 100 continue 150 continue c return c----------end-of-lsolc------------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ldsoll ( n , x , y , al , jal , nlev , lev , ilev ) implicit none integer n , nlev , jal ( * ), ilev ( nlev + 1 ), lev ( n ) real * 8 x ( n ), y ( n ), al ( * ) c----------------------------------------------------------------------- c    Solves L x = y    L = triangular. Uses LEVEL SCHEDULING/MSR format c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right hand side. c c al, c jal,   = Lower triangular matrix stored in Modified Sparse Row c          format. c nlev   = number of levels in matrix c lev    = integer array of length n, containing the permutation c          that defines the levels in the level scheduling ordering. c ilev   = pointer to beginning of levels in lev. c          the numbers lev(i) to lev(i+1)-1 contain the row numbers c          that belong to level number i, in the level shcheduling c          ordering. c c On return: c----------- c\tx = The solution of  L x = y . c-------------------------------------------------------------------- integer ii , jrow , i , k real * 8 t c c     outer loop goes through the levels. (SEQUENTIAL loop) c do 150 ii = 1 , nlev c c     next loop executes within the same level. PARALLEL loop c do 100 i = ilev ( ii ), ilev ( ii + 1 ) - 1 jrow = lev ( i ) c c compute inner product of row jrow with x c t = y ( jrow ) do 130 k = jal ( jrow ), jal ( jrow + 1 ) - 1 t = t - al ( k ) * x ( jal ( k )) 130 continue x ( jrow ) = t * al ( jrow ) 100 continue 150 continue return c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine usol ( n , x , y , au , jau , iau ) implicit none integer n , jau ( * ), iau ( n + 1 ) real * 8 x ( n ), y ( n ), au ( * ) c----------------------------------------------------------------------- c             Solves   U x = y    U = unit upper triangular. c----------------------------------------------------------------------- c solves a unit upper triangular system by standard (sequential ) c backward elimination - matrix stored in CSR format. c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right side. c c au, c jau, c iau,    = Lower triangular matrix stored in compressed sparse row c          format. c c On return: c----------- c\tx = The solution of  U x = y . c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- x ( n ) = y ( n ) do 150 k = n - 1 , 1 , - 1 t = y ( k ) do 100 j = iau ( k ), iau ( k + 1 ) - 1 t = t - au ( j ) * x ( jau ( j )) 100 continue x ( k ) = t 150 continue c return c----------end-of-usol-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine udsol ( n , x , y , au , jau ) implicit none integer n , jau ( * ) real * 8 x ( n ), y ( n ), au ( * ) c----------------------------------------------------------------------- c             Solves   U x = y  ;   U = upper triangular in MSR format c----------------------------------------------------------------------- c solves a non-unit upper triangular matrix by standard (sequential ) c backward elimination - matrix stored in MSR format. c with diagonal elements already inverted (otherwise do inversion, c au(1:n) = 1.0/au(1:n),  before calling). c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real array containg the right side. c c au, c jau,    = Lower triangular matrix stored in modified sparse row c          format. c c On return: c----------- c\tx = The solution of  U x = y . c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- x ( n ) = y ( n ) * au ( n ) do 150 k = n - 1 , 1 , - 1 t = y ( k ) do 100 j = jau ( k ), jau ( k + 1 ) - 1 t = t - au ( j ) * x ( jau ( j )) 100 continue x ( k ) = au ( k ) * t 150 continue c return c----------end-of-udsol------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine usolc ( n , x , y , au , jau , iau ) implicit none real * 8 x ( * ), y ( * ), au ( * ) integer n , jau ( * ), iau ( * ) c----------------------------------------------------------------------- c       SOUVES     U x = y ;    where U = unit upper trang. CSC format c----------------------------------------------------------------------- c solves a unit upper triangular system by standard (sequential ) c forward elimination - matrix stored in CSC format. c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real*8 array containg the right side. c c au, c jau, c iau,    = Uower triangular matrix stored in compressed sparse column c          format. c c On return: c----------- c\tx  = The solution of  U x  = y. c----------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- do 140 k = 1 , n x ( k ) = y ( k ) 140 continue do 150 k = n , 1 , - 1 t = x ( k ) do 100 j = iau ( k ), iau ( k + 1 ) - 1 x ( jau ( j )) = x ( jau ( j )) - t * au ( j ) 100 continue 150 continue c return c----------end-of-usolc------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine udsolc ( n , x , y , au , jau ) implicit none integer n , jau ( * ) real * 8 x ( n ), y ( n ), au ( * ) c----------------------------------------------------------------------- c    Solves     U x = y ;    U = nonunit Up. Triang. MSC format c----------------------------------------------------------------------- c solves a (non-unit) upper triangular system by standard (sequential) c forward elimination - matrix stored in Modified Sparse Column format c with diagonal elements already inverted (otherwise do inversion, c auuuul(1:n) = 1.0/au(1:n),  before calling ldsol). c----------------------------------------------------------------------- c c On entry: c---------- c n      = integer. dimension of problem. c y      = real*8 array containg the right hand side. c c au, c jau,   = Upper triangular matrix stored in Modified Sparse Column c          format. c c On return: c----------- c\tx = The solution of  U x = y . c-------------------------------------------------------------------- c local variables c integer k , j real * 8 t c----------------------------------------------------------------------- do 140 k = 1 , n x ( k ) = y ( k ) 140 continue do 150 k = n , 1 , - 1 x ( k ) = x ( k ) * au ( k ) t = x ( k ) do 100 j = jau ( k ), jau ( k + 1 ) - 1 x ( jau ( j )) = x ( jau ( j )) - t * au ( j ) 100 continue 150 continue c return c----------end-of-udsolc------------------------------------------------ c----------------------------------------------------------------------- end","tags":"","loc":"sourcefile\\matvec.f.html"},{"title":"unary.f – LINALG","text":"Contents Functions getelm Subroutines submat filter filterm csort clncsr copmat msrcop getdia transp getl getu levels amask rperm cperm dperm dperm1 dperm2 dmperm dvperm ivperm retmx diapos dscaldg extbdg getbwd blkfnd blkchk infdia amubdg aplbdg rnrms cnrms roscal coscal addblk get1up xtrows csrkvstr csrkvstc kvstmerge Source Code unary.f Source Code c----------------------------------------------------------------------c c                          S P A R S K I T                             c c----------------------------------------------------------------------c c                     UNARY SUBROUTINES MODULE                         c c----------------------------------------------------------------------c c contents:                                                            c c----------                                                            c c submat : extracts a submatrix from a sparse matrix.                  c c filter : filters elements from a matrix according to their magnitude.c c filterm: same as above, but for the MSR format                       c c csort  : sorts the elements in increasing order of columns           c c clncsr : clean up the CSR format matrix, remove duplicate entry, etc c c transp : in-place transposition routine (see also csrcsc in formats) c c copmat : copy of a matrix into another matrix (both stored csr)      c c msrcop : copies a matrix in MSR format into a matrix in MSR format   c c getelm : returns a(i,j) for any (i,j) from a CSR-stored matrix.      c c getdia : extracts a specified diagonal from a matrix.                c c getl   : extracts lower triangular part                              c c getu   : extracts upper triangular part                              c c levels : gets the level scheduling structure for lower triangular    c c          matrices.                                                   c c amask  : extracts     C = A mask M                                   c c rperm  : permutes the rows of a matrix (B = P A)                     c c cperm  : permutes the columns of a matrix (B = A Q)                  c c dperm  : permutes both the rows and columns of a matrix (B = P A Q ) c c dperm1 : general extractiob routine (extracts arbitrary rows)        c c dperm2 : general submatrix permutation/extraction routine            c c dmperm : symmetric permutation of row and column (B=PAP') in MSR fmt c c dvperm : permutes a real vector (in-place)                           c c ivperm : permutes an integer vector (in-place)                       c c retmx  : returns the max absolute value in each row of the matrix    c c diapos : returns the positions of the diagonal elements in A.        c c extbdg : extracts the main diagonal blocks of a matrix.              c c getbwd : returns the bandwidth information on a matrix.              c c blkfnd : finds the block-size of a matrix.                           c c blkchk : checks whether a given integer is the block size of A.      c c infdia : obtains information on the diagonals of A.                  c c amubdg : gets number of nonzeros in each row of A*B (as well as NNZ) c c aplbdg : gets number of nonzeros in each row of A+B (as well as NNZ) c c rnrms  : computes the norms of the rows of A                         c c cnrms  : computes the norms of the columns of A                      c c roscal : scales the rows of a matrix by their norms.                 c c coscal : scales the columns of a matrix by their norms.              c c addblk : Adds a matrix B into a block of A.                          c c get1up : Collects the first elements of each row of the upper        c c          triangular portion of the matrix.                           c c xtrows : extracts given rows from a matrix in CSR format.            c c csrkvstr:  Finds block row partitioning of matrix in CSR format      c c csrkvstc:  Finds block column partitioning of matrix in CSR format   c c kvstmerge: Merges block partitionings, for conformal row/col pattern c c----------------------------------------------------------------------c subroutine submat ( job , i1 , i2 , j1 , j2 , a , ja , ia , nr , nc , ao , jao , iao ) implicit none integer job , i1 , i2 , j1 , j2 , nr , nc , ia ( * ), ja ( * ), jao ( * ), iao ( * ) real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c extracts the submatrix A(i1:i2,j1:j2) and puts the result in c matrix ao,iao,jao c---- In place: ao,jao,iao may be the same as a,ja,ia. c-------------- c on input c--------- c n\t= row dimension of the matrix c i1,i2 = two integers with i2 .ge. i1 indicating the range of rows to be c          extracted. c j1,j2 = two integers with j2 .ge. j1 indicating the range of columns c         to be extracted. c         * There is no checking whether the input values for i1, i2, j1, c           j2 are between 1 and n. c a, c ja, c ia    = matrix in compressed sparse row format. c c job\t= job indicator: if job .ne. 1 then the real values in a are NOT c         extracted, only the column indices (i.e. data structure) are. c         otherwise values as well as column indices are extracted... c c on output c-------------- c nr\t= number of rows of submatrix c nc\t= number of columns of submatrix c\t  * if either of nr or nc is nonpositive the code will quit. c c ao, c jao,iao = extracted matrix in general sparse format with jao containing c\tthe column indices,and iao being the pointer to the beginning c\tof the row,in arrays a,ja. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer i , ii , j , k , k1 , k2 , klen nr = i2 - i1 + 1 nc = j2 - j1 + 1 c if ( nr . le . 0 . or . nc . le . 0 ) return c klen = 0 c c     simple procedure. proceeds row-wise... c do 100 i = 1 , nr ii = i1 + i - 1 k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 iao ( i ) = klen + 1 c----------------------------------------------------------------------- do 60 k = k1 , k2 j = ja ( k ) if ( j . ge . j1 . and . j . le . j2 ) then klen = klen + 1 if ( job . eq . 1 ) ao ( klen ) = a ( k ) jao ( klen ) = j - j1 + 1 endif 60 continue 100 continue iao ( nr + 1 ) = klen + 1 return c------------end-of submat---------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine filter ( n , job , drptol , a , ja , ia , b , jb , ib , len , ierr ) implicit none real * 8 a ( * ), b ( * ), drptol integer ja ( * ), jb ( * ), ia ( * ), ib ( * ), n , job , len , ierr c----------------------------------------------------------------------- c     This module removes any elements whose absolute value c     is small from an input matrix A and puts the resulting c     matrix in B.  The input parameter job selects a definition c     of small. c----------------------------------------------------------------------- c on entry: c--------- c  n\t = integer. row dimension of matrix c  job   = integer. used to determine strategy chosen by caller to c         drop elements from matrix A. c          job = 1 c              Elements whose absolute value is less than the c              drop tolerance are removed. c          job = 2 c              Elements whose absolute value is less than the c              product of the drop tolerance and the Euclidean c              norm of the row are removed. c          job = 3 c              Elements whose absolute value is less that the c              product of the drop tolerance and the largest c              element in the row are removed. c c drptol = real. drop tolerance used for dropping strategy. c a c ja c ia     = input matrix in compressed sparse format c len\t = integer. the amount of space available in arrays b and jb. c c on return: c---------- c b c jb c ib    = resulting matrix in compressed sparse format. c c ierr\t= integer. containing error message. c         ierr .eq. 0 indicates normal return c         ierr .gt. 0 indicates that there is'nt enough c         space is a and ja to store the resulting matrix. c         ierr then contains the row number where filter stopped. c note: c------ This module is in place. (b,jb,ib can ne the same as c       a, ja, ia in which case the result will be overwritten). c----------------------------------------------------------------------c c           contributed by David Day,  Sep 19, 1989.                   c c----------------------------------------------------------------------c c local variables real * 8 norm , loctol integer index , row , k , k1 , k2 c index = 1 do 10 row = 1 , n k1 = ia ( row ) k2 = ia ( row + 1 ) - 1 ib ( row ) = index goto ( 100 , 200 , 300 ) job 100 norm = 1.0d0 goto 400 200 norm = 0.0d0 do 22 k = k1 , k2 norm = norm + a ( k ) * a ( k ) 22 continue norm = sqrt ( norm ) goto 400 300 norm = 0.0d0 do 23 k = k1 , k2 if ( abs ( a ( k )) . gt . norm ) then norm = abs ( a ( k )) endif 23 continue 400 loctol = drptol * norm do 30 k = k1 , k2 if ( abs ( a ( k )) . gt . loctol ) then if ( index . gt . len ) then ierr = row return endif b ( index ) = a ( k ) jb ( index ) = ja ( k ) index = index + 1 endif 30 continue 10 continue ib ( n + 1 ) = index return c--------------------end-of-filter ------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine filterm ( n , job , drop , a , ja , b , jb , len , ierr ) implicit none real * 8 a ( * ), b ( * ), drop integer ja ( * ), jb ( * ), n , job , len , ierr c----------------------------------------------------------------------- c     This subroutine removes any elements whose absolute value c     is small from an input matrix A. Same as filter but c     uses the MSR format. c----------------------------------------------------------------------- c on entry: c--------- c  n\t = integer. row dimension of matrix c  job   = integer. used to determine strategy chosen by caller to c         drop elements from matrix A. c          job = 1 c              Elements whose absolute value is less than the c              drop tolerance are removed. c          job = 2 c              Elements whose absolute value is less than the c              product of the drop tolerance and the Euclidean c              norm of the row are removed. c          job = 3 c              Elements whose absolute value is less that the c              product of the drop tolerance and the largest c              element in the row are removed. c c drop = real. drop tolerance used for dropping strategy. c a c ja     = input matrix in Modifief Sparse Row format c len\t = integer. the amount of space in arrays b and jb. c c on return: c---------- c c b, jb = resulting matrix in Modifief Sparse Row format c c ierr\t= integer. containing error message. c         ierr .eq. 0 indicates normal return c         ierr .gt. 0 indicates that there is'nt enough c         space is a and ja to store the resulting matrix. c         ierr then contains the row number where filter stopped. c note: c------ This module is in place. (b,jb can ne the same as c       a, ja in which case the result will be overwritten). c----------------------------------------------------------------------c c           contributed by David Day,  Sep 19, 1989.                   c c----------------------------------------------------------------------c c local variables c real * 8 norm , loctol integer index , row , k , k1 , k2 c index = n + 2 do 10 row = 1 , n k1 = ja ( row ) k2 = ja ( row + 1 ) - 1 jb ( row ) = index goto ( 100 , 200 , 300 ) job 100 norm = 1.0d0 goto 400 200 norm = a ( row ) ** 2 do 22 k = k1 , k2 norm = norm + a ( k ) * a ( k ) 22 continue norm = sqrt ( norm ) goto 400 300 norm = abs ( a ( row )) do 23 k = k1 , k2 norm = max ( abs ( a ( k )), norm ) 23 continue 400 loctol = drop * norm do 30 k = k1 , k2 if ( abs ( a ( k )) . gt . loctol ) then if ( index . gt . len ) then ierr = row return endif b ( index ) = a ( k ) jb ( index ) = ja ( k ) index = index + 1 endif 30 continue 10 continue jb ( n + 1 ) = index return c--------------------end-of-filterm------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- c----------------------------------------------------------------------- subroutine csort ( n , a , ja , ia , values ) implicit none logical values integer n , ja ( * ), ia ( n + 1 ) real * 8 a ( * ) c----------------------------------------------------------------------- c This routine sorts the elements of  a matrix (stored in Compressed c Sparse Row Format) in increasing order of their column indices within c each row. It uses insertion sort c----------------------------------------------------------------------- c on entry: c--------- c n     = the row dimension of the matrix c a     = the matrix A in compressed sparse row format. c ja    = the array of column indices of the elements in array a. c ia    = the array of pointers to the rows. c values= logical indicating whether or not the real values a(*) must c         also be permuted. if (.not. values) then the array a is not c         touched by csort and can be a dummy array. c c on return: c---------- c the matrix stored in the structure a, ja, ia is permuted in such a c way that the column indices are in increasing order within each row. c iwork(1:nnz) contains the permutation used  to rearrange the elements. c----------------------------------------------------------------------- c Y. Saad - recoded Dec. 20th -  2017 - c----------------------------------------------------------------------- c local variables integer row , i , k , j real * 8 rj rj = 0.0 c c for each row c do row = 1 , n c c scan row and do an insertion sort c do k = ia ( row ) + 1 , ia ( row + 1 ) - 1 j = ja ( k ) if ( values ) rj = a ( k ) i = k - 1 ; do while (( i . ge . ia ( row )) . and . ( j < ja ( i )) ) ja ( i + 1 ) = ja ( i ) if ( values ) a ( i + 1 ) = a ( i ) i = i - 1 if ( i . eq . 0 ) exit enddo ja ( i + 1 ) = j if ( values ) a ( i + 1 ) = rj enddo enddo return c---------------end-of-csort-------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine clncsr ( job , value2 , nrow , a , ja , ia , indu , iwk ) implicit none c     .. Scalar Arguments .. integer job , nrow , value2 c     .. c     .. Array Arguments .. integer ia ( nrow + 1 ), indu ( nrow ), iwk ( nrow + 1 ), ja ( * ) real * 8 a ( * ) c     .. c c     This routine performs two tasks to clean up a CSR matrix c     -- remove duplicate/zero entries, c     -- perform a partial ordering, new order lower triangular part, c        main diagonal, upper triangular part. c c     On entry: c c     job   = options c         0 -- nothing is done c         1 -- eliminate duplicate entries, zero entries. c         2 -- eliminate duplicate entries and perform partial ordering. c         3 -- eliminate duplicate entries, sort the entries in the c              increasing order of clumn indices. c c     value2  -- 0 the matrix is pattern only (a is not touched) c                1 matrix has values too. c     nrow    -- row dimension of the matrix c     a,ja,ia -- input matrix in CSR format c c     On return: c     a,ja,ia -- cleaned matrix c     indu    -- pointers to the beginning of the upper triangular c                portion if job > 1 c c     Work space: c     iwk     -- integer work space of size nrow+1 c c     .. Local Scalars .. integer i , j , k , ko , ipos , kfirst , klast real * 8 tmp c     .. c if ( job . le . 0 ) return c c     .. eliminate duplicate entries -- c     array INDU is used as marker for existing indices, it is also the c     location of the entry. c     IWK is used to stored the old IA array. c     matrix is copied to squeeze out the space taken by the duplicated c     entries. c do 90 i = 1 , nrow indu ( i ) = 0 iwk ( i ) = ia ( i ) 90 continue iwk ( nrow + 1 ) = ia ( nrow + 1 ) k = 1 do 120 i = 1 , nrow ia ( i ) = k ipos = iwk ( i ) klast = iwk ( i + 1 ) 100 if ( ipos . lt . klast ) then j = ja ( ipos ) if ( indu ( j ). eq . 0 ) then c     .. new entry .. if ( value2 . ne . 0 ) then if ( a ( ipos ) . ne . 0.0D0 ) then indu ( j ) = k ja ( k ) = ja ( ipos ) a ( k ) = a ( ipos ) k = k + 1 endif else indu ( j ) = k ja ( k ) = ja ( ipos ) k = k + 1 endif else if ( value2 . ne . 0 ) then c     .. duplicate entry .. a ( indu ( j )) = a ( indu ( j )) + a ( ipos ) endif ipos = ipos + 1 go to 100 endif c     .. remove marks before working on the next row .. do 110 ipos = ia ( i ), k - 1 indu ( ja ( ipos )) = 0 110 continue 120 continue ia ( nrow + 1 ) = k if ( job . le . 1 ) return c c     .. partial ordering .. c     split the matrix into strict upper/lower triangular c     parts, INDU points to the the beginning of the upper part. c do 140 i = 1 , nrow klast = ia ( i + 1 ) - 1 kfirst = ia ( i ) 130 if ( klast . gt . kfirst ) then if ( ja ( klast ). lt . i . and . ja ( kfirst ). ge . i ) then c     .. swap klast with kfirst .. j = ja ( klast ) ja ( klast ) = ja ( kfirst ) ja ( kfirst ) = j if ( value2 . ne . 0 ) then tmp = a ( klast ) a ( klast ) = a ( kfirst ) a ( kfirst ) = tmp endif endif if ( ja ( klast ). ge . i ) & klast = klast - 1 if ( ja ( kfirst ). lt . i ) & kfirst = kfirst + 1 go to 130 endif c if ( ja ( klast ). lt . i ) then indu ( i ) = klast + 1 else indu ( i ) = klast endif 140 continue if ( job . le . 2 ) return c c     .. order the entries according to column indices c     burble-sort is used c do 190 i = 1 , nrow do 160 ipos = ia ( i ), indu ( i ) - 1 do 150 j = indu ( i ) - 1 , ipos + 1 , - 1 k = j - 1 if ( ja ( k ). gt . ja ( j )) then ko = ja ( k ) ja ( k ) = ja ( j ) ja ( j ) = ko if ( value2 . ne . 0 ) then tmp = a ( k ) a ( k ) = a ( j ) a ( j ) = tmp endif endif 150 continue 160 continue do 180 ipos = indu ( i ), ia ( i + 1 ) - 1 do 170 j = ia ( i + 1 ) - 1 , ipos + 1 , - 1 k = j - 1 if ( ja ( k ). gt . ja ( j )) then ko = ja ( k ) ja ( k ) = ja ( j ) ja ( j ) = ko if ( value2 . ne . 0 ) then tmp = a ( k ) a ( k ) = a ( j ) a ( j ) = tmp endif endif 170 continue 180 continue 190 continue return c---- end of clncsr ---------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine copmat ( nrow , a , ja , ia , ao , jao , iao , ipos , job ) implicit none real * 8 a ( * ), ao ( * ) integer nrow , ia ( * ), ja ( * ), jao ( * ), iao ( * ), ipos , job c---------------------------------------------------------------------- c copies the matrix a, ja, ia, into the matrix ao, jao, iao. c---------------------------------------------------------------------- c on entry: c--------- c nrow\t= row dimension of the matrix c a, c ja, c ia    = input matrix in compressed sparse row format. c ipos  = integer. indicates the position in the array ao, jao c         where the first element should be copied. Thus c         iao(1) = ipos on return. c job   = job indicator. if (job .ne. 1) the values are not copies c         (i.e., pattern only is copied in the form of arrays ja, ia). c c on return: c---------- c ao, c jao, c iao   = output matrix containing the same data as a, ja, ia. c----------------------------------------------------------------------- c           Y. Saad, March 1990. c----------------------------------------------------------------------- c local variables integer kst , i , k c kst = ipos - ia ( 1 ) do 100 i = 1 , nrow + 1 iao ( i ) = ia ( i ) + kst 100 continue c do 200 k = ia ( 1 ), ia ( nrow + 1 ) - 1 jao ( kst + k ) = ja ( k ) 200 continue c if ( job . ne . 1 ) return do 201 k = ia ( 1 ), ia ( nrow + 1 ) - 1 ao ( kst + k ) = a ( k ) 201 continue c return c--------end-of-copmat ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine msrcop ( nrow , a , ja , ao , jao , job ) implicit none real * 8 a ( * ), ao ( * ) integer nrow , ja ( * ), jao ( * ), job c---------------------------------------------------------------------- c copies the MSR matrix a, ja, into the MSR matrix ao, jao c---------------------------------------------------------------------- c on entry: c--------- c nrow\t= row dimension of the matrix c a,ja  = input matrix in Modified compressed sparse row format. c job   = job indicator. Values are not copied if job .ne. 1 c c on return: c---------- c ao, jao   = output matrix containing the same data as a, ja. c----------------------------------------------------------------------- c           Y. Saad, c----------------------------------------------------------------------- c local variables integer i , k c do 100 i = 1 , nrow + 1 jao ( i ) = ja ( i ) 100 continue c do 200 k = ja ( 1 ), ja ( nrow + 1 ) - 1 jao ( k ) = ja ( k ) 200 continue c if ( job . ne . 1 ) return do 201 k = ja ( 1 ), ja ( nrow + 1 ) - 1 ao ( k ) = a ( k ) 201 continue do 202 k = 1 , nrow ao ( k ) = a ( k ) 202 continue c return c--------end-of-msrcop ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- double precision function getelm ( i , j , a , ja , ia , iadd , sorted ) c----------------------------------------------------------------------- c     purpose: c     -------- c     this function returns the element a(i,j) of a matrix a, c     for any pair (i,j).  the matrix is assumed to be stored c     in compressed sparse row (csr) format. getelm performs a c     binary search in the case where it is known that the elements c     are sorted so that the column indices are in increasing order. c     also returns (in iadd) the address of the element a(i,j) in c     arrays a and ja when the search is successsful (zero if not). c----- c     first contributed by noel nachtigal (mit). c     recoded jan. 20, 1991, by y. saad [in particular c     added handling of the non-sorted case + the iadd output] c----------------------------------------------------------------------- c     parameters: c     ----------- c on entry: c---------- c     i      = the row index of the element sought (input). c     j      = the column index of the element sought (input). c     a      = the matrix a in compressed sparse row format (input). c     ja     = the array of column indices (input). c     ia     = the array of pointers to the rows' data (input). c     sorted = logical indicating whether the matrix is knonw to c              have its column indices sorted in increasing order c              (sorted=.true.) or not (sorted=.false.). c              (input). c on return: c----------- c     getelm = value of a(i,j). c     iadd   = address of element a(i,j) in arrays a, ja if found, c              zero if not found. (output) c c     note: the inputs i and j are not checked for validity. c----------------------------------------------------------------------- c     noel m. nachtigal october 28, 1990 -- youcef saad jan 20, 1991. c----------------------------------------------------------------------- implicit none integer i , ia ( * ), iadd , j , ja ( * ) double precision a ( * ) logical sorted c c     local variables. c integer ibeg , iend , imid , k c c     initialization c iadd = 0 getelm = 0.0 ibeg = ia ( i ) iend = ia ( i + 1 ) - 1 c c     case where matrix is not necessarily sorted c if (. not . sorted ) then c c scan the row - exit as soon as a(i,j) is found c do 5 k = ibeg , iend if ( ja ( k ) . eq . j ) then iadd = k goto 20 endif 5 continue c c     end unsorted case. begin sorted case c else c c     begin binary search.   compute the middle index. c 10 imid = ( ibeg + iend ) / 2 c c     test if  found c if ( ja ( imid ). eq . j ) then iadd = imid goto 20 endif if ( ibeg . ge . iend ) goto 20 c c     else     update the interval bounds. c if ( ja ( imid ). gt . j ) then iend = imid - 1 else ibeg = imid + 1 endif goto 10 c c     end both cases c endif c 20 if ( iadd . ne . 0 ) getelm = a ( iadd ) c return c--------end-of-getelm-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine getdia ( nrow , ncol , job , a , ja , ia , len , diag , idiag , ioff ) implicit none real * 8 diag ( * ), a ( * ) integer nrow , ncol , job , len , ioff , ia ( * ), ja ( * ), idiag ( * ) c----------------------------------------------------------------------- c this subroutine extracts a given diagonal from a matrix stored in csr c format. the output matrix may be transformed with the diagonal removed c from it if desired (as indicated by job.) c----------------------------------------------------------------------- c our definition of a diagonal of matrix is a vector of length nrow c (always) which contains the elements in rows 1 to nrow of c the matrix that are contained in the diagonal offset by ioff c with respect to the main diagonal. if the diagonal element c falls outside the matrix then it is defined as a zero entry. c thus the proper definition of diag(*) with offset ioff is c c     diag(i) = a(i,ioff+i) i=1,2,...,nrow c     with elements falling outside the matrix being defined as zero. c c----------------------------------------------------------------------- c c on entry: c---------- c c nrow\t= integer. the row dimension of the matrix a. c ncol\t= integer. the column dimension of the matrix a. c job   = integer. job indicator.  if job = 0 then c         the matrix a, ja, ia, is not altered on return. c         if job.ne.0  then getdia will remove the entries c         collected in diag from the original matrix. c         this is done in place. c c a,ja, c    ia = matrix stored in compressed sparse row a,ja,ia,format c ioff  = integer,containing the offset of the wanted diagonal c\t  the diagonal extracted is the one corresponding to the c\t  entries a(i,j) with j-i = ioff. c\t  thus ioff = 0 means the main diagonal c c on return: c----------- c len   = number of nonzero elements found in diag. c         (len .le. min(nrow,ncol-ioff)-max(1,1-ioff) + 1 ) c c diag  = real*8 array of length nrow containing the wanted diagonal. c\t  diag contains the diagonal (a(i,j),j-i = ioff ) as defined c         above. c c idiag = integer array of  length len, containing the poisitions c         in the original arrays a and ja of the diagonal elements c         collected in diag. a zero entry in idiag(i) means that c         there was no entry found in row i belonging to the diagonal. c c a, ja, c    ia = if job .ne. 0 the matrix is unchanged. otherwise the nonzero c         diagonal entries collected in diag are removed from the c         matrix and therefore the arrays a, ja, ia will change. c\t  (the matrix a, ja, ia will contain len fewer elements) c c----------------------------------------------------------------------c c     Y. Saad, sep. 21 1989 - modified and retested Feb 17, 1996.      c c----------------------------------------------------------------------c c     local variables integer istart , max , iend , i , kold , k , kdiag , ko c istart = max ( 0 , - ioff ) iend = min ( nrow , ncol - ioff ) len = 0 do 1 i = 1 , nrow idiag ( i ) = 0 diag ( i ) = 0.0d0 1 continue c c     extract  diagonal elements c do 6 i = istart + 1 , iend do 51 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) - i . eq . ioff ) then diag ( i ) = a ( k ) idiag ( i ) = k len = len + 1 goto 6 endif 51 continue 6 continue if ( job . eq . 0 . or . len . eq . 0 ) return c c     remove diagonal elements and rewind structure c ko = 0 do 7 i = 1 , nrow kold = ko kdiag = idiag ( i ) do 71 k = ia ( i ), ia ( i + 1 ) - 1 if ( k . ne . kdiag ) then ko = ko + 1 a ( ko ) = a ( k ) ja ( ko ) = ja ( k ) endif 71 continue ia ( i ) = kold + 1 7 continue c c     redefine ia(nrow+1) c ia ( nrow + 1 ) = ko + 1 return c------------end-of-getdia---------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine transp ( nrow , ncol , a , ja , ia , iwk , ierr ) implicit none integer nrow , ncol , ia ( * ), ja ( * ), iwk ( * ), ierr real * 8 a ( * ) c------------------------------------------------------------------------ c In-place transposition routine. c------------------------------------------------------------------------ c this subroutine transposes a matrix stored in compressed sparse row c format. the transposition is done in place in that the arrays a,ja,ia c of the transpose are overwritten onto the original arrays. c------------------------------------------------------------------------ c on entry: c--------- c nrow\t= integer. The row dimension of A. c ncol\t= integer. The column dimension of A. c a\t= real array of size nnz (number of nonzero elements in A). c         containing the nonzero elements c ja\t= integer array of length nnz containing the column positions c \t  of the corresponding elements in a. c ia\t= integer of size n+1, where n = max(nrow,ncol). On entry c         ia(k) contains the position in a,ja of  the beginning of c         the k-th row. c c iwk\t= integer work array of same length as ja. c c on return: c---------- c c ncol\t= actual row dimension of the transpose of the input matrix. c         Note that this may be .le. the input value for ncol, in c         case some of the last columns of the input matrix are zero c         columns. In the case where the actual number of rows found c         in transp(A) exceeds the input value of ncol, transp will c         return without completing the transposition. see ierr. c a, c ja, c ia\t= contains the transposed matrix in compressed sparse c         row format. The row dimension of a, ja, ia is now ncol. c c ierr\t= integer. error message. If the number of rows for the c         transposed matrix exceeds the input value of ncol, c         then ierr is  set to that number and transp quits. c         Otherwise ierr is set to 0 (normal return). c c Note: c----- 1) If you do not need the transposition to be done in place c         it is preferrable to use the conversion routine csrcsc c         (see conversion routines in formats). c      2) the entries of the output matrix are not sorted (the column c         indices in each are not in increasing order) use csrcsc c         if you want them sorted. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c  modified Oct. 11, 1989.                                             c c----------------------------------------------------------------------c c local variables real * 8 t , t1 integer i , j , nnz , jcol , k , init , l , inext ierr = 0 nnz = ia ( nrow + 1 ) - 1 c c     determine column dimension c jcol = 0 do 1 k = 1 , nnz jcol = max ( jcol , ja ( k )) 1 continue if ( jcol . gt . ncol ) then ierr = jcol return endif c c     convert to coordinate format. use iwk for row indices. c ncol = jcol c do 3 i = 1 , nrow do 2 k = ia ( i ), ia ( i + 1 ) - 1 iwk ( k ) = i 2 continue 3 continue c     find pointer array for transpose. do 35 i = 1 , ncol + 1 ia ( i ) = 0 35 continue do 4 k = 1 , nnz i = ja ( k ) ia ( i + 1 ) = ia ( i + 1 ) + 1 4 continue ia ( 1 ) = 1 c------------------------------------------------------------------------ do 44 i = 1 , ncol ia ( i + 1 ) = ia ( i ) + ia ( i + 1 ) 44 continue c c     loop for a cycle in chasing process. c init = 1 k = 0 5 t = a ( init ) i = ja ( init ) j = iwk ( init ) iwk ( init ) = - 1 c------------------------------------------------------------------------ 6 k = k + 1 c     current row number is i.  determine  where to go. l = ia ( i ) c     save the chased element. t1 = a ( l ) inext = ja ( l ) c     then occupy its location. a ( l ) = t ja ( l ) = j c     update pointer information for next element to be put in row i. ia ( i ) = l + 1 c     determine  next element to be chased if ( iwk ( l ) . lt . 0 ) goto 65 t = t1 i = inext j = iwk ( l ) iwk ( l ) = - 1 if ( k . lt . nnz ) goto 6 goto 70 65 init = init + 1 if ( init . gt . nnz ) goto 70 if ( iwk ( init ) . lt . 0 ) goto 65 c     restart chasing -- goto 5 70 continue do 80 i = ncol , 1 , - 1 ia ( i + 1 ) = ia ( i ) 80 continue ia ( 1 ) = 1 c return c------------------end-of-transp ---------------------------------------- c------------------------------------------------------------------------ end c------------------------------------------------------------------------ subroutine getl ( n , a , ja , ia , ao , jao , iao ) implicit none integer n , ia ( * ), ja ( * ), iao ( * ), jao ( * ) real * 8 a ( * ), ao ( * ) c------------------------------------------------------------------------ c this subroutine extracts the lower triangular part of a matrix c and writes the result ao, jao, iao. The routine is in place in c that ao, jao, iao can be the same as a, ja, ia if desired. c----------- c on input: c c n     = dimension of the matrix a. c a, ja, c    ia = matrix stored in compressed sparse row format. c On return: c ao, jao, c    iao = lower triangular matrix (lower part of a) c\tstored in a, ja, ia, format c note: the diagonal element is the last element in each row. c i.e. in  a(ia(i+1)-1 ) c ao, jao, iao may be the same as a, ja, ia on entry -- in which case c getl will overwrite the result on a, ja, ia. c c------------------------------------------------------------------------ c local variables real * 8 t integer ko , kold , kdiag , k , i c c inititialize ko (pointer for output matrix) c ko = 0 do 7 i = 1 , n kold = ko kdiag = 0 do 71 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) . gt . i ) goto 71 ko = ko + 1 ao ( ko ) = a ( k ) jao ( ko ) = ja ( k ) if ( ja ( k ) . eq . i ) kdiag = ko 71 continue if ( kdiag . eq . 0 . or . kdiag . eq . ko ) goto 72 c c     exchange c t = ao ( kdiag ) ao ( kdiag ) = ao ( ko ) ao ( ko ) = t c k = jao ( kdiag ) jao ( kdiag ) = jao ( ko ) jao ( ko ) = k 72 iao ( i ) = kold + 1 7 continue c     redefine iao(n+1) iao ( n + 1 ) = ko + 1 return c----------end-of-getl ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine getu ( n , a , ja , ia , ao , jao , iao ) implicit none integer n , ia ( * ), ja ( * ), iao ( * ), jao ( * ) real * 8 a ( * ), ao ( * ) c------------------------------------------------------------------------ c this subroutine extracts the upper triangular part of a matrix c and writes the result ao, jao, iao. The routine is in place in c that ao, jao, iao can be the same as a, ja, ia if desired. c----------- c on input: c c n     = dimension of the matrix a. c a, ja, c    ia = matrix stored in a, ja, ia, format c On return: c ao, jao, c    iao = upper triangular matrix (upper part of a) c\tstored in compressed sparse row format c note: the diagonal element is the last element in each row. c i.e. in  a(ia(i+1)-1 ) c ao, jao, iao may be the same as a, ja, ia on entry -- in which case c getu will overwrite the result on a, ja, ia. c c------------------------------------------------------------------------ c local variables real * 8 t integer ko , k , i , kdiag , kfirst ko = 0 do 7 i = 1 , n kfirst = ko + 1 kdiag = 0 do 71 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) . lt . i ) goto 71 ko = ko + 1 ao ( ko ) = a ( k ) jao ( ko ) = ja ( k ) if ( ja ( k ) . eq . i ) kdiag = ko 71 continue if ( kdiag . eq . 0 . or . kdiag . eq . kfirst ) goto 72 c     exchange t = ao ( kdiag ) ao ( kdiag ) = ao ( kfirst ) ao ( kfirst ) = t c k = jao ( kdiag ) jao ( kdiag ) = jao ( kfirst ) jao ( kfirst ) = k 72 iao ( i ) = kfirst 7 continue c     redefine iao(n+1) iao ( n + 1 ) = ko + 1 return c----------end-of-getu ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine levels ( n , jal , ial , nlev , lev , ilev , levnum ) implicit none integer n , nlev integer jal ( * ), ial ( * ), levnum ( * ), ilev ( * ), lev ( * ) c----------------------------------------------------------------------- c levels gets the level structure of a lower triangular matrix c for level scheduling in the parallel solution of triangular systems c strict lower matrices (e.g. unit) as well matrices with their main c diagonal are accepted. c----------------------------------------------------------------------- c on entry: c---------- c n        = integer. The row dimension of the matrix c jal, ial = c c on return: c----------- c nlev     = integer. number of levels found c lev      = integer array of length n containing the level c            scheduling permutation. c ilev     = integer array. pointer to beginning of levels in lev. c            the numbers lev(i) to lev(i+1)-1 contain the row numbers c            that belong to level number i, in the level scheduling c            ordering. The equations of the same level can be solved c            in parallel, once those of all the previous levels have c            been solved. c work arrays: c------------- c levnum   = integer array of length n (containing the level numbers c            of each unknown on return) c----------------------------------------------------------------------- integer i , j , levi do 10 i = 1 , n levnum ( i ) = 0 10 continue c c     compute level of each node -- c nlev = 0 do 20 i = 1 , n levi = 0 do 15 j = ial ( i ), ial ( i + 1 ) - 1 levi = max ( levi , levnum ( jal ( j ))) 15 continue levi = levi + 1 levnum ( i ) = levi nlev = max ( nlev , levi ) 20 continue c-------------set data structure  -------------------------------------- do 21 j = 1 , nlev + 1 ilev ( j ) = 0 21 continue c------count  number   of elements in each level ----------------------- do 22 j = 1 , n i = levnum ( j ) + 1 ilev ( i ) = ilev ( i ) + 1 22 continue c---- set up pointer for  each  level ---------------------------------- ilev ( 1 ) = 1 do 23 j = 1 , nlev ilev ( j + 1 ) = ilev ( j ) + ilev ( j + 1 ) 23 continue c-----determine elements of each level -------------------------------- do 30 j = 1 , n i = levnum ( j ) lev ( ilev ( i )) = j ilev ( i ) = ilev ( i ) + 1 30 continue c     reset pointers backwards do 35 j = nlev , 1 , - 1 ilev ( j + 1 ) = ilev ( j ) 35 continue ilev ( 1 ) = 1 return c----------end-of-levels------------------------------------------------ C----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amask ( nrow , ncol , a , ja , ia , jmask , imask , * c , jc , ic , iw , nzmax , ierr ) c--------------------------------------------------------------------- implicit none integer nrow , ncol , nzmax , ierr real * 8 a ( * ), c ( * ) integer ia ( nrow + 1 ), ja ( * ), jc ( * ), ic ( nrow + 1 ), jmask ( * ), imask ( nrow + 1 ) logical iw ( ncol ) c----------------------------------------------------------------------- c This subroutine builds a sparse matrix from an input matrix by c extracting only elements in positions defined by the mask jmask, imask c----------------------------------------------------------------------- c On entry: c--------- c nrow  = integer. row dimension of input matrix c ncol\t= integer. Column dimension of input matrix. c c a, c ja, c ia\t= matrix in Compressed Sparse Row format c c jmask, c imask = matrix defining mask (pattern only) stored in compressed c         sparse row format. c c nzmax = length of arrays c and jc. see ierr. c c On return: c----------- c c a, ja, ia and jmask, imask are unchanged. c c c c jc, c ic\t= the output matrix in Compressed Sparse Row format. c c ierr  = integer. serving as error message.c c         ierr = 1  means normal return c         ierr .gt. 1 means that amask stopped when processing c         row number ierr, because there was not enough space in c         c, jc according to the value of nzmax. c c work arrays: c------------- c iw\t= logical work array of length ncol. c c note: c------ the  algorithm is in place: c, jc, ic can be the same as c a, ja, ia in which cas the code will overwrite the matrix c c on a, ja, ia c c----------------------------------------------------------------------- integer len , ii , j , k1 , k2 , k ierr = 0 len = 0 do 1 j = 1 , ncol iw ( j ) = . false . 1 continue c     unpack the mask for row ii in iw do 100 ii = 1 , nrow c     save pointer in order to be able to do things in place do 2 k = imask ( ii ), imask ( ii + 1 ) - 1 iw ( jmask ( k )) = . true . 2 continue c     add umasked elemnts of row ii k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 ic ( ii ) = len + 1 do 200 k = k1 , k2 j = ja ( k ) if ( iw ( j )) then len = len + 1 if ( len . gt . nzmax ) then ierr = ii return endif jc ( len ) = j c ( len ) = a ( k ) endif 200 continue c do 3 k = imask ( ii ), imask ( ii + 1 ) - 1 iw ( jmask ( k )) = . false . 3 continue 100 continue ic ( nrow + 1 ) = len + 1 c return c-----end-of-amask ----------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine rperm ( nrow , a , ja , ia , ao , jao , iao , perm , job ) implicit none integer nrow , ja ( * ), ia ( nrow + 1 ), jao ( * ), iao ( nrow + 1 ), perm ( nrow ), job real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c this subroutine permutes the rows of a matrix in CSR format. c rperm  computes B = P A  where P is a permutation matrix. c the permutation P is defined through the array perm: for each j, c perm(j) represents the destination row number of row number j. c Youcef Saad -- recoded Jan 28, 1991. c----------------------------------------------------------------------- c on entry: c---------- c n \t= dimension of the matrix c a, ja, ia = input matrix in csr format c perm \t= integer array of length nrow containing the permutation arrays c\t  for the rows: perm(i) is the destination of row i in the c         permuted matrix. c         ---> a(i,j) in the original matrix becomes a(perm(i),j) c         in the output  matrix. c c job\t= integer indicating the work to be done: c \t\tjob = 1\tpermute a, ja, ia into ao, jao, iao c                       (including the copying of real values ao and c                       the array iao). c \t\tjob .ne. 1 :  ignore real values. c                     (in which case arrays a and ao are not needed nor c                      used). c c------------ c on return: c------------ c ao, jao, iao = input matrix in a, ja, ia format c note : c        if (job.ne.1)  then the arrays a and ao are not used. c----------------------------------------------------------------------c c           Y. Saad, May  2, 1990                                      c c----------------------------------------------------------------------c logical values integer i , j , ii , ko , k values = ( job . eq . 1 ) c c     determine pointers for output matix. c do 50 j = 1 , nrow i = perm ( j ) iao ( i + 1 ) = ia ( j + 1 ) - ia ( j ) 50 continue c c get pointers from lengths c iao ( 1 ) = 1 do 51 j = 1 , nrow iao ( j + 1 ) = iao ( j + 1 ) + iao ( j ) 51 continue c c copying c do 100 ii = 1 , nrow c c old row = ii  -- new row = iperm(ii) -- ko = new pointer c ko = iao ( perm ( ii )) do 60 k = ia ( ii ), ia ( ii + 1 ) - 1 jao ( ko ) = ja ( k ) if ( values ) ao ( ko ) = a ( k ) ko = ko + 1 60 continue 100 continue c return c---------end-of-rperm ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine cperm ( nrow , a , ja , ia , ao , jao , iao , perm , job ) implicit none integer nrow , ja ( * ), ia ( nrow + 1 ), jao ( * ), iao ( nrow + 1 ), perm ( * ), job real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c this subroutine permutes the columns of a matrix a, ja, ia. c the result is written in the output matrix  ao, jao, iao. c cperm computes B = A P, where  P is a permutation matrix c that maps column j into column perm(j), i.e., on return c      a(i,j) becomes a(i,perm(j)) in new matrix c Y. Saad, May 2, 1990 / modified Jan. 28, 1991. c----------------------------------------------------------------------- c on entry: c---------- c nrow \t= row dimension of the matrix c c a, ja, ia = input matrix in csr format. c c perm\t= integer array of length ncol (number of columns of A c         containing the permutation array  the columns: c         a(i,j) in the original matrix becomes a(i,perm(j)) c         in the output matrix. c c job\t= integer indicating the work to be done: c \t\tjob = 1\tpermute a, ja, ia into ao, jao, iao c                       (including the copying of real values ao and c                       the array iao). c \t\tjob .ne. 1 :  ignore real values ao and ignore iao. c c------------ c on return: c------------ c ao, jao, iao = input matrix in a, ja, ia format (array ao not needed) c c Notes: c------- c 1. if job=1 then ao, iao are not used. c 2. This routine is in place: ja, jao can be the same. c 3. If the matrix is initially sorted (by increasing column number) c    then ao,jao,iao  may not be on return. c c----------------------------------------------------------------------c c local parameters: integer k , i , nnz c nnz = ia ( nrow + 1 ) - 1 do 100 k = 1 , nnz jao ( k ) = perm ( ja ( k )) 100 continue c c     done with ja array. return if no need to touch values. c if ( job . ne . 1 ) return c c else get new pointers -- and copy values too. c do 1 i = 1 , nrow + 1 iao ( i ) = ia ( i ) 1 continue c do 2 k = 1 , nnz ao ( k ) = a ( k ) 2 continue c return c---------end-of-cperm-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine dperm ( nrow , a , ja , ia , ao , jao , iao , perm , qperm , job ) implicit none integer nrow , ja ( * ), ia ( nrow + 1 ), jao ( * ), iao ( nrow + 1 ), perm ( nrow ), + qperm ( * ), job real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c This routine permutes the rows and columns of a matrix stored in CSR c format. i.e., it computes P A Q, where P, Q are permutation matrices. c P maps row i into row perm(i) and Q maps column j into column qperm(j): c      a(i,j)    becomes   a(perm(i),qperm(j)) in new matrix c In the particular case where Q is the transpose of P (symmetric c permutation of A) then qperm is not needed. c note that qperm should be of length ncol (number of columns) but this c is not checked. c----------------------------------------------------------------------- c Y. Saad, Sep. 21 1989 / recoded Jan. 28 1991. c----------------------------------------------------------------------- c on entry: c---------- c n \t= dimension of the matrix c a, ja, c    ia = input matrix in a, ja, ia format c perm \t= integer array of length n containing the permutation arrays c\t  for the rows: perm(i) is the destination of row i in the c         permuted matrix -- also the destination of column i in case c         permutation is symmetric (job .le. 2) c c qperm\t= same thing for the columns. This should be provided only c         if job=3 or job=4, i.e., only in the case of a nonsymmetric c\t  permutation of rows and columns. Otherwise qperm is a dummy c c job\t= integer indicating the work to be done: c * job = 1,2 permutation is symmetric  Ao :== P * A * transp(P) c \t\tjob = 1\tpermute a, ja, ia into ao, jao, iao c \t\tjob = 2 permute matrix ignoring real values. c * job = 3,4 permutation is non-symmetric  Ao :== P * A * Q c \t\tjob = 3\tpermute a, ja, ia into ao, jao, iao c \t\tjob = 4 permute matrix ignoring real values. c c on return: c----------- c ao, jao, iao = input matrix in a, ja, ia format c c in case job .eq. 2 or job .eq. 4, a and ao are never referred to c and can be dummy arguments. c Notes: c------- c  1) algorithm is in place c  2) column indices may not be sorted on return even  though they may be c     on entry. c----------------------------------------------------------------------c c local variables integer locjob , mod c c     locjob indicates whether or not real values must be copied. c locjob = mod ( job , 2 ) c c permute rows first c call rperm ( nrow , a , ja , ia , ao , jao , iao , perm , locjob ) c c then permute columns c locjob = 0 c if ( job . le . 2 ) then call cperm ( nrow , ao , jao , iao , ao , jao , iao , perm , locjob ) else call cperm ( nrow , ao , jao , iao , ao , jao , iao , qperm , locjob ) endif c return c-------end-of-dperm---------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine dperm1 ( i1 , i2 , a , ja , ia , b , jb , ib , perm , ipos , job ) implicit none integer i1 , i2 , job , ja ( * ), ia ( * ), jb ( * ), ib ( * ), perm ( * ), ipos real * 8 a ( * ), b ( * ) c----------------------------------------------------------------------- c     general submatrix extraction routine. c----------------------------------------------------------------------- c     extracts rows perm(i1), perm(i1+1), ..., perm(i2) (in this order) c     from a matrix (doing nothing in the column indices.) The resulting c     submatrix is constructed in b, jb, ib. A pointer ipos to the c     beginning of arrays b,jb,is also allowed (i.e., nonzero elements c     are accumulated starting in position ipos of b, jb). c----------------------------------------------------------------------- c Y. Saad,Sep. 21 1989 / recoded Jan. 28 1991 / modified for PSPARSLIB c Sept. 1997.. c----------------------------------------------------------------------- c on entry: c---------- c n \t= dimension of the matrix c a,ja, c   ia  = input matrix in CSR format c perm \t= integer array of length n containing the indices of the rows c         to be extracted. c c job   = job indicator. if (job .ne.1) values are not copied (i.e., c         only pattern is copied). c c on return: c----------- c b,ja, c ib   = matrix in csr format. b(ipos:ipos+nnz-1),jb(ipos:ipos+nnz-1) c     contain the value and column indices respectively of the nnz c     nonzero elements of the permuted matrix. thus ib(1)=ipos. c c Notes: c------- c  algorithm is NOT in place c----------------------------------------------------------------------- c local variables c integer ko , irow , k , i logical values c----------------------------------------------------------------------- values = ( job . eq . 1 ) ko = ipos ib ( 1 ) = ko do 900 i = i1 , i2 irow = perm ( i ) do 800 k = ia ( irow ), ia ( irow + 1 ) - 1 if ( values ) b ( ko ) = a ( k ) jb ( ko ) = ja ( k ) ko = ko + 1 800 continue ib ( i - i1 + 2 ) = ko 900 continue return c--------end-of-dperm1-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine dperm2 ( i1 , i2 , a , ja , ia , b , jb , ib , cperm , rperm , istart , * ipos , job ) implicit none integer ipos integer i1 , i2 , job , istart , ja ( * ), ia ( * ), jb ( * ), ib ( * ), cperm ( * ), rperm ( * ) real * 8 a ( * ), b ( * ) c----------------------------------------------------------------------- c     general submatrix permutation/ extraction routine. c----------------------------------------------------------------------- c     extracts rows rperm(i1), rperm(i1+1), ..., rperm(i2) and does an c     associated column permutation (using array cperm). The resulting c     submatrix is constructed in b, jb, ib. For added flexibility, the c     extracted elements are put in sequence starting from row 'istart' c     of B. In addition a pointer ipos to the beginning of arrays b,jb, c     is also allowed (i.e., nonzero elements are accumulated starting in c     position ipos of b, jb). In most applications istart and ipos are c     equal to one. However, the generality adds substantial flexiblity. c     EXPLE: (1) to permute msr to msr (excluding diagonals) c     call dperm2 (1,n,a,ja,ja,b,jb,jb,rperm,rperm,1,n+2) c            (2) To extract rows 1 to 10: define rperm and cperm to be c     identity permutations (rperm(i)=i, i=1,n) and then c            call dperm2 (1,10,a,ja,ia,b,jb,ib,rperm,rperm,1,1) c            (3) to achieve a symmetric permutation as defined by perm: c            call dperm2 (1,10,a,ja,ia,b,jb,ib,perm,perm,1,1) c            (4) to get a symmetric permutation of A and append the c            resulting data structure to A's data structure (useful!) c            call dperm2 (1,10,a,ja,ia,a,ja,ia(n+1),perm,perm,1,ia(n+1)) c----------------------------------------------------------------------- c Y. Saad,Sep. 21 1989 / recoded Jan. 28 1991. c----------------------------------------------------------------------- c on entry: c---------- c n \t= dimension of the matrix c i1,i2 = extract rows rperm(i1) to rperm(i2) of A, with i1<i2. c c a,ja, c   ia  = input matrix in CSR format c cperm = integer array of length n containing the permutation arrays c\t  for the columns: cperm(i) is the destination of column j, c         i.e., any column index ja(k) is transformed into cperm(ja(k)) c c rperm\t=  permutation array for the rows. rperm(i) = origin (in A) of c          row i in B. This is the reverse permutation relative to the c          ones used in routines cperm, dperm,.... c          rows rperm(i1), rperm(i1)+1, ... rperm(i2) are c          extracted from A and stacked into B, starting in row istart c          of B. c istart= starting row for B where extracted matrix is to be added. c         this is also only a pointer of the be beginning address for c         ib , on return. c ipos  = beginning position in arrays b and jb where to start copying c         elements. Thus, ib(istart) = ipos. c c job   = job indicator. if (job .ne.1) values are not copied (i.e., c         only pattern is copied). c c on return: c----------- c b,ja, c ib   = matrix in csr format. positions 1,2,...,istart-1 of ib c     are not touched. b(ipos:ipos+nnz-1),jb(ipos:ipos+nnz-1) c     contain the value and column indices respectively of the nnz c     nonzero elements of the permuted matrix. thus ib(istart)=ipos. c c Notes: c------- c  1) algorithm is NOT in place c  2) column indices may not be sorted on return even  though they c     may be on entry. c----------------------------------------------------------------------- c local variables c integer ko , irow , k , i logical values c----------------------------------------------------------------------- values = ( job . eq . 1 ) ko = ipos ib ( istart ) = ko do 900 i = i1 , i2 irow = rperm ( i ) do 800 k = ia ( irow ), ia ( irow + 1 ) - 1 if ( values ) b ( ko ) = a ( k ) jb ( ko ) = cperm ( ja ( k )) ko = ko + 1 800 continue ib ( istart + i - i1 + 1 ) = ko 900 continue return c--------end-of-dperm2-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine dmperm ( nrow , a , ja , ao , jao , perm , job ) implicit none integer nrow , ja ( * ), jao ( * ), perm ( nrow ), job real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c This routine performs a symmetric permutation of the rows and c columns of a matrix stored in MSR format. i.e., it computes c B = P A transp(P), where P, is  a permutation matrix. c P maps row i into row perm(i) and column j into column perm(j): c      a(i,j)    becomes   a(perm(i),perm(j)) in new matrix c (i.e.  ao(perm(i),perm(j)) = a(i,j) ) c calls dperm. c----------------------------------------------------------------------- c Y. Saad, Nov 15, 1991. c----------------------------------------------------------------------- c on entry: c---------- c n \t= dimension of the matrix c a, ja = input matrix in MSR format. c perm \t= integer array of length n containing the permutation arrays c\t  for the rows: perm(i) is the destination of row i in the c         permuted matrix -- also the destination of column i in case c         permutation is symmetric (job .le. 2) c c job\t= integer indicating the work to be done: c \t\tjob = 1\tpermute a, ja, ia into ao, jao, iao c \t\tjob = 2 permute matrix ignoring real values. c c on return: c----------- c ao, jao = output matrix in MSR. c c in case job .eq. 2 a and ao are never referred to and can be dummy c arguments. c c Notes: c------- c  1) algorithm is NOT in place c  2) column indices may not be sorted on return even  though they may be c     on entry. c----------------------------------------------------------------------c c     local variables c integer n1 , n2 , j n1 = nrow + 1 n2 = n1 + 1 c call dperm ( nrow , a , ja , ja , ao ( n2 ), jao ( n2 ), jao , perm , perm , job ) c jao ( 1 ) = n2 do 101 j = 1 , nrow ao ( perm ( j )) = a ( j ) jao ( j + 1 ) = jao ( j + 1 ) + n1 101 continue c c done c return c----------------------------------------------------------------------- c--------end-of-dmperm-------------------------------------------------- end c----------------------------------------------------------------------- subroutine dvperm ( n , x , perm ) implicit none integer n , perm ( n ) real * 8 x ( n ) c----------------------------------------------------------------------- c this subroutine performs an in-place permutation of a real vector x c according to the permutation array perm(*), i.e., on return, c the vector x satisfies, c c\tx(perm(j)) :== x(j), j=1,2,.., n c c----------------------------------------------------------------------- c on entry: c--------- c n \t= length of vector x. c perm \t= integer array of length n containing the permutation  array. c x\t= input vector c c on return: c---------- c x\t= vector x permuted according to x(perm(*)) :=  x(*) c c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c c local variables real * 8 tmp , tmp1 integer init , ii , k , next , j c init = 1 tmp = x ( init ) ii = perm ( init ) perm ( init ) = - perm ( init ) k = 0 c c loop c 6 k = k + 1 c c save the chased element -- c tmp1 = x ( ii ) x ( ii ) = tmp next = perm ( ii ) if ( next . lt . 0 ) goto 65 c c test for end c if ( k . gt . n ) goto 101 tmp = tmp1 perm ( ii ) = - perm ( ii ) ii = next c c end loop c goto 6 c c reinitilaize cycle -- c 65 init = init + 1 if ( init . gt . n ) goto 101 if ( perm ( init ) . lt . 0 ) goto 65 tmp = x ( init ) ii = perm ( init ) perm ( init ) =- perm ( init ) goto 6 c 101 continue do 200 j = 1 , n perm ( j ) = - perm ( j ) 200 continue c return c-------------------end-of-dvperm--------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine ivperm ( n , ix , perm ) implicit none integer n , perm ( n ), ix ( n ) c----------------------------------------------------------------------- c this subroutine performs an in-place permutation of an integer vector c ix according to the permutation array perm(*), i.e., on return, c the vector x satisfies, c c\tix(perm(j)) :== ix(j), j=1,2,.., n c c----------------------------------------------------------------------- c on entry: c--------- c n \t= length of vector x. c perm \t= integer array of length n containing the permutation  array. c ix\t= input vector c c on return: c---------- c ix\t= vector x permuted according to ix(perm(*)) :=  ix(*) c c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c c local variables integer tmp , tmp1 , init , ii , k , next , j c init = 1 tmp = ix ( init ) ii = perm ( init ) perm ( init ) = - perm ( init ) k = 0 c c loop c 6 k = k + 1 c c save the chased element -- c tmp1 = ix ( ii ) ix ( ii ) = tmp next = perm ( ii ) if ( next . lt . 0 ) goto 65 c c test for end c if ( k . gt . n ) goto 101 tmp = tmp1 perm ( ii ) = - perm ( ii ) ii = next c c end loop c goto 6 c c reinitilaize cycle -- c 65 init = init + 1 if ( init . gt . n ) goto 101 if ( perm ( init ) . lt . 0 ) goto 65 tmp = ix ( init ) ii = perm ( init ) perm ( init ) =- perm ( init ) goto 6 c 101 continue do 200 j = 1 , n perm ( j ) = - perm ( j ) 200 continue c return c-------------------end-of-ivperm--------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine retmx ( n , a , ja , ia , dd ) implicit none real * 8 a ( * ), dd ( * ) integer n , ia ( * ), ja ( * ) c----------------------------------------------------------------------- c returns in dd(*) the max absolute value of elements in row *. c used for scaling purposes. superseded by rnrms  . c c on entry: c n\t= dimension of A c a,ja,ia c\t= matrix stored in compressed sparse row format c dd\t= real*8 array of length n. On output,entry dd(i) contains c\t  the element of row i that has the largest absolute value. c\t  Moreover the sign of dd is modified such that it is the c\t  same as that of the diagonal element in row i. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c c local variables integer k2 , i , k1 , k real * 8 t , t1 , t2 t = 0.0 t2 = 0.0 t1 = 0.0 c c initialize c k2 = 1 do 11 i = 1 , n k1 = k2 k2 = ia ( i + 1 ) - 1 t = 0.0d0 do 101 k = k1 , k2 t1 = abs ( a ( k )) if ( t1 . gt . t ) t = t1 if ( ja ( k ) . eq . i ) then if ( a ( k ) . ge . 0.0 ) then t2 = a ( k ) else t2 = - a ( k ) endif endif 101 continue dd ( i ) = t2 * t c     we do not invert diag 11 continue return c---------end of retmx ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine diapos ( n , ja , ia , idiag ) implicit none integer n , ia ( n + 1 ), ja ( * ), idiag ( n ) c----------------------------------------------------------------------- c this subroutine returns the positions of the diagonal elements of a c sparse matrix a, ja, ia, in the array idiag. c----------------------------------------------------------------------- c on entry: c---------- c c n\t= integer. row dimension of the matrix a. c a,ja, c    ia = matrix stored compressed sparse row format. a array skipped. c c on return: c----------- c idiag  = integer array of length n. The i-th entry of idiag c          points to the diagonal element a(i,i) in the arrays c          a, ja. (i.e., a(idiag(i)) = element A(i,i) of matrix A) c          if no diagonal element is found the entry is set to 0. c----------------------------------------------------------------------c c           Y. Saad, March, 1990 c----------------------------------------------------------------------c integer i , k do 1 i = 1 , n idiag ( i ) = 0 1 continue c c     sweep through data structure. c do 6 i = 1 , n do 51 k = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( k ) . eq . i ) idiag ( i ) = k 51 continue 6 continue c----------- -end-of-diapos--------------------------------------------- c----------------------------------------------------------------------- return end c----------------------------------------------------------------------- subroutine dscaldg ( n , a , ja , ia , diag , job ) implicit none integer n , job real * 8 a ( * ), diag ( * ), t integer ia ( * ), ja ( * ) c----------------------------------------------------------------------- c scales rows by diag where diag is either given (job=0) c or to be computed: c  job = 1 ,scale row i by  by  +/- max |a(i,j) | and put inverse of c       scaling factor in diag(i),where +/- is the sign of a(i,i). c  job = 2 scale by 2-norm of each row.. c if diag(i) = 0,then diag(i) is replaced by one c (no scaling).. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer j , k1 , k2 , k , i goto ( 12 , 11 , 10 ) job + 1 10 do 110 j = 1 , n k1 = ia ( j ) k2 = ia ( j + 1 ) - 1 t = 0.0d0 do 111 k = k1 , k2 111 t = t + a ( k ) * a ( k ) 110 diag ( j ) = sqrt ( t ) goto 12 11 continue call retmx ( n , a , ja , ia , diag ) c------ 12 do 1 j = 1 , n if ( diag ( j ) . ne . 0.0d0 ) then diag ( j ) = 1.0d0 / diag ( j ) else diag ( j ) = 1.0d0 endif 1 continue do 2 i = 1 , n t = diag ( i ) do 21 k = ia ( i ), ia ( i + 1 ) - 1 a ( k ) = a ( k ) * t 21 continue 2 continue return c--------end of dscaldg ----------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine extbdg ( n , a , ja , ia , bdiag , nblk , ao , jao , iao ) c      implicit real*8 (a-h,o-z) implicit none real * 8 bdiag ( * ), a ( * ), ao ( * ) integer n , ia ( * ), ja ( * ), jao ( * ), iao ( * ), nblk c----------------------------------------------------------------------- c this subroutine extracts the main diagonal blocks of a c matrix stored in compressed sparse row format and puts the result c into the array bdiag and the remainder in ao,jao,iao. c----------------------------------------------------------------------- c on entry: c---------- c n\t= integer. The row dimension of the matrix a. c a, c ja, c ia    = matrix stored in csr format c nblk  = dimension of each diagonal block. The diagonal blocks are c         stored in compressed format rowwise,i.e.,we store in c\t  succession the i nonzeros of the i-th row after those of c\t  row number i-1.. c c on return: c---------- c bdiag = real*8 array of size (n x nblk) containing the diagonal c\t  blocks of A on return c ao, c jao, C iao   = remainder of the matrix stored in csr format. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer m , ltr , l , i , ko , kb , jj , j1 , j2 , j , k m = 1 + ( n - 1 ) / nblk c this version is sequential -- there is a more parallel version c that goes through the structure twice .... ltr = (( nblk - 1 ) * nblk ) / 2 l = m * ltr do 1 i = 1 , l bdiag ( i ) = 0.0d0 1 continue ko = 0 kb = 1 iao ( 1 ) = 1 c------------------------- do 11 jj = 1 , m j1 = ( jj - 1 ) * nblk + 1 j2 = min0 ( n , j1 + nblk - 1 ) do 12 j = j1 , j2 do 13 i = ia ( j ), ia ( j + 1 ) - 1 k = ja ( i ) if ( k . lt . j1 ) then ko = ko + 1 ao ( ko ) = a ( i ) jao ( ko ) = k else if ( k . lt . j ) then c     kb = (jj-1)*ltr+((j-j1)*(j-j1-1))/2+k-j1+1 c     bdiag(kb) = a(i) bdiag ( kb + k - j1 ) = a ( i ) endif 13 continue kb = kb + j - j1 iao ( j + 1 ) = ko + 1 12 continue 11 continue return c---------end-of-extbdg------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine getbwd ( n , ja , ia , ml , mu ) implicit none integer n , ja ( * ), ia ( n + 1 ), ml , mu c----------------------------------------------------------------------- c gets the bandwidth of lower part and upper part of A. c does not assume that A is sorted. c----------------------------------------------------------------------- c on entry: c---------- c n\t= integer = the row dimension of the matrix c a, ja, c    ia = matrix in compressed sparse row format. c        Only arrays ja, ia are used and passed c on return: c----------- c ml\t= integer. The bandwidth of the strict lower part of A c mu\t= integer. The bandwidth of the strict upper part of A c c Notes: c ===== ml and mu are allowed to be negative or return. This may be c       useful since it will tell us whether a band is confined c       in the strict  upper/lower triangular part. c       indeed the definitions of ml and mu are c c       ml = max ( (i-j)  s.t. a(i,j) .ne. 0  ) c       mu = max ( (j-i)  s.t. a(i,j) .ne. 0  ) c----------------------------------------------------------------------c c Y. Saad, Sep. 21 1989                                                c c----------------------------------------------------------------------c integer ldist , i , k ml = - n mu = - n do 3 i = 1 , n do 31 k = ia ( i ), ia ( i + 1 ) - 1 ldist = i - ja ( k ) ml = max ( ml , ldist ) mu = max ( mu , - ldist ) 31 continue 3 continue return c---------------end-of-getbwd ------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine blkfnd ( nrow , ja , ia , nblk ) implicit none integer nrow , nblk c----------------------------------------------------------------------- c This routine attemptps to determine whether or not  the input c matrix has a block structure and finds the blocks size c if it does. A block matrix is one which is c comprised of small square dense blocks. If there are zero c elements within the square blocks and the original data structure c takes these zeros into account then blkchk may fail to find the c correct block size. c----------------------------------------------------------------------- c on entry c--------- c nrow\t= integer equal to the row dimension of the matrix. c ja    = integer array containing the column indices of the entries c         nonzero entries of the matrix stored by row. c ia    = integer array of length nrow + 1 containing the pointers c         beginning of each row in array ja. c c nblk  = integer containing the assumed value of nblk if job = 0 c c on return c---------- c nblk  = integer containing the value found for nblk when job = 1. c         if imsg .ne. 0 this value is meaningless however. c c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer ia ( nrow + 1 ), ja ( * ) c----------------------------------------------------------------------- c first part of code will find candidate block sizes. c criterion used here is a simple one: scan rows and  determine groups c of rows that have the same length and such that the first column c number and the last column number are identical. c----------------------------------------------------------------------- integer minlen , irow , i , len , iblk , len0 , jfirst , jlast , jrow integer i1 , i2 , jf , jl , imsg minlen = ia ( 2 ) - ia ( 1 ) irow = 1 do 1 i = 2 , nrow len = ia ( i + 1 ) - ia ( i ) if ( len . lt . minlen ) then minlen = len irow = i endif 1 continue c c     ---- candidates are all dividers of minlen c nblk = 1 if ( minlen . le . 1 ) return c do 99 iblk = minlen , 1 , - 1 if ( mod ( minlen , iblk ) . ne . 0 ) goto 99 len = ia ( 2 ) - ia ( 1 ) len0 = len jfirst = ja ( 1 ) jlast = ja ( ia ( 2 ) - 1 ) do 10 jrow = irow + 1 , irow + nblk - 1 i1 = ia ( jrow ) i2 = ia ( jrow + 1 ) - 1 len = i2 + 1 - i1 jf = ja ( i1 ) jl = ja ( i2 ) if ( len . ne . len0 . or . jf . ne . jfirst . or . * jl . ne . jlast ) goto 99 10 continue c c     check for this candidate ---- c call blkchk ( nrow , ja , ia , iblk , imsg ) if ( imsg . eq . 0 ) then c c     block size found c nblk = iblk return endif 99 continue c--------end-of-blkfnd ------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine blkchk ( nrow , ja , ia , nblk , imsg ) implicit none integer nrow , nblk , imsg c----------------------------------------------------------------------- c This routine checks whether the input matrix is a block c matrix with block size of nblk. A block matrix is one which is c comprised of small square dense blocks. If there are zero c elements within the square blocks and the data structure c takes them into account then blkchk may fail to find the c correct block size. c----------------------------------------------------------------------- c on entry c--------- c nrow\t= integer equal to the row dimension of the matrix. c ja    = integer array containing the column indices of the entries c         nonzero entries of the matrix stored by row. c ia    = integer array of length nrow + 1 containing the pointers c         beginning of each row in array ja. c c nblk  = integer containing the value of nblk to be checked. c c on return c---------- c c imsg  = integer containing a message  with the following meaning. c          imsg = 0 means that the output value of nblk is a correct c                   block size. nblk .lt. 0 means nblk not correct c                   block size. c          imsg = -1 : nblk does not divide nrow c          imsg = -2 : a starting element in a row is at wrong position c             (j .ne. mult*nblk +1 ) c          imsg = -3 : nblk does divide a row length - c          imsg = -4 : an element is isolated outside a block or c             two rows in same group have different lengths c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer ia ( nrow + 1 ), ja ( * ) integer nr , irow , ii , i1 , j2 , lena , len , i , k , jstart , j c---------------------------------------------------------------------- c first part of code will find candidate block sizes. c this is not guaranteed to work . so a check is done at the end c the criterion used here is a simple one: c scan rows and determine groups of rows that have the same length c and such that the first column number and the last column number c are identical. c---------------------------------------------------------------------- imsg = 0 if ( nblk . le . 1 ) return nr = nrow / nblk if ( nr * nblk . ne . nrow ) goto 101 c--   main loop --------------------------------------------------------- irow = 1 do 20 ii = 1 , nr c     i1= starting position for group of nblk rows in original matrix i1 = ia ( irow ) j2 = i1 c     lena = length of each row in that group  in the original matrix lena = ia ( irow + 1 ) - i1 c     len = length of each block-row in that group in the output matrix len = lena / nblk if ( len * nblk . ne . lena ) goto 103 c c     for each row c do 6 i = 1 , nblk irow = irow + 1 if ( ia ( irow ) - ia ( irow - 1 ) . ne . lena ) goto 104 c c     for each block c do 7 k = 0 , len - 1 jstart = ja ( i1 + nblk * k ) - 1 if ( ( jstart / nblk ) * nblk . ne . jstart ) goto 102 c c     for each column c do 5 j = 1 , nblk if ( jstart + j . ne . ja ( j2 ) ) goto 104 j2 = j2 + 1 5 continue 7 continue 6 continue 20 continue c     went through all loops successfully: return 101 imsg = - 1 return 102 imsg = - 2 return 103 imsg = - 3 return 104 imsg = - 4 c----------------end of chkblk ----------------------------------------- c----------------------------------------------------------------------- return end c----------------------------------------------------------------------- subroutine infdia ( n , ja , ia , ind , idiag ) implicit none integer n , idiag , ia ( * ), ind ( * ), ja ( * ) c----------------------------------------------------------------------- c     obtains information on the diagonals of A. c----------------------------------------------------------------------- c this subroutine finds the lengths of each of the 2*n-1 diagonals of A c it also outputs the number of nonzero diagonals found. c----------------------------------------------------------------------- c on entry: c---------- c n\t= dimension of the matrix a. c c a,    ..... not needed here. c ja, c ia    = matrix stored in csr format c c on return: c----------- c c idiag = integer. number of nonzero diagonals found. c c ind   = integer array of length at least 2*n-1. The k-th entry in c         ind contains the number of nonzero elements in the diagonal c         number k, the numbering beeing from the lowermost diagonal c         (bottom-left). In other words ind(k) = length of diagonal c         whose offset wrt the main diagonal is = - n + k. c----------------------------------------------------------------------c c           Y. Saad, Sep. 21 1989                                      c c----------------------------------------------------------------------c integer n2 , i , j , k n2 = n + n - 1 do 1 i = 1 , n2 ind ( i ) = 0 1 continue do 3 i = 1 , n do 2 k = ia ( i ), ia ( i + 1 ) - 1 j = ja ( k ) ind ( n + j - i ) = ind ( n + j - i ) + 1 2 continue 3 continue c     count the nonzero ones. idiag = 0 do 41 k = 1 , n2 if ( ind ( k ) . ne . 0 ) idiag = idiag + 1 41 continue return c done c------end-of-infdia --------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine amubdg ( nrow , ncol , ncolb , ja , ia , jb , ib , ndegr , nnz , iw ) implicit none integer nrow , ncol , ncolb , nnz integer ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( ncol + 1 ), ndegr ( nrow ), iw ( ncolb ) c----------------------------------------------------------------------- c gets the number of nonzero elements in each row of A*B and the total c number of nonzero elements in A*B. c----------------------------------------------------------------------- c on entry: c -------- c c nrow  = integer.  row dimension of matrix A c ncol  = integer.  column dimension of matrix A = row dimension of c                   matrix B. c ncolb = integer. the colum dimension of the matrix B. c c ja, ia= row structure of input matrix A: ja = column indices of c         the nonzero elements of A stored by rows. c         ia = pointer to beginning of each row  in ja. c c jb, ib= row structure of input matrix B: jb = column indices of c         the nonzero elements of A stored by rows. c         ib = pointer to beginning of each row  in jb. c c on return: c --------- c ndegr\t= integer array of length nrow containing the degrees (i.e., c         the number of nonzeros in  each row of the matrix A * B c c nnz   = total number of nonzero elements found in A * B c c work arrays: c------------- c iw\t= integer work array of length ncolb. c----------------------------------------------------------------------- integer k , ii , ldg , last , j , jr , jc do 1 k = 1 , ncolb iw ( k ) = 0 1 continue do 2 k = 1 , nrow ndegr ( k ) = 0 2 continue c c     method used: Transp(A) * A = sum [over i=1, nrow]  a(i)&#94;T a(i) c     where a(i) = i-th row of  A. We must be careful not to add  the c     elements already accounted for. c c do 7 ii = 1 , nrow c c     for each row of A c ldg = 0 c c    end-of-linked list c last = - 1 do 6 j = ia ( ii ), ia ( ii + 1 ) - 1 c c     row number to be added: c jr = ja ( j ) do 5 k = ib ( jr ), ib ( jr + 1 ) - 1 jc = jb ( k ) if ( iw ( jc ) . eq . 0 ) then c c     add one element to the linked list c ldg = ldg + 1 iw ( jc ) = last last = jc endif 5 continue 6 continue ndegr ( ii ) = ldg c c     reset iw to zero c do 61 k = 1 , ldg j = iw ( last ) iw ( last ) = 0 last = j 61 continue c----------------------------------------------------------------------- 7 continue c nnz = 0 do 8 ii = 1 , nrow nnz = nnz + ndegr ( ii ) 8 continue c return c---------------end-of-amubdg ------------------------------------------ c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine aplbdg ( nrow , ncol , ja , ia , jb , ib , ndegr , nnz , iw ) implicit none integer nrow , ncol , nnz integer ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), iw ( ncol ), ndegr ( nrow ) c----------------------------------------------------------------------- c gets the number of nonzero elements in each row of A+B and the total c number of nonzero elements in A+B. c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A and B c ncol  = integer. The column dimension of A and B. c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c b, c jb, c ib\t=  Matrix B in compressed sparse row format. c c on return: c---------- c ndegr\t= integer array of length nrow containing the degrees (i.e., c         the number of nonzeros in  each row of the matrix A + B. c c nnz   = total number of nonzero elements found in A * B c c work arrays: c------------ c iw\t= integer work array of length equal to ncol. c c----------------------------------------------------------------------- integer k , ii , ldg , last , j , jr , jc do 1 k = 1 , ncol iw ( k ) = 0 1 continue c do 2 k = 1 , nrow ndegr ( k ) = 0 2 continue c do 7 ii = 1 , nrow ldg = 0 c c    end-of-linked list c last = - 1 c c     row of A c do 5 j = ia ( ii ), ia ( ii + 1 ) - 1 jr = ja ( j ) c c     add element to the linked list c ldg = ldg + 1 iw ( jr ) = last last = jr 5 continue c c     row of B c do 6 j = ib ( ii ), ib ( ii + 1 ) - 1 jc = jb ( j ) if ( iw ( jc ) . eq . 0 ) then c c     add one element to the linked list c ldg = ldg + 1 iw ( jc ) = last last = jc endif 6 continue c     done with row ii. ndegr ( ii ) = ldg c c     reset iw to zero c do 61 k = 1 , ldg j = iw ( last ) iw ( last ) = 0 last = j 61 continue c----------------------------------------------------------------------- 7 continue c nnz = 0 do 8 ii = 1 , nrow nnz = nnz + ndegr ( ii ) 8 continue return c----------------end-of-aplbdg ----------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine rnrms ( nrow , nrm , a , ia , diag ) implicit none integer nrow , nrm real * 8 a ( * ), diag ( nrow ), scal integer ia ( nrow + 1 ) c----------------------------------------------------------------------- c gets the norms of each row of A. (choice of three norms) c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c nrm   = integer. norm indicator. nrm = 1, means 1-norm, nrm =2 c                  means the 2-nrm, nrm = 0 means max norm c c a, c ja, c ia   = Matrix A in compressed sparse row format. c        ja is not used - not passed. c on return: c---------- c c diag = real vector of length nrow containing the norms c c----------------------------------------------------------------- integer ii , k1 , k2 , k do 1 ii = 1 , nrow c c     compute the norm if each element. c scal = 0.0d0 k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 if ( nrm . eq . 0 ) then do 2 k = k1 , k2 scal = max ( scal , abs ( a ( k ) ) ) 2 continue elseif ( nrm . eq . 1 ) then do 3 k = k1 , k2 scal = scal + abs ( a ( k ) ) 3 continue else do 4 k = k1 , k2 scal = scal + a ( k ) ** 2 4 continue endif if ( nrm . eq . 2 ) scal = sqrt ( scal ) diag ( ii ) = scal 1 continue return c----------------------------------------------------------------------- c-------------end-of-rnrms---------------------------------------------- end c----------------------------------------------------------------------- subroutine cnrms ( nrow , nrm , a , ja , ia , diag ) implicit none integer nrow , nrm real * 8 a ( * ), diag ( nrow ) integer ja ( * ), ia ( nrow + 1 ) c----------------------------------------------------------------------- c gets the norms of each column of A. (choice of three norms) c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c nrm   = integer. norm indicator. nrm = 1, means 1-norm, nrm =2 c                  means the 2-nrm, nrm = 0 means max norm c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c on return: c---------- c c diag = real vector of length nrow containing the norms c NOTE: this is designed for square matrices. For the case c nrow .ne. ncol -- diag must be of size max(nrow,ncol) even c though only the ncol first entries will be filled.. c [report E. Canot 10/20/05 ] c----------------------------------------------------------------- integer k , ii , k1 , k2 , j do 10 k = 1 , nrow diag ( k ) = 0.0d0 10 continue do 1 ii = 1 , nrow k1 = ia ( ii ) k2 = ia ( ii + 1 ) - 1 do 2 k = k1 , k2 j = ja ( k ) c     update the norm of each column if ( nrm . eq . 0 ) then diag ( j ) = max ( diag ( j ), abs ( a ( k ) ) ) elseif ( nrm . eq . 1 ) then diag ( j ) = diag ( j ) + abs ( a ( k ) ) else diag ( j ) = diag ( j ) + a ( k ) ** 2 endif 2 continue 1 continue if ( nrm . ne . 2 ) return do 3 k = 1 , nrow diag ( k ) = sqrt ( diag ( k )) 3 continue return c----------------------------------------------------------------------- c------------end-of-cnrms----------------------------------------------- end c----------------------------------------------------------------------- subroutine roscal ( nrow , job , nrm , a , ja , ia , diag , b , jb , ib , ierr ) implicit none real * 8 a ( * ), b ( * ), diag ( nrow ) integer nrow , job , nrm , ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ierr c----------------------------------------------------------------------- c scales the rows of A such that their norms are one on return c 3 choices of norms: 1-norm, 2-norm, max-norm. c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c job   = integer. job indicator. Job=0 means get array b only c         job = 1 means get b, and the integer arrays ib, jb. c c nrm   = integer. norm indicator. nrm = 1, means 1-norm, nrm =2 c                  means the 2-nrm, nrm = 0 means max norm c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c on return: c---------- c c diag = diagonal matrix stored as a vector containing the matrix c        by which the rows have been scaled, i.e., on return c        we have B = Diag*A. c c b, c jb, c ib\t= resulting matrix B in compressed sparse row sparse format. c c ierr  = error message. ierr=0     : Normal return c                        ierr=i > 0 : Row number i is a zero row. c Notes: c------- c 1)        The column dimension of A is not needed. c 2)        algorithm in place (B can take the place of A). c----------------------------------------------------------------- integer j call rnrms ( nrow , nrm , a , ia , diag ) ierr = 0 do 1 j = 1 , nrow if ( diag ( j ) . eq . 0.0d0 ) then ierr = j return else diag ( j ) = 1.0d0 / diag ( j ) endif 1 continue call diamua ( nrow , job , a , ja , ia , diag , b , jb , ib ) return c-------end-of-roscal--------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine coscal ( nrow , job , nrm , a , ja , ia , diag , b , jb , ib , ierr ) c----------------------------------------------------------------------- implicit none integer nrm real * 8 a ( * ), b ( * ), diag ( nrow ) integer nrow , job , ja ( * ), jb ( * ), ia ( nrow + 1 ), ib ( nrow + 1 ), ierr c----------------------------------------------------------------------- c scales the columns of A such that their norms are one on return c result matrix written on b, or overwritten on A. c 3 choices of norms: 1-norm, 2-norm, max-norm. in place. c----------------------------------------------------------------------- c on entry: c --------- c nrow\t= integer. The row dimension of A c c job   = integer. job indicator. Job=0 means get array b only c         job = 1 means get b, and the integer arrays ib, jb. c c nrm   = integer. norm indicator. nrm = 1, means 1-norm, nrm =2 c                  means the 2-nrm, nrm = 0 means max norm c c a, c ja, c ia   = Matrix A in compressed sparse row format. c c on return: c---------- c c diag = diagonal matrix stored as a vector containing the matrix c        by which the columns have been scaled, i.e., on return c        we have B = A * Diag c c b, c jb, c ib\t= resulting matrix B in compressed sparse row sparse format. c c ierr  = error message. ierr=0     : Normal return c                        ierr=i > 0 : Column number i is a zero row. c Notes: c------- c 1)     The column dimension of A is not needed. c 2)     algorithm in place (B can take the place of A). c----------------------------------------------------------------- integer j call cnrms ( nrow , nrm , a , ja , ia , diag ) ierr = 0 do 1 j = 1 , nrow if ( diag ( j ) . eq . 0.0 ) then ierr = j return else diag ( j ) = 1.0d0 / diag ( j ) endif 1 continue call amudia ( nrow , job , a , ja , ia , diag , b , jb , ib ) return c--------end-of-coscal-------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine addblk ( nrowa , ncola , a , ja , ia , ipos , jpos , job , & nrowb , ncolb , b , jb , ib , nrowc , ncolc , c , jc , ic , nzmx , ierr ) c      implicit none implicit none integer nrowa , nrowb , nrowc , ncola , ncolb , ncolc , ipos , jpos integer nzmx , ierr , job integer ja ( 1 : * ), ia ( 1 : * ), jb ( 1 : * ), ib ( 1 : * ), jc ( 1 : * ), ic ( 1 : * ) real * 8 a ( 1 : * ), b ( 1 : * ), c ( 1 : * ) c----------------------------------------------------------------------- c     This subroutine adds a matrix B into a submatrix of A whose c     (1,1) element is located in the starting position (ipos, jpos). c     The resulting matrix is allowed to be larger than A (and B), c     and the resulting dimensions nrowc, ncolc will be redefined c     accordingly upon return. c     The input matrices are assumed to be sorted, i.e. in each row c     the column indices appear in ascending order in the CSR format. c----------------------------------------------------------------------- c on entry: c --------- c nrowa    = number of rows in A. c bcola    = number of columns in A. c a,ja,ia  = Matrix A in compressed sparse row format with entries sorted c nrowb    = number of rows in B. c ncolb    = number of columns in B. c b,jb,ib  = Matrix B in compressed sparse row format with entries sorted c c nzmax\t   = integer. The  length of the arrays c and jc. addblk will c            stop if the number of nonzero elements in the matrix C c            exceeds nzmax. See ierr. c c on return: c---------- c nrowc    = number of rows in C. c ncolc    = number of columns in C. c c,jc,ic  = resulting matrix C in compressed sparse row sparse format c            with entries sorted ascendly in each row. c c ierr\t   = integer. serving as error message. c         ierr = 0 means normal return, c         ierr .gt. 0 means that addblk stopped while computing the c         i-th row  of C with i=ierr, because the number c         of elements in C exceeds nzmax. c c Notes: c------- c     this will not work if any of the two input matrices is not sorted c----------------------------------------------------------------------- logical values integer i , j1 , j2 , ka , kb , kc , kamax , kbmax kamax = 0 values = ( job . ne . 0 ) ierr = 0 nrowc = max ( nrowa , nrowb + ipos - 1 ) ncolc = max ( ncola , ncolb + jpos - 1 ) kc = 1 kbmax = 0 ic ( 1 ) = kc c do 10 i = 1 , nrowc if ( i . le . nrowa ) then ka = ia ( i ) kamax = ia ( i + 1 ) - 1 else ka = ia ( nrowa + 1 ) end if if (( i . ge . ipos ). and .(( i - ipos ). le . nrowb )) then kb = ib ( i - ipos + 1 ) kbmax = ib ( i - ipos + 2 ) - 1 else kb = ib ( nrowb + 1 ) end if c c     a do-while type loop -- goes through all the elements in a row. c 20 continue if ( ka . le . kamax ) then j1 = ja ( ka ) else j1 = ncolc + 1 endif if ( kb . le . kbmax ) then j2 = jb ( kb ) + jpos - 1 else j2 = ncolc + 1 endif c c     if there are more elements to be added. c if (( ka . le . kamax . or . kb . le . kbmax ) . and . & ( j1 . le . ncolc . or . j2 . le . ncolc )) then c c     three cases c if ( j1 . eq . j2 ) then if ( values ) c ( kc ) = a ( ka ) + b ( kb ) jc ( kc ) = j1 ka = ka + 1 kb = kb + 1 kc = kc + 1 else if ( j1 . lt . j2 ) then jc ( kc ) = j1 if ( values ) c ( kc ) = a ( ka ) ka = ka + 1 kc = kc + 1 else if ( j1 . gt . j2 ) then jc ( kc ) = j2 if ( values ) c ( kc ) = b ( kb ) kb = kb + 1 kc = kc + 1 endif if ( kc . gt . nzmx ) goto 999 goto 20 end if ic ( i + 1 ) = kc 10 continue return 999 ierr = i return c---------end-of-addblk------------------------------------------------- end c----------------------------------------------------------------------- subroutine get1up ( n , ja , ia , ju ) implicit none integer n , ja ( * ), ia ( * ), ju ( * ) c---------------------------------------------------------------------- c obtains the first element of each row of the upper triangular part c of a matrix. Assumes that the matrix is already sorted. c----------------------------------------------------------------------- c parameters c input c ----- c ja      = integer array containing the column indices of aij c ia      = pointer array. ia(j) contains the position of the c           beginning of row j in ja c c output c ------ c ju      = integer array of length n. ju(i) is the address in ja c           of the first element of the uper triangular part of c           of A (including rthe diagonal. Thus if row i does have c           a nonzero diagonal element then ju(i) will point to it. c           This is a more general version of diapos. c----------------------------------------------------------------------- c local vAriables integer i , k c do 5 i = 1 , n ju ( i ) = 0 k = ia ( i ) c 1 continue if ( ja ( k ) . ge . i ) then ju ( i ) = k goto 5 elseif ( k . lt . ia ( i + 1 ) - 1 ) then k = k + 1 c c go try next element in row c goto 1 endif 5 continue return c-----end-of-get1up----------------------------------------------------- end c---------------------------------------------------------------------- subroutine xtrows ( i1 , i2 , a , ja , ia , ao , jao , iao , iperm , job ) implicit none integer i1 , i2 , ja ( * ), ia ( * ), jao ( * ), iao ( * ), iperm ( * ), job real * 8 a ( * ), ao ( * ) c----------------------------------------------------------------------- c this subroutine extracts given rows from a matrix in CSR format. c Specifically, rows number iperm(i1), iperm(i1+1), ...., iperm(i2) c are extracted and put in the output matrix ao, jao, iao, in CSR c format.  NOT in place. c Youcef Saad -- coded Feb 15, 1992. c----------------------------------------------------------------------- c on entry: c---------- c i1,i2   = two integers indicating the rows to be extracted. c           xtrows will extract rows iperm(i1), iperm(i1+1),..,iperm(i2), c           from original matrix and stack them in output matrix c           ao, jao, iao in csr format c c a, ja, ia = input matrix in csr format c c iperm\t= integer array of length nrow containing the reverse permutation c         array for the rows. row number iperm(j) in permuted matrix PA c         used to be row number j in unpermuted matrix. c         ---> a(i,j) in the permuted matrix was a(iperm(i),j) c         in the inout matrix. c c job\t= integer indicating the work to be done: c \t\tjob .ne. 1 : get structure only of output matrix,, c               i.e., ignore real values. (in which case arrays a c               and ao are not used nor accessed). c \t\tjob = 1\tget complete data structure of output matrix. c               (i.e., including arrays ao and iao). c------------ c on return: c------------ c ao, jao, iao = input matrix in a, ja, ia format c note : c        if (job.ne.1)  then the arrays a and ao are not used. c----------------------------------------------------------------------c c           Y. Saad, revised May  2, 1990                              c c----------------------------------------------------------------------c logical values integer ko , j , ii , k values = ( job . eq . 1 ) c c copying c ko = 1 iao ( 1 ) = ko do 100 j = i1 , i2 c c ii=iperm(j) is the index of old row to be copied. c ii = iperm ( j ) do 60 k = ia ( ii ), ia ( ii + 1 ) - 1 jao ( ko ) = ja ( k ) if ( values ) ao ( ko ) = a ( k ) ko = ko + 1 60 continue iao ( j - i1 + 2 ) = ko 100 continue c return c---------end-of-xtrows------------------------------------------------- c----------------------------------------------------------------------- end c----------------------------------------------------------------------- subroutine csrkvstr ( n , ia , ja , nr , kvstr ) c----------------------------------------------------------------------- implicit none integer n , ia ( n + 1 ), ja ( * ), nr , kvstr ( * ) c----------------------------------------------------------------------- c     Finds block row partitioning of matrix in CSR format. c----------------------------------------------------------------------- c     On entry: c-------------- c     n       = number of matrix scalar rows c     ia,ja   = input matrix sparsity structure in CSR format c c     On return: c--------------- c     nr      = number of block rows c     kvstr   = first row number for each block row c c     Notes: c----------- c     Assumes that the matrix is sorted by columns. c     This routine does not need any workspace. c c----------------------------------------------------------------------- c     local variables integer i , j , jdiff c----------------------------------------------------------------------- nr = 1 kvstr ( 1 ) = 1 c--------------------------------- do i = 2 , n jdiff = ia ( i + 1 ) - ia ( i ) if ( jdiff . eq . ia ( i ) - ia ( i - 1 )) then do j = ia ( i ), ia ( i + 1 ) - 1 if ( ja ( j ) . ne . ja ( j - jdiff )) then nr = nr + 1 kvstr ( nr ) = i goto 299 endif enddo 299 continue else nr = nr + 1 kvstr ( nr ) = i endif enddo kvstr ( nr + 1 ) = n + 1 c--------------------------------- return end c----------------------------------------------------------------------- c------------------------end-of-csrkvstr-------------------------------- subroutine csrkvstc ( n , ia , ja , nc , kvstc , iwk ) c----------------------------------------------------------------------- implicit none integer n , ia ( n + 1 ), ja ( * ), nc , kvstc ( * ), iwk ( * ) c----------------------------------------------------------------------- c     Finds block column partitioning of matrix in CSR format. c----------------------------------------------------------------------- c     On entry: c-------------- c     n       = number of matrix scalar rows c     ia,ja   = input matrix sparsity structure in CSR format c c     On return: c--------------- c     nc      = number of block columns c     kvstc   = first column number for each block column c c     Work space: c---------------- c     iwk(*) of size equal to the number of scalar columns plus one. c        Assumed initialized to 0, and left initialized on return. c c     Notes: c----------- c     Assumes that the matrix is sorted by columns. c c----------------------------------------------------------------------- c     local variables integer i , j , k , ncol c c----------------------------------------------------------------------- c-----use ncol to find maximum scalar column number ncol = 0 c-----mark the beginning position of the blocks in iwk do i = 1 , n if ( ia ( i ) . lt . ia ( i + 1 )) then j = ja ( ia ( i )) iwk ( j ) = 1 do k = ia ( i ) + 1 , ia ( i + 1 ) - 1 j = ja ( k ) if ( ja ( k - 1 ). ne . j - 1 ) then iwk ( j ) = 1 iwk ( ja ( k - 1 ) + 1 ) = 1 endif enddo iwk ( j + 1 ) = 1 ncol = max0 ( ncol , j ) endif enddo c--------------------------------- nc = 1 kvstc ( 1 ) = 1 do i = 2 , ncol + 1 if ( iwk ( i ). ne . 0 ) then nc = nc + 1 kvstc ( nc ) = i iwk ( i ) = 0 endif enddo nc = nc - 1 c--------------------------------- return end c----------------------------------------------------------------------- c------------------------end-of-csrkvstc-------------------------------- c----------------------------------------------------------------------- subroutine kvstmerge ( nr , kvstr , nc , kvstc , n , kvst ) c----------------------------------------------------------------------- implicit none integer nr , kvstr ( nr + 1 ), nc , kvstc ( nc + 1 ), n , kvst ( * ) c----------------------------------------------------------------------- c     Merges block partitionings, for conformal row/col pattern. c----------------------------------------------------------------------- c     On entry: c-------------- c     nr,nc   = matrix block row and block column dimension c     kvstr   = first row number for each block row c     kvstc   = first column number for each block column c c     On return: c--------------- c     n       = conformal row/col matrix block dimension c     kvst    = conformal row/col block partitioning c c     Notes: c----------- c     If matrix is not square, this routine returns without warning. c c----------------------------------------------------------------------- c-----local variables integer i , j c--------------------------------- if ( kvstr ( nr + 1 ) . ne . kvstc ( nc + 1 )) return i = 1 j = 1 n = 1 200 if ( i . gt . nr + 1 ) then kvst ( n ) = kvstc ( j ) j = j + 1 elseif ( j . gt . nc + 1 ) then kvst ( n ) = kvstr ( i ) i = i + 1 elseif ( kvstc ( j ) . eq . kvstr ( i )) then kvst ( n ) = kvstc ( j ) j = j + 1 i = i + 1 elseif ( kvstc ( j ) . lt . kvstr ( i )) then kvst ( n ) = kvstc ( j ) j = j + 1 else kvst ( n ) = kvstr ( i ) i = i + 1 endif n = n + 1 if ( i . le . nr + 1 . or . j . le . nc + 1 ) goto 200 n = n - 2 c--------------------------------- return c------------------------end-of-kvstmerge------------------------------- end","tags":"","loc":"sourcefile\\unary.f.html"}]}