var tipuesearch = {"pages":[{"title":" LINALG ","text":"LINALG Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"csr_matrix – LINALG ","text":"type, public :: csr_matrix A sparse matrix stored in compressed sparse row (CSR) format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: column_indices An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the column indices of each value. integer(kind=int32), public, allocatable, dimension(:) :: row_indices An M+1 element array containing the indices in V an JA at which the\nrequested row starts. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the non-zero values of the matrix. Type-Bound Procedures procedure, public :: extract_diagonal => csr_extract_diagonal private  subroutine csr_extract_diagonal(a, diag, err) Extracts the diagonal from a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(out), dimension(:) :: diag The diagonal values. class(errors), intent(inout), optional, target :: err The error object to be updated. procedure, public :: get => csr_get_element private  function csr_get_element(this, i, j) result(rst) Retrieves the element at the specified row and column. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: this The CSR matrix object. integer(kind=int32), intent(in) :: i The row index. integer(kind=int32), intent(in) :: j The column index. Return Value real(kind=real64) The value at the specified row and column.","tags":"","loc":"type\\csr_matrix.html"},{"title":"msr_matrix – LINALG ","text":"type, public :: msr_matrix A sparse matrix stored in modified sparse row format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: indices An NNZ-element array containing the index information. integer(kind=int32), public :: m = 0 The number of rows in the matrix. integer(kind=int32), public :: n = 0 The number of columns in the matrix. integer(kind=int32), public :: nnz = 0 The number of nonzero values in the matrix. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array containing the non-zero values from the\nmatrix.  The first MIN(M,N) elements contain the diagonal.","tags":"","loc":"type\\msr_matrix.html"},{"title":"sort – LINALG","text":"public interface sort An interface to the sorting routines. Module Procedures private  subroutine sort_dbl_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_dbl_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_cmplx_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_cmplx_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_cmplx(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. complex(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_dbl(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_int32_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_int32_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\sort.html"},{"title":"report_array_size_error – LINALG","text":"public  subroutine report_array_size_error(fcn, err, name, expected, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expected The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_inner_matrix_dimension_error – LINALG","text":"public  subroutine report_inner_matrix_dimension_error(fcn, err, name1, name2, expected, actual) Reports an inner matrix dimension error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name1 The name of the first matrix. character(len=*), intent(in) :: name2 The name of the second matrix. integer(kind=int32), intent(in) :: expected The expected inner dimension. integer(kind=int32), intent(in) :: actual The actual inner dimension. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_inner_matrix_dimension_error.html"},{"title":"report_matrix_size_error – LINALG","text":"public  subroutine report_matrix_size_error(fcn, err, name, expectedRows, expectedCols, actualRows, actualCols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedRows The expected number of rows in the matrix. integer(kind=int32), intent(in) :: expectedCols The expected number of columns in the matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – LINALG","text":"public  subroutine report_memory_error(fcn, err, flag) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: flag The error flag. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_singular_matrix_warning – LINALG","text":"public  subroutine report_singular_matrix_warning(fcn, err, row) Reports a singular matrix error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: row The row index where the singularity issue was first encountered. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_singular_matrix_warning.html"},{"title":"report_square_matrix_error – LINALG","text":"public  subroutine report_square_matrix_error(fcn, err, name, expectedSize, actualRows, actualCols) Reports an error where a square matrix was expected but a non-square \nmatrix was provided. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedSize The expected size of the square matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_square_matrix_error.html"},{"title":"form_lq – LINALG","text":"public interface form_lq Module Procedures private  subroutine form_lq_no_pivot(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lq_no_pivot_cmplx(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_lq.html"},{"title":"lq_factor – LINALG","text":"public interface lq_factor Module Procedures private  subroutine lq_factor_no_pivot(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine lq_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\lq_factor.html"},{"title":"mult_lq – LINALG","text":"public interface mult_lq Module Procedures private  subroutine mult_lq_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_lq.html"},{"title":"solve_lq – LINALG","text":"public interface solve_lq Module Procedures private  subroutine solve_lq_mtx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_lq_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_lq.html"},{"title":"solve_least_squares – LINALG","text":"public interface solve_least_squares Module Procedures private  subroutine solve_least_squares_mtx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares.html"},{"title":"solve_least_squares_full – LINALG","text":"public interface solve_least_squares_full Module Procedures private  subroutine solve_least_squares_mtx_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares_full.html"},{"title":"solve_least_squares_svd – LINALG","text":"public interface solve_least_squares_svd Module Procedures private  subroutine solve_least_squares_mtx_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_least_squares_vec_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_least_squares_vec_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_least_squares_svd.html"},{"title":"band_diag_mtx_mult – LINALG","text":"public interface band_diag_mtx_mult An interface to the banded diagonal matrix multiplication routines. Module Procedures private  subroutine band_diag_mtx_mult_dbl(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. real(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_diag_mtx_mult_cmplx(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. complex(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_diag_mtx_mult.html"},{"title":"band_mtx_mult – LINALG","text":"public interface band_mtx_mult An interface to the banded matrix multiplication routines. Module Procedures private  subroutine band_mtx_vec_mult_dbl(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation or where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating whether to perform the operation (FALSE) or (TRUE). integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. real(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_mtx_vec_mult_cmplx(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: trans An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. complex(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_mtx_mult.html"},{"title":"band_mtx_to_full_mtx – LINALG","text":"public interface band_mtx_to_full_mtx An interface to the banded matrix to full matrix conversion routines. Module Procedures private  subroutine band_to_full_mtx_dbl(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_to_full_mtx_cmplx(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. complex(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\band_mtx_to_full_mtx.html"},{"title":"banded_to_dense – LINALG","text":"public interface banded_to_dense An interface to the banded to dense matrix conversion routines. Module Procedures private  subroutine banded_to_dense_dbl(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. real(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine banded_to_dense_cmplx(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. complex(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\banded_to_dense.html"},{"title":"dense_to_banded – LINALG","text":"public interface dense_to_banded An interface to the dense to banded matrix conversion routines. Module Procedures private  subroutine dense_to_banded_dbl(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine dense_to_banded_cmplx(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\dense_to_banded.html"},{"title":"det – LINALG","text":"public interface det An interface to the determinant routines. Module Procedures private  function det_dbl(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value real(kind=real64) The determinant of the matrix. private  function det_cmplx(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value complex(kind=real64) The determinant of the matrix.","tags":"","loc":"interface\\det.html"},{"title":"diag_mtx_mult – LINALG","text":"public interface diag_mtx_mult An interface to the diagonal matrix multiplication routines. Module Procedures private  subroutine diag_mtx_mult_mtx(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx3(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx4(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_cmplx(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_cmplx(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_mix(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_mix(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_sparse_mult(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix and is a sparse matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in), dimension(:) :: a class( csr_matrix ), intent(inout) :: b class(errors), intent(inout), optional, target :: err","tags":"","loc":"interface\\diag_mtx_mult.html"},{"title":"extract_diagonal – LINALG","text":"public interface extract_diagonal An interface to the diagonal extraction routines. Module Procedures private  subroutine extract_diagonal_dbl(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_cmplx(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. complex(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_csr(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\extract_diagonal.html"},{"title":"mtx_mult – LINALG","text":"public interface mtx_mult An interface to the matrix multiplication routines. Module Procedures private  subroutine mtx_mult_mtx(transa, transb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: transa A logical flag indicating if the matrix should be transposed. logical, intent(in) :: transb A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine mtx_mult_vec(trans, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:) :: b The vector in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the vector . real(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_mtx(opa, opb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_vec(opa, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:) :: b The vector in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the vector . complex(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\mtx_mult.html"},{"title":"mtx_rank – LINALG","text":"public interface mtx_rank An interface to the matrix rank routines. Module Procedures private  function mtx_rank_dbl(a, tol, work, olwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value integer(kind=int32) The rank of the matrix. private  function mtx_rank_cmplx(a, tol, work, olwork, rwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any\nlocal memory allocation for real-valued workspace arrays.  If not \nprovided, the memory required is allocated within.  If provided, the\nlength of the array must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The rank of the matrix. Return Value integer(kind=int32) The rank of the matrix.","tags":"","loc":"interface\\mtx_rank.html"},{"title":"rank1_update – LINALG","text":"public interface rank1_update An interface to the rank-1 update routines. Module Procedures private  subroutine rank1_update_dbl(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . real(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. real(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. real(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine rank1_update_cmplx(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . complex(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. complex(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\rank1_update.html"},{"title":"recip_mult_array – LINALG","text":"public interface recip_mult_array An interface to the reciprocal multiplication routines. Module Procedures private  subroutine recip_mult_array_dbl(a, x) Computes the product of a scalar and a vector, where the scalar is \nthe reciprocal of the scalar A. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar A, which is the reciprocal of the scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: x On input, the vector to multiply.  On output, the product of the\nvector and the scalar reciprocal.","tags":"","loc":"interface\\recip_mult_array.html"},{"title":"swap – LINALG","text":"public interface swap An interface to the swap routines. Module Procedures private  subroutine swap_dbl(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the \nfirst array are copied to the second array. real(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the \nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine swap_cmplx(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the\nfirst array are copied to the second array. complex(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the\nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\swap.html"},{"title":"trace – LINALG","text":"public interface trace An interface to the trace routines. Module Procedures private pure function trace_dbl(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value real(kind=real64) The trace of the matrix. private pure function trace_cmplx(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value complex(kind=real64) The trace of the matrix.","tags":"","loc":"interface\\trace.html"},{"title":"tri_mtx_mult – LINALG","text":"public interface tri_mtx_mult An interface to the triangular matrix multiplication routines. Module Procedures private  subroutine tri_mtx_mult_dbl(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular \n(TRUE) or lower triangular (FALSE). real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine tri_mtx_mult_cmplx(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular\n(TRUE) or lower triangular (FALSE). complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\tri_mtx_mult.html"},{"title":"cholesky_factor – LINALG","text":"public interface cholesky_factor Module Procedures private  subroutine cholesky_factor_dbl(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine cholesky_factor_cmplx(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\cholesky_factor.html"},{"title":"cholesky_rank1_downdate – LINALG","text":"public interface cholesky_rank1_downdate Module Procedures private  subroutine cholesky_rank1_downdate_dbl(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_downdate_cmplx(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\cholesky_rank1_downdate.html"},{"title":"cholesky_rank1_update – LINALG","text":"public interface cholesky_rank1_update Module Procedures private  subroutine cholesky_rank1_update_dbl(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_update_cmplx(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\cholesky_rank1_update.html"},{"title":"solve_cholesky – LINALG","text":"public interface solve_cholesky Module Procedures private  subroutine solve_cholesky_mtx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_mtx_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private module subroutine solve_cholesky_vec_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\solve_cholesky.html"},{"title":"eigen – LINALG","text":"public interface eigen An interface to the eigenvalue and eigenvector routines. Module Procedures private  subroutine eigen_symm(vecs, a, vals, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is a symmetric matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: vecs Set to true to compute the eigenvectors as well as the eigenvalues; \nelse, set to false to just compute the eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N symmetric matrix on which to operate.  On \noutput, and if vecs is set to true, the matrix will contain the \neigenvectors (one per column) corresponding to each eigenvalue in \nvals.  If vecs is set to false, the lower triangular portion of the \nmatrix is overwritten. real(kind=real64), intent(out), dimension(:) :: vals An N-element array that will contain the eigenvalues sorted into \nascending order. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_asymm(a, vals, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_gen(a, b, alpha, beta, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, by solving\nthe eigenvalue problem: . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: alpha An N-element array that, if beta is not supplied, contains the \neigenvalues.  If beta is supplied however, the eigenvalues must be \ncomputed as .  This however, is not as\ntrivial as it seems as it is entirely possible, and likely, that can overflow or underflow.  With that said, the \nvalues in will always be less than and usually comparable \nwith the NORM( ). real(kind=real64), intent(out), optional, dimension(:) :: beta An optional N-element array that if provided forces alpha to return \nthe numerator, and this array contains the denominator used to \ndetermine the eigenvalues as .  If used,\nthe values in this array will always be less than and usually \ncomparable with the NORM( ). complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_cmplx(a, vals, vecs, work, olwork, rwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 2 * N. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"interface\\eigen.html"},{"title":"form_lu – LINALG","text":"public interface form_lu Module Procedures private  subroutine form_lu_all(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_all_cmplx(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only_cmplx(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_lu.html"},{"title":"lu_factor – LINALG","text":"public interface lu_factor Module Procedures private  subroutine lu_factor_dbl(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine lu_factor_cmplx(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine csr_lu_factor(a, lu, ju, droptol, err) Factors a matrix using an LU decomposition. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix to factor. type( msr_matrix ), intent(out) :: lu The LU matrix. integer(kind=int32), intent(out), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\lu_factor.html"},{"title":"solve_lu – LINALG","text":"public interface solve_lu Module Procedures private  subroutine solve_lu_mtx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_mtx_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine csr_lu_solve(lu, ju, b, x, err) Solves a linear system using an LU decomposition. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: lu The LU matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_lu.html"},{"title":"solve_triangular_system – LINALG","text":"public interface solve_triangular_system Module Procedures private module subroutine solve_tri_mtx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in) :: alpha The scalar multiplier . real(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_mtx_cmplx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in) :: alpha The scalar multiplier . complex(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . real(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec_cmplx(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . complex(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_triangular_system.html"},{"title":"svd – LINALG","text":"public interface svd Module Procedures private module subroutine svd_dbl(a, s, u, vt, work, olwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. real(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). real(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \ntranspose of the N-by-N orthogonal matrix .  The matrix contains the right singular vectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine svd_cmplx(a, s, u, vt, work, olwork, rwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. complex(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). complex(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \nconjugate transpose of the N-by-N orthogonal matrix .  The \nmatrix contains the right singular vectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\svd.html"},{"title":"mult_rz – LINALG","text":"public interface mult_rz Module Procedures private  subroutine mult_rz_mtx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_mtx_cmplx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. real(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec_cmplx(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. complex(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_rz.html"},{"title":"rz_factor – LINALG","text":"public interface rz_factor Module Procedures private  subroutine rz_factor_dbl(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine rz_factor_cmplx(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\rz_factor.html"},{"title":"form_qr – LINALG","text":"public interface form_qr Module Procedures private  subroutine form_qr_no_pivot(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_no_pivot_cmplx(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine form_qr_pivot_cmplx(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\form_qr.html"},{"title":"mult_qr – LINALG","text":"public interface mult_qr Module Procedures private  subroutine mult_qr_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mult_qr.html"},{"title":"qr_factor – LINALG","text":"public interface qr_factor Module Procedures private  subroutine qr_factor_no_pivot(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot(a, tau, jpvt, work, olwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot_cmplx(a, tau, jpvt, work, olwork, rwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local allocate of \nreal-valued memory.  If not provided, the memory required is \nallocated within.  If provided, the length of the array must be at\nleast 2*N. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\qr_factor.html"},{"title":"qr_rank1_update – LINALG","text":"public interface qr_rank1_update Module Procedures private  subroutine qr_rank1_update_dbl(q, r, u, v, work, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . real(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine qr_rank1_update_cmplx(q, r, u, v, work, rwork, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\qr_rank1_update.html"},{"title":"solve_qr – LINALG","text":"public interface solve_qr Module Procedures private  subroutine solve_qr_no_pivot_mtx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_no_pivot_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_pivot_vec(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_pivot_vec_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\solve_qr.html"},{"title":"banded_to_csr – LINALG","text":"public  function banded_to_csr(m, ml, mu, a, err) result(rst) Converts a banded matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the banded matrix. integer(kind=int32), intent(in) :: ml The number of lower diagonals in the banded matrix. integer(kind=int32), intent(in) :: mu The number of upper diagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix.","tags":"","loc":"proc\\banded_to_csr.html"},{"title":"create_csr_matrix – LINALG","text":"public  function create_csr_matrix(m, n, rows, cols, vals, err) result(rst) Creates a CSR matrix from the input data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in), dimension(:) :: rows The row indices. integer(kind=int32), intent(in), dimension(:) :: cols The column indices. real(kind=real64), intent(in), dimension(:) :: vals The values. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix.","tags":"","loc":"proc\\create_csr_matrix.html"},{"title":"create_empty_csr_matrix – LINALG","text":"public  function create_empty_csr_matrix(m, n, nnz, err) result(rst) Creates an empty CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero values in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The empty CSR matrix.","tags":"","loc":"proc\\create_empty_csr_matrix.html"},{"title":"create_empty_msr_matrix – LINALG","text":"public  function create_empty_msr_matrix(m, n, nnz, err) result(rst) Creates an empty MSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero elements in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix.","tags":"","loc":"proc\\create_empty_msr_matrix.html"},{"title":"csr_to_msr – LINALG","text":"public  function csr_to_msr(a, err) result(rst) Converts a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix.","tags":"","loc":"proc\\csr_to_msr.html"},{"title":"dense_to_csr – LINALG","text":"public  function dense_to_csr(a, err) result(rst) Converts a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix.","tags":"","loc":"proc\\dense_to_csr.html"},{"title":"dense_to_msr – LINALG","text":"public  function dense_to_msr(a, err) result(rst) Converts a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix.","tags":"","loc":"proc\\dense_to_msr.html"},{"title":"diag_to_csr – LINALG","text":"public  function diag_to_csr(a, err) result(rst) Converts a diagonal matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix.","tags":"","loc":"proc\\diag_to_csr.html"},{"title":"msr_to_csr – LINALG","text":"public  function msr_to_csr(a, err) result(rst) Converts an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix.","tags":"","loc":"proc\\msr_to_csr.html"},{"title":"csr_to_dense – LINALG","text":"public  subroutine csr_to_dense(a, x, err) Converts a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"proc\\csr_to_dense.html"},{"title":"msr_to_dense – LINALG","text":"public  subroutine msr_to_dense(a, x, err) Converts an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"proc\\msr_to_dense.html"},{"title":"assignment(=) – LINALG","text":"public interface assignment(=) Module Procedures private  subroutine csr_assign_to_dense(dense, sparse) Assigns the values of a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( csr_matrix ), intent(in) :: sparse The CSR matrix. private  subroutine dense_assign_to_csr(sparse, dense) Assigns the values of a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: sparse The CSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine msr_assign_to_dense(dense, msr) Assigns an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. private  subroutine dense_assign_to_msr(msr, dense) Assigns a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine csr_assign_to_msr(msr, csr) Assigns a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. class( csr_matrix ), intent(in) :: csr The CSR matrix. private  subroutine msr_assign_to_csr(csr, msr) Assigns an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: csr The CSR matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix.","tags":"","loc":"interface\\assignment(=).html"},{"title":"matmul – LINALG","text":"public interface matmul Module Procedures private  function csr_mtx_mtx_mult(a, b) result(rst) Multiplies two CSR matrices together. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_vec_mult(a, b) result(rst) Multiplies a CSR matrix by a vector. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in), dimension(:) :: b The vector. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector.","tags":"","loc":"interface\\matmul.html"},{"title":"nonzero_count – LINALG","text":"public interface nonzero_count Module Procedures private pure function nonzero_count_csr(x) result(rst) Returns the number of non-zero values in the matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. Return Value integer(kind=int32) The number of non-zero values in the matrix. private pure function nonzero_count_msr(x) result(rst) Returns the number of non-zero elements in an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. Return Value integer(kind=int32) The number of non-zero elements.","tags":"","loc":"interface\\nonzero_count.html"},{"title":"operator(*) – LINALG","text":"public interface operator(*) Module Procedures private  function csr_mtx_mult_scalar_1(a, b) result(rst) Multiplies a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_mult_scalar_2(a, b) result(rst) Multiplies a scalar by a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar. class( csr_matrix ), intent(in) :: b The CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"operator(+) – LINALG","text":"public interface operator(+) Module Procedures private  function csr_mtx_add(a, b) result(rst) Adds two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(+).html"},{"title":"operator(-) – LINALG","text":"public interface operator(-) Module Procedures private  function csr_mtx_sub(a, b) result(rst) Subtracts two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix.","tags":"","loc":"interface\\operator(-).html"},{"title":"operator(/) – LINALG","text":"public interface operator(/) Module Procedures private  function csr_mtx_divide_scalar_1(a, b) result(rst) Divides a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix )","tags":"","loc":"interface\\operator(SLASH).html"},{"title":"pgmres_solver – LINALG","text":"public interface pgmres_solver Module Procedures private  subroutine csr_pgmres_solver(a, lu, ju, b, x, im, tol, maxits, iout, err) Solves a linear system using the PGMRES method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. class( msr_matrix ), intent(in) :: lu The LU factored matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(inout), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. integer(kind=int32), intent(in), optional :: im The Krylov subspace size. real(kind=real64), intent(in), optional :: tol The convergence tolerance. integer(kind=int32), intent(in), optional :: maxits The maximum number of iterations. integer(kind=int32), intent(in), optional :: iout The output level. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\pgmres_solver.html"},{"title":"size – LINALG","text":"public interface size Module Procedures private pure function csr_size(x, dim) result(rst) Returns the size of the matrix along the specified dimension. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the matrix along the specified dimension. private pure function msr_size(x, dim) result(rst) Returns the size of the specified dimension of an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the specified dimension.","tags":"","loc":"interface\\size.html"},{"title":"sparse_direct_solve – LINALG","text":"public interface sparse_direct_solve Module Procedures private  subroutine csr_solve_sparse_direct(a, b, x, droptol, err) Solves a linear system using a direct method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\sparse_direct_solve.html"},{"title":"transpose – LINALG","text":"public interface transpose Module Procedures private module function csr_transpose(a) result(rst) Transposes a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. Return Value type( csr_matrix ) The transposed CSR matrix.","tags":"","loc":"interface\\transpose.html"},{"title":"mtx_inverse – LINALG","text":"public interface mtx_inverse Module Procedures private  subroutine mtx_inverse_dbl(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_inverse_cmplx(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mtx_inverse.html"},{"title":"mtx_pinverse – LINALG","text":"public interface mtx_pinverse Module Procedures private  subroutine mtx_pinverse_dbl(a, ainv, tol, work, olwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. real(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine mtx_pinverse_cmplx(a, ainv, tol, work, olwork, rwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. complex(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"interface\\mtx_pinverse.html"},{"title":"linalg_sorting – LINALG","text":"Uses iso_fortran_env lapack linalg_errors ferror Interfaces public        interface sort An interface to the sorting routines. private  subroutine sort_dbl_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_dbl_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_cmplx_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_cmplx_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_cmplx(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. complex(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_eigen_dbl(vals, vecs, ascend, err) Sorts eigenvalues and their associated eigenvectors. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: vals On input, an N-element array containing the eigenvalues.  On output,\nthe sored eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: vecs On input, the N-by-N matrix containing the eigenvectors (one vector\nper column) associated with vals.  On output, the sorted eigenvector\nmatrix. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine sort_int32_array(x, ascend) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. private  subroutine sort_int32_array_ind(x, ind, ascend, err) Sorts an array. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: x On input, the array to sort.  On output, the sorted array. integer(kind=int32), intent(inout), dimension(:) :: ind An array, the same size as x, that is sorted along with x.  This is\noften useful as a tracking array. logical, intent(in), optional :: ascend An optional input that, if specified, controls if the array is \nsorted in an ascending order (default), or a descending order. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_sorting.html"},{"title":"linalg_errors – LINALG","text":"Uses iso_fortran_env ferror Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: LA_ARRAY_SIZE_ERROR = 102 An error flag denoting an improperly sized array. integer(kind=int32), public, parameter :: LA_CONVERGENCE_ERROR = 106 An error flag denoting a convergence failure. integer(kind=int32), public, parameter :: LA_INVALID_INPUT_ERROR = 101 An error flag denoting an invalid input. integer(kind=int32), public, parameter :: LA_INVALID_OPERATION_ERROR = 107 An error resulting from an invalid operation. integer(kind=int32), public, parameter :: LA_MATRIX_FORMAT_ERROR = 104 An error flag denoting an issue with the matrix format. integer(kind=int32), public, parameter :: LA_NO_ERROR = 0 An flag denoting no error condition. integer(kind=int32), public, parameter :: LA_OUT_OF_MEMORY_ERROR = 105 An error flag denoting that there is insufficient memory available. integer(kind=int32), public, parameter :: LA_SINGULAR_MATRIX_ERROR = 103 An error flag denoting a singular matrix. Subroutines public  subroutine report_array_size_error (fcn, err, name, expected, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expected The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. public  subroutine report_inner_matrix_dimension_error (fcn, err, name1, name2, expected, actual) Reports an inner matrix dimension error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name1 The name of the first matrix. character(len=*), intent(in) :: name2 The name of the second matrix. integer(kind=int32), intent(in) :: expected The expected inner dimension. integer(kind=int32), intent(in) :: actual The actual inner dimension. public  subroutine report_matrix_size_error (fcn, err, name, expectedRows, expectedCols, actualRows, actualCols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedRows The expected number of rows in the matrix. integer(kind=int32), intent(in) :: expectedCols The expected number of columns in the matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix. public  subroutine report_memory_error (fcn, err, flag) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: flag The error flag. public  subroutine report_singular_matrix_warning (fcn, err, row) Reports a singular matrix error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. integer(kind=int32), intent(in) :: row The row index where the singularity issue was first encountered. public  subroutine report_square_matrix_error (fcn, err, name, expectedSize, actualRows, actualCols) Reports an error where a square matrix was expected but a non-square \nmatrix was provided. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fcn The name of the function that failed. class(errors), intent(inout) :: err The error object to be updated. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expectedSize The expected size of the square matrix. integer(kind=int32), intent(in) :: actualRows The actual number of rows in the matrix. integer(kind=int32), intent(in) :: actualCols The actual number of columns in the matrix.","tags":"","loc":"module\\linalg_errors.html"},{"title":"linalg – LINALG","text":"Uses linalg_inverse linalg_sorting linalg_cholesky linalg_lu linalg_tri linalg_qr linalg_eigen linalg_rz linalg_sparse linalg_lq linalg_least_squares linalg_svd linalg_basic","tags":"","loc":"module\\linalg.html"},{"title":"linalg_lq – LINALG","text":"Uses iso_fortran_env linalg_tri lapack linalg_errors Interfaces public        interface form_lq private  subroutine form_lq_no_pivot(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lq_no_pivot_cmplx(l, tau, q, work, olwork, err) Forms the orthogonal matrix from the elementary reflectors returned \nby the LQ factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: l On input, an M-by-N matrix where the elements above the diagonal \ncontain the elementary reflectors generated from the LQ factorization\nperformed by lq_factor.  On and below the diagonal the matrix \ncontains the matrix .  On output, the elements above the \ndiagonal are zeroed sucht hat the remaining matrix is the M-by-N \nlower trapezoidal matrix where only the M-by-M submatrix is \nthe lower triangular matrix .  Notice, M must be less than or \nequal to N for this routine. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An N-by-N matrix where the orthogonal matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface lq_factor private  subroutine lq_factor_no_pivot(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine lq_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the LQ factorization of an M-by-N matrix where is a lower triangular (or lower trapezoidal) matrix and is\na orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand below the diagonal contain the MIN(M, N)-by-N lower trapezoidal \nmatrix ( is lower triangular if M >= N).  The elements\nabove the diagonal, along with the array tau, represent the \northogonal matrix as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mult_lq private  subroutine mult_lq_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a matrix by the orthogonal matrix from an LQ\nfactorization. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to\ncompute . logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-P matrix containing the elementary reflectors \noutput from the LQ factorization.  If lside is set to true, P = M; \nelse, if lside is set to false, P = N. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix C.  On output, the product of the \northogonal matrix Q and the original matrix C. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . real(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_lq_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector with the orthogonal matrix from an LQ \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to compute ; else, set to false to \ncompute . complex(kind=real64), intent(in), dimension(:,:) :: a On input, an K-by-M matrix containing the elementary reflectors \noutput from the LQ factorization.  Notice, the contents of this \nmatrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in a. complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the product \nof the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_lq private  subroutine solve_lq_mtx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_lq_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, an N-by-NRHS matrix where the first M rows contain \nthe right-hand-side matrix .  On output, the N-by-NRHS solution\nmatrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lq_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of LQ factored equations of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. On output, the contents of this matrix are restored.  Notice, N must\nbe greater than or equal to M. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, an N-element vector where the first M rows contain the \nright-hand-side vector .  On output, the N-element vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_lq.html"},{"title":"linalg_least_squares – LINALG","text":"Uses iso_fortran_env lapack linalg_errors Interfaces public        interface solve_least_squares private  subroutine solve_least_squares_mtx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of \nfull rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_cmplx(a, b, work, olwork, err) Solves the system of equations assuming matrix is of full rank. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, if M is greater than\nor equal to N, the QR factorization of in the form provided\nby qr_factor; else, if M is less than N, the LQ factorization of as returned by lq_factor. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_least_squares_full private  subroutine solve_least_squares_mtx_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full orthogonal\nfactorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt(a, b, ipvt, arnk, work, olwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_vec_pvt_cmplx(a, b, ipvt, arnk, work, olwork, rwork, err) Solves the system of equations using a full \northogonal factorization of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten by its orthogonal factorization. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . integer(kind=int32), intent(inout), optional, target, dimension(:) :: ipvt An optional input that on input, an N-element array that if \nIPVT(I) .ne. 0, the I-th column of A is permuted to the front\nof A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On\noutput, if IPVT(I) = K, then the I-th column of A * P was the K-th\ncolumn of A.  If not supplied, memory is allocated internally, and \nIPVT is set to all zeros such that all columns are treated as free. integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 2 * N. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_least_squares_svd private  subroutine solve_least_squares_mtx_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_least_squares_mtx_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular value\ndecomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:,:) :: b If the system is overdetermined, the M-by-NRHS matrix ; else,\nthe matrix should be sized as N-by-NRHS with the first M rows \ncontaining .  On output, the first N rows will contain the\nsolution matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_least_squares_vec_svd(a, b, s, arnk, work, olwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. real(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_least_squares_vec_svd_cmplx(a, b, s, arnk, work, olwork, rwork, err) Solves the system of equations using a singular \nvalue decomposition of . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix .  On output, the matrix is \noverwritten. complex(kind=real64), intent(inout), dimension(:) :: b If the system is overdetermined, the M-element vector ;\nelse, the array should be sized as N-element with the first M\nelements containing .  On output, the first N rows will\ncontain the solution vector . real(kind=real64), intent(out), optional, target, dimension(:) :: s An optional MIN(M, N)-element array that on output contains the \nsingular values of in descending order.  Notice, the condition\nnumber of can be determined by S(1) / S(MIN(M, N)). integer(kind=int32), intent(out), optional :: arnk An optional output, that if provided, will return the rank of . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_least_squares.html"},{"title":"linalg_basic – LINALG","text":"Uses linalg_errors linalg_sparse blas iso_fortran_env lapack ferror Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: LA_HERMITIAN_TRANSPOSE = 2 Defines a Hermitian transpose operation for a complex-valued matrix. integer(kind=int32), public, parameter :: LA_NO_OPERATION = 0 Defines no operation should be performed on the matrix. integer(kind=int32), public, parameter :: LA_TRANSPOSE = 1 Defines a transpose operation. Interfaces public        interface band_diag_mtx_mult An interface to the banded diagonal matrix multiplication routines. private  subroutine band_diag_mtx_mult_dbl(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. real(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_diag_mtx_mult_cmplx(left, m, kl, ku, alpha, a, b, err) Performs the matrix operation or where is a banded matrix and is a diagonal matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: left A logical flag indicating whether to perform the operation (TRUE) or (FALSE). integer(kind=int32), intent(in) :: m The number of rows in the banded matrix . integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: a The banded matrix to multiply. complex(kind=real64), intent(in), dimension(:) :: b The diagonal matrix to multiply by. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface band_mtx_mult An interface to the banded matrix multiplication routines. private  subroutine band_mtx_vec_mult_dbl(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation or where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating whether to perform the operation (FALSE) or (TRUE). integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. real(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_mtx_vec_mult_cmplx(trans, kl, ku, alpha, a, x, beta, y, err) Performs the matrix operation where is a banded matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: trans An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix . integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix . complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to multiply by. complex(kind=real64), intent(in), dimension(:) :: x The vector to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:) :: y On input, the vector to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface band_mtx_to_full_mtx An interface to the banded matrix to full matrix conversion routines. private  subroutine band_to_full_mtx_dbl(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine band_to_full_mtx_cmplx(kl, ku, b, f, err) Converts a banded matrix to a full matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: kl The number of subdiagonals in the banded matrix. integer(kind=int32), intent(in) :: ku The number of superdiagonals in the banded matrix. complex(kind=real64), intent(in), dimension(:,:) :: b The banded matrix to convert. complex(kind=real64), intent(out), dimension(:,:) :: f The full matrix to store the result in. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface banded_to_dense An interface to the banded to dense matrix conversion routines. private  subroutine banded_to_dense_dbl(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. real(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine banded_to_dense_cmplx(m, kl, ku, a, x, err) Converts a banded matrix to a dense matrix. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The M-by-N dense matrix. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(in), dimension(:,:) :: a The (KL+KU+1)-by-N banded matrix. complex(kind=real64), intent(out), dimension(:,:) :: x The M-by-N dense matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface dense_to_banded An interface to the dense to banded matrix conversion routines. private  subroutine dense_to_banded_dbl(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. real(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine dense_to_banded_cmplx(a, kl, ku, x, err) Converts a banded matrix stored in dense format to a compressed form. The banded matrix is stored in a compressed form supplied column by \ncolumn.  The following code segment transfers between a full matrix\nto the bonded matrix storage scheme.\n\\code{fortran}\ndo j = 1, n\n   k = ku + 1 - j\n   do i = max(1, j - ku), min(n, j + kl)\n      a(k + i, j) = matrix(i, j)\n   end do\nend do\n\\endcode Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The matrix to convert. integer(kind=int32), intent(in) :: kl The number of subdiagonals.  Must be at least 0. integer(kind=int32), intent(in) :: ku The number of superdiagonals.  Must be at least 0. complex(kind=real64), intent(out), dimension(:,:) :: x The (KL+KU+1)-by-N banded matrix. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface det An interface to the determinant routines. private  function det_dbl(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value real(kind=real64) The determinant of the matrix. private  function det_cmplx(a, iwork, err) result(x) Computes the determinant of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the matrix on which to operate.  On output, the LU factored\nmatrix in the form [L\\U] where L is unit lower triangular and U is\nupper triangular.  The unit diagonal elements of L are not stored. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An MIN(M, N)-element array used to track row-pivot operations.  The\narray stored pivot information such that row I is interchanged with \nrow IPVT(I).  If not supplied, this array is allocated within. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value complex(kind=real64) The determinant of the matrix. public        interface diag_mtx_mult An interface to the diagonal matrix multiplication routines. private  subroutine diag_mtx_mult_mtx(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx3(lside, trans, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx4(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_cmplx(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_cmplx(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx_mix(lside, opb, alpha, a, b, beta, c, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_mult_mtx2_mix(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside A logical flag indicating if the diagonal matrix is on the left. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix in the operation. complex(kind=real64), intent(inout), dimension(:,:) :: b The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine diag_mtx_sparse_mult(lside, alpha, a, b, err) Performs the matrix operation or where is a diagonal matrix and is a sparse matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside real(kind=real64), intent(in) :: alpha real(kind=real64), intent(in), dimension(:) :: a class( csr_matrix ), intent(inout) :: b class(errors), intent(inout), optional, target :: err public        interface extract_diagonal An interface to the diagonal extraction routines. private  subroutine extract_diagonal_dbl(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_cmplx(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The M-by-N matrix. complex(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine extract_diagonal_csr(a, diag, err) Extracts the diagonal of a matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The M-by-N matrix. real(kind=real64), intent(out), dimension(:) :: diag The MIN(M, N) element array for the diagonal elements. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface mtx_mult An interface to the matrix multiplication routines. private  subroutine mtx_mult_mtx(transa, transb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: transa A logical flag indicating if the matrix should be transposed. logical, intent(in) :: transb A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the matrix . real(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine mtx_mult_vec(trans, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans A logical flag indicating if the matrix should be transposed. real(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . real(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. real(kind=real64), intent(in), dimension(:) :: b The vector in the operation. real(kind=real64), intent(in) :: beta The scalar to multiply the vector . real(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_mtx(opa, opb, alpha, a, b, beta, c, err) Performs the matrix operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer(kind=int32), intent(in) :: opb An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:,:) :: b The matrix in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the matrix . complex(kind=real64), intent(inout), dimension(:,:) :: c The matrix in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cmtx_mult_vec(opa, alpha, a, b, beta, c, err) Performs the matrix-vector operation . Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: opa An integer flag indicating the operation to perform on matrix .\nPossible options are: LA_NO_OPERATION: No operation is performed on matrix. LA_TRANSPOSE: The transpose of matrix is used. LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex(kind=real64), intent(in) :: alpha The scalar to multiply the product of and . complex(kind=real64), intent(in), dimension(:,:) :: a The matrix in the operation. complex(kind=real64), intent(in), dimension(:) :: b The vector in the operation. complex(kind=real64), intent(in) :: beta The scalar to multiply the vector . complex(kind=real64), intent(inout), dimension(:) :: c The vector in the operation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface mtx_rank An interface to the matrix rank routines. private  function mtx_rank_dbl(a, tol, work, olwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. Return Value integer(kind=int32) The rank of the matrix. private  function mtx_rank_cmplx(a, tol, work, olwork, rwork, err) result(rnk) Computes the rank of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default\ntolerance on singular values such that singular values less than \nthis tolerance are treated as zero.  The default tolerance is:\nMAX(M, N) * EPS * MAX(S).  If the supplied value is less than the\nsmallest value that causes an overflow if inverted, the tolerance\nreverts back to its default value, and the operation continues; \nhowever, a warning message is issued. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local\nmemory allocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  If not provided, the memory required is allocated within. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any\nlocal memory allocation for real-valued workspace arrays.  If not \nprovided, the memory required is allocated within.  If provided, the\nlength of the array must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The rank of the matrix. Return Value integer(kind=int32) The rank of the matrix. public        interface rank1_update An interface to the rank-1 update routines. private  subroutine rank1_update_dbl(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . real(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. real(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. real(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine rank1_update_cmplx(alpha, x, y, a, err) Performs a rank-1 update of a matrix of the form . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: alpha The scalar to multiply the outer product of and . complex(kind=real64), intent(in), dimension(:) :: x The vector in the outer product. complex(kind=real64), intent(in), dimension(:) :: y The vector in the outer product. complex(kind=real64), intent(inout), dimension(:,:) :: a The matrix to update. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface recip_mult_array An interface to the reciprocal multiplication routines. private  subroutine recip_mult_array_dbl(a, x) Computes the product of a scalar and a vector, where the scalar is \nthe reciprocal of the scalar A. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar A, which is the reciprocal of the scalar to multiply by. real(kind=real64), intent(inout), dimension(:) :: x On input, the vector to multiply.  On output, the product of the\nvector and the scalar reciprocal. public        interface swap An interface to the swap routines. private  subroutine swap_dbl(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the \nfirst array are copied to the second array. real(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the \nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine swap_cmplx(x, y, err) Swaps the contents of two arrays. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:) :: x On input, the first array to swap.  On output, the contents of the\nfirst array are copied to the second array. complex(kind=real64), intent(inout), dimension(:) :: y On input, the second array to swap.  On output, the contents of the\nsecond array are copied to the first array. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface trace An interface to the trace routines. private pure function trace_dbl(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value real(kind=real64) The trace of the matrix. private pure function trace_cmplx(x) result(y) Computes the trace of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x The matrix. Return Value complex(kind=real64) The trace of the matrix. public        interface tri_mtx_mult An interface to the triangular matrix multiplication routines. private  subroutine tri_mtx_mult_dbl(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular \n(TRUE) or lower triangular (FALSE). real(kind=real64), intent(in) :: alpha The scalar to multiply by. real(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. real(kind=real64), intent(in) :: beta The scalar to multiply by. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine tri_mtx_mult_cmplx(upper, alpha, a, beta, b, err) Performs the matrix operation or where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper A logical flag indicating whether the matrix A is upper triangular\n(TRUE) or lower triangular (FALSE). complex(kind=real64), intent(in) :: alpha The scalar to multiply by. complex(kind=real64), intent(in), dimension(:,:) :: a The triangular matrix to multiply by. complex(kind=real64), intent(in) :: beta The scalar to multiply by. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the matrix to multiply.  On output, the result of the\noperation. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_basic.html"},{"title":"linalg_cholesky – LINALG","text":"Uses iso_fortran_env qrupdate linalg_errors lapack Interfaces public        interface cholesky_factor private  subroutine cholesky_factor_dbl(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine cholesky_factor_cmplx(a, upper, err) Computes the Cholesky factorization of a symmetric, positive definite\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to factor.  On output, the factored \nmatrix is returned in either the upper or lower triangular portion \nof the matrix, dependent upon the value of upper. logical, intent(in), optional :: upper An optional input that, if specified, provides control over whether\nthe factorization is computed as (set to true), or\nas (set to false).  The default is true such that . class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface cholesky_rank1_downdate private  subroutine cholesky_rank1_downdate_dbl(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_downdate_cmplx(r, u, work, err) Computes the rank 1 downdate to a Cholesky factored matrix such that .  This operation only works if\nthe new matrix is positive definite. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface cholesky_rank1_update private  subroutine cholesky_rank1_update_dbl(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine cholesky_rank1_update_cmplx(r, u, work, err) Computes the rank 1 update to a Cholesky factored matrix such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the N-by-N upper triangular matrix .  On output, the \nupdated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the N-element vector .  On output, the rotation\nsines used to transform to . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least N elements. Additionally, this workspace array is used to contain the rotation \ncosines used to transform to . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. public        interface solve_cholesky private  subroutine solve_cholesky_mtx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_mtx_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS matrix .  On output, the resulting\nN-by-NRHS matrix . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine solve_cholesky_vec(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private module subroutine solve_cholesky_vec_cmplx(upper, a, b, err) Solves the system of Cholesky factored equations or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is factored such that ; else, set\nto false if is factored such that . complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the N-element vector .  On output, the resulting\nN-element vector . class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_cholesky.html"},{"title":"linalg_eigen – LINALG","text":"Uses iso_fortran_env lapack linalg_errors ferror Interfaces public        interface eigen An interface to the eigenvalue and eigenvector routines. private  subroutine eigen_symm(vecs, a, vals, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is a symmetric matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: vecs Set to true to compute the eigenvectors as well as the eigenvalues; \nelse, set to false to just compute the eigenvalues. real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N symmetric matrix on which to operate.  On \noutput, and if vecs is set to true, the matrix will contain the \neigenvectors (one per column) corresponding to each eigenvalue in \nvals.  If vecs is set to false, the lower triangular portion of the \nmatrix is overwritten. real(kind=real64), intent(out), dimension(:) :: vals An N-element array that will contain the eigenvalues sorted into \nascending order. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_asymm(a, vals, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_gen(a, b, alpha, beta, vecs, work, olwork, err) Computes the eigenvalues, and optionally the eigenvectors, by solving\nthe eigenvalue problem: . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-N matrix .  On output, the contents of this \nmatrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: alpha An N-element array that, if beta is not supplied, contains the \neigenvalues.  If beta is supplied however, the eigenvalues must be \ncomputed as .  This however, is not as\ntrivial as it seems as it is entirely possible, and likely, that can overflow or underflow.  With that said, the \nvalues in will always be less than and usually comparable \nwith the NORM( ). real(kind=real64), intent(out), optional, dimension(:) :: beta An optional N-element array that if provided forces alpha to return \nthe numerator, and this array contains the denominator used to \ndetermine the eigenvalues as .  If used,\nthe values in this array will always be less than and usually \ncomparable with the NORM( ). complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. real(kind=real64), intent(out), optional, pointer, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine eigen_cmplx(a, vals, vecs, work, olwork, rwork, err) Computes the eigenvalues, and optionally the eigenvectors, of a matrix\nby solving the eigenvalue problem when is square, but not necessarily symmetric. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix on which to operate.  On output, the \ncontents of this matrix are overwritten. complex(kind=real64), intent(out), dimension(:) :: vals An N-element array containing the eigenvalues of the matrix.  The \neigenvalues are not sorted. complex(kind=real64), intent(out), optional, dimension(:,:) :: vecs An optional N-by-N matrix, that if supplied, signals to compute the \nright eigenvectors (one per column).  If not provided, only the \neigenvalues will be computed. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns without\nperforming any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 2 * N. class(errors), intent(inout), optional, target :: err An error object to report any errors that occur.","tags":"","loc":"module\\linalg_eigen.html"},{"title":"linalg_lu – LINALG","text":"Uses linalg_errors lapack sparskit iso_fortran_env linalg_sparse linalg_basic ferror Interfaces public        interface form_lu private  subroutine form_lu_all(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_all_cmplx(lu, ipvt, u, p, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the row permutation matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. real(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_lu_only_cmplx(lu, u, err) Extracts the L and U matrices from the condensed [L\\U] storage format \nused by the lu_factor. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: lu On input, the N-by-N matrix as output by lu_factor.  On output, the \nN-by-N lower triangular matrix L. complex(kind=real64), intent(out), dimension(:,:) :: u An N-by-N matrix where the U matrix will be written. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface lu_factor private  subroutine lu_factor_dbl(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine lu_factor_cmplx(a, ipvt, err) Computes the LU factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix on which to operate.  On output, the \nLU factored matrix in the form [L\\U] where the unit diagonal\nelements of L are not stored. integer(kind=int32), intent(out), dimension(:) :: ipvt An MIN(M, N)-element array used to track row-pivot operations.  The \narray stored pivot information such that row I is interchanged with \nrow IPVT(I). class(errors), intent(inout), optional, target :: err An error object to report any errors that occur. private  subroutine csr_lu_factor(a, lu, ju, droptol, err) Factors a matrix using an LU decomposition. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix to factor. type( msr_matrix ), intent(out) :: lu The LU matrix. integer(kind=int32), intent(out), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_lu private  subroutine solve_lu_mtx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_mtx_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the N-by-NRHS right-hand-side matrix.  On output, the \nN-by-NRHS solution matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. real(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_lu_vec_cmplx(a, ipvt, b, err) Solves a system of LU-factored equations. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N LU factored matrix as output by lu_factor. integer(kind=int32), intent(in), dimension(:) :: ipvt The N-element pivot array as output by lu_factor. complex(kind=real64), intent(inout), dimension(:) :: b The N-element right-hand-side array. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine csr_lu_solve(lu, ju, b, x, err) Solves a linear system using an LU decomposition. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: lu The LU matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_lu.html"},{"title":"linalg_tri – LINALG","text":"Uses iso_fortran_env blas linalg_errors Interfaces public        interface solve_triangular_system private module subroutine solve_tri_mtx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in) :: alpha The scalar multiplier . real(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_mtx_cmplx(lside, upper, trans, nounit, alpha, a, b, err) Solves a triangular system of equations of the form or where is a \ntriangular matrix (either upper or lower) for the unknown . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to solve ; else, set to false to\nsolve . logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in) :: alpha The scalar multiplier . complex(kind=real64), intent(in), dimension(:,:) :: a If lside is true, the M-by-M triangular matrix ; else, is\nN-by-N if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-N matrix .  On output, the M-by-N solution \nmatrix . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. real(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . real(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_tri_vec_cmplx(upper, trans, nounit, a, x, err) Solves the triangular system where is a triangular matrix. Arguments Type Intent Optional Attributes Name logical, intent(in) :: upper Set to true if is upper triangular; else, set to false if is lower triangular. logical, intent(in) :: trans Set to true if ; else, set to false if . logical, intent(in) :: nounit Set to true if is unit-triangular (ones on the diagonal); else,\nfalse if is not unit-triangular. complex(kind=real64), intent(in), dimension(:,:) :: a The N-by-N triangular matrix . complex(kind=real64), intent(inout), dimension(:) :: x On input, the N-element vector .  On output, the \nN-element solution vector . class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_tri.html"},{"title":"linalg_svd – LINALG","text":"Uses iso_fortran_env lapack linalg_errors Interfaces public        interface svd private module subroutine svd_dbl(a, s, u, vt, work, olwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. real(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). real(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \ntranspose of the N-by-N orthogonal matrix .  The matrix contains the right singular vectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine svd_cmplx(a, s, u, vt, work, olwork, rwork, err) Computes the singular value decomposition of an M-by-N matrix such \nthat where is an M-by-M orthogonal matrix, is an M-by-N diagonal matrix containing the singular values, and is an N-by-N orthogonal matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  The matrix is overwritten on \noutput. real(kind=real64), intent(out), dimension(:) :: s A MIN(M, N)-element array containing the singular values of a sorted \nin descending order. complex(kind=real64), intent(out), optional, dimension(:,:) :: u An optional argument, that if supplied, is used to contain the \northogonal matrix from the decomposition.  The matrix contains the left singular vectors, and can be either M-by-M \n(all left singular vectors are computed), or M-by-MIN(M,N) (only the \nfirst MIN(M, N) left singular vectors are computed). complex(kind=real64), intent(out), optional, dimension(:,:) :: vt An optional argument, that if supplied, is used to contain the \nconjugate transpose of the N-by-N orthogonal matrix .  The \nmatrix contains the right singular vectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the memory \nrequired is allocated within.  If provided, the length of the array \nmust be at least 5 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_svd.html"},{"title":"linalg_rz – LINALG","text":"Uses iso_fortran_env linalg_errors lapack ferror Interfaces public        interface mult_rz private  subroutine mult_rz_mtx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. real(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_mtx_cmplx(lside, trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to compute ; else, set to false to \ncompute . logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors.  If lside is true, ; \nelse, if lside is false, . complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix , where if \nlside is true; else, if lside is false.  The I-th row \nmust contain the Householder vector in the last rows. Notice, \nthe contents of this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A -element array containing the scalar factors of the elementary \nreflectors, where if lside is true; else, if lside is false. complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the -by- matrix .  On output, the product \nof the orthogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. real(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. real(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. real(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_rz_vec_cmplx(trans, l, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix Z from an \nRZ factorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true if ; else, set to false if . integer(kind=int32), intent(in) :: l The number of columns in matrix containing the meaningful part \nof the Householder vectors. complex(kind=real64), intent(inout), dimension(:,:) :: a On input the -by- matrix .  The I-th row must contain \nthe Householder vector in the last rows. Notice, the contents \nof this matrix are restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau An -element array containing the scalar factors of the\nelementary reflectors. complex(kind=real64), intent(inout), dimension(:) :: c On input, the -element array .  On output, the product\nof and . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface rz_factor private  subroutine rz_factor_dbl(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine rz_factor_cmplx(a, tau, work, olwork, err) Factors an upper trapezoidal matrix by means of orthogonal \ntransformations such that . is an orthogonal\nmatrix of dimension N-by-N, and is an M-by-M upper triangular\nmatrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N upper trapezoidal matrix to factor.  On output,\nthe leading M-by-M upper triangular part of the matrix contains the \nupper triangular matrix , and elements N-L+1 to N of the\nfirst M rows of , with the array tau, represent the orthogonal\nmatrix as a product of M elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau An M-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated \nwithin.  If provided, the length of the array must be at least\nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for @p work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_rz.html"},{"title":"linalg_qr – LINALG","text":"Uses qrupdate linalg_errors linalg_rz linalg_tri blas iso_fortran_env lapack ferror Interfaces public        interface form_qr private  subroutine form_qr_no_pivot(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_no_pivot_cmplx(r, tau, q, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine form_qr_pivot(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. real(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . real(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine form_qr_pivot_cmplx(r, tau, pvt, q, p, work, olwork, err) Forms the full M-by-M orthogonal matrix from the elementary\nreflectors returned by the base QR factorization algorithm. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: r On input, an M-by-N matrix where the elements below the diagonal \ncontain the elementary reflectors generated from the QR \nfactorization.  On and above the diagonal, the matrix contains the\nmatrix .  On output, the elements below the diagonal are zeroed \nsuch that the remaining matrix is simply the M-by-N matrix . complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of each \nelementary reflector defined in . integer(kind=int32), intent(in), dimension(:) :: pvt An N-element column pivot array as returned by the QR factorization. complex(kind=real64), intent(out), dimension(:,:) :: q An M-by-M matrix where the full orthogonal matrix will be\nwritten.  In the event that M > N, may be supplied as M-by-N, \nand therefore only return the useful submatrix as the factorization can be written as . complex(kind=real64), intent(out), dimension(:,:) :: p An N-by-N matrix where the pivot matrix will be written. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mult_qr private  subroutine mult_qr_mtx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_mtx_cmplx(lside, trans, a, tau, c, work, olwork, err) Multiplies a general matrix by the orthogonal matrix from a QR\nfactorization such that or . Arguments Type Intent Optional Attributes Name logical, intent(in) :: lside Set to true to apply or from the left; else, set to \nfalse to apply or from the right. logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an LDA-by-K matrix containing the elementary reflectors \noutput from the QR factorization.  If lside is set to true, LDA = M, \nand M >= K >= 0; else, if lside is set to false, LDA = N, and \nN >= K >= 0.  Notice, the contents of this matrix are\nrestored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:,:) :: c On input, the M-by-N matrix .  On output, the product of the \northogonal matrix and the original matrix . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . real(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. real(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . real(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mult_qr_vec_cmplx(trans, a, tau, c, work, olwork, err) Multiplies a vector by the orthogonal matrix from a QR \nfactorization such that . Arguments Type Intent Optional Attributes Name logical, intent(in) :: trans Set to true to apply ; else, set to false to apply . complex(kind=real64), intent(inout), dimension(:,:) :: a On input, an M-by-K matrix containing the elementary reflectors \noutput from the QR factorization. Notice, the contents of this matrix\nare restored on exit. complex(kind=real64), intent(in), dimension(:) :: tau A K-element array containing the scalar factors of each elementary \nreflector defined in . complex(kind=real64), intent(inout), dimension(:) :: c On input, the M-element vector .  On output, the\nproduct of the orthogonal matrix and the original vector . complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface qr_factor private  subroutine qr_factor_no_pivot(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_no_pivot_cmplx(a, tau, work, olwork, err) Computes the QR factorization of an M-by-N matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot(a, tau, jpvt, work, olwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. real(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine qr_factor_pivot_cmplx(a, tau, jpvt, work, olwork, rwork, err) Computes the QR factorization of an M-by-N matrix using column pivoting\nsuch that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to factor.  On output, the elements on \nand above the diagonal contain the MIN(M, N)-by-N upper trapezoidal \nmatrix R (R is upper triangular if M >= N).  The elements below the \ndiagonal, along with the array tau, represent the orthogonal matrix\nQ as a product of elementary reflectors. complex(kind=real64), intent(out), dimension(:) :: tau A MIN(M, N)-element array used to store the scalar factors of the \nelementary reflectors. integer(kind=int32), intent(inout), dimension(:) :: jpvt On input, an N-element array that if JPVT(I) .ne. 0, the I-th column \nof A is permuted to the front of A * P; if JPVT(I) = 0, the I-th \ncolumn of A is a free column.  On output, if JPVT(I) = K, then the \nI-th column of A * P was the K-th column of A. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local allocate of \nreal-valued memory.  If not provided, the memory required is \nallocated within.  If provided, the length of the array must be at\nleast 2*N. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface qr_rank1_update private  subroutine qr_rank1_update_dbl(q, r, u, v, work, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . real(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . real(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine qr_rank1_update_cmplx(q, r, u, v, work, rwork, err) Computes the rank-1 update to an M-by-N QR factored matrix where , , and such that . Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: q On input, the original M-by-K orthogonal matrix .  On output, \nthe updated matrix . complex(kind=real64), intent(inout), dimension(:,:) :: r On input, the M-by-N matrix .  On output, the updated matrix . complex(kind=real64), intent(inout), dimension(:) :: u On input, the M-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(inout), dimension(:) :: v On input, the N-element update vector.  On output, the \noriginal content of the array is overwritten. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional argument that if supplied prevents local memory \nallocation.  If provided, the array must have at least K elements. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface solve_qr private  subroutine solve_qr_no_pivot_mtx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_mtx_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the M-by-NRHS right-hand-side matrix.  On output, the \nfirst N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_no_pivot_vec(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. real(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_no_pivot_vec_cmplx(a, tau, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns.  M must be\ngreater than or equal to N. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored.  Notice, M must\nbe greater than or equal to N. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. complex(kind=real64), intent(inout), dimension(:) :: b On input, the M-element right-hand-side vector.  On output, the first\nN elements are overwritten with the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine solve_qr_pivot_mtx_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:,:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output,\nthe first N rows are overwritten by the solution matrix. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_pivot_vec(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. real(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. real(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine solve_qr_pivot_vec_cmplx(a, tau, jpvt, b, work, olwork, err) Solves a system of M QR-factored equations of N unknowns. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. complex(kind=real64), intent(in), dimension(:) :: tau A MIN(M, N)-element array containing the scalar factors of the \nelementary reflectors as returned by qr_factor. integer(kind=int32), intent(in), dimension(:) :: jpvt An N-element array, as output by qr_factor, used to track the \ncolumn pivots. complex(kind=real64), intent(inout), dimension(:) :: b On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output,\nthe first N rows are overwritten by the solution vector. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_qr.html"},{"title":"linalg_sparse – LINALG","text":"Uses linalg_errors blas sparskit iso_fortran_env ferror Interfaces public        interface assignment(=) private  subroutine csr_assign_to_dense(dense, sparse) Assigns the values of a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( csr_matrix ), intent(in) :: sparse The CSR matrix. private  subroutine dense_assign_to_csr(sparse, dense) Assigns the values of a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: sparse The CSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine msr_assign_to_dense(dense, msr) Assigns an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), dimension(:,:) :: dense The dense matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. private  subroutine dense_assign_to_msr(msr, dense) Assigns a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. real(kind=real64), intent(in), dimension(:,:) :: dense The dense matrix. private  subroutine csr_assign_to_msr(msr, csr) Assigns a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name type( msr_matrix ), intent(out) :: msr The MSR matrix. class( csr_matrix ), intent(in) :: csr The CSR matrix. private  subroutine msr_assign_to_csr(csr, msr) Assigns an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name type( csr_matrix ), intent(out) :: csr The CSR matrix. class( msr_matrix ), intent(in) :: msr The MSR matrix. public        interface matmul private  function csr_mtx_mtx_mult(a, b) result(rst) Multiplies two CSR matrices together. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_vec_mult(a, b) result(rst) Multiplies a CSR matrix by a vector. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in), dimension(:) :: b The vector. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. public        interface nonzero_count private pure function nonzero_count_csr(x) result(rst) Returns the number of non-zero values in the matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. Return Value integer(kind=int32) The number of non-zero values in the matrix. private pure function nonzero_count_msr(x) result(rst) Returns the number of non-zero elements in an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. Return Value integer(kind=int32) The number of non-zero elements. public        interface operator(*) private  function csr_mtx_mult_scalar_1(a, b) result(rst) Multiplies a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) The resulting CSR matrix. private  function csr_mtx_mult_scalar_2(a, b) result(rst) Multiplies a scalar by a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The scalar. class( csr_matrix ), intent(in) :: b The CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(+) private  function csr_mtx_add(a, b) result(rst) Adds two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(-) private  function csr_mtx_sub(a, b) result(rst) Subtracts two CSR matrices. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The first CSR matrix. class( csr_matrix ), intent(in) :: b The second CSR matrix. Return Value type( csr_matrix ) The resulting CSR matrix. public        interface operator(/) private  function csr_mtx_divide_scalar_1(a, b) result(rst) Divides a CSR matrix by a scalar. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. real(kind=real64), intent(in) :: b The scalar. Return Value type( csr_matrix ) public        interface pgmres_solver private  subroutine csr_pgmres_solver(a, lu, ju, b, x, im, tol, maxits, iout, err) Solves a linear system using the PGMRES method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. class( msr_matrix ), intent(in) :: lu The LU factored matrix. integer(kind=int32), intent(in), dimension(:) :: ju The row tracking array. real(kind=real64), intent(inout), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. integer(kind=int32), intent(in), optional :: im The Krylov subspace size. real(kind=real64), intent(in), optional :: tol The convergence tolerance. integer(kind=int32), intent(in), optional :: maxits The maximum number of iterations. integer(kind=int32), intent(in), optional :: iout The output level. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface size private pure function csr_size(x, dim) result(rst) Returns the size of the matrix along the specified dimension. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: x The CSR matrix object. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the matrix along the specified dimension. private pure function msr_size(x, dim) result(rst) Returns the size of the specified dimension of an MSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: x The MSR matrix. integer(kind=int32), intent(in) :: dim The dimension to return the size of. Return Value integer(kind=int32) The size of the specified dimension. public        interface sparse_direct_solve private  subroutine csr_solve_sparse_direct(a, b, x, droptol, err) Solves a linear system using a direct method. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The matrix. real(kind=real64), intent(in), dimension(:) :: b The right-hand side. real(kind=real64), intent(out), dimension(:) :: x The solution. real(kind=real64), intent(in), optional :: droptol The drop tolerance for the ILUT factorization. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface transpose private module function csr_transpose(a) result(rst) Transposes a CSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix. Return Value type( csr_matrix ) The transposed CSR matrix. Derived Types type, public :: csr_matrix A sparse matrix stored in compressed sparse row (CSR) format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: column_indices An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the column indices of each value. integer(kind=int32), public, allocatable, dimension(:) :: row_indices An M+1 element array containing the indices in V an JA at which the\nrequested row starts. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array, where NNZ is the number of non-zero values,\ncontaining the non-zero values of the matrix. Type-Bound Procedures procedure, public :: extract_diagonal => csr_extract_diagonal procedure, public :: get => csr_get_element type, public :: msr_matrix A sparse matrix stored in modified sparse row format. Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable, dimension(:) :: indices An NNZ-element array containing the index information. integer(kind=int32), public :: m = 0 The number of rows in the matrix. integer(kind=int32), public :: n = 0 The number of columns in the matrix. integer(kind=int32), public :: nnz = 0 The number of nonzero values in the matrix. real(kind=real64), public, allocatable, dimension(:) :: values An NNZ-element array containing the non-zero values from the\nmatrix.  The first MIN(M,N) elements contain the diagonal. Functions public  function banded_to_csr (m, ml, mu, a, err) result(rst) Converts a banded matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the banded matrix. integer(kind=int32), intent(in) :: ml The number of lower diagonals in the banded matrix. integer(kind=int32), intent(in) :: mu The number of upper diagonals in the banded matrix. real(kind=real64), intent(in), dimension(:,:) :: a The banded matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function create_csr_matrix (m, n, rows, cols, vals, err) result(rst) Creates a CSR matrix from the input data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in), dimension(:) :: rows The row indices. integer(kind=int32), intent(in), dimension(:) :: cols The column indices. real(kind=real64), intent(in), dimension(:) :: vals The values. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function create_empty_csr_matrix (m, n, nnz, err) result(rst) Creates an empty CSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero values in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The empty CSR matrix. public  function create_empty_msr_matrix (m, n, nnz, err) result(rst) Creates an empty MSR matrix. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: m The number of rows in the matrix. integer(kind=int32), intent(in) :: n The number of columns in the matrix. integer(kind=int32), intent(in) :: nnz The number of non-zero elements in the matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function csr_to_msr (a, err) result(rst) Converts a CSR matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function dense_to_csr (a, err) result(rst) Converts a dense matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function dense_to_msr (a, err) result(rst) Converts a dense matrix to an MSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a The dense matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( msr_matrix ) The MSR matrix. public  function diag_to_csr (a, err) result(rst) Converts a diagonal matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: a The diagonal matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. public  function msr_to_csr (a, err) result(rst) Converts an MSR matrix to a CSR matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. class(errors), intent(inout), optional, target :: err The error object to be updated. Return Value type( csr_matrix ) The CSR matrix. Subroutines public  subroutine csr_to_dense (a, x, err) Converts a CSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( csr_matrix ), intent(in) :: a The CSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated. public  subroutine msr_to_dense (a, x, err) Converts an MSR matrix to a dense matrix. Arguments Type Intent Optional Attributes Name class( msr_matrix ), intent(in) :: a The MSR matrix to convert. real(kind=real64), intent(out), dimension(:,:) :: x The dense matrix. class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_sparse.html"},{"title":"linalg_inverse – LINALG","text":"Uses iso_fortran_env blas lapack linalg_errors Interfaces public        interface mtx_inverse private  subroutine mtx_inverse_dbl(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private  subroutine mtx_inverse_cmplx(a, iwork, work, olwork, err) Computes the inverse of a square matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the N-by-N matrix to invert.  On output, the inverted\nmatrix. integer(kind=int32), intent(out), optional, target, dimension(:) :: iwork An optional N-element integer workspace array. complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. public        interface mtx_pinverse private  subroutine mtx_pinverse_dbl(a, ainv, tol, work, olwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. real(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. class(errors), intent(inout), optional, target :: err The error object to be updated. private module subroutine mtx_pinverse_cmplx(a, ainv, tol, work, olwork, rwork, err) Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the\nsingular value decomposition of the matrix. Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(inout), dimension(:,:) :: a On input, the M-by-N matrix to invert.  The matrix is overwritten \non output. complex(kind=real64), intent(out), dimension(:,:) :: ainv The N-by-M matrix where the pseudo-inverse of will be written. real(kind=real64), intent(in), optional :: tol An optional input, that if supplied, overrides the default tolerance \non singular values such that singular values less than this\ntolerance are forced to have a reciprocal of zero, as opposed to \n1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex(kind=real64), intent(out), optional, target, dimension(:) :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least \nolwork. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size.  If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. real(kind=real64), intent(out), optional, target, dimension(:) :: rwork An optional input, that if provided, prevents any local memory \nallocation for real-valued workspaces.  If not provided, the \nmemory required is allocated within.  If provided, the length of the \narray must be at least 6 * MIN(M, N). class(errors), intent(inout), optional, target :: err The error object to be updated.","tags":"","loc":"module\\linalg_inverse.html"},{"title":"linalg_sorting.f90 – LINALG","text":"Source Code ! linalg_sorting.f90 module linalg_sorting use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use ferror implicit none private public :: sort interface sort !! An interface to the sorting routines. module procedure :: sort_dbl_array module procedure :: sort_dbl_array_ind module procedure :: sort_cmplx_array module procedure :: sort_cmplx_array_ind module procedure :: sort_eigen_cmplx module procedure :: sort_eigen_dbl module procedure :: sort_int32_array module procedure :: sort_int32_array_ind end interface contains ! ****************************************************************************** ! SORTING ROUTINES ! ------------------------------------------------------------------------------ subroutine sort_dbl_array ( x , ascend ) !! Sorts an array. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables character :: id integer ( int32 ) :: n , info ! Initialization if ( present ( ascend )) then if ( ascend ) then id = 'I' else id = 'D' end if else id = 'I' end if n = size ( x ) ! Process call DLASRT ( id , n , x , info ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_dbl_array_ind ( x , ind , ascend , err ) !! Sorts an array. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_dbl_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_dbl_ind ( dir , x , ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_cmplx_array ( x , ascend ) !! Sorts an array. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables logical :: dir ! Initialization if ( present ( ascend )) then dir = ascend else dir = . true . end if ! Process call qsort_cmplx ( dir , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_cmplx_array_ind ( x , ind , ascend , err ) !! Sorts an array. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_cmplx_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_cmplx_ind ( dir , x , ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_eigen_cmplx ( vals , vecs , ascend , err ) !! Sorts eigenvalues and their associated eigenvectors. complex ( real64 ), intent ( inout ), dimension (:) :: vals !! On input, an N-element array containing the eigenvalues.  On output, !! the sored eigenvalues. complex ( real64 ), intent ( inout ), dimension (:,:) :: vecs !! On input, the N-by-N matrix containing the eigenvectors (one vector !! per column) associated with vals.  On output, the sorted eigenvector !! matrix. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , n , flag logical :: dir integer ( int32 ), allocatable , dimension (:) :: ind ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Ensure the eigenvector matrix is sized appropriately n = size ( vals ) if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"sort_eigen_cmplx\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) end if ! Allocate memory for the tracking array allocate ( ind ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"sort_eigen_cmplx\" , errmgr , flag ) return end if do i = 1 , n ind ( i ) = i end do ! Sort call qsort_cmplx_ind ( dir , vals , ind ) ! Shift the eigenvectors around to keep them associated with the ! appropriate eigenvalue vecs = vecs (:, ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_eigen_dbl ( vals , vecs , ascend , err ) !! Sorts eigenvalues and their associated eigenvectors. real ( real64 ), intent ( inout ), dimension (:) :: vals !! On input, an N-element array containing the eigenvalues.  On output, !! the sored eigenvalues. real ( real64 ), intent ( inout ), dimension (:,:) :: vecs !! On input, the N-by-N matrix containing the eigenvectors (one vector !! per column) associated with vals.  On output, the sorted eigenvector !! matrix. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , n , flag logical :: dir integer ( int32 ), allocatable , dimension (:) :: ind ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Ensure the eigenvector matrix is sized appropriately n = size ( vals ) if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"sort_eigen_dbl\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) return end if ! Allocate memory for the tracking array allocate ( ind ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"sort_eigen_dbl\" , errmgr , flag ) return end if do i = 1 , n ind ( i ) = i end do ! Sort call qsort_dbl_ind ( dir , vals , ind ) ! Shift the eigenvectors around to keep them associated with the ! appropriate eigenvalue vecs = vecs (:, ind ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_int32_array ( x , ascend ) !! Sorts an array. integer ( int32 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. ! Local Variables logical :: dir ! Initialization if ( present ( ascend )) then dir = ascend else dir = . true . end if ! Process call qsort_int32 ( dir , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine sort_int32_array_ind ( x , ind , ascend , err ) !! Sorts an array. integer ( int32 ), intent ( inout ), dimension (:) :: x !! On input, the array to sort.  On output, the sorted array. integer ( int32 ), intent ( inout ), dimension (:) :: ind !! An array, the same size as x, that is sorted along with x.  This is !! often useful as a tracking array. logical , intent ( in ), optional :: ascend !! An optional input that, if specified, controls if the array is !! sorted in an ascending order (default), or a descending order. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: n logical :: dir ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ascend )) then dir = ascend else dir = . true . ! Ascend == true end if ! Input Check if ( size ( ind ) /= n ) then call report_array_size_error ( \"sort_int32_array_ind\" , errmgr , \"ind\" , & n , size ( ind )) return end if if ( n <= 1 ) return ! Process call qsort_int32_ind ( dir , x , ind ) end subroutine ! ****************************************************************************** ! PRIVATE HELPER ROUTINES ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_dbl_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend real ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call dbl_partition_ind ( ascend , x , ind , iq ) call qsort_dbl_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_dbl_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine dbl_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend real ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp real ( real64 ) :: temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 recursive subroutine qsort_cmplx ( ascend , x ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call cmplx_partition ( ascend , x , iq ) call qsort_cmplx ( ascend , x (: iq - 1 )) call qsort_cmplx ( ascend , x ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[out] marker The partioning marker. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. subroutine cmplx_partition ( ascend , x , marker ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j complex ( real64 ) :: temp real ( real64 ) :: pivot ! Process pivot = real ( x ( 1 ), real64 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 recursive subroutine qsort_cmplx_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call cmplx_partition_ind ( ascend , x , ind , iq ) call qsort_cmplx_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_cmplx_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Remarks !! As this routine operates on complex valued items, the complex values are !! sorted based upon the real component of the number. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. subroutine cmplx_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend complex ( real64 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp complex ( real64 ) :: temp real ( real64 ) :: pivot ! Process pivot = real ( x ( 1 ), real64 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( real ( x ( j ), real64 ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( real ( x ( i ), real64 ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_int32 ( ascend , x ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call int32_partition ( ascend , x , iq ) call qsort_int32 ( ascend , x (: iq - 1 )) call qsort_int32 ( ascend , x ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine int32_partition ( ascend , x , marker ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A recursive quick sort algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95. recursive subroutine qsort_int32_ind ( ascend , x , ind ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind ! Local Variables integer ( int32 ) :: iq ! Process if ( size ( x ) > 1 ) then call int32_partition_ind ( ascend , x , ind , iq ) call qsort_int32_ind ( ascend , x (: iq - 1 ), ind (: iq - 1 )) call qsort_int32_ind ( ascend , x ( iq :), ind ( iq :)) end if end subroutine ! ------------------------------------------------------------------------------ !> @brief A routine to perform the partioning necessary for the quick sort !! algorithm. !! !! @param[in] ascend Set to true to sort in ascending order; else, false !!  to sort in descending order. !! @param[in,out] x On input, the array to sort.  On output, the sorted !!  array. !! @param[in,out] ind On input, a tracking array of the same length as @p x. !!  On output, the same array, but shuffled to match the sorting order of !!  @p x. !! @param[out] marker The partioning marker. !! !! @par Notes !! This implementation is a slight modification of the code presented at !! http://www.fortran.com/qsort_c.f95 subroutine int32_partition_ind ( ascend , x , ind , marker ) ! Arguments logical , intent ( in ) :: ascend integer ( int32 ), intent ( inout ), dimension (:) :: x integer ( int32 ), intent ( inout ), dimension (:) :: ind integer ( int32 ), intent ( out ) :: marker ! Local Variables integer ( int32 ) :: i , j , itemp , temp , pivot ! Process pivot = x ( 1 ) i = 0 j = size ( x ) + 1 if ( ascend ) then ! Ascending Sort do j = j - 1 do if ( x ( j ) <= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) >= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do else ! Descending Sort do j = j - 1 do if ( x ( j ) >= pivot ) exit j = j - 1 end do i = i + 1 do if ( x ( i ) <= pivot ) exit i = i + 1 end do if ( i < j ) then ! Exchage X(I) and X(J) temp = x ( i ) x ( i ) = x ( j ) x ( j ) = temp itemp = ind ( i ) ind ( i ) = ind ( j ) ind ( j ) = itemp else if ( i == j ) then marker = i + 1 return else marker = i return end if end do end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_sorting.f90.html"},{"title":"linalg_errors.f90 – LINALG","text":"Source Code module linalg_errors use iso_fortran_env use ferror implicit none integer ( int32 ), parameter :: LA_NO_ERROR = 0 !! An flag denoting no error condition. integer ( int32 ), parameter :: LA_INVALID_INPUT_ERROR = 101 !! An error flag denoting an invalid input. integer ( int32 ), parameter :: LA_ARRAY_SIZE_ERROR = 102 !! An error flag denoting an improperly sized array. integer ( int32 ), parameter :: LA_SINGULAR_MATRIX_ERROR = 103 !! An error flag denoting a singular matrix. integer ( int32 ), parameter :: LA_MATRIX_FORMAT_ERROR = 104 !! An error flag denoting an issue with the matrix format. integer ( int32 ), parameter :: LA_OUT_OF_MEMORY_ERROR = 105 !! An error flag denoting that there is insufficient memory available. integer ( int32 ), parameter :: LA_CONVERGENCE_ERROR = 106 !! An error flag denoting a convergence failure. integer ( int32 ), parameter :: LA_INVALID_OPERATION_ERROR = 107 !! An error resulting from an invalid operation. contains subroutine report_memory_error ( fcn , err , flag ) !! Reports a memory allocation error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. integer ( int32 ), intent ( in ) :: flag !! The error flag. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Memory allocation failed in \" , fcn , & \" with code \" , flag , \".\" call err % report_error ( fcn , trim ( msg ), LA_OUT_OF_MEMORY_ERROR ) ! Formatting 100 format ( A , A , A , I0 , A ) end subroutine subroutine report_array_size_error ( fcn , err , name , expected , actual ) !! Reports an array size error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the array. integer ( int32 ), intent ( in ) :: expected !! The expected size of the array. integer ( int32 ), intent ( in ) :: actual !! The actual size of the array. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected array size of \" , expected , & \" but received \" , actual , \" in \" , fcn , \"for array \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_matrix_size_error ( fcn , err , name , expectedRows , & expectedCols , actualRows , actualCols ) !! Reports a matrix size error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the matrix. integer ( int32 ), intent ( in ) :: expectedRows !! The expected number of rows in the matrix. integer ( int32 ), intent ( in ) :: expectedCols !! The expected number of columns in the matrix. integer ( int32 ), intent ( in ) :: actualRows !! The actual number of rows in the matrix. integer ( int32 ), intent ( in ) :: actualCols !! The actual number of columns in the matrix. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected matrix size of \" , expectedRows , \" x \" , & expectedCols , \" but received \" , actualRows , \" x \" , actualCols , & \" in \" , fcn , \"for matrix \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_inner_matrix_dimension_error ( fcn , err , name1 , name2 , & expected , actual ) !! Reports an inner matrix dimension error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name1 !! The name of the first matrix. character ( len =* ), intent ( in ) :: name2 !! The name of the second matrix. integer ( int32 ), intent ( in ) :: expected !! The expected inner dimension. integer ( int32 ), intent ( in ) :: actual !! The actual inner dimension. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected inner matrix dimension of \" , expected , & \" but received \" , actual , \" in \" , fcn , \"for matrices \" , name1 , & \" and \" , name2 , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_square_matrix_error ( fcn , err , name , expectedSize , & actualRows , actualCols ) !! Reports an error where a square matrix was expected but a non-square !! matrix was provided. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. character ( len =* ), intent ( in ) :: name !! The name of the matrix. integer ( int32 ), intent ( in ) :: expectedSize !! The expected size of the square matrix. integer ( int32 ), intent ( in ) :: actualRows !! The actual number of rows in the matrix. integer ( int32 ), intent ( in ) :: actualCols !! The actual number of columns in the matrix. ! Local Variables character ( len = 256 ) :: msg ! Construct the error message write ( msg , 100 ) \"Expected square matrix of size \" , expectedSize , & \" but received \" , actualRows , \" x \" , actualCols , \" in \" , fcn , & \"for matrix \" , name , \" .\" call err % report_error ( fcn , trim ( msg ), LA_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A , A , A , A , A ) end subroutine subroutine report_singular_matrix_warning ( fcn , err , row ) !! Reports a singular matrix error. character ( len =* ), intent ( in ) :: fcn !! The name of the function that failed. class ( errors ), intent ( inout ) :: err !! The error object to be updated. integer ( int32 ), intent ( in ) :: row !! The row index where the singularity issue was first encountered. ! Local Variables character ( len = 256 ) :: msg ! Write the error message write ( msg , 100 ) & \"A singular matrix was encountered with the issue found at row \" , & row , \" of the matrix.\" call err % report_warning ( fcn , trim ( msg ), LA_SINGULAR_MATRIX_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine end module","tags":"","loc":"sourcefile\\linalg_errors.f90.html"},{"title":"linalg.f90 – LINALG","text":"Source Code ! linalg.f90 module linalg use linalg_sparse use linalg_basic use linalg_sorting use linalg_eigen use linalg_lu use linalg_rz use linalg_qr use linalg_tri use linalg_cholesky use linalg_lq use linalg_svd use linalg_inverse use linalg_least_squares implicit none private ! LINALG_BASIC.F90 public :: LA_NO_OPERATION public :: LA_TRANSPOSE public :: LA_HERMITIAN_TRANSPOSE public :: mtx_mult public :: rank1_update public :: diag_mtx_mult public :: trace public :: mtx_rank public :: det public :: swap public :: recip_mult_array public :: tri_mtx_mult public :: band_mtx_mult public :: band_mtx_to_full_mtx public :: band_diag_mtx_mult public :: banded_to_dense public :: dense_to_banded public :: extract_diagonal ! LINALG_SPARSE.F90 public :: csr_matrix public :: msr_matrix public :: size public :: create_empty_csr_matrix public :: create_empty_msr_matrix public :: nonzero_count public :: dense_to_csr public :: diag_to_csr public :: banded_to_csr public :: csr_to_dense public :: csr_to_msr public :: msr_to_csr public :: dense_to_msr public :: msr_to_dense public :: create_csr_matrix public :: matmul public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) public :: operator ( / ) public :: assignment ( = ) public :: transpose public :: sparse_direct_solve public :: pgmres_solver ! LINALG_SORTING.F90 public :: sort ! LINALG_EIGEN.F90 public :: eigen ! LINALG_LU.F90 public :: lu_factor public :: form_lu public :: solve_lu ! LINALG_RZ.F90 public :: rz_factor public :: mult_rz ! LINALG_QR.F90 public :: qr_factor public :: form_qr public :: mult_qr public :: qr_rank1_update public :: solve_qr ! LINALG_TRI.F90 public :: solve_triangular_system ! LINALG_CHOLESKY.F90 public :: cholesky_factor public :: cholesky_rank1_update public :: cholesky_rank1_downdate public :: solve_cholesky ! LINALG_LQ.F90 public :: lq_factor public :: form_lq public :: mult_lq public :: solve_lq ! LINALG_SVD.F90 public :: svd ! LINALG_INVERSE.F90 public :: mtx_inverse public :: mtx_pinverse ! LINALG_LEAST_SQUARES.F90 public :: solve_least_squares public :: solve_least_squares_full public :: solve_least_squares_svd end module","tags":"","loc":"sourcefile\\linalg.f90.html"},{"title":"linalg_lq.f90 – LINALG","text":"Source Code module linalg_lq use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use linalg_tri implicit none private public :: lq_factor public :: form_lq public :: mult_lq public :: solve_lq interface lq_factor module procedure :: lq_factor_no_pivot module procedure :: lq_factor_no_pivot_cmplx end interface interface form_lq module procedure :: form_lq_no_pivot module procedure :: form_lq_no_pivot_cmplx end interface interface mult_lq module procedure :: mult_lq_mtx module procedure :: mult_lq_mtx_cmplx module procedure :: mult_lq_vec module procedure :: mult_lq_vec_cmplx end interface interface solve_lq module procedure :: solve_lq_mtx module procedure :: solve_lq_mtx_cmplx module procedure :: solve_lq_vec module procedure :: solve_lq_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine lq_factor_no_pivot ( a , tau , work , olwork , err ) !! Computes the LQ factorization of an M-by-N matrix A = L Q where !! L is a lower triangular (or lower trapezoidal) matrix and Q is !! a orthogonal matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and below the diagonal contain the MIN(M, N)-by-N lower trapezoidal !! matrix L (L is lower triangular if M >= N).  The elements !! above the diagonal, along with the array tau, represent the !! orthogonal matrix Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"lq_factor_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return end if ! Workspace Query call DGELQF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"lq_factor_no_pivot\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"lq_factor_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGELQF call DGELQF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine lq_factor_no_pivot_cmplx ( a , tau , work , olwork , err ) !! Computes the LQ factorization of an M-by-N matrix A = L Q where !! L is a lower triangular (or lower trapezoidal) matrix and Q is !! a orthogonal matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and below the diagonal contain the MIN(M, N)-by-N lower trapezoidal !! matrix L (L is lower triangular if M >= N).  The elements !! above the diagonal, along with the array tau, represent the !! orthogonal matrix Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return end if ! Workspace Query call ZGELQF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"lq_factor_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGELQF call ZGELQF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_lq_no_pivot ( l , tau , q , work , olwork , err ) !! Forms the orthogonal matrix Q from the elementary reflectors returned !! by the LQ factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: l !! On input, an M-by-N matrix where the elements above the diagonal !! contain the elementary reflectors generated from the LQ factorization !! performed by lq_factor.  On and below the diagonal the matrix !! contains the matrix L.  On output, the elements above the !! diagonal are zeroed sucht hat the remaining matrix is the M-by-N !! lower trapezoidal matrix L where only the M-by-M submatrix is !! the lower triangular matrix L.  Notice, M must be less than or !! equal to N for this routine. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in L. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An N-by-N matrix where the orthogonal matrix Q will be written. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , m , n , mn , k , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( l , 1 ) n = size ( l , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"form_lq_no_pivot\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_lq_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= n . or . size ( q , 2 ) /= n ) then call report_matrix_size_error ( \"form_lq_no_pivot\" , errmgr , \"q\" , & n , n , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call DORGLQ ( n , n , mn , q , n , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_lq_no_pivot\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_lq_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the upper triangular portion of L to Q, and then zero it out in L do j = 2 , n k = min ( j - 1 , m ) q ( 1 : k , j ) = l ( 1 : k , j ) l ( 1 : k , j ) = zero end do ! Build Q call DORGLQ ( n , n , mn , q , n , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_lq_no_pivot_cmplx ( l , tau , q , work , olwork , err ) !! Forms the orthogonal matrix Q from the elementary reflectors returned !! by the LQ factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: l !! On input, an M-by-N matrix where the elements above the diagonal !! contain the elementary reflectors generated from the LQ factorization !! performed by lq_factor.  On and below the diagonal the matrix !! contains the matrix L.  On output, the elements above the !! diagonal are zeroed sucht hat the remaining matrix is the M-by-N !! lower trapezoidal matrix L where only the M-by-M submatrix is !! the lower triangular matrix L.  Notice, M must be less than or !! equal to N for this routine. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in L. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An N-by-N matrix where the orthogonal matrix Q will be written. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , m , n , mn , k , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( l , 1 ) n = size ( l , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"form_lq_no_pivot_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= n . or . size ( q , 2 ) /= n ) then call report_matrix_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , \"q\" , & n , n , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call ZUNGLQ ( n , n , mn , q , n , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_lq_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_lq_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the upper triangular portion of L to Q, and then zero it out in L do j = 2 , n k = min ( j - 1 , m ) q ( 1 : k , j ) = l ( 1 : k , j ) l ( 1 : k , j ) = zero end do ! Build Q call ZUNGLQ ( n , n , mn , q , n , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_mtx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a matrix by the orthogonal matrix Q from an LQ !! factorization. logical , intent ( in ) :: lside !! Set to true to compute C = op(Q) C; else, set to false to !! compute C = C op(Q). logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;T; else, set to false to !! compute op(Q) = Q. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-P matrix containing the elementary reflectors !! output from the LQ factorization.  If lside is set to true, P = M; !! else, if lside is set to false, P = N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , ncola , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' ncola = m else side = 'R' ncola = n end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= ncola ) then call report_matrix_size_error ( \"mult_lq_mtx\" , errmgr , \"a\" , k , ncola , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_mtx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMLQ call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_mtx_cmplx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a matrix by the orthogonal matrix Q from an LQ !! factorization. logical , intent ( in ) :: lside !! Set to true to compute C = op(Q) C; else, set to false to !! compute C = C op(Q). logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;H; else, set to false to !! compute op(Q) = Q. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-P matrix containing the elementary reflectors !! output from the LQ factorization.  If lside is set to true, P = M; !! else, if lside is set to false, P = N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , ncola , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' ncola = m else side = 'R' ncola = n end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= ncola ) then call report_matrix_size_error ( \"mult_lq_mtx_cmplx\" , errmgr , \"a\" , k , & ncola , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMLQ call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_vec ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector with the orthogonal matrix Q from an LQ !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;T; else, set to false to !! compute op(Q) = Q. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-M matrix containing the elementary reflectors !! output from the LQ factorization.  Notice, the contents of this !! matrix are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the product !! of the orthogonal matrix Q and the original vector \\vec{c}. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) n = 1 k = size ( tau ) side = 'L' if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= m ) then call report_matrix_size_error ( \"mult_lq_vec\" , errmgr , \"a\" , k , m , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMLQ call DORMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_lq_vec_cmplx ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector with the orthogonal matrix Q from an LQ !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to compute op(Q) = Q&#94;H; else, set to false to !! compute op(Q) = Q. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, an K-by-M matrix containing the elementary reflectors !! output from the LQ factorization.  Notice, the contents of this !! matrix are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined in a. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the product !! of the orthogonal matrix Q and the original vector \\vec{c}. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) n = 1 k = size ( tau ) side = 'L' if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= k . or . size ( a , 2 ) /= m ) then call report_matrix_size_error ( \"mult_lq_vec_cmplx\" , errmgr , \"a\" , k , m , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_lq_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_lq_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMLQ call ZUNMLQ ( side , t , m , n , k , a , k , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_mtx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form A X = L Q X = B. real ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, an N-by-NRHS matrix where the first M rows contain !! the right-hand-side matrix B.  On output, the N-by-NRHS solution !! matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_mtx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_mtx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lq_mtx\" , errmgr , \"b\" , n , nrhs , & size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_lq (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_mtx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. true ., . false ., . false ., . true ., one , & a ( 1 : m , 1 : m ), b ( 1 : m ,:), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., . true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_lq_mtx_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form A X = L Q X = B. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, an N-by-NRHS matrix where the first M rows contain !! the right-hand-side matrix B.  On output, the N-by-NRHS solution !! matrix X. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_mtx_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"b\" , n , & nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_lq (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. true ., . false ., . false ., . true ., one , & a ( 1 : m , 1 : m ), b ( 1 : m ,:), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., . true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_vec ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form !! A \\vec{x} = L Q \\vec{x} = \\vec{b}. real ( real64 ), intent ( in ), dimension (:,:) :: a !! !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, an N-element vector where the first M rows contain the !! right-hand-side vector \\vec{b}.  On output, the N-element vector !! \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_vec\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_vec\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b ) /= n ) then call report_memory_error ( \"solve_lq_vec\" , errmgr , istat ) return end if ! Workspace Query call mult_lq (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. false ., . false ., . true ., a ( 1 : m , 1 : m ), & b ( 1 : m ), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lq_vec_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of LQ factored equations of the form !! A \\vec{x} = L Q \\vec{x} = \\vec{b}. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! !! On input, the M-by-N LQ factored matrix as returned by lq_factor. !! On output, the contents of this matrix are restored.  Notice, N must !! be greater than or equal to M. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, an N-element vector where the first M rows contain the !! right-hand-side vector \\vec{b}.  On output, the N-element vector !! \\vec{x}. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m > n ) then call errmgr % report_error ( \"solve_lq_vec_cmplx\" , & \"This routine does not handle the overdetermined case.\" , & LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_lq_vec_cmplx\" , errmgr , \"tau\" , k , & size ( tau )) return else if ( size ( b ) /= n ) then call report_memory_error ( \"solve_lq_vec_cmplx\" , errmgr , istat ) return end if ! Workspace Query call mult_lq (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_lq_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_lq_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Solve the lower triangular system L * Y = B for Y, where Y = Q * X. ! The lower triangular system is M-by-M and Y is M-by-NHRS. call solve_triangular_system (. false ., . false ., . true ., a ( 1 : m , 1 : m ), & b ( 1 : m ), errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute Q**T * Y = X call mult_lq (. true ., a , tau , b , work = wptr , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_lq.f90.html"},{"title":"linalg_least_squares.f90 – LINALG","text":"Source Code module linalg_least_squares use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors implicit none private public :: solve_least_squares public :: solve_least_squares_full public :: solve_least_squares_svd interface solve_least_squares module procedure :: solve_least_squares_mtx module procedure :: solve_least_squares_mtx_cmplx module procedure :: solve_least_squares_vec module procedure :: solve_least_squares_vec_cmplx end interface interface solve_least_squares_full module procedure :: solve_least_squares_mtx_pvt module procedure :: solve_least_squares_mtx_pvt_cmplx module procedure :: solve_least_squares_vec_pvt module procedure :: solve_least_squares_vec_pvt_cmplx end interface interface solve_least_squares_svd module procedure :: solve_least_squares_mtx_svd module procedure :: solve_least_squares_mtx_svd_cmplx module procedure :: solve_least_squares_vec_svd module procedure :: solve_least_squares_vec_svd_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx ( a , b , work , olwork , err ) !! Solves the system of equations A X = B assuming matrix A is of !! full rank. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_cmplx ( a , b , work , olwork , err ) !! Solves the system of equations A X = B assuming matrix A is of !! full rank. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZGELS ( 'N' , m , n , nrhs , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_cmplx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec ( a , b , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} assuming matrix !! A is of full rank. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call DGELS ( 'N' , m , n , 1 , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DGELS ( 'N' , m , n , 1 , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_cmplx ( a , b , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} assuming matrix !! A is of full rank. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, if M is greater than !! or equal to N, the QR factorization of A in the form provided !! by qr_factor; else, if M is less than N, the LQ factorization of !! A as returned by lq_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_cmplx\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELS ( 'N' , m , n , 1 , a , m , b , maxmn , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZGELS ( 'N' , m , n , 1 , a , m , b , maxmn , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_cmplx\" , & \"The supplied matrix is not of full rank; therefore, \" // & \"the solution could not be computed via this routine.  \" // & \"Try a routine that utilizes column pivoting.\" , & LA_INVALID_OPERATION_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_pvt ( a , b , ipvt , arnk , work , olwork , err ) !! Solves the system of equations A X = B using a full orthogonal !! factorization of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag , rnk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr real ( real64 ), dimension ( 1 ) :: temp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELSY ( m , n , nrhs , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSY ( m , n , nrhs , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_pvt_cmplx ( a , b , ipvt , arnk , & work , olwork , rwork , err ) !! Solves the system of equations A X = B using a full orthogonal !! factorization of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 2 * N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , nrhs , lwork , istat , flag , rnk , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) lrwork = 2 * n rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELSY ( m , n , nrhs , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_pvt_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSY ( m , n , nrhs , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_pvt ( a , b , ipvt , arnk , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a full !! orthogonal factorization of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , istat , flag , rnk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr real ( real64 ), dimension ( 1 ) :: temp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call DGELSY ( m , n , 1 , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt\" , errmgr , & istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSY ( m , n , 1 , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_vec_pvt_cmplx ( a , b , ipvt , arnk , & work , olwork , rwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a full !! orthogonal factorization of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten by its orthogonal factorization. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. integer ( int32 ), intent ( inout ), target , optional , dimension (:) :: ipvt !! An optional input that on input, an N-element array that if !! IPVT(I) .ne. 0, the I-th column of A is permuted to the front !! of A * P; if IPVT(I) = 0, the I-th column of A is a free column.  On !! output, if IPVT(I) = K, then the I-th column of A * P was the K-th !! column of A.  If not supplied, memory is allocated internally, and !! IPVT is set to all zeros such that all columns are treated as free. integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 2 * N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , maxmn , lwork , lrwork , istat , flag , rnk complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk integer ( int32 ), allocatable , target , dimension (:) :: iwrk integer ( int32 ), pointer , dimension (:) :: iptr complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp integer ( int32 ), dimension ( 1 ) :: itemp real ( real64 ) :: rc class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) maxmn = max ( m , n ) lrwork = 2 * n rc = epsilon ( rc ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELSY ( m , n , 1 , a , m , b , maxmn , itemp , rc , rnk , temp , - 1 , rtemp , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( ipvt )) then if ( size ( ipvt ) < n ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"ipvt\" , n , size ( ipvt )) return end if iptr => ipvt ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if iptr => iwrk iptr = 0 end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_pvt_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSY ( m , n , 1 , a , m , b , maxmn , iptr , rc , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_svd ( a , b , s , arnk , work , olwork , err ) !! Solves the system of equations A X = B using a singular value !! decomposition of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , nrhs , mn , maxmn , istat , flag , lwork , rnk real ( real64 ), pointer , dimension (:) :: wptr , sptr real ( real64 ), allocatable , target , dimension (:) :: wrk , sing real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_svd\" , errmgr , & \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call DGELSS ( m , n , nrhs , a , m , b , maxmn , temp , rcond , rnk , temp , - 1 , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_mtx_svd\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd\" , errmgr , & istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSS ( m , n , nrhs , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_svd\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_least_squares_mtx_svd_cmplx ( a , b , s , arnk , work , & olwork , rwork , err ) !! Solves the system of equations A X = B using a singular value !! decomposition of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! If the system is overdetermined, the M-by-NRHS matrix B; else, !! the matrix should be sized as N-by-NRHS with the first M rows !! containing B.  On output, the first N rows will contain the !! solution matrix X. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , nrhs , mn , maxmn , istat , flag , lwork , rnk , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr , sptr real ( real64 ), allocatable , target , dimension (:) :: rwrk , sing complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) mn = min ( m , n ) lrwork = 5 * mn maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"b\" , maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call ZGELSS ( m , n , nrhs , a , m , b , maxmn , rtemp , rcond , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_mtx_svd_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSS ( m , n , nrhs , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_mtx_svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_least_squares_vec_svd ( a , b , s , arnk , work , olwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a singular !! value decomposition of A. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. real ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , maxmn , istat , flag , lwork , rnk real ( real64 ), pointer , dimension (:) :: wptr , sptr real ( real64 ), allocatable , target , dimension (:) :: wrk , sing real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , errmgr , & \"b\" , maxmn , size ( b )) return end if ! Workspace Query call DGELSS ( m , n , 1 , a , m , b , maxmn , temp , rcond , rnk , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd\" , errmgr , & istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DGELSS ( m , n , 1 , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec_svd\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_least_squares_vec_svd_cmplx ( a , b , s , arnk , work , & olwork , rwork , err ) !! Solves the system of equations A \\vec{x} = \\vec{b} using a singular !! value decomposition of A. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix A.  On output, the matrix is !! overwritten. complex ( real64 ), intent ( inout ), dimension (:) :: b !! If the system is overdetermined, the M-element vector \\vec{b}; !! else, the array should be sized as N-element with the first M !! elements containing \\vec{b}.  On output, the first N rows will !! contain the solution vector \\vec{x}. real ( real64 ), intent ( out ), target , optional , dimension (:) :: s !! An optional MIN(M, N)-element array that on output contains the !! singular values of A in descending order.  Notice, the condition !! number of A can be determined by S(1) / S(MIN(M, N)). integer ( int32 ), intent ( out ), optional :: arnk !! An optional output, that if provided, will return the rank of A. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , maxmn , istat , flag , lwork , rnk , lrwork real ( real64 ), pointer , dimension (:) :: rwptr , sptr real ( real64 ), allocatable , target , dimension (:) :: rwrk , sing complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ) :: rcond class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 5 * mn maxmn = max ( m , n ) rcond = epsilon ( rcond ) if ( present ( arnk )) arnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"b\" , maxmn , size ( b )) return end if ! Workspace Query call ZGELSS ( m , n , 1 , a , m , b , maxmn , rtemp , rcond , rnk , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( s )) then if ( size ( s ) < mn ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"s\" , mn , size ( s )) return end if sptr => s ( 1 : mn ) else allocate ( sing ( mn ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if sptr => sing end if if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_least_squares_vec_svd_cmplx\" , & errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZGELSS ( m , n , 1 , a , m , b , maxmn , sptr , rcond , rnk , wptr , lwork , & rwptr , flag ) if ( present ( arnk )) arnk = rnk if ( flag > 0 ) then call errmgr % report_error ( \"solve_least_squares_vec_svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_least_squares.f90.html"},{"title":"linalg_basic.f90 – LINALG","text":"Source Code ! linalg_basic.f90 module linalg_basic use iso_fortran_env , only : int32 , real64 use blas use lapack use linalg_sparse use linalg_errors use ferror implicit none private public :: LA_NO_OPERATION public :: LA_TRANSPOSE public :: LA_HERMITIAN_TRANSPOSE public :: mtx_mult public :: rank1_update public :: diag_mtx_mult public :: trace public :: mtx_rank public :: det public :: swap public :: recip_mult_array public :: tri_mtx_mult public :: band_mtx_mult public :: band_mtx_to_full_mtx public :: band_diag_mtx_mult public :: banded_to_dense public :: dense_to_banded public :: extract_diagonal integer ( int32 ), parameter :: LA_NO_OPERATION = 0 !! Defines no operation should be performed on the matrix. integer ( int32 ), parameter :: LA_TRANSPOSE = 1 !! Defines a transpose operation. integer ( int32 ), parameter :: LA_HERMITIAN_TRANSPOSE = 2 !! Defines a Hermitian transpose operation for a complex-valued matrix. interface mtx_mult !! An interface to the matrix multiplication routines. module procedure :: mtx_mult_mtx module procedure :: mtx_mult_vec module procedure :: cmtx_mult_mtx module procedure :: cmtx_mult_vec end interface interface rank1_update !! An interface to the rank-1 update routines. module procedure :: rank1_update_dbl module procedure :: rank1_update_cmplx end interface interface diag_mtx_mult !! An interface to the diagonal matrix multiplication routines. module procedure :: diag_mtx_mult_mtx module procedure :: diag_mtx_mult_mtx2 module procedure :: diag_mtx_mult_mtx3 module procedure :: diag_mtx_mult_mtx4 module procedure :: diag_mtx_mult_mtx_cmplx module procedure :: diag_mtx_mult_mtx2_cmplx module procedure :: diag_mtx_mult_mtx_mix module procedure :: diag_mtx_mult_mtx2_mix module procedure :: diag_mtx_sparse_mult end interface interface trace !! An interface to the trace routines. module procedure :: trace_dbl module procedure :: trace_cmplx end interface interface mtx_rank !! An interface to the matrix rank routines. module procedure :: mtx_rank_dbl module procedure :: mtx_rank_cmplx end interface interface det !! An interface to the determinant routines. module procedure :: det_dbl module procedure :: det_cmplx end interface interface swap !! An interface to the swap routines. module procedure :: swap_dbl module procedure :: swap_cmplx end interface interface recip_mult_array !! An interface to the reciprocal multiplication routines. module procedure :: recip_mult_array_dbl end interface interface tri_mtx_mult !! An interface to the triangular matrix multiplication routines. module procedure :: tri_mtx_mult_dbl module procedure :: tri_mtx_mult_cmplx end interface interface band_mtx_mult !! An interface to the banded matrix multiplication routines. module procedure :: band_mtx_vec_mult_dbl module procedure :: band_mtx_vec_mult_cmplx end interface interface band_mtx_to_full_mtx !! An interface to the banded matrix to full matrix conversion routines. module procedure :: band_to_full_mtx_dbl module procedure :: band_to_full_mtx_cmplx end interface interface band_diag_mtx_mult !! An interface to the banded diagonal matrix multiplication routines. module procedure :: band_diag_mtx_mult_dbl module procedure :: band_diag_mtx_mult_cmplx end interface interface banded_to_dense !! An interface to the banded to dense matrix conversion routines. module procedure :: banded_to_dense_dbl module procedure :: banded_to_dense_cmplx end interface interface dense_to_banded !! An interface to the dense to banded matrix conversion routines. module procedure :: dense_to_banded_dbl module procedure :: dense_to_banded_cmplx end interface interface extract_diagonal !! An interface to the diagonal extraction routines. module procedure :: extract_diagonal_dbl module procedure :: extract_diagonal_cmplx module procedure :: extract_diagonal_csr end interface contains ! ****************************************************************************** ! MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine mtx_mult_mtx ( transa , transb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A B + \\beta C . logical , intent ( in ) :: transa !! A logical flag indicating if the matrix A should be transposed. logical , intent ( in ) :: transb !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: ta , tb integer ( int32 ) :: m , n , k , lda , ldb , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) if ( transa ) then ! K = # of columns in op(A) (# of rows in op(B)) k = size ( a , 1 ) ta = 'T' lda = k else k = size ( a , 2 ) ta = 'N' lda = m end if if ( transb ) then tb = 'T' ldb = n else tb = 'N' ldb = k end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( transa ) then if ( size ( a , 2 ) /= m ) flag = 4 else if ( size ( a , 1 ) /= m ) flag = 4 end if if ( transb ) then if ( size ( b , 2 ) /= k . or . size ( b , 1 ) /= n ) flag = 5 else if ( size ( b , 1 ) /= k . or . size ( b , 2 ) /= n ) flag = 5 end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"mtx_mult_mtx\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call DGEMM call DGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , m ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_mult_vec ( trans , alpha , a , b , beta , c , err ) !! Performs the matrix-vector operation C = \\alpha A B + \\beta C . logical , intent ( in ) :: trans !! A logical flag indicating if the matrix A should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the vector C. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. real ( real64 ), intent ( in ), dimension (:) :: b !! The vector B in the operation. real ( real64 ), intent ( inout ), dimension (:) :: c !! The vector C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: t integer ( int32 ) :: m , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) t = 'N' if ( trans ) t = 'T' if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( trans ) then if ( size ( b ) /= m ) then flag = 4 else if ( size ( c ) /= n ) then flag = 6 end if else if ( size ( b ) /= n ) then flag = 4 else if ( size ( c ) /= m ) then flag = 6 end if end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"mtx_mult_vec\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call DGEMV call DGEMV ( t , m , n , alpha , a , m , b , 1 , beta , c , 1 ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! !                           COMPLEX VALUED VERSIONS                            ! ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! subroutine cmtx_mult_mtx ( opa , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A B + \\beta C . integer ( int32 ), intent ( in ) :: opa !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: ta , tb integer ( int32 ) :: m , n , k , lda , ldb , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) if ( opa == LA_TRANSPOSE ) then ! K = # of columns in op(A) (# of rows in op(B)) k = size ( a , 1 ) ta = 'T' lda = k else if ( opa == LA_HERMITIAN_TRANSPOSE ) then k = size ( a , 1 ) ta = 'C' lda = k else k = size ( a , 2 ) ta = 'N' lda = m end if if ( opb == LA_TRANSPOSE ) then tb = 'T' ldb = n else if ( opb == LA_HERMITIAN_TRANSPOSE ) then tb = 'C' ldb = n else tb = 'N' ldb = k end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( opa == LA_TRANSPOSE . or . opa == LA_HERMITIAN_TRANSPOSE ) then if ( size ( a , 2 ) /= m ) flag = 4 else if ( size ( a , 1 ) /= m ) flag = 4 end if if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then if ( size ( b , 2 ) /= k . or . size ( b , 1 ) /= n ) flag = 5 else if ( size ( b , 1 ) /= k . or . size ( b , 2 ) /= n ) flag = 5 end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"cmtx_mult_mtx\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call ZGEMM call ZGEMM ( ta , tb , m , n , k , alpha , a , lda , b , ldb , beta , c , m ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine cmtx_mult_vec ( opa , alpha , a , b , beta , c , err ) !! Performs the matrix-vector operation C = \\alpha A B + \\beta C . integer ( int32 ), intent ( in ) :: opa !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the vector C. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:) :: b !! The vector B in the operation. complex ( real64 ), intent ( inout ), dimension (:) :: c !! The vector C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: t integer ( int32 ) :: m , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( opa == LA_TRANSPOSE ) then t = 'T' else if ( opa == LA_HERMITIAN_TRANSPOSE ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( opa == LA_TRANSPOSE . or . opa == LA_HERMITIAN_TRANSPOSE ) then if ( size ( b ) /= m ) then flag = 4 else if ( size ( c ) /= n ) then flag = 6 end if else if ( size ( b ) /= n ) then flag = 4 else if ( size ( c ) /= m ) then flag = 6 end if end if if ( flag /= 0 ) then ! ERROR: Matrix dimensions mismatch allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) & \"Matrix dimension mismatch.  Input number \" , flag , & \" was not sized correctly.\" call errmgr % report_error ( \"cmtx_mult_vec\" , errmsg , & LA_ARRAY_SIZE_ERROR ) return end if ! Call ZGEMV call ZGEMV ( t , m , n , alpha , a , m , b , 1 , beta , c , 1 ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ****************************************************************************** ! RANK 1 UPDATE ! ------------------------------------------------------------------------------ subroutine rank1_update_dbl ( alpha , x , y , a , err ) !! Performs a rank-1 update of a matrix of the form A = \\alpha x y&#94;T + A. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the outer product of x and y. real ( real64 ), intent ( in ), dimension (:) :: x !! The vector x in the outer product. real ( real64 ), intent ( in ), dimension (:) :: y !! The vector y in the outer product. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix A to update. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , m , n real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( x ) n = size ( y ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= m . or . size ( a , 2 ) /= n ) then ! ERROR: Matrix dimension array call report_matrix_size_error ( \"rank1_update_dbl\" , errmgr , \"A\" , m , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Process do j = 1 , n if ( y ( j ) /= zero ) then temp = alpha * y ( j ) a (:, j ) = a (:, j ) + temp * x end if end do end subroutine ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! !                           COMPLEX VALUED VERSIONS                            ! ! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ! subroutine rank1_update_cmplx ( alpha , x , y , a , err ) !! Performs a rank-1 update of a matrix of the form A = \\alpha x y&#94;H + A. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the outer product of x and y. complex ( real64 ), intent ( in ), dimension (:) :: x !! The vector x in the outer product. complex ( real64 ), intent ( in ), dimension (:) :: y !! The vector y in the outer product. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix A to update. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , m , n complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( x ) n = size ( y ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 1 ) /= m . or . size ( a , 2 ) /= n ) then ! ERROR: Matrix dimension array call report_matrix_size_error ( \"rank1_update_cmplx\" , errmgr , \"A\" , m , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Process do j = 1 , n if ( y ( j ) /= zero ) then temp = alpha * conjg ( y ( j )) a (:, j ) = a (:, j ) + temp * x end if end do end subroutine ! ****************************************************************************** ! DIAGONAL MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx ( lside , trans , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. logical , intent ( in ) :: trans !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( trans ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( trans ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2 ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , k real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx3 ( lside , trans , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha B A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. logical , intent ( in ) :: trans !! A logical flag indicating if the matrix B should be transposed. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( trans ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx3\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( trans ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( trans ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx4 ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx4\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx_cmplx ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2_cmplx ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2_cmplx\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx_mix ( lside , opb , alpha , a , b , beta , c , err ) !! Performs the matrix operation C = \\alpha A op(B) + \\beta C  or !! C = \\alpha op(B) A + \\beta C  where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. integer ( int32 ), intent ( in ) :: opb !! An integer flag indicating the operation to perform on matrix B. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply the matrix C. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The matrix B in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! The matrix C in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k , nrowb , ncolb , flag complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( a ) nrowb = size ( b , 1 ) ncolb = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( k > m ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C if ( nrowb /= n . or . ncolb < k ) flag = 5 else ! Compute C = alpha * A * B + beta * C if ( nrowb < k . or . ncolb /= n ) flag = 5 end if end if else if ( k > n ) then flag = 4 else if ( opb == LA_TRANSPOSE . or . opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C if ( ncolb /= m . or . nrowb < k ) flag = 5 else ! Compute C = alpha * B * A + beta * C if ( nrowb /= m . or . ncolb < k ) flag = 5 end if end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"diag_mtx_mult_mtx_mix\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Deal with ALPHA == 0 if ( alpha == 0 ) then if ( beta == zero ) then c = zero else if ( beta /= one ) then c = beta * c end if return end if ! Process if ( lside ) then if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * A * B**T + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b (:, i ) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * A * B**H + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * conjg ( b (:, i )) end do else ! Compute C = alpha * A * B + beta * C do i = 1 , k if ( beta == zero ) then c ( i ,:) = zero else if ( beta /= one ) then c ( i ,:) = beta * c ( i ,:) end if temp = alpha * a ( i ) c ( i ,:) = c ( i ,:) + temp * b ( i ,:) end do end if ! Handle extra rows if ( m > k ) then if ( beta == zero ) then c ( k + 1 : m ,:) = zero else c ( k + 1 : m ,:) = beta * c ( k + 1 : m ,:) end if end if else if ( opb == LA_TRANSPOSE ) then ! Compute C = alpha * B**T * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b ( i ,:) end do else if ( opb == LA_HERMITIAN_TRANSPOSE ) then ! Compute C = alpha * B**H * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * conjg ( b ( i ,:)) end do else ! Compute C = alpha * B * A + beta * C do i = 1 , k if ( beta == zero ) then c (:, i ) = zero else if ( beta /= one ) then c (:, i ) = beta * c (:, i ) end if temp = alpha * a ( i ) c (:, i ) = c (:, i ) + temp * b (:, i ) end do end if ! Handle extra columns if ( n > k ) then if ( beta == zero ) then c (:, k + 1 : m ) = zero else if ( beta /= one ) then c (:, k + 1 : m ) = beta * c (:, k + 1 : m ) end if end if end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_mult_mtx2_mix ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix. logical , intent ( in ) :: lside !! A logical flag indicating if the diagonal matrix is on the left. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply the product of A and B. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix A in the operation. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! The matrix B in the operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , k complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) k = size ( a ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (( lside . and . k > m ) . or . (. not . lside . and . k > n )) then ! ERROR: One of the input arrays is not sized correctly call errmgr % report_error ( \"diag_mtx_mult_mtx2_cmplx\" , & \"Input number 3 is not sized correctly.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process if ( lside ) then ! Compute B = alpha * A * B do i = 1 , k temp = alpha * a ( i ) b ( i ,:) = temp * b ( i ,:) end do if ( m > k ) b ( k + 1 : m ,:) = zero else ! Compute B = alpha * B * A do i = 1 , k temp = alpha * a ( i ) b (:, i ) = temp * b (:, i ) end do if ( n > k ) b (:, k + 1 : n ) = zero end if end subroutine ! ------------------------------------------------------------------------------ subroutine diag_mtx_sparse_mult ( lside , alpha , a , b , err ) !! Performs the matrix operation B = \\alpha A B  or B = \\alpha B A  !! where A is a diagonal matrix and B is a sparse matrix. logical , intent ( in ) :: lside real ( real64 ), intent ( in ) :: alpha real ( real64 ), intent ( in ), dimension (:) :: a class ( csr_matrix ), intent ( inout ) :: b class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: ii , k , k1 , k2 , nrow real ( real64 ) :: scal class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization nrow = size ( b , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then if ( size ( a ) /= nrow ) then call report_inner_matrix_dimension_error ( \"diag_mtx_sparse_mult\" , & errmgr , \"a\" , \"b\" , nrow , size ( a )) return end if else if ( size ( a ) /= size ( b , 2 )) then call report_inner_matrix_dimension_error ( \"diag_mtx_sparse_mult\" , & errmgr , \"a\" , \"b\" , size ( b , 2 ), size ( a )) return end if end if ! Process if ( lside ) then ! Compute B = DIAG * B do ii = 1 , nrow k1 = b % row_indices ( ii ) k2 = b % row_indices ( ii + 1 ) - 1 if ( alpha == 1.0d0 ) then scal = a ( ii ) else scal = alpha * a ( ii ) end if do k = k1 , k2 b % values ( k ) = b % values ( k ) * scal end do end do else ! Compute B = B * DIAG do ii = 1 , nrow k1 = b % row_indices ( ii ) k2 = b % row_indices ( ii + 1 ) - 1 if ( alpha == 1.0d0 ) then do k = k1 , k2 b % values ( k ) = b % values ( k ) * a ( b % column_indices ( k )) end do else do k = k1 , k2 b % values ( k ) = alpha * b % values ( k ) * a ( b % column_indices ( k )) end do end if end do end if end subroutine ! ****************************************************************************** ! BASIC OPERATION ROUTINES ! ------------------------------------------------------------------------------ pure function trace_dbl ( x ) result ( y ) !! Computes the trace of a matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix. real ( real64 ) :: y !! The trace of the matrix. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn ! Initialization y = zero m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) ! Process do i = 1 , mn y = y + x ( i , i ) end do end function ! ------------------------------------------------------------------------------ pure function trace_cmplx ( x ) result ( y ) !! Computes the trace of a matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix. complex ( real64 ) :: y !! The trace of the matrix. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn ! Initialization y = zero m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) ! Process do i = 1 , mn y = y + x ( i , i ) end do end function ! ------------------------------------------------------------------------------ function mtx_rank_dbl ( a , tol , work , olwork , err ) result ( rnk ) !! Computes the rank of a matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default !! tolerance on singular values such that singular values less than !! this tolerance are treated as zero.  The default tolerance is: !! MAX(M, N) * EPS * MAX(S).  If the supplied value is less than the !! smallest value that causes an overflow if inverted, the tolerance !! reverts back to its default value, and the operation continues; !! however, a warning message is issued. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local !! memory allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork.  If not provided, the memory required is allocated within. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size. If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. integer ( int32 ) :: rnk !! The rank of the matrix. ! Local Variables integer ( int32 ) :: i , m , n , mn , istat , lwork , flag real ( real64 ), pointer , dimension (:) :: wptr , s , w real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ) :: t , tref , smlnum real ( real64 ), dimension ( 1 ) :: dummy , temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) smlnum = DLAMCH ( 's' ) rnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Workspace Query !call svd(a, a(1:mn,1), olwork = lwork) call DGESVD ( 'N' , 'N' , m , n , a , m , dummy , dummy , m , dummy , n , temp , & - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"mtx_rank\" , & \"Incorrectly sized input array WORK, argument 5.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_rank\" , errmgr , flag ) return end if wptr => wrk end if s => wptr ( 1 : mn ) w => wptr ( mn + 1 : lwork ) ! Compute the singular values of A call DGESVD ( 'N' , 'N' , m , n , a , m , s , dummy , m , dummy , n , w , & lwork - mn , flag ) if ( flag > 0 ) then allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) flag , \" superdiagonals could not \" // & \"converge to zero as part of the QR iteration process.\" call errmgr % report_warning ( \"mtx_rank\" , errmsg , LA_CONVERGENCE_ERROR ) end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if if ( t < smlnum ) then ! ! The supplied tolerance is too small, simply fall back to the ! ! default, but issue a warning to the user ! t = tref ! call report_warning(\"mtx_rank\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Count the singular values that are larger than the tolerance value do i = 1 , mn if ( s ( i ) < t ) exit rnk = rnk + 1 end do ! Formatting 100 format ( I0 , A ) end function ! ------------------------------------------------------------------------------ function mtx_rank_cmplx ( a , tol , work , olwork , rwork , err ) result ( rnk ) !! Computes the rank of a matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The matrix. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default !! tolerance on singular values such that singular values less than !! this tolerance are treated as zero.  The default tolerance is: !! MAX(M, N) * EPS * MAX(S).  If the supplied value is less than the !! smallest value that causes an overflow if inverted, the tolerance !! reverts back to its default value, and the operation continues; !! however, a warning message is issued. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local !! memory allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork.  If not provided, the memory required is allocated within. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size. If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any !! local memory allocation for real-valued workspace arrays.  If not !! provided, the memory required is allocated within.  If provided, the !! length of the array must be at least 6 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The rank of the matrix. integer ( int32 ) :: rnk !! The rank of the matrix. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Local Variables integer ( int32 ) :: i , m , n , mn , istat , lwork , flag , lrwork real ( real64 ), pointer , dimension (:) :: s , rwptr , rw real ( real64 ), allocatable , target , dimension (:) :: rwrk complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), pointer , dimension (:) :: wptr real ( real64 ) :: t , tref , smlnum real ( real64 ), dimension ( 1 ) :: dummy complex ( real64 ), dimension ( 1 ) :: cdummy , temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 6 * mn smlnum = DLAMCH ( 's' ) rnk = 0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Workspace Query call ZGESVD ( 'N' , 'N' , m , n , a , m , dummy , cdummy , m , cdummy , n , temp , & - 1 , dummy , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"mtx_rank_cmplx\" , & \"Incorrectly sized input array WORK, argument 5.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_rank_cmplx\" , errmgr , flag ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then ! ERROR: RWORK not sized correctly call errmgr % report_error ( \"mtx_rank_cmplx\" , & \"Incorrectly sized input array RWORK.\" , & LA_ARRAY_SIZE_ERROR ) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then end if rwptr => rwrk end if s => rwptr ( 1 : mn ) rw => rwptr ( mn + 1 : lrwork ) ! Compute the singular values of A call ZGESVD ( 'N' , 'N' , m , n , a , m , s , cdummy , m , cdummy , n , wptr , & lwork - mn , rw , flag ) if ( flag > 0 ) then allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) flag , \" superdiagonals could not \" // & \"converge to zero as part of the QR iteration process.\" call errmgr % report_warning ( \"mtx_rank_cmplx\" , errmsg , LA_CONVERGENCE_ERROR ) end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if if ( t < smlnum ) then ! ! The supplied tolerance is too small, simply fall back to the ! ! default, but issue a warning to the user ! t = tref ! call report_warning(\"mtx_rank\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Count the singular values that are larger than the tolerance value do i = 1 , mn if ( s ( i ) < t ) exit rnk = rnk + 1 end do ! Formatting 100 format ( I0 , A ) end function ! ------------------------------------------------------------------------------ function det_dbl ( a , iwork , err ) result ( x ) !! Computes the determinant of a matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the matrix on which to operate.  On output, the LU factored !! matrix in the form [L\\\\U] where L is unit lower triangular and U is !! upper triangular.  The unit diagonal elements of L are not stored. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I).  If not supplied, this array is allocated within. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. real ( real64 ) :: x !! The determinant of the matrix. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 real ( real64 ), parameter :: p1 = 1.0d-1 ! Local Variables integer ( int32 ) :: i , ep , n , istat , flag integer ( int32 ), pointer , dimension (:) :: ipvt integer ( int32 ), allocatable , target , dimension (:) :: iwrk real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) x = zero if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"det\" , errmgr , \"a\" , n , size ( a , 1 ), & size ( a , 2 )) return end if ! Local Memory Allocation if ( present ( iwork )) then if ( size ( iwork ) < n ) then call report_array_size_error ( \"det\" , errmgr , \"iwork\" , n , n ) return end if ipvt => iwork ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then ! ERROR: Out of memory call report_memory_error ( \"det\" , errmgr , flag ) return end if ipvt => iwrk end if ! Compute the LU factorization of A call DGETRF ( n , n , a , n , ipvt , flag ) if ( flag > 0 ) then ! A singular matrix has a determinant of zero x = zero return end if ! Compute the product of the diagonal of A temp = one ep = 0 do i = 1 , n if ( ipvt ( i ) /= i ) temp = - temp temp = a ( i , i ) * temp if ( temp == zero ) then x = zero exit end if do while ( abs ( temp ) < one ) temp = ten * temp ep = ep - 1 end do do while ( abs ( temp ) > ten ) temp = p1 * temp ep = ep + 1 end do end do x = temp * ten ** ep end function ! ------------------------------------------------------------------------------ function det_cmplx ( a , iwork , err ) result ( x ) !! Computes the determinant of a matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the matrix on which to operate.  On output, the LU factored !! matrix in the form [L\\\\U] where L is unit lower triangular and U is !! upper triangular.  The unit diagonal elements of L are not stored. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I).  If not supplied, this array is allocated within. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. complex ( real64 ) :: x !! The determinant of the matrix. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) complex ( real64 ), parameter :: ten = ( 1.0d1 , 0.0d0 ) complex ( real64 ), parameter :: p1 = ( 1.0d-1 , 0.0d0 ) real ( real64 ), parameter :: real_one = 1.0d0 real ( real64 ), parameter :: real_ten = 1.0d1 ! Local Variables integer ( int32 ) :: i , ep , n , istat , flag integer ( int32 ), pointer , dimension (:) :: ipvt integer ( int32 ), allocatable , target , dimension (:) :: iwrk complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) x = zero if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"det_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return end if ! Local Memory Allocation if ( present ( iwork )) then if ( size ( iwork ) < n ) then call report_array_size_error ( \"det_cmplx\" , errmgr , \"iwork\" , n , n ) end if ipvt => iwork ( 1 : n ) else allocate ( iwrk ( n ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"det_cmplx\" , errmgr , flag ) end if ipvt => iwrk end if ! Compute the LU factorization of A call ZGETRF ( n , n , a , n , ipvt , flag ) if ( flag > 0 ) then ! A singular matrix has a determinant of zero x = zero return end if ! Compute the product of the diagonal of A temp = one ep = 0 do i = 1 , n if ( ipvt ( i ) /= i ) temp = - temp temp = a ( i , i ) * temp if ( temp == zero ) then x = zero exit end if do while ( abs ( temp ) < real_one ) temp = ten * temp ep = ep - 1 end do do while ( abs ( temp ) > real_ten ) temp = p1 * temp ep = ep + 1 end do end do x = temp * ten ** ep end function ! ****************************************************************************** ! ARRAY SWAPPING ROUTINE ! ------------------------------------------------------------------------------ subroutine swap_dbl ( x , y , err ) !! Swaps the contents of two arrays. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the first array to swap.  On output, the contents of the !! first array are copied to the second array. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the second array to swap.  On output, the contents of the !! second array are copied to the first array. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then call report_array_size_error ( \"swap_dbl\" , errmgr , \"y\" , n , n ) return end if ! Process do i = 1 , n temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp end do end subroutine ! ------------------------------------------------------------------------------ subroutine swap_cmplx ( x , y , err ) !! Swaps the contents of two arrays. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the first array to swap.  On output, the contents of the !! first array are copied to the second array. complex ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the second array to swap.  On output, the contents of the !! second array are copied to the first array. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , n complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then call report_array_size_error ( \"swap_cmplx\" , errmgr , \"y\" , n , n ) return end if ! Process do i = 1 , n temp = x ( i ) x ( i ) = y ( i ) y ( i ) = temp end do end subroutine ! ****************************************************************************** ! ARRAY MULTIPLICIATION ROUTINES ! ------------------------------------------------------------------------------ subroutine recip_mult_array_dbl ( a , x ) !! Computes the product of a scalar and a vector, where the scalar is !! the reciprocal of the scalar A. real ( real64 ), intent ( in ) :: a !! The scalar A, which is the reciprocal of the scalar to multiply by. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the vector to multiply.  On output, the product of the !! vector and the scalar reciprocal. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: twotho = 2.0d3 ! Local Variables logical :: done real ( real64 ) :: bignum , cden , cden1 , cnum , cnum1 , mul , smlnum ! Initialization smlnum = DLAMCH ( 's' ) bignum = one / smlnum if ( log10 ( bignum ) > twotho ) then smlnum = sqrt ( smlnum ) bignum = sqrt ( bignum ) end if ! Initialize the denominator to A, and the numerator to ONE cden = a cnum = one ! Process do cden1 = cden * smlnum cnum1 = cnum / bignum if ( abs ( cden1 ) > abs ( cnum ) . and . cnum /= zero ) then mul = smlnum done = . false . cden = cden1 else if ( abs ( cnum1 ) > abs ( cden )) then mul = bignum done = . false . cnum = cnum1 else mul = cnum / cden done = . true . end if ! Scale the vector X by MUL x = mul * x ! Exit if done if ( done ) exit end do end subroutine ! ****************************************************************************** ! TRIANGULAR MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine tri_mtx_mult_dbl ( upper , alpha , a , beta , b , err ) !! Performs the matrix operation B = \\alpha A&#94;T A + \\beta B or !! B = \\alpha A A&#94;T + \\beta B where A is a triangular matrix. logical , intent ( in ) :: upper !! A logical flag indicating whether the matrix A is upper triangular !! (TRUE) or lower triangular (FALSE). real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The triangular matrix A to multiply by. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the matrix B to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , k , n , d1 , d2 real ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) d1 = n d2 = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then d2 = size ( a , 2 ) call report_square_matrix_error ( \"tri_mtx_mult_dbl\" , errmgr , \"a\" , n , & n , size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then d1 = size ( b , 1 ) d2 = size ( b , 2 ) call report_matrix_size_error ( \"tri_mtx_mult_dbl\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Process if ( upper ) then ! Form: B = alpha * A**T * A + beta * B if ( beta == zero ) then do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if else ! Form: B = alpha * A * A**T + beta * B if ( beta == zero ) then do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if end if end subroutine ! ------------------------------------------------------------------------------ subroutine tri_mtx_mult_cmplx ( upper , alpha , a , beta , b , err ) !! Performs the matrix operation B = \\alpha A&#94;T A + \\beta B or !! B = \\alpha A A&#94;T + \\beta B where A is a triangular matrix. logical , intent ( in ) :: upper !! A logical flag indicating whether the matrix A is upper triangular !! (TRUE) or lower triangular (FALSE). complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The triangular matrix A to multiply by. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the matrix B to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , k , n , d1 , d2 complex ( real64 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) d1 = n d2 = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then d2 = size ( a , 2 ) call report_square_matrix_error ( \"tri_mtx_mult_cmplx\" , errmgr , \"a\" , n , & n , size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then d1 = size ( b , 1 ) d2 = size ( b , 2 ) call report_matrix_size_error ( \"tri_mtx_mult_cmplx\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Process if ( upper ) then ! Form: B = alpha * A**T * A + beta * B if ( beta == zero ) then do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = 1 , j temp = zero do k = 1 , j temp = temp + a ( k , i ) * a ( k , j ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if else ! Form: B = alpha * A * A**T + beta * B if ( beta == zero ) then do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp if ( i /= j ) b ( j , i ) = temp end do end do else do j = 1 , n do i = j , n temp = zero do k = 1 , j temp = temp + a ( i , k ) * a ( j , k ) end do temp = alpha * temp b ( i , j ) = temp + beta * b ( i , j ) if ( i /= j ) b ( j , i ) = temp + beta * b ( j , i ) end do end do end if end if end subroutine ! ****************************************************************************** ! BANDED MATRIX MULTIPLICATION ROUTINES ! ------------------------------------------------------------------------------ subroutine band_mtx_vec_mult_dbl ( trans , kl , ku , alpha , a , x , beta , & y , err ) !! Performs the matrix operation y = \\alpha A x + \\beta y or !! y = \\alpha A&#94;T A + \\beta y where A is a banded matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: trans !! A logical flag indicating whether to perform the operation !! y = \\alpha A x + \\beta y (FALSE) or y = \\alpha A&#94;T x + \\beta y !! (TRUE). integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix A. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix A. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix A to multiply by. real ( real64 ), intent ( in ), dimension (:) :: x !! The vector x to multiply by. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the vector y to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( trans ) then m = size ( x ) n = size ( y ) else m = size ( y ) n = size ( x ) end if ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( a , 1 ) /= kl + ku + 1 ) go to 30 if ( size ( a , 2 ) /= n ) go to 30 ! Process if ( trans ) then call DGBMV ( \"T\" , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) else call DGBMV ( \"N\" , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_mtx_vec_mult_dbl\" , & \"The size of matrix A is not compatible with the other vectors.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_mtx_vec_mult_cmplx ( trans , kl , ku , alpha , a , x , & beta , y , err ) !! Performs the matrix operation y = \\alpha op(A) x + \\beta y  where !! A is a banded matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: trans !! An integer flag indicating the operation to perform on matrix A. !! Possible options are: !! !! - LA_NO_OPERATION: No operation is performed on matrix. !! !! - LA_TRANSPOSE: The transpose of matrix is used. !! !! - LA_HERMITIAN_TRANSPOSE: The Hermitian transpose of matrix is used. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix A. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix A. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( in ) :: beta !! The scalar \\beta to multiply by. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix A to multiply by. complex ( real64 ), intent ( in ), dimension (:) :: x !! The vector x to multiply by. complex ( real64 ), intent ( inout ), dimension (:) :: y !! On input, the vector y to multiply.  On output, the result of the !! operation. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: op logical :: trns integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( trans == LA_TRANSPOSE ) then op = \"T\" trns = . true . else if ( trans == LA_HERMITIAN_TRANSPOSE ) then op = \"C\" trns = . true . else op = \"N\" trns = . false . end if if ( trns ) then m = size ( x ) n = size ( y ) else m = size ( y ) n = size ( x ) end if ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( a , 1 ) /= kl + ku + 1 ) go to 30 if ( size ( a , 2 ) /= n ) go to 30 ! Process call ZGBMV ( op , m , n , kl , ku , alpha , a , size ( a , 1 ), x , 1 , beta , y , 1 ) ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_mtx_vec_mult_cmplx\" , & \"The size of matrix A is not compatible with the other vectors.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_to_full_mtx_dbl ( kl , ku , b , f , err ) !! Converts a banded matrix to a full matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. real ( real64 ), intent ( in ), dimension (:,:) :: b !! The banded matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: f !! The full matrix to store the result in. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , j , k , m , n , i1 , i2 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( f , 1 ) n = size ( f , 2 ) ! Input Check if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( b , 2 ) /= n ) go to 30 if ( size ( b , 1 ) /= kl + ku + 1 ) go to 40 ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) do i = 1 , i1 - 1 f ( i , j ) = zero end do do i = i1 , i2 f ( i , j ) = b ( k + i , j ) end do do i = i2 + 1 , m f ( i , j ) = zero end do end do ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of columns in the banded matrix does not match \" // & \"the number of columns in the full matrix.\" , & LA_ARRAY_SIZE_ERROR ) return 40 continue call errmgr % report_error ( \"band_to_full_mtx_dbl\" , & \"The number of rows in the banded matrix does not align with \" // & \"the number of sub and super-diagonals specified.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_to_full_mtx_cmplx ( kl , ku , b , f , err ) !! Converts a banded matrix to a full matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: b !! The banded matrix to convert. complex ( real64 ), intent ( out ), dimension (:,:) :: f !! The full matrix to store the result in. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , j , k , m , n , i1 , i2 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( f , 1 ) n = size ( f , 2 ) ! Input Check if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( size ( b , 2 ) /= n ) go to 30 if ( size ( b , 1 ) /= kl + ku + 1 ) go to 40 ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) do i = 1 , i1 - 1 f ( i , j ) = zero end do do i = i1 , i2 f ( i , j ) = b ( k + i , j ) end do do i = i2 + 1 , m f ( i , j ) = zero end do end do ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! A is incorrectly sized 30 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of columns in the banded matrix does not match \" // & \"the number of columns in the full matrix.\" , & LA_ARRAY_SIZE_ERROR ) return 40 continue call errmgr % report_error ( \"band_to_full_mtx_cmplx\" , & \"The number of rows in the banded matrix does not align with \" // & \"the number of sub and super-diagonals specified.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_diag_mtx_mult_dbl ( left , m , kl , ku , alpha , a , b , err ) !! Performs the matrix operation A = \\alpha A B or A = \\alpha B A !! where A is a banded matrix and B is a diagonal matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: left !! A logical flag indicating whether to perform the operation !! A = \\alpha A B (TRUE) or A = \\alpha B A (FALSE). integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix A. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. real ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! The banded matrix to multiply. real ( real64 ), intent ( in ), dimension (:) :: b !! The diagonal matrix to multiply by. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , i1 , i2 , j , k , n real ( real64 ) :: temp ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( left ) then if ( size ( b ) /= n ) go to 30 else if ( size ( b ) < m ) go to 30 end if ! Process if ( left ) then ! Compute A = A * B do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) + k i2 = min ( m , j + kl ) + k if ( alpha == one ) then temp = b ( j ) else temp = alpha * b ( j ) end if do i = i1 , i2 a ( i , j ) = a ( i , j ) * temp end do end do else ! Compute A = B * A do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) if ( alpha == 1.0d0 ) then do i = i1 , i2 a ( i + k , j ) = a ( i + k , j ) * b ( i ) end do else do i = i1 , i2 a ( i + k , j ) = alpha * a ( i + k , j ) * b ( i ) end do end if end do end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! B is not sized correctly 30 continue call errmgr % report_error ( \"band_diag_mtx_mult_dbl\" , & \"Inner matrix dimensions do not agree.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine band_diag_mtx_mult_cmplx ( left , m , kl , ku , alpha , a , b , err ) !! Performs the matrix operation A = \\alpha A B or A = \\alpha B A !! where A is a banded matrix and B is a diagonal matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode logical , intent ( in ) :: left !! A logical flag indicating whether to perform the operation !! A = \\alpha A B (TRUE) or A = \\alpha B A (FALSE). integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix A. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals in the banded matrix. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals in the banded matrix. complex ( real64 ), intent ( in ) :: alpha !! The scalar \\alpha to multiply by. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! The banded matrix to multiply. complex ( real64 ), intent ( in ), dimension (:) :: b !! The diagonal matrix to multiply by. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: i , i1 , i2 , j , k , n complex ( real64 ) :: temp ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 ) go to 10 if ( ku < 0 ) go to 20 if ( left ) then if ( size ( b ) /= n ) go to 30 else if ( size ( b ) < m ) go to 30 end if ! Process if ( left ) then ! Compute A = A * B do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) + k i2 = min ( m , j + kl ) + k if ( alpha == one ) then temp = b ( j ) else temp = alpha * b ( j ) end if do i = i1 , i2 a ( i , j ) = a ( i , j ) * temp end do end do else ! Compute A = B * A do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) if ( alpha == 1.0d0 ) then do i = i1 , i2 a ( i + k , j ) = a ( i + k , j ) * b ( i ) end do else do i = i1 , i2 a ( i + k , j ) = alpha * a ( i + k , j ) * b ( i ) end do end if end do end if ! End return ! KL < 0 10 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"The number of subdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! KU < 0 20 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"The number of superdiagonals must be at least 0.\" , & LA_INVALID_INPUT_ERROR ) return ! B is not sized correctly 30 continue call errmgr % report_error ( \"band_diag_mtx_mult_cmplx\" , & \"Inner matrix dimensions do not agree.\" , & LA_ARRAY_SIZE_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine banded_to_dense_dbl ( m , kl , ku , a , x , err ) !! Converts a banded matrix to a dense matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: m !! The M-by-N dense matrix. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The (KL+KU+1)-by-N banded matrix. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The M-by-N dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , j , k , n , i1 , i2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( a , 1 ) /= kl + ku + 1 ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , \"The size of \" // & \"the input matrix does not match the specified bandwidth.\" , & LA_MATRIX_FORMAT_ERROR ) return end if if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"banded_to_dense_dbl\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) x (: i1 - 1 , j ) = zero do i = i1 , i2 x ( i , j ) = a ( k + i , j ) end do x ( i2 + 1 :, j ) = zero end do end subroutine ! ------------------------------------------------------------------------------ subroutine banded_to_dense_cmplx ( m , kl , ku , a , x , err ) !! Converts a banded matrix to a dense matrix. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode integer ( int32 ), intent ( in ) :: m !! The M-by-N dense matrix. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The (KL+KU+1)-by-N banded matrix. complex ( real64 ), intent ( out ), dimension (:,:) :: x !! The M-by-N dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , k , n , i1 , i2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 2 ) ! Input Checking if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( a , 1 ) /= kl + ku + 1 ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , \"The size of \" // & \"the input matrix does not match the specified bandwidth.\" , & LA_MATRIX_FORMAT_ERROR ) return end if if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"banded_to_dense_cmplx\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j i1 = max ( 1 , j - ku ) i2 = min ( m , j + kl ) x (: i1 - 1 , j ) = zero do i = i1 , i2 x ( i , j ) = a ( k + i , j ) end do x ( i2 + 1 :, j ) = zero end do end subroutine ! ------------------------------------------------------------------------------ subroutine dense_to_banded_dbl ( a , kl , ku , x , err ) !! Converts a banded matrix stored in dense format to a compressed form. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode real ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix to convert. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The (KL+KU+1)-by-N banded matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , j , k , m , n , mm , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mm = kl + ku + 1 ! Input Check if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"dense_to_banded_dbl\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( x , 1 ) /= mm . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"dense_to_banded_dbl\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) x ( k + i , j ) = a ( i , j ) end do end do end subroutine ! ------------------------------------------------------------------------------ subroutine dense_to_banded_cmplx ( a , kl , ku , x , err ) !! Converts a banded matrix stored in dense format to a compressed form. !! !! The banded matrix is stored in a compressed form supplied column by !! column.  The following code segment transfers between a full matrix !! to the bonded matrix storage scheme. !! \\code{fortran} !! do j = 1, n !!    k = ku + 1 - j !!    do i = max(1, j - ku), min(n, j + kl) !!       a(k + i, j) = matrix(i, j) !!    end do !! end do !! \\endcode complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The matrix to convert. integer ( int32 ), intent ( in ) :: kl !! The number of subdiagonals.  Must be at least 0. integer ( int32 ), intent ( in ) :: ku !! The number of superdiagonals.  Must be at least 0. complex ( real64 ), intent ( out ), dimension (:,:) :: x !! The (KL+KU+1)-by-N banded matrix. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , j , k , m , n , mm , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mm = kl + ku + 1 ! Input Check if ( kl < 0 . or . ku < 0 ) then call errmgr % report_error ( \"dense_to_banded_cmplx\" , & \"The bandwidth dimensions must not be negative-valued.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( x , 1 ) /= mm . or . size ( x , 2 ) /= n ) then call errmgr % report_error ( \"dense_to_banded_cmplx\" , & \"The output matrix dimensions are not correct.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Process do j = 1 , n k = ku + 1 - j do i = max ( 1 , j - ku ), min ( m , j + kl ) x ( k + i , j ) = a ( i , j ) end do end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_dbl ( a , diag , err ) !! Extracts the diagonal of a matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_dbl\" , errmgr , \"diag\" , & mn , size ( diag )) return end if ! Process do i = 1 , mn diag ( i ) = a ( i , i ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_cmplx ( a , diag , err ) !! Extracts the diagonal of a matrix. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The M-by-N matrix. complex ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_cmplx\" , errmgr , & \"diag\" , mn , size ( diag )) return end if ! Process do i = 1 , mn diag ( i ) = a ( i , i ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine extract_diagonal_csr ( a , diag , err ) !! Extracts the diagonal of a matrix. class ( csr_matrix ), intent ( in ) :: a !! The M-by-N matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The MIN(M, N) element array for the diagonal elements. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: i , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Checking if ( size ( diag ) /= mn ) then call report_array_size_error ( \"extract_diagonal_cmplx\" , errmgr , & \"diag\" , mn , size ( diag )) return end if ! Process call a % extract_diagonal ( diag , errmgr ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_basic.f90.html"},{"title":"linalg_cholesky.f90 – LINALG","text":"Source Code module linalg_cholesky use iso_fortran_env , only : int32 , real64 use linalg_errors use lapack use qrupdate implicit none private public :: cholesky_factor public :: cholesky_rank1_update public :: cholesky_rank1_downdate public :: solve_cholesky interface cholesky_factor module procedure :: cholesky_factor_dbl module procedure :: cholesky_factor_cmplx end interface interface cholesky_rank1_update module procedure :: cholesky_rank1_update_dbl module procedure :: cholesky_rank1_update_cmplx end interface interface cholesky_rank1_downdate module procedure :: cholesky_rank1_downdate_dbl module procedure :: cholesky_rank1_downdate_cmplx end interface interface solve_cholesky module procedure :: solve_cholesky_mtx module procedure :: solve_cholesky_mtx_cmplx module procedure :: solve_cholesky_vec module procedure :: solve_cholesky_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine cholesky_factor_dbl ( a , upper , err ) !! Computes the Cholesky factorization of a symmetric, positive definite !! matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to factor.  On output, the factored !! matrix is returned in either the upper or lower triangular portion !! of the matrix, dependent upon the value of upper. logical , intent ( in ), optional :: upper !! An optional input that, if specified, provides control over whether !! the factorization is computed as A = U&#94;T U (set to true), or !! as A = L L&#94;T (set to false).  The default is true such that !! A = U&#94;T U. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo integer ( int32 ) :: i , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if else uplo = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_factor\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Process call DPOTRF ( uplo , n , a , n , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"cholesky_factor\" , & \"The matrix is not positive-definite.\" , LA_MATRIX_FORMAT_ERROR ) return end if ! Zero out the non-used upper or lower diagonal if ( uplo == 'U' ) then ! Zero out the lower do i = 1 , n - 1 a ( i + 1 : n , i ) = zero end do else ! Zero out the upper do i = 2 , n a ( 1 : i - 1 , i ) = zero end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_factor_cmplx ( a , upper , err ) !! Computes the Cholesky factorization of a symmetric, positive definite !! matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to factor.  On output, the factored !! matrix is returned in either the upper or lower triangular portion !! of the matrix, dependent upon the value of upper. logical , intent ( in ), optional :: upper !! An optional input that, if specified, provides control over whether !! the factorization is computed as A = U&#94;H U (set to true), or !! as A = L L&#94;H (set to false).  The default is true such that !! A = U&#94;H U. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables character :: uplo integer ( int32 ) :: i , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( upper )) then if ( upper ) then uplo = 'U' else uplo = 'L' end if else uplo = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_factor_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Process call ZPOTRF ( uplo , n , a , n , flag ) if ( flag > 0 ) then ! ERROR: Matrix is not positive definite call errmgr % report_error ( \"cholesky_factor_cmplx\" , & \"The matrix is not positive-definite.\" , LA_MATRIX_FORMAT_ERROR ) end if ! Zero out the non-used upper or lower diagonal if ( uplo == 'U' ) then ! Zero out the lower do i = 1 , n - 1 a ( i + 1 : n , i ) = zero end do else ! Zero out the upper do i = 2 , n a ( 1 : i - 1 , i ) = zero end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_update_dbl ( r , u , work , err ) !! Computes the rank 1 update to a Cholesky factored matrix A = R&#94;T R !! such that A_1 = A + \\vec{u} \\vec{u}&#94;T. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_update_dbl\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_update_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DCH1UP ( n , r , n , u , wptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_update_cmplx ( r , u , work , err ) !! Computes the rank 1 update to a Cholesky factored matrix A = R&#94;H R !! such that A_1 = A + \\vec{u} \\vec{u}&#94;H. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_update_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_update_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZCH1UP ( n , r , n , u , wptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_downdate_dbl ( r , u , work , err ) !! Computes the rank 1 downdate to a Cholesky factored matrix A = R&#94;T R !! such that A_1 = A - \\vec{u} \\vec{u}&#94;T.  This operation only works if !! the new matrix A_1 is positive definite. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_downdate_dbl\" , & errmgr , \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_downdate_dbl\" , errmgr , & \"u\" , n , size ( u )) end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_downdate_dbl\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_downdate_dbl\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call DCH1DN ( n , r , n , u , wptr , flag ) if ( flag == 1 ) then ! ERROR: The matrix is not positive definite call errmgr % report_error ( \"cholesky_rank1_downdate\" , & \"The downdated matrix is not positive definite.\" , & LA_MATRIX_FORMAT_ERROR ) else if ( flag == 2 ) then ! ERROR: The matrix is singular call errmgr % report_error ( \"cholesky_rank1_downdate\" , & \"The input matrix is singular.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine cholesky_rank1_downdate_cmplx ( r , u , work , err ) !! Computes the rank 1 downdate to a Cholesky factored matrix A = R&#94;H R !! such that A_1 = A - \\vec{u} \\vec{u}&#94;H.  This operation only works if !! the new matrix A_1 is positive definite. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R.  On output, the !! updated matrix R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the N-element vector \\vec{u}.  On output, the rotation !! sines used to transform R to R_1. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least N elements. !! Additionally, this workspace array is used to contain the rotation !! cosines used to transform R to R_1. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: n , lwork , istat , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( r , 1 ) lwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( r , 2 ) /= n ) then call report_square_matrix_error ( \"cholesky_rank1_downdate_cmplx\" , & errmgr , \"r\" , n , size ( r , 1 ), size ( r , 2 )) return else if ( size ( u ) /= n ) then call report_array_size_error ( \"cholesky_rank1_downdate_cmplx\" , errmgr , & \"u\" , n , size ( u )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"cholesky_rank1_downdate_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"cholesky_rank1_downdate_cmplx\" , errmgr , & istat ) return end if wptr => wrk end if ! Process call ZCH1DN ( n , r , n , u , wptr , flag ) if ( flag == 1 ) then ! ERROR: The matrix is not positive definite call errmgr % report_error ( \"cholesky_rank1_downdate_cmplx\" , & \"The downdated matrix is not positive definite.\" , & LA_MATRIX_FORMAT_ERROR ) else if ( flag == 2 ) then ! ERROR: The matrix is singular call errmgr % report_error ( \"cholesky_rank1_downdate_cmplx\" , & \"The input matrix is singular.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_mtx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations A X = R&#94;T R X = B or !! A X = L L&#94;T X = B. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;T R; else, set !! to false if A is factored such that A = L L&#94;T. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS matrix B.  On output, the resulting !! N-by-NRHS matrix X. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_mtx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_cholesky_mtx\" , errmgr , \"b\" , & n , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Process call DPOTRS ( uplo , n , nrhs , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_mtx_cmplx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations A X = R&#94;H R X = B or !! A X = L L&#94;H X = B. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;H R; else, set !! to false if A is factored such that A = L L&#94;H. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS matrix B.  On output, the resulting !! N-by-NRHS matrix X. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_mtx_cmplx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_cholesky_mtx_cmplx\" , errmgr , \"b\" , & n , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Process call ZPOTRS ( uplo , n , nrhs , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_cholesky_vec ( upper , a , b , err ) !! Solves the system of Cholesky factored equations !! A \\vec{x} = R&#94;T R \\vec{x} = \\vec{b} or !! A \\vec{x} = L L&#94;T \\vec{x} = \\vec{b}. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;T R; else, set !! to false if A is factored such that A = L L&#94;T. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the N-element vector \\vec{b}.  On output, the resulting !! N-element vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_vec\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_cholesky_vec\" , errmgr , \"b\" , & n , size ( b )) return end if ! Process call DPOTRS ( uplo , n , 1 , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_cholesky_vec_cmplx ( upper , a , b , err ) !! Solves the system of Cholesky factored equations !! A \\vec{x} = R&#94;H R \\vec{x} = \\vec{b} or !! A \\vec{x} = L L&#94;H \\vec{x} = \\vec{b}. logical , intent ( in ) :: upper !! Set to true if A is factored such that A = R&#94;H R; else, set !! to false if A is factored such that A = L L&#94;H. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N Cholesky factored matrix as returned by cholesky_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the N-element vector \\vec{b}.  On output, the resulting !! N-element vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: uplo integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_cholesky_vec_cmplx\" , errmgr , & \"a\" , n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_cholesky_vec_cmplx\" , errmgr , \"b\" , & n , size ( b )) return end if ! Process call ZPOTRS ( uplo , n , 1 , a , n , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_cholesky.f90.html"},{"title":"linalg_eigen.f90 – LINALG","text":"Source Code ! linalg_eigen.f90 module linalg_eigen use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors use ferror implicit none private public :: eigen interface eigen !! An interface to the eigenvalue and eigenvector routines. module procedure :: eigen_symm module procedure :: eigen_asymm module procedure :: eigen_gen module procedure :: eigen_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine eigen_symm ( vecs , a , vals , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is a symmetric matrix. logical , intent ( in ) :: vecs !! Set to true to compute the eigenvectors as well as the eigenvalues; !! else, set to false to just compute the eigenvalues. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N symmetric matrix on which to operate.  On !! output, and if vecs is set to true, the matrix will contain the !! eigenvectors (one per column) corresponding to each eigenvalue in !! vals.  If vecs is set to false, the lower triangular portion of the !! matrix is overwritten. real ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array that will contain the eigenvalues sorted into !! ascending order. real ( real64 ), intent ( out ), pointer , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: jobz integer ( int32 ) :: n , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( vecs ) then jobz = 'V' else jobz = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_symm\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_symm\" , errmgr , \"vals\" , n , & size ( vals )) return end if ! Workspace Query call DSYEV ( jobz , 'L' , n , a , n , vals , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_symm\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_symm\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DSYEV ( jobz , 'L' , n , a , n , vals , wptr , lwork , flag ) if ( flag > 0 ) then call errmgr % report_error ( \"eigen_symm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_asymm ( a , vals , vecs , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is square, but not necessarily symmetric. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix on which to operate.  On output, the !! contents of this matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array containing the eigenvalues of the matrix.  The !! eigenvalues are not sorted. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. real ( real64 ), intent ( out ), pointer , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns without !! performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , n1 , n2a , n2b , n3a , n3b , istat , flag , & lwork , lwork1 real ( real64 ) :: eps real ( real64 ), dimension ( 1 ) :: dummy , temp real ( real64 ), dimension ( 1 , 1 ) :: dummy_mtx real ( real64 ), pointer , dimension (:) :: wr , wi , wptr , w real ( real64 ), pointer , dimension (:,:) :: vr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization jobvl = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) eps = two * epsilon ( eps ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_asymm\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_asymm\" , errmgr , \"vals\" , n , & size ( vals )) return else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_asymm\" , errmgr , \"vecs\" , & n , n , size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call DGEEV ( jobvl , jobvr , n , a , n , dummy , dummy , dummy_mtx , n , & dummy_mtx , n , temp , - 1 , flag ) lwork1 = int ( temp ( 1 ), int32 ) if ( present ( vecs )) then lwork = lwork1 + 2 * n + n * n else lwork = lwork1 + 2 * n end if if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_asymm\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_asymm\" , errmgr , istat ) return end if wptr => wrk end if ! Locate each array within the workspace array n1 = n n2a = n1 + 1 n2b = n2a + n - 1 n3a = n2b + 1 n3b = n3a + lwork1 - 1 ! Assign pointers wr => wptr ( 1 : n1 ) wi => wptr ( n2a : n2b ) w => wptr ( n3a : n3b ) ! Process if ( present ( vecs )) then ! Assign a pointer to the eigenvector matrix vr ( 1 : n , 1 : n ) => wptr ( n3b + 1 : lwork ) ! Compute the eigenvectors and eigenvalues call DGEEV ( jobvl , jobvr , n , a , n , wr , wi , dummy_mtx , n , vr , n , & w , lwork1 , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_asymm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues and eigenvectors j = 1 do while ( j <= n ) if ( abs ( wi ( j )) < eps ) then ! We've got a real-valued eigenvalue vals ( j ) = cmplx ( wr ( j ), zero , real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), zero , real64 ) end do else ! We've got a complex cojugate pair of eigenvalues jp1 = j + 1 vals ( j ) = cmplx ( wr ( j ), wi ( j ), real64 ) vals ( jp1 ) = conjg ( vals ( j )) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), vr ( i , jp1 ), real64 ) vecs ( i , jp1 ) = conjg ( vecs ( i , j )) end do ! Increment j and continue the loop j = j + 2 cycle end if ! Increment j j = j + 1 end do else ! Compute just the eigenvalues call DGEEV ( jobvl , jobvr , n , a , n , wr , wi , dummy_mtx , n , & dummy_mtx , n , w , lwork1 , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_asymm\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues do i = 1 , n vals ( i ) = cmplx ( wr ( i ), wi ( i ), real64 ) end do end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_gen ( a , b , alpha , beta , vecs , work , olwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, by solving !! the eigenvalue problem: A X = \\lambda B X. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix A.  On output, the contents of this !! matrix are overwritten. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-N matrix B.  On output, the contents of this !! matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: alpha !! An N-element array that, if beta is not supplied, contains the !! eigenvalues.  If beta is supplied however, the eigenvalues must be !! computed as \\lambda = \\alpha / \\beta.  This however, is not as !! trivial as it seems as it is entirely possible, and likely, that !! \\alpha / \\beta can overflow or underflow.  With that said, the !! values in \\alpha will always be less than and usually comparable !! with the NORM(A). real ( real64 ), intent ( out ), optional , dimension (:) :: beta !! An optional N-element array that if provided forces alpha to return !! the numerator, and this array contains the denominator used to !! determine the eigenvalues as \\lambda = \\alpha / \\beta.  If used, !! the values in this array will always be less than and usually !! comparable with the NORM(B). complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. real ( real64 ), intent ( out ), optional , pointer , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: i , j , jp1 , n , n1 , n2a , n2b , n3a , n3b , n4a , n4b , & istat , flag , lwork , lwork1 real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 , 1 ) :: dummy real ( real64 ), pointer , dimension (:) :: wptr , w , alphar , alphai , bptr real ( real64 ), pointer , dimension (:,:) :: vr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ) :: eps class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization jobvl = 'N' jobvr = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) eps = two * epsilon ( eps ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_gen\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( b , 1 ) /= n . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_gen\" , errmgr , \"b\" , n , n , & size ( b , 1 ), size ( b , 2 )) return else if ( size ( alpha ) /= n ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"alpha\" , n , & size ( alpha )) return else if ( present ( beta )) then if ( size ( beta ) /= n ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"beta\" , n , & size ( beta )) return end if else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_gen\" , errmgr , \"vecs\" , n , n , & size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call DGGEV ( jobvl , jobvr , n , a , n , b , n , temp , temp , temp , dummy , n , & dummy , n , temp , - 1 , flag ) lwork1 = int ( temp ( 1 ), int32 ) lwork = lwork1 + 2 * n if (. not . present ( beta )) then lwork = lwork + n end if if ( present ( vecs )) then lwork = lwork + n * n end if if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_gen\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"eigen_gen\" , errmgr , istat ) return end if wptr => wrk end if ! Locate each array within the workspace array & assign pointers n1 = n n2a = n1 + 1 n2b = n2a + n - 1 n3a = n2b + 1 n3b = n3a + lwork1 - 1 n4b = n3b alphar => wptr ( 1 : n1 ) alphai => wptr ( n2a : n2b ) w => wptr ( n3a : n3b ) if (. not . present ( beta )) then n4a = n3b + 1 n4b = n4a + n - 1 bptr => wptr ( n4a : n4b ) end if ! Process if ( present ( vecs )) then ! Assign a pointer to the eigenvector matrix vr ( 1 : n , 1 : n ) => wptr ( n4b + 1 : lwork ) ! Compute the eigenvalues and eigenvectors if ( present ( beta )) then call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & beta , dummy , n , vr , n , w , lwork1 , flag ) else call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & bptr , dummy , n , vr , n , w , lwork1 , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_gen\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues and eigenvectors j = 1 do while ( j <= n ) if ( abs ( alphai ( j )) < eps ) then ! Real-Valued alpha ( j ) = cmplx ( alphar ( j ), zero , real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), zero , real64 ) end do else ! Complex-Valued jp1 = j + 1 alpha ( j ) = cmplx ( alphar ( j ), alphai ( j ), real64 ) alpha ( jp1 ) = cmplx ( alphar ( jp1 ), alphai ( jp1 ), real64 ) do i = 1 , n vecs ( i , j ) = cmplx ( vr ( i , j ), vr ( i , jp1 ), real64 ) vecs ( i , jp1 ) = conjg ( vecs ( i , j )) end do ! Increment j and continue j = j + 2 cycle end if ! Increment j j = j + 1 end do if (. not . present ( beta )) alpha = alpha / bptr else ! Compute just the eigenvalues if ( present ( beta )) then call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & beta , dummy , n , dummy , n , w , lwork1 , flag ) else call DGGEV ( jobvl , jobvr , n , a , n , b , n , alphar , alphai , & bptr , dummy , n , dummy , n , w , lwork1 , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"eigen_gen\" , & \"The algorithm failed to converge.\" , LA_CONVERGENCE_ERROR ) return end if ! Store the eigenvalues do i = 1 , n alpha ( i ) = cmplx ( alphar ( i ), alphai ( i ), real64 ) end do if (. not . present ( beta )) alpha = alpha / bptr end if end subroutine ! ------------------------------------------------------------------------------ subroutine eigen_cmplx ( a , vals , vecs , work , olwork , rwork , err ) !! Computes the eigenvalues, and optionally the eigenvectors, of a matrix !! by solving the eigenvalue problem A \\vec{v} = \\lambda \\vec{v} when !! A is square, but not necessarily symmetric. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix on which to operate.  On output, the !! contents of this matrix are overwritten. complex ( real64 ), intent ( out ), dimension (:) :: vals !! An N-element array containing the eigenvalues of the matrix.  The !! eigenvalues are not sorted. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vecs !! An optional N-by-N matrix, that if supplied, signals to compute the !! right eigenvectors (one per column).  If not provided, only the !! eigenvalues will be computed. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 2 * N. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns without !! performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables character :: jobvl , jobvr integer ( int32 ) :: n , flag , lwork , lrwork real ( real64 ) :: rdummy ( 1 ) complex ( real64 ) :: temp ( 1 ), dummy ( 1 ), dummy_mtx ( 1 , 1 ) complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: rwrk real ( real64 ), pointer , dimension (:) :: rwptr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if jobvl = 'N' if ( present ( vecs )) then jobvr = 'V' else jobvr = 'N' end if n = size ( a , 1 ) lrwork = 2 * n ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"eigen_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( vals ) /= n ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"vals\" , n , & size ( vals )) return else if ( present ( vecs )) then if ( size ( vecs , 1 ) /= n . or . size ( vecs , 2 ) /= n ) then call report_matrix_size_error ( \"eigen_cmplx\" , errmgr , \"vecs\" , n , n , & size ( vecs , 1 ), size ( vecs , 2 )) return end if end if ! Workspace Query call ZGEEV ( jobvl , jobvr , n , a , n , dummy , dummy_mtx , n , dummy_mtx , n , temp , & - 1 , rdummy , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work else allocate ( wrk ( lwork ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"eigen_cmplx\" , errmgr , flag ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"eigen_cmplx\" , errmgr , \"rwork\" , & lrwork , size ( rwork )) return end if rwptr => rwork else allocate ( rwrk ( lrwork ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"eigen_cmplx\" , errmgr , flag ) return end if rwptr => rwrk end if ! Process if ( present ( vecs )) then call ZGEEV ( jobvl , jobvr , n , a , n , vals , dummy_mtx , n , vecs , n , & wptr , lwork , rwptr , flag ) else call ZGEEV ( jobvl , jobvr , n , a , n , vals , dummy_mtx , n , dummy_mtx , n , & wptr , lwork , rwptr , flag ) end if if ( flag > 0 ) then call errmgr % report_error ( \"eigen_cmplx\" , & \"The algorithm failed to converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_eigen.f90.html"},{"title":"linalg_lu.f90 – LINALG","text":"Source Code module linalg_lu use iso_fortran_env use linalg_errors use linalg_sparse use linalg_basic use ferror use lapack use sparskit implicit none private public :: lu_factor public :: form_lu public :: solve_lu interface lu_factor module procedure :: lu_factor_dbl module procedure :: lu_factor_cmplx module procedure :: csr_lu_factor end interface interface form_lu module procedure :: form_lu_all module procedure :: form_lu_all_cmplx module procedure :: form_lu_only module procedure :: form_lu_only_cmplx end interface interface solve_lu module procedure :: solve_lu_mtx module procedure :: solve_lu_mtx_cmplx module procedure :: solve_lu_vec module procedure :: solve_lu_vec_cmplx module procedure :: csr_lu_solve end interface contains ! ------------------------------------------------------------------------------ subroutine lu_factor_dbl ( a , ipvt , err ) !! Computes the LU factorization of an M-by-N matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix on which to operate.  On output, the !! LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. integer ( int32 ), intent ( out ), dimension (:) :: ipvt !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I). class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( ipvt ) /= mn ) then ! ERROR: IPVT not sized correctly call report_array_size_error ( \"lu_factor_dbl\" , errmgr , \"ipvt\" , mn , & size ( ipvt )) return end if ! Compute the LU factorization by calling the LAPACK routine DGETRF call DGETRF ( m , n , a , m , ipvt , flag ) ! If flag > 0, the matrix is singular.  Notice, flag should not be ! able to be < 0 as we've already verrified inputs prior to making the ! call to LAPACK if ( flag > 0 ) then ! WARNING: Singular matrix call report_singular_matrix_warning ( \"lu_factor_dbl\" , errmgr , flag ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine lu_factor_cmplx ( a , ipvt , err ) !! Computes the LU factorization of an M-by-N matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix on which to operate.  On output, the !! LU factored matrix in the form [L\\\\U] where the unit diagonal !! elements of L are not stored. integer ( int32 ), intent ( out ), dimension (:) :: ipvt !! An MIN(M, N)-element array used to track row-pivot operations.  The !! array stored pivot information such that row I is interchanged with !! row IPVT(I). class ( errors ), intent ( inout ), optional , target :: err !! An error object to report any errors that occur. ! Local Variables integer ( int32 ) :: m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( ipvt ) /= mn ) then ! ERROR: IPVT not sized correctly call errmgr % report_error ( \"lu_factor_cmplx\" , & \"Incorrectly sized input array IPVT, argument 2.\" , & LA_ARRAY_SIZE_ERROR ) return end if ! Compute the LU factorization by calling the LAPACK routine ZGETRF call ZGETRF ( m , n , a , m , ipvt , flag ) ! If flag > 0, the matrix is singular.  Notice, flag should not be ! able to be < 0 as we've already verrified inputs prior to making the ! call to LAPACK if ( flag > 0 ) then ! WARNING: Singular matrix call report_singular_matrix_warning ( \"lu_factor_cmplx\" , errmgr , flag ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine csr_lu_factor ( a , lu , ju , droptol , err ) !! Factors a matrix using an LU decomposition. class ( csr_matrix ), intent ( in ) :: a !! The matrix to factor. type ( msr_matrix ), intent ( out ) :: lu !! The LU matrix. integer ( int32 ), intent ( out ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( in ), optional :: droptol !! The drop tolerance for the ILUT factorization. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , m , n , nn , nnz , lfil , iwk , ierr , flag integer ( int32 ), allocatable , dimension (:) :: jlu , jw real ( real64 ), allocatable , dimension (:) :: alu , w real ( real64 ) :: dt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( droptol )) then dt = droptol else dt = sqrt ( epsilon ( dt )) end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Check if ( size ( ju ) /= m ) then call report_array_size_error ( \"csr_lu_factor\" , errmgr , \"ju\" , m , size ( ju )) return end if ! Parameter Determination lfil = 1 do i = 1 , m lfil = max ( lfil , a % row_indices ( i + 1 ) - a % row_indices ( i )) end do iwk = max ( lfil * m , nnz ) ! somewhat arbitrary - can be adjusted ! Local Memory Allocation allocate ( alu ( iwk ), w ( n + 1 ), jlu ( iwk ), jw ( 2 * n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Factorization do ! Factor the matrix call ilut ( n , a % values , a % column_indices , a % row_indices , lfil , dt , & alu , jlu , ju , iwk , w , jw , ierr ) ! Check the error flag if ( ierr == 0 ) then ! Success exit else if ( ierr > 0 ) then ! Zero pivot else if ( ierr == - 1 ) then ! The input matrix is not formatted correctly go to 20 else if ( ierr == - 2 . or . ierr == - 3 ) then ! ALU and JLU are too small - try something larger ! This is the main reason for the loop - to offload worrying about ! workspace size from the user iwk = min ( iwk + m + n , m * n ) deallocate ( alu ) deallocate ( jlu ) allocate ( alu ( iwk ), jlu ( iwk ), stat = flag ) if ( flag /= 0 ) go to 10 else if ( ierr == - 4 ) then ! Illegal value for LFIL - reset and try again lfil = n else if ( ierr == - 5 ) then ! Zero row encountered go to 30 else ! We should never get here, but just in case go to 40 end if end do ! Determine the actual number of non-zero elements nnz = jlu ( m + 1 ) - 1 ! Copy the contents to the output arrays lu % m = m lu % n = n lu % nnz = nnz nn = m + 1 + nnz - min ( m , n ) allocate ( lu % values ( nn ), source = alu (: nn ), stat = flag ) if ( flag /= 0 ) go to 10 allocate ( lu % indices ( nn ), source = jlu (: nn ), stat = flag ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_lu_factor\" , errmgr , flag ) return ! Matrix Format Error 20 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"The input matrix was incorrectly formatted.  A row with more \" // & \"than N entries was found.\" , LA_MATRIX_FORMAT_ERROR ) return ! Zero Row Error 30 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"A row with all zeros was encountered in the matrix.\" , & LA_SINGULAR_MATRIX_ERROR ) return ! Unknown Error 40 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , \"ILUT encountered \" // & \"an unknown error.  The error code from the ILUT routine is \" // & \"provided in the output.\" , ierr ) return ! Zero Pivot Error 50 continue call errmgr % report_error ( \"csr_lu_factor\" , & \"A zero pivot was encountered.\" , LA_SINGULAR_MATRIX_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_all ( lu , ipvt , u , p , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the row permutation matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , jp , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_all\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"form_lu_all\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return else if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Ensure P starts off as an identity matrix call DLASET ( 'A' , n , n , zero , one , p , n ) ! Process do j = 1 , n ! Define the pivot matrix jp = ipvt ( j ) if ( j /= jp ) call swap ( p ( j , 1 : n ), p ( jp , 1 : n )) ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_all_cmplx ( lu , ipvt , u , p , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the row permutation matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , jp , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 complex ( real64 ), parameter :: c_zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: c_one = ( 1.0d0 , 0.0d0 ) ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_all_cmplx\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"form_lu_all_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all_cmplx\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return else if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_all_cmplx\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Ensure P starts off as an identity matrix call DLASET ( 'A' , n , n , zero , one , p , n ) ! Process do j = 1 , n ! Define the pivot matrix jp = ipvt ( j ) if ( j /= jp ) call swap ( p ( j , 1 : n ), p ( jp , 1 : n )) ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = c_zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = c_zero lu ( j , j ) = c_one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_only ( lu , u , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. real ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_only\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_only\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return end if ! Process do j = 1 , n ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine form_lu_only_cmplx ( lu , u , err ) !! Extracts the L and U matrices from the condensed [L\\\\U] storage format !! used by the lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: lu !! On input, the N-by-N matrix as output by lu_factor.  On output, the !! N-by-N lower triangular matrix L. complex ( real64 ), intent ( out ), dimension (:,:) :: u !! An N-by-N matrix where the U matrix will be written. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: j , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Initialization n = size ( lu , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( lu , 2 ) /= n ) then call report_square_matrix_error ( \"form_lu_only_cmplx\" , errmgr , \"lu\" , n , & size ( lu , 1 ), size ( lu , 2 )) return else if ( size ( u , 1 ) /= n . or . size ( u , 2 ) /= n ) then call report_matrix_size_error ( \"form_lu_only_cmplx\" , errmgr , \"u\" , n , n , & size ( u , 1 ), size ( u , 2 )) return end if ! Process do j = 1 , n ! Build L and U u ( 1 : j , j ) = lu ( 1 : j , j ) u ( j + 1 : n , j ) = zero if ( j > 1 ) lu ( 1 : j - 1 , j ) = zero lu ( j , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_mtx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS right-hand-side matrix.  On output, the !! N-by-NRHS solution matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_mtx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_mtx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lu_mtx\" , errmgr , \"b\" , n , & size ( b , 2 ), size ( b , 1 ), size ( b , 2 )) return end if ! Call DGETRS call DGETRS ( \"N\" , n , nrhs , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_mtx_cmplx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the N-by-NRHS right-hand-side matrix.  On output, the !! N-by-NRHS solution matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , nrhs , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) nrhs = size ( b , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b , 1 ) /= n ) then call report_matrix_size_error ( \"solve_lu_mtx_cmplx\" , errmgr , \"b\" , n , & size ( b , 2 ), size ( b , 1 ), size ( b , 2 )) return end if ! Call ZGETRS call ZGETRS ( \"N\" , n , nrhs , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_vec ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! The N-element right-hand-side array. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_vec\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_vec\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_lu_vec\" , errmgr , \"b\" , n , & size ( b )) return end if ! Call DGETRS call DGETRS ( \"N\" , n , 1 , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_lu_vec_cmplx ( a , ipvt , b , err ) !! Solves a system of LU-factored equations. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N LU factored matrix as output by lu_factor. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! The N-element pivot array as output by lu_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! The N-element right-hand-side array. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_lu_vec_cmplx\" , errmgr , \"a\" , n , & size ( a , 1 ), size ( a , 2 )) return else if ( size ( ipvt ) /= n ) then call report_array_size_error ( \"solve_lu_vec_cmplx\" , errmgr , \"ipvt\" , n , & size ( ipvt )) return else if ( size ( b ) /= n ) then call report_array_size_error ( \"solve_lu_vec_cmplx\" , errmgr , \"b\" , n , & size ( b )) return end if ! Call ZGETRS call ZGETRS ( \"N\" , n , 1 , a , n , ipvt , b , n , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_lu_solve ( lu , ju , b , x , err ) !! Solves a linear system using an LU decomposition. class ( msr_matrix ), intent ( in ) :: lu !! The LU matrix. integer ( int32 ), intent ( in ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( in ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( lu , 1 ) n = size ( lu , 2 ) ! Input Check if ( m /= n ) then call report_square_matrix_error ( \"csr_lu_solve\" , errmgr , \"lu\" , m , m , n ) return end if if ( size ( x ) /= m ) then call report_inner_matrix_dimension_error ( \"csr_lu_solve\" , errmgr , & \"lu\" , \"x\" , m , size ( x )) return end if if ( size ( b ) /= m ) then call report_array_size_error ( \"csr_lu_solve\" , errmgr , \"b\" , m , size ( b )) return end if if ( size ( ju ) /= m ) then call report_array_size_error ( \"csr_lu_solve\" , errmgr , \"ju\" , m , size ( ju )) return end if ! Process call lusol ( m , b , x , lu % values , lu % indices , ju ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_lu.f90.html"},{"title":"linalg_tri.f90 – LINALG","text":"Source Code module linalg_tri use iso_fortran_env use blas use linalg_errors implicit none private public :: solve_triangular_system interface solve_triangular_system module procedure :: solve_tri_mtx module procedure :: solve_tri_mtx_cmplx module procedure :: solve_tri_vec module procedure :: solve_tri_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ module subroutine solve_tri_mtx ( lside , upper , trans , nounit , alpha , a , b , err ) !! Solves a triangular system of equations of the form !! op(A) X = \\alpha B or X op(A) = \\alpha B where A is a !! triangular matrix (either upper or lower) for the unknown X. logical , intent ( in ) :: lside !! Set to true to solve op(A) X = \\alpha B; else, set to false to !! solve X op(A) = \\alpha B. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if !! A is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. real ( real64 ), intent ( in ) :: alpha !! The scalar multiplier \\alpha. real ( real64 ), intent ( in ), dimension (:,:) :: a !! If lside is true, the M-by-M triangular matrix A; else, A is !! N-by-N if lside is false. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-N matrix B.  On output, the M-by-N solution !! matrix X. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters character :: side , uplo , transa , diag ! Local Variables integer ( int32 ) :: m , n , nrowa class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) if ( lside ) then nrowa = m side = 'L' else nrowa = n side = 'R' end if if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then transa = 'T' else transa = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check - matrix A must be square if ( size ( a , 1 ) /= nrowa . or . size ( a , 2 ) /= nrowa ) then call report_matrix_size_error ( \"solve_tri_mtx\" , errmgr , \"a\" , & nrowa , nrowa , size ( a , 1 ), size ( a , 2 )) return end if ! Call DTRSM call DTRSM ( side , uplo , transa , diag , m , n , alpha , a , nrowa , b , m ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_mtx_cmplx ( lside , upper , trans , nounit , alpha , a , b , err ) !! Solves a triangular system of equations of the form !! op(A) X = \\alpha B or X op(A) = \\alpha B where A is a !! triangular matrix (either upper or lower) for the unknown X. logical , intent ( in ) :: lside !! Set to true to solve op(A) X = \\alpha B; else, set to false to !! solve X op(A) = \\alpha B. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if !! A is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;H; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. complex ( real64 ), intent ( in ) :: alpha !! The scalar multiplier \\alpha. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! If lside is true, the M-by-M triangular matrix A; else, A is !! N-by-N if lside is false. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-N matrix B.  On output, the M-by-N solution !! matrix X. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters character :: side , uplo , transa , diag ! Local Variables integer ( int32 ) :: m , n , nrowa class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) if ( lside ) then nrowa = m side = 'L' else nrowa = n side = 'R' end if if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then transa = 'C' else transa = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check - matrix A must be square if ( size ( a , 1 ) /= nrowa . or . size ( a , 2 ) /= nrowa ) then call report_matrix_size_error ( \"solve_tri_mtx_cmplx\" , errmgr , \"a\" , & nrowa , nrowa , size ( a , 1 ), size ( a , 2 )) return end if ! Call ZTRSM call ZTRSM ( side , uplo , transa , diag , m , n , alpha , a , nrowa , b , m ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_vec ( upper , trans , nounit , a , x , err ) !! Solves the triangular system op(A) \\vec{x} = \\vec{b} where A !! is a triangular matrix. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if A !! is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular matrix A. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the N-element vector \\vec{b}.  On output, the !! N-element solution vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo , t , diag integer ( int32 ) :: n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then t = 'T' else t = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_tri_vec\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"solve_tri_vec\" , errmgr , & \"a\" , \"x\" , n , size ( x )) return end if ! Call DTRSV call DTRSV ( uplo , t , diag , n , a , n , x , 1 ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_tri_vec_cmplx ( upper , trans , nounit , a , x , err ) !! Solves the triangular system op(A) \\vec{x} = \\vec{b} where A !! is a triangular matrix. logical , intent ( in ) :: upper !! Set to true if A is upper triangular; else, set to false if A !! is lower triangular. logical , intent ( in ) :: trans !! Set to true if op(A) = A&#94;T; else, set to false if op(A) = A. logical , intent ( in ) :: nounit !! Set to true if A is unit-triangular (ones on the diagonal); else, !! false if A is not unit-triangular. complex ( real64 ), intent ( in ), dimension (:,:) :: a !! The N-by-N triangular matrix A. complex ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the N-element vector \\vec{b}.  On output, the !! N-element solution vector \\vec{x}. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables character :: uplo , t , diag integer ( int32 ) :: n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( upper ) then uplo = 'U' else uplo = 'L' end if if ( trans ) then t = 'C' else t = 'N' end if if ( nounit ) then diag = 'N' else diag = 'U' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"solve_tri_vec_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return else if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"solve_tri_vec_cmplx\" , & errmgr , \"a\" , \"x\" , n , size ( x )) return end if ! Call ZTRSV call ZTRSV ( uplo , t , diag , n , a , n , x , 1 ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_tri.f90.html"},{"title":"linalg_svd.f90 – LINALG","text":"Source Code module linalg_svd use iso_fortran_env , only : int32 , real64 use lapack use linalg_errors implicit none private public :: svd interface svd module procedure :: svd_dbl module procedure :: svd_cmplx end interface contains ! ------------------------------------------------------------------------------ module subroutine svd_dbl ( a , s , u , vt , work , olwork , err ) !! Computes the singular value decomposition of an M-by-N matrix A such !! that A = U S V&#94;T where U is an M-by-M orthogonal matrix, S !! is an M-by-N diagonal matrix containing the singular values, and V !! is an N-by-N orthogonal matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  The matrix is overwritten on !! output. real ( real64 ), intent ( out ), dimension (:) :: s !! A MIN(M, N)-element array containing the singular values of a sorted !! in descending order. real ( real64 ), intent ( out ), optional , dimension (:,:) :: u !! An optional argument, that if supplied, is used to contain the !! orthogonal matrix U from the decomposition.  The matrix U !! contains the left singular vectors, and can be either M-by-M !! (all left singular vectors are computed), or M-by-MIN(M,N) (only the !! first MIN(M, N) left singular vectors are computed). real ( real64 ), intent ( out ), optional , dimension (:,:) :: vt !! An optional argument, that if supplied, is used to contain the !! transpose of the N-by-N orthogonal matrix V.  The matrix V !! contains the right singular vectors. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: jobu , jobvt integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else if ( size ( u , 2 ) == mn ) then jobu = 'S' end if else jobu = 'N' end if if ( present ( vt )) then jobvt = 'A' else jobvt = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( s ) /= mn ) then call report_array_size_error ( \"svd_dbl\" , errmgr , \"s\" , mn , size ( s )) return else if ( present ( u )) then if ( size ( u , 1 ) /= m ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if if ( size ( u , 2 ) /= m . and . size ( u , 2 ) /= mn ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if else if ( present ( vt )) then if ( size ( vt , 1 ) /= n . or . size ( vt , 2 ) /= n ) then call report_matrix_size_error ( \"svd_dbl\" , errmgr , \"vt\" , n , n , & size ( vt , 1 ), size ( vt , 2 )) return end if end if ! Workspace Query call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , temp , - 1 , & flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"svd_dbl\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGESVD if ( present ( u ) . and . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , u , m , vt , n , wptr , lwork , & flag ) else if ( present ( u ) . and . . not . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , u , m , temp , n , wptr , & lwork , flag ) else if (. not . present ( u ) . and . present ( vt )) then call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , vt , n , wptr , & lwork , flag ) else call DGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , wptr , & lwork , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"svd_dbl\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine svd_cmplx ( a , s , u , vt , work , olwork , rwork , err ) !! Computes the singular value decomposition of an M-by-N matrix A such !! that A = U S V&#94;H where U is an M-by-M orthogonal matrix, S !! is an M-by-N diagonal matrix containing the singular values, and V !! is an N-by-N orthogonal matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  The matrix is overwritten on !! output. real ( real64 ), intent ( out ), dimension (:) :: s !! A MIN(M, N)-element array containing the singular values of a sorted !! in descending order. complex ( real64 ), intent ( out ), optional , dimension (:,:) :: u !! An optional argument, that if supplied, is used to contain the !! orthogonal matrix U from the decomposition.  The matrix U !! contains the left singular vectors, and can be either M-by-M !! (all left singular vectors are computed), or M-by-MIN(M,N) (only the !! first MIN(M, N) left singular vectors are computed). complex ( real64 ), intent ( out ), optional , dimension (:,:) :: vt !! An optional argument, that if supplied, is used to contain the !! conjugate transpose of the N-by-N orthogonal matrix V.  The !! matrix V contains the right singular vectors. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the memory !! required is allocated within.  If provided, the length of the array !! must be at least 5 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: jobu , jobvt integer ( int32 ) :: m , n , mn , istat , lwork , flag , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp real ( real64 ), dimension ( 1 ) :: rtemp real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 5 * mn if ( present ( u )) then if ( size ( u , 2 ) == m ) then jobu = 'A' else if ( size ( u , 2 ) == mn ) then jobu = 'S' end if else jobu = 'N' end if if ( present ( vt )) then jobvt = 'A' else jobvt = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( s ) /= mn ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"s\" , mn , size ( s )) return else if ( present ( u )) then if ( size ( u , 1 ) /= m ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if if ( size ( u , 2 ) /= m . and . size ( u , 2 ) /= mn ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"u\" , m , m , & size ( u , 1 ), size ( u , 2 )) return end if else if ( present ( vt )) then if ( size ( vt , 1 ) /= n . or . size ( vt , 2 ) /= n ) then call report_matrix_size_error ( \"svd_cmplx\" , errmgr , \"vt\" , n , n , & size ( vt , 1 ), size ( vt , 2 )) return end if end if ! Workspace Query call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"svd_cmplx\" , errmgr , \"rwork\" , lrwork , & size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"svd_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if ! Call ZGESVD if ( present ( u ) . and . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , u , m , vt , n , wptr , lwork , & rwptr , flag ) else if ( present ( u ) . and . . not . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , u , m , temp , n , wptr , & lwork , rwptr , flag ) else if (. not . present ( u ) . and . present ( vt )) then call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , vt , n , wptr , & lwork , rwptr , flag ) else call ZGESVD ( jobu , jobvt , m , n , a , m , s , temp , m , temp , n , wptr , & lwork , rwptr , flag ) end if ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"svd_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_svd.f90.html"},{"title":"linalg_rz.f90 – LINALG","text":"Source Code module linalg_rz use iso_fortran_env , only : int32 , real64 use linalg_errors use lapack use ferror implicit none private public :: rz_factor public :: mult_rz interface rz_factor module procedure :: rz_factor_dbl module procedure :: rz_factor_cmplx end interface interface mult_rz module procedure :: mult_rz_mtx module procedure :: mult_rz_mtx_cmplx module procedure :: mult_rz_vec module procedure :: mult_rz_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine rz_factor_dbl ( a , tau , work , olwork , err ) !! Factors an upper trapezoidal matrix by means of orthogonal !! transformations such that A = R Z = (R 0) Z . Z is an orthogonal !! matrix of dimension N-by-N, and R is an M-by-M upper triangular !! matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N upper trapezoidal matrix to factor.  On output, !! the leading M-by-M upper triangular part of the matrix contains the !! upper triangular matrix R, and elements N-L+1 to N of the !! first M rows of A, with the array tau, represent the orthogonal !! matrix Z as a product of M elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! An M-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , lwork , flag , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= m ) then call report_array_size_error ( \"rz_factor_dbl\" , errmgr , \"tau\" , m , & size ( tau )) return end if ! Workspace Query call DTZRZF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"rz_factor_dbl\" , errmgr , \"lwork\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"rz_factor_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Call DTZRZF call DTZRZF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine rz_factor_cmplx ( a , tau , work , olwork , err ) !! Factors an upper trapezoidal matrix by means of orthogonal !! transformations such that A = R Z = (R 0) Z . Z is an orthogonal !! matrix of dimension N-by-N, and R is an M-by-M upper triangular !! matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N upper trapezoidal matrix to factor.  On output, !! the leading M-by-M upper triangular part of the matrix contains the !! upper triangular matrix R, and elements N-L+1 to N of the !! first M rows of A, with the array tau, represent the orthogonal !! matrix Z as a product of M elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! An M-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , lwork , flag , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( tau ) /= m ) then call report_array_size_error ( \"rz_factor_cmplx\" , errmgr , \"tau\" , m , & size ( tau )) return end if ! Workspace Query call ZTZRZF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"rz_factor_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"rz_factor_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZTZRZF call ZTZRZF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_mtx ( lside , trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C or C = C op(Z) logical , intent ( in ) :: lside !! Set to true to compute C = op(Z) C; else, set to false to !! compute C = C op(Z). logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors.  If lside is true, M \\ge L \\ge 0; !! else, if lside is false, N \\ge L \\ge 0. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the K-by-LTA matrix Z, where LTA = M if !! lside is true; else, LTA = N if lside is false.  The I-th row !! must contain the Householder vector in the last k rows. Notice, !! the contents of this matrix are restored on exit. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product !! of the orthogonal matrix Z and the original matrix C. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of the elementary !! reflectors, where M \\ge K \\ge 0 if lside is true; else, !! N \\ge K \\ge 0 if lside is false. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , lwork , flag , istat , lda real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) lda = size ( a , 1 ) if ( lside ) then side = 'L' else side = 'R' end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( l > m . or . l < 0 ) then flag = 3 else if ( k > m ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 4 end if else if ( l > n . or . l < 0 ) then flag = 3 else if ( k > n ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= n ) then flag = 4 end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_mtx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call DORMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_mtx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMRZ call DORMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_mtx_cmplx ( lside , trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C or C = C op(Z). logical , intent ( in ) :: lside !! Set to true to compute C = op(Z) C; else, set to false to !! compute C = C op(Z). logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors.  If lside is true, M \\ge L \\ge 0; !! else, if lside is false, N \\ge L \\ge 0. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the K-by-LTA matrix Z, where LTA = M if !! lside is true; else, LTA = N if lside is false.  The I-th row !! must contain the Householder vector in the last k rows. Notice, !! the contents of this matrix are restored on exit. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product !! of the orthogonal matrix Z and the original matrix C. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of the elementary !! reflectors, where M \\ge K \\ge 0 if lside is true; else, !! N \\ge K \\ge 0 if lside is false. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , lwork , flag , istat , lda complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) lda = size ( a , 1 ) if ( lside ) then side = 'L' else side = 'R' end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( lside ) then if ( l > m . or . l < 0 ) then flag = 3 else if ( k > m ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 4 end if else if ( l > n . or . l < 0 ) then flag = 3 else if ( k > n ) then flag = 5 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= n ) then flag = 4 end if end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_mtx_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call ZUNMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMRZ call ZUNMRZ ( side , t , m , n , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_vec ( trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C. logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the M-by-M matrix Z.  The I-th row must contain !! the Householder vector in the last k rows. Notice, the contents !! of this matrix are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! An M-element array containing the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element array C.  On output, the product !! of Z and C. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , k , lwork , flag , istat , lda real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) lda = size ( a , 1 ) side = 'L' if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( l > m . or . l < 0 ) then flag = 2 else if ( k > m ) then flag = 4 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_vec\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call DORMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMRZ call DORMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_rz_vec_cmplx ( trans , l , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Z from an !! RZ factorization such that C = op(Z) C. logical , intent ( in ) :: trans !! Set to true if op(Z) = Z&#94;{T}; else, set to false if !! op(Z) = Z. integer ( int32 ), intent ( in ) :: l !! The number of columns in matrix A containing the meaningful part !! of the Householder vectors. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input the M-by-M matrix Z.  The I-th row must contain !! the Householder vector in the last k rows. Notice, the contents !! of this matrix are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! An M-element array containing the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element array C.  On output, the product !! of Z and C. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for @p work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables character :: side , t integer ( int32 ) :: m , k , lwork , flag , istat , lda complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) lda = size ( a , 1 ) side = 'L' if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( l > m . or . l < 0 ) then flag = 2 else if ( k > m ) then flag = 4 else if ( size ( a , 1 ) < k . or . size ( a , 2 ) /= m ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: One of the input arrays is not sized correctly allocate ( character ( len = 256 ) :: errmsg ) write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"mult_rz_vec_cmplx\" , trim ( errmsg ), & LA_ARRAY_SIZE_ERROR ) return end if ! Workspace Query call ZUNMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_rz_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_rz_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMRZ call ZUNMRZ ( side , t , m , 1 , k , l , a , lda , tau , c , m , wptr , lwork , flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_rz.f90.html"},{"title":"linalg_qr.f90 – LINALG","text":"Source Code module linalg_qr use iso_fortran_env use linalg_errors use linalg_rz use linalg_tri use lapack use blas use ferror use qrupdate implicit none private public :: qr_factor public :: form_qr public :: mult_qr public :: qr_rank1_update public :: solve_qr interface qr_factor module procedure :: qr_factor_no_pivot module procedure :: qr_factor_no_pivot_cmplx module procedure :: qr_factor_pivot module procedure :: qr_factor_pivot_cmplx end interface interface form_qr module procedure :: form_qr_no_pivot module procedure :: form_qr_no_pivot_cmplx module procedure :: form_qr_pivot module procedure :: form_qr_pivot_cmplx end interface interface mult_qr module procedure :: mult_qr_mtx module procedure :: mult_qr_mtx_cmplx module procedure :: mult_qr_vec module procedure :: mult_qr_vec_cmplx end interface interface qr_rank1_update module procedure :: qr_rank1_update_dbl module procedure :: qr_rank1_update_cmplx end interface interface solve_qr module procedure :: solve_qr_no_pivot_mtx module procedure :: solve_qr_no_pivot_mtx_cmplx module procedure :: solve_qr_no_pivot_vec module procedure :: solve_qr_no_pivot_vec_cmplx module procedure :: solve_qr_pivot_mtx module procedure :: solve_qr_pivot_mtx_cmplx module procedure :: solve_qr_pivot_vec module procedure :: solve_qr_pivot_vec_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine qr_factor_no_pivot ( a , tau , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then ! ERROR: TAU not sized correctly call report_array_size_error ( \"qr_factor_no_pivot\" , errmgr , \"tau\" , mn , & size ( tau )) return end if ! Workspace Query call DGEQRF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"qr_factor_no_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Call DGEQRF call DGEQRF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_no_pivot_cmplx ( a , tau , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return end if ! Workspace Query call ZGEQRF ( m , n , a , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , & \"tau\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGEQRF call ZGEQRF ( m , n , a , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_pivot ( a , tau , jpvt , work , olwork , err ) !! Computes the QR factorization of an M-by-N matrix using column pivoting !! such that A P = Q R. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. real ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. integer ( int32 ), intent ( inout ), dimension (:) :: jpvt !! On input, an N-element array that if JPVT(I) .ne. 0, the I-th column !! of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th !! column of A is a free column.  On output, if JPVT(I) = K, then the !! I-th column of A * P was the K-th column of A. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag real ( real64 ), dimension ( 1 ) :: temp real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"tau\" , mn , & size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"jpvt\" , n , & size ( jpvt )) return end if ! Workspace Query call DGEQP3 ( m , n , a , m , jpvt , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_pivot\" , errmgr , istat ) end if wptr => wrk end if ! Call DGEQP3 call DGEQP3 ( m , n , a , m , jpvt , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_factor_pivot_cmplx ( a , tau , jpvt , work , olwork , rwork , err ) !! Computes the QR factorization of an M-by-N matrix using column pivoting !! such that A P = Q R. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the elements on !! and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal !! matrix R (R is upper triangular if M >= N).  The elements below the !! diagonal, along with the array tau, represent the orthogonal matrix !! Q as a product of elementary reflectors. complex ( real64 ), intent ( out ), dimension (:) :: tau !! A MIN(M, N)-element array used to store the scalar factors of the !! elementary reflectors. integer ( int32 ), intent ( inout ), dimension (:) :: jpvt !! On input, an N-element array that if JPVT(I) .ne. 0, the I-th column !! of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th !! column of A is a free column.  On output, if JPVT(I) = K, then the !! I-th column of A * P was the K-th column of A. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , dimension (:), optional :: rwork !! An optional input, that if provided, prevents any local allocate of !! real-valued memory.  If not provided, the memory required is !! allocated within.  If provided, the length of the array must be at !! least 2*N. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , istat , lwork , flag complex ( real64 ), dimension ( 1 ) :: temp complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return end if if ( present ( rwork )) then if ( size ( rwork ) < 2 * n ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"rwork\" , 2 * n , size ( rwork )) return end if rptr => rwork ( 1 : 2 * n ) else allocate ( rwrk ( 2 * n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"qr_factor_pivot_cmplx\" , errmgr , flag ) return end if rptr => rwrk end if ! Workspace Query call ZGEQP3 ( m , n , a , m , jpvt , tau , temp , - 1 , rptr , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_factor_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_factor_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZGEQP3 call ZGEQP3 ( m , n , a , m , jpvt , tau , wptr , lwork , rptr , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_no_pivot ( r , tau , q , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , m , n , mn , qcol , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) qcol = size ( q , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_qr_no_pivot\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= m . or . ( qcol /= m . and . qcol /= n )) then call report_matrix_size_error ( \"form_qr_no_pivot\" , errmgr , \"q\" , m , mn , & size ( q , 1 ), size ( q , 2 )) return else if ( qcol == n . and . m < n ) then call report_matrix_size_error ( \"form_qr_no_pivot\" , errmgr , \"q\" , m , m , & size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call DORGQR ( m , qcol , mn , q , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_qr_no_pivot\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_qr_no_pivot\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the sub-diagonal portion of R to Q, and then zero out the ! sub-diagonal portion of R do j = 1 , mn q ( j + 1 : m , j ) = r ( j + 1 : m , j ) r ( j + 1 : m , j ) = zero end do ! Build Q - Build M-by-M or M-by-N, but M-by-N only for M >= N call DORGQR ( m , qcol , mn , q , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_no_pivot_cmplx ( r , tau , q , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , m , n , mn , qcol , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) qcol = size ( q , 2 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( q , 1 ) /= m . or . ( qcol /= m . and . qcol /= n )) then call report_matrix_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"q\" , & m , mn , size ( q , 1 ), size ( q , 2 )) return else if ( qcol == n . and . m < n ) then call report_matrix_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return end if ! Workspace Query call ZUNGQR ( m , qcol , mn , q , m , tau , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"form_qr_no_pivot_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"form_qr_no_pivot_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Copy the sub-diagonal portion of R to Q, and then zero out the ! sub-diagonal portion of R do j = 1 , mn q ( j + 1 : m , j ) = r ( j + 1 : m , j ) r ( j + 1 : m , j ) = zero end do ! Build Q - Build M-by-M or M-by-N, but M-by-N only for M >= N call ZUNGQR ( m , qcol , mn , q , m , tau , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine form_qr_pivot ( r , tau , pvt , q , p , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. integer ( int32 ), intent ( in ), dimension (:) :: pvt !! An N-element column pivot array as returned by the QR factorization. real ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. real ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the pivot matrix will be written. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: j , jp , m , n , mn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_qr_pivot\" , errmgr , \"p\" , n , n , & size ( p , 1 ), size ( p , 2 )) return end if ! Generate Q and R call form_qr_no_pivot ( r , tau , q , work = work , olwork = olwork , & err = errmgr ) if ( present ( olwork )) return ! Just a workspace query if ( errmgr % has_error_occurred ()) return ! Form P do j = 1 , n jp = pvt ( j ) p (:, j ) = zero p ( jp , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ module subroutine form_qr_pivot_cmplx ( r , tau , pvt , q , p , work , olwork , err ) !! Forms the full M-by-M orthogonal matrix Q from the elementary !! reflectors returned by the base QR factorization algorithm. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, an M-by-N matrix where the elements below the diagonal !! contain the elementary reflectors generated from the QR !! factorization.  On and above the diagonal, the matrix contains the !! matrix R.  On output, the elements below the diagonal are zeroed !! such that the remaining matrix is simply the M-by-N matrix R. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of each !! elementary reflector defined in R. integer ( int32 ), intent ( in ), dimension (:) :: pvt !! An N-element column pivot array as returned by the QR factorization. complex ( real64 ), intent ( out ), dimension (:,:) :: q !! An M-by-M matrix where the full orthogonal matrix Q will be !! written.  In the event that M > N, Q may be supplied as M-by-N, !! and therefore only return the useful submatrix Q_1 !! Q = [Q_1 Q_2] as the factorization can be written as !! Q R = [Q_1, Q_2] [R1 0]&#94;T. complex ( real64 ), intent ( out ), dimension (:,:) :: p !! An N-by-N matrix where the pivot matrix will be written. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , jp , m , n , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( r , 1 ) n = size ( r , 2 ) mn = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( p , 1 ) /= n . or . size ( p , 2 ) /= n ) then call report_matrix_size_error ( \"form_qr_pivot_cmplx\" , errmgr , \"p\" , & n , n , size ( p , 1 ), size ( p , 2 )) return end if ! Generate Q and R call form_qr_no_pivot_cmplx ( r , tau , q , work = work , olwork = olwork , & err = errmgr ) if ( present ( olwork )) return ! Just a workspace query if ( errmgr % has_error_occurred ()) return ! Form P do j = 1 , n jp = pvt ( j ) p (:, j ) = zero p ( jp , j ) = one end do end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_mtx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that C = op(Q) C or C = C op(Q). logical , intent ( in ) :: lside !! Set to true to apply Q or Q&#94;T from the left; else, set to !! false to apply Q or Q&#94;T from the right. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;T; else, set to false to apply Q. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an LDA-by-K matrix containing the elementary reflectors !! output from the QR factorization.  If lside is set to true, LDA = M, !! and M >= K >= 0; else, if lside is set to false, LDA = N, and !! N >= K >= 0.  Notice, the contents of this matrix are !! restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. real ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , nrowa , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' nrowa = m else side = 'R' nrowa = n end if if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then ! A is M-by-K, M >= K >= 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if else ! A is N-by-K, N >= K >= 0 if ( size ( a , 1 ) /= n . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx\" , errmgr , \"a\" , n , k , & size ( a , 1 ), size ( a , 2 )) return end if end if ! Workspace Query call DORMQR ( side , t , m , n , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_mtx\" , errmgr , \"work\" , lwork , & size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMQR call DORMQR ( side , t , m , n , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_mtx_cmplx ( lside , trans , a , tau , c , work , olwork , err ) !! Multiplies a general matrix by the orthogonal matrix Q from a QR !! factorization such that C = op(Q) C or C = C op(Q). logical , intent ( in ) :: lside !! Set to true to apply Q or Q&#94;H from the left; else, set to !! false to apply Q or Q&#94;H from the right. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;H; else, set to false to apply Q. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an LDA-by-K matrix containing the elementary reflectors !! output from the QR factorization.  If lside is set to true, LDA = M, !! and M >= K >= 0; else, if lside is set to false, LDA = N, and !! N >= K >= 0.  Notice, the contents of this matrix are !! restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. complex ( real64 ), intent ( inout ), dimension (:,:) :: c !! On input, the M-by-N matrix C.  On output, the product of the !! orthogonal matrix Q and the original matrix C. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables character :: side , t integer ( int32 ) :: m , n , k , nrowa , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c , 1 ) n = size ( c , 2 ) k = size ( tau ) if ( lside ) then side = 'L' nrowa = m else side = 'R' nrowa = n end if if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( lside ) then ! A is M-by-K, M >= K >= 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"a\" , & m , k , size ( a , 1 ), size ( a , 2 )) return end if else ! A is N-by-K, N >= K >= 0 if ( size ( a , 1 ) /= n . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"a\" , & n , k , size ( a , 1 ), size ( a , 2 )) return end if end if ! Workspace Query call ZUNMQR ( side , t , m , n , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"mult_qr_mtx_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMQR call ZUNMQR ( side , t , m , n , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_vec ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector by the orthogonal matrix Q from a QR !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;T; else, set to false to apply Q. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an M-by-K matrix containing the elementary reflectors !! output from the QR factorization. Notice, the contents of this matrix !! are restored on exit. real ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. real ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the !! product of the orthogonal matrix Q and the original vector !! \\vec{c}. real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables character :: side , t integer ( int32 ) :: m , k , nrowa , istat , flag , lwork real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( c ) k = size ( tau ) side = 'L' nrowa = m if ( trans ) then t = 'T' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_vec\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DORMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_vec\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Call DORMQR call DORMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine mult_qr_vec_cmplx ( trans , a , tau , c , work , olwork , err ) !! Multiplies a vector by the orthogonal matrix Q from a QR !! factorization such that \\vec{c} = op(Q) \\vec{c}. logical , intent ( in ) :: trans !! Set to true to apply Q&#94;H; else, set to false to apply Q. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, an M-by-K matrix containing the elementary reflectors !! output from the QR factorization. Notice, the contents of this matrix !! are restored on exit. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A K-element array containing the scalar factors of each elementary !! reflector defined inA. complex ( real64 ), intent ( inout ), dimension (:) :: c !! On input, the M-element vector \\vec{c}.  On output, the !! product of the orthogonal matrix Q and the original vector !! \\vec{c}. complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables character :: side , t integer ( int32 ) :: m , k , nrowa , istat , flag , lwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization m = size ( c ) k = size ( tau ) side = 'L' nrowa = m if ( trans ) then t = 'C' else t = 'N' end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check flag = 0 if ( size ( a , 1 ) /= m . or . size ( a , 2 ) < k ) then call report_matrix_size_error ( \"mult_qr_vec_cmplx\" , errmgr , \"a\" , m , k , & size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZUNMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mult_qr_vec_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mult_qr_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Call ZUNMQR call ZUNMQR ( side , t , m , 1 , k , a , nrowa , tau , c , m , wptr , lwork , flag ) end subroutine ! ------------------------------------------------------------------------------ subroutine qr_rank1_update_dbl ( q , r , u , v , work , err ) !! Computes the rank-1 update to an M-by-N QR factored matrix A where !! M \\ge N, A = Q R, and A_1 = A + \\vec{u} \\vec{v}&#94;T such that !! A_1 = Q_1 R_1. real ( real64 ), intent ( inout ), dimension (:,:) :: q !! On input, the original M-by-K orthogonal matrix Q.  On output, !! the updated matrix Q_1. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the M-by-N matrix R.  On output, the updated matrix !! R_1. real ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the M-element \\vec{u} update vector.  On output, the !! original content of the array is overwritten. real ( real64 ), intent ( inout ), dimension (:) :: v !! On input, the N-element \\vec{v} update vector.  On output, the !! original content of the array is overwritten. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least K elements. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables logical :: full integer ( int32 ) :: m , n , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( u , 1 ) n = size ( r , 2 ) k = min ( m , n ) full = size ( q , 2 ) == m lwork = 2 * k if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"qr_rank1_update_dbl\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if (. not . full . and . size ( q , 2 ) /= k ) then call report_matrix_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return else if ( size ( r , 1 ) /= m ) then call report_inner_matrix_dimension_error ( \"qr_rank1_update_dbl\" , & errmgr , \"q\" , \"r\" , m , size ( r , 1 )) return else if ( size ( u ) /= m ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"u\" , m , & size ( u )) return else if ( size ( v ) /= n ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , \"v\" , n , & size ( v )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_rank1_update_dbl\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Process call DQR1UP ( m , n , k , q , m , r , m , u , v , wptr ) end subroutine ! ------------------------------------------------------------------------------ module subroutine qr_rank1_update_cmplx ( q , r , u , v , work , rwork , err ) !! Computes the rank-1 update to an M-by-N QR factored matrix A where !! M \\ge N, A = Q R, and A_1 = A + \\vec{u} \\vec{v}&#94;H such that !! A_1 = Q_1 R_1. complex ( real64 ), intent ( inout ), dimension (:,:) :: q !! On input, the original M-by-K orthogonal matrix Q.  On output, !! the updated matrix Q_1. complex ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the M-by-N matrix R.  On output, the updated matrix !! R_1. complex ( real64 ), intent ( inout ), dimension (:) :: u !! On input, the M-element \\vec{u} update vector.  On output, the !! original content of the array is overwritten. complex ( real64 ), intent ( inout ), dimension (:) :: v !! On input, the N-element \\vec{v} update vector.  On output, the !! original content of the array is overwritten. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least K elements. real ( real64 ), intent ( out ), target , optional , dimension (:) :: rwork !! An optional argument that if supplied prevents local memory !! allocation.  If provided, the array must have at least K elements. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables logical :: full integer ( int32 ) :: m , n , k , lwork , istat , lrwork complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), pointer , dimension (:) :: rwptr real ( real64 ), allocatable , target , dimension (:) :: rwrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( u , 1 ) n = size ( r , 2 ) k = min ( m , n ) full = size ( q , 2 ) == m lwork = k lrwork = k if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"qr_rank1_update_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if (. not . full . and . size ( q , 2 ) /= k ) then call report_matrix_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"q\" , & m , m , size ( q , 1 ), size ( q , 2 )) return else if ( size ( r , 1 ) /= m ) then call report_inner_matrix_dimension_error ( \"qr_rank1_update_cmplx\" , & errmgr , \"q\" , \"r\" , m , size ( r , 1 )) return else if ( size ( u ) /= m ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"u\" , m , & size ( u )) return else if ( size ( v ) /= n ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , \"v\" , n , & size ( v )) return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"qr_rank1_update_cmplx\" , errmgr , & \"rwork\" , lrwork , size ( rwork )) return end if wptr => work ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"qr_rank1_update_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if ! Process call ZQR1UP ( m , n , k , q , m , r , m , u , v , wptr , rwptr ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_mtx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-NRHS right-hand-side matrix.  On output, the !! first N rows are overwritten by the solution matrix. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx\" , errmgr , \"tau\" , & k , size ( tau )) return else if ( size ( b , 1 ) /= m ) then call report_matrix_size_error ( \"solve_qr_no_pivot_mtx\" , errmgr , \"b\" , & m , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_qr (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"Incorrectly sized input array WORK, argument 4.\" , & LA_ARRAY_SIZE_ERROR ) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"solve_qr_no_pivot_mtx\" , & \"Insufficient memory available.\" , & LA_OUT_OF_MEMORY_ERROR ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., . true ., a , tau , b , wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N,:) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : n , 1 : n ), b ( 1 : n ,:)) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_mtx_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the M-by-NRHS right-hand-side matrix.  On output, the !! first N rows are overwritten by the solution matrix. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: m , n , nrhs , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nrhs = size ( b , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , errmgr , & \"tau\" , k , size ( tau )) return else if ( size ( b , 1 ) /= m ) then call report_matrix_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , errmgr , & \"b\" , m , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call mult_qr (. true ., . true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_mtx_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., . true ., a , tau , b , wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N,:) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : n , 1 : n ), b ( 1 : n ,:)) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_no_pivot_vec ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the M-element right-hand-side vector.  On output, the first !! N elements are overwritten with the solution vector. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , flag , lwork , istat real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_vec\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , \"tau\" , & k , size ( tau )) return else if ( size ( b ) /= m ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , \"b\" , & m , size ( b )) return end if ! Workspace Query call mult_qr (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., a , tau , b , work = wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : n , 1 : n ), b ) end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_qr_no_pivot_vec_cmplx ( a , tau , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns.  M must be !! greater than or equal to N. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored.  Notice, M must !! be greater than or equal to N. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the M-element right-hand-side vector.  On output, the first !! N elements are overwritten with the solution vector. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , k , lwork , istat complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) k = min ( m , n ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( m < n ) then call errmgr % report_error ( \"solve_qr_no_pivot_vec_cmplx\" , & \"The problem must not be underdetermined.\" , LA_INVALID_INPUT_ERROR ) return else if ( size ( tau ) /= k ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , errmgr , & \"tau\" , k , size ( tau )) return else if ( size ( b ) /= m ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , errmgr , & \"b\" , m , size ( b )) return end if ! Workspace Query call mult_qr (. true ., a , tau , b , olwork = lwork ) if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_no_pivot_vec_cmplx\" , & errmgr , \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_no_pivot_vec_cmplx\" , & errmgr , istat ) return end if wptr => wrk end if ! Compute Q**T * B, and store in B call mult_qr (. true ., a , tau , b , work = wptr ) ! Solve the triangular system: A(1:N,1:N)*X = B(1:N) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : n , 1 : n ), b ) end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_mtx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. real ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output, !! the first N rows are overwritten by the solution matrix. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , j , m , n , mn , nrhs , lwork , ismin , ismax , & rnk , maxmn , istat , lwork1 , lwork2 , lwork3 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr , s1 , c1 , s2 , c2 real ( real64 ), pointer , dimension (:) :: wptr , w , tau2 real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return else if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_qr_pivot_mtx\" , errmgr , \"b\" , & maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), olwork = lwork2 ) call mult_rz (. true ., . true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ,:), & olwork = lwork3 ) lwork = max ( lwork1 , lwork2 , lwork3 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_mtx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_mtx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( 1 : maxmn ,:) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call DLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call DLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), w ) ! Solve the triangular system T11 * B(1:rnk,1:nrhs) = B(1:rnk,1:nrhs) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : rnk , 1 : rnk ), b ( 1 : rnk ,:)) if ( n > rnk ) b ( rnk + 1 : n ,:) = zero ! Compute B(1:n,1:nrhs) = Y**T * B(1:n,1:nrhs) if ( rnk < n ) then call mult_rz (. true ., . true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ,:), w ) end if ! Apply the pivoting: B(1:N,1:NRHS) = P * B(1:N,1:NRHS) do j = 1 , nrhs do i = 1 , n wptr ( jpvt ( i )) = b ( i , j ) end do b ( 1 : n , j ) = wptr ( 1 : n ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine solve_qr_pivot_mtx_cmplx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. complex ( real64 ), intent ( inout ), dimension (:,:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side matrix.  On output, !! the first N rows are overwritten by the solution matrix. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , j , m , n , mn , nrhs , lwork , ismin , ismax , & rnk , maxmn , istat , lwork1 , lwork2 , lwork3 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr complex ( real64 ) :: s1 , c1 , s2 , c2 complex ( real64 ), pointer , dimension (:) :: wptr , w , tau2 complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) nrhs = size ( b , 2 ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"jpvt\" , n , size ( jpvt )) return else if ( size ( b , 1 ) /= maxmn ) then call report_matrix_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , \"b\" , & maxmn , nrhs , size ( b , 1 ), size ( b , 2 )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), olwork = lwork2 ) call mult_rz (. true ., . true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ,:), & olwork = lwork3 ) lwork = max ( lwork1 , lwork2 , lwork3 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_mtx_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( 1 : maxmn ,:) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call ZLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call ZLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., . true ., a , tau , b ( 1 : m ,:), w ) ! Solve the triangular system T11 * B(1:rnk,1:nrhs) = B(1:rnk,1:nrhs) call solve_triangular_system (. true ., . true ., . false ., . true ., one , & a ( 1 : rnk , 1 : rnk ), b ( 1 : rnk ,:)) if ( n > rnk ) b ( rnk + 1 : n ,:) = zero ! Compute B(1:n,1:nrhs) = Y**T * B(1:n,1:nrhs) if ( rnk < n ) then call mult_rz (. true ., . true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ,:), w ) end if ! Apply the pivoting: B(1:N,1:NRHS) = P * B(1:N,1:NRHS) do j = 1 , nrhs do i = 1 , n wptr ( jpvt ( i )) = b ( i , j ) end do b ( 1 : n , j ) = wptr ( 1 : n ) end do end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_qr_pivot_vec ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. real ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. real ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output, !! the first N rows are overwritten by the solution vector. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , ismin , ismax , rnk , maxmn , & istat , lwork1 , lwork2 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr , s1 , c1 , s2 , c2 real ( real64 ), pointer , dimension (:) :: wptr , w , tau2 real ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"tau\" , & mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"jpvt\" , & n , size ( jpvt )) return else if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_rz (. true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ), olwork = lwork2 ) lwork = max ( lwork1 , lwork2 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_vec\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_vec\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( maxmn ) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call DLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call DLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., a , tau , b ( 1 : m )) ! Solve the triangular system T11 * B(1:rnk) = B(1:rnk) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : rnk , 1 : rnk ), & b ( 1 : rnk )) if ( n > rnk ) b ( rnk + 1 : n ) = zero ! Compute B(1:n) = Y**T * B(1:n) if ( rnk < n ) then call mult_rz (. true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ), w ) end if ! Apply the pivoting: B(1:N) = P * B(1:N) do i = 1 , n wptr ( jpvt ( i )) = b ( i ) end do b = wptr ( 1 : n ) end subroutine ! ------------------------------------------------------------------------------ module subroutine solve_qr_pivot_vec_cmplx ( a , tau , jpvt , b , work , olwork , err ) !! Solves a system of M QR-factored equations of N unknowns. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N QR factored matrix as returned by qr_factor. !! On output, the contents of this matrix are restored. complex ( real64 ), intent ( in ), dimension (:) :: tau !! A MIN(M, N)-element array containing the scalar factors of the !! elementary reflectors as returned by qr_factor. integer ( int32 ), intent ( in ), dimension (:) :: jpvt !! An N-element array, as output by qr_factor, used to track the !! column pivots. complex ( real64 ), intent ( inout ), dimension (:) :: b !! On input, the MAX(M, N)-by-NRHS right-hand-side vector.  On output, !! the first N rows are overwritten by the solution vector. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters integer ( int32 ), parameter :: imin = 2 integer ( int32 ), parameter :: imax = 1 complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , ismin , ismax , rnk , maxmn , & istat , lwork1 , lwork2 real ( real64 ) :: rcond , smax , smin , smaxpr , sminpr complex ( real64 ) :: s1 , c1 , s2 , c2 complex ( real64 ), pointer , dimension (:) :: wptr , w , tau2 complex ( real64 ), allocatable , target , dimension (:) :: wrk class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) maxmn = max ( m , n ) ismin = mn + 1 ismax = 2 * mn + 1 rcond = epsilon ( rcond ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( tau ) /= mn ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"tau\" , mn , size ( tau )) return else if ( size ( jpvt ) /= n ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"jpvt\" , n , size ( jpvt )) return else if ( size ( b ) /= maxmn ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , \"b\" , & maxmn , size ( b )) return end if ! Workspace Query call rz_factor ( a ( 1 : mn ,:), a ( 1 : mn , 1 ), olwork = lwork1 ) call mult_rz (. true ., n , a ( 1 : mn ,:), a ( 1 : mn , 1 ), b ( 1 : n ), olwork = lwork2 ) lwork = max ( lwork1 , lwork2 , 2 * mn + 1 ) + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , & \"work\" , lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"solve_qr_pivot_vec_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Determine the rank of R11 using an incremental condition estimation wptr ( ismin ) = one wptr ( ismax ) = one smax = abs ( a ( 1 , 1 )) smin = smax if ( abs ( a ( 1 , 1 )) == zero ) then rnk = 0 b ( maxmn ) = zero return else rnk = 1 end if do if ( rnk < mn ) then i = rnk + 1 call ZLAIC1 ( imin , rnk , wptr ( ismin : ismin + rnk - 1 ), smin , & a ( 1 : rnk - 1 , i ), a ( i , i ), sminpr , s1 , c1 ) call ZLAIC1 ( imax , rnk , wptr ( ismax : ismax + rnk - 1 ), smax , & a ( 1 : rnk - 1 , i ), a ( i , i ), smaxpr , s2 , c2 ) if ( smaxpr * rcond <= sminpr ) then do i = 1 , rnk wptr ( ismin + i - 1 ) = s1 * wptr ( ismin + i - 1 ) wptr ( ismax + i - 1 ) = s2 * wptr ( ismax + i - 1 ) end do wptr ( ismin + rnk ) = c1 wptr ( ismax + rnk ) = c2 smin = sminpr smax = smaxpr rnk = rnk + 1 cycle end if end if exit end do ! Partition R = [R11 R12] !               [ 0  R22] tau2 => wptr ( 1 : rnk ) w => wptr ( rnk + 1 : lwork ) if ( rnk < n ) call rz_factor ( a ( 1 : rnk ,:), tau2 , w ) ! Compute B(1:m,1:NRHS) = Q**T * B(1:M,1:NRHS) call mult_qr (. true ., a , tau , b ( 1 : m )) ! Solve the triangular system T11 * B(1:rnk) = B(1:rnk) call solve_triangular_system (. true ., . false ., . true ., a ( 1 : rnk , 1 : rnk ), & b ( 1 : rnk )) if ( n > rnk ) b ( rnk + 1 : n ) = zero ! Compute B(1:n) = Y**T * B(1:n) if ( rnk < n ) then call mult_rz (. true ., n - rnk , a ( 1 : rnk ,:), tau2 , b ( 1 : n ), w ) end if ! Apply the pivoting: B(1:N) = P * B(1:N) do i = 1 , n wptr ( jpvt ( i )) = b ( i ) end do b = wptr ( 1 : n ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_qr.f90.html"},{"title":"linalg_sparse.f90 – LINALG","text":"Source Code module linalg_sparse use iso_fortran_env , only : int32 , real64 use sparskit use blas use ferror use linalg_errors implicit none private public :: csr_matrix public :: msr_matrix public :: size public :: create_empty_csr_matrix public :: create_empty_msr_matrix public :: nonzero_count public :: dense_to_csr public :: diag_to_csr public :: banded_to_csr public :: csr_to_dense public :: csr_to_msr public :: msr_to_csr public :: dense_to_msr public :: msr_to_dense public :: create_csr_matrix public :: matmul public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) public :: operator ( / ) public :: assignment ( = ) public :: transpose public :: sparse_direct_solve public :: pgmres_solver type :: csr_matrix !! A sparse matrix stored in compressed sparse row (CSR) format. integer ( int32 ), allocatable , dimension (:) :: row_indices !! An M+1 element array containing the indices in V an JA at which the !! requested row starts. integer ( int32 ), allocatable , dimension (:) :: column_indices !! An NNZ-element array, where NNZ is the number of non-zero values, !! containing the column indices of each value. real ( real64 ), allocatable , dimension (:) :: values !! An NNZ-element array, where NNZ is the number of non-zero values, !! containing the non-zero values of the matrix. integer ( int32 ), private :: n = 0 !! The number of columns in the matrix. contains procedure , public :: get => csr_get_element procedure , public :: extract_diagonal => csr_extract_diagonal end type ! ------------------------------------------------------------------------------ type :: msr_matrix !! A sparse matrix stored in modified sparse row format. integer ( int32 ), allocatable , dimension (:) :: indices !! An NNZ-element array containing the index information. real ( real64 ), allocatable , dimension (:) :: values !! An NNZ-element array containing the non-zero values from the !! matrix.  The first MIN(M,N) elements contain the diagonal. integer ( int32 ) :: m = 0 !! The number of rows in the matrix. integer ( int32 ) :: n = 0 !! The number of columns in the matrix. integer ( int32 ) :: nnz = 0 !! The number of nonzero values in the matrix. end type ! ------------------------------------------------------------------------------ interface nonzero_count module procedure :: nonzero_count_csr module procedure :: nonzero_count_msr end interface interface size module procedure :: csr_size module procedure :: msr_size end interface interface matmul module procedure :: csr_mtx_mtx_mult module procedure :: csr_mtx_vec_mult end interface interface operator ( + ) module procedure :: csr_mtx_add end interface interface operator ( - ) module procedure :: csr_mtx_sub end interface interface operator ( * ) module procedure :: csr_mtx_mult_scalar_1 module procedure :: csr_mtx_mult_scalar_2 end interface interface operator ( / ) module procedure :: csr_mtx_divide_scalar_1 end interface interface assignment ( = ) module procedure :: csr_assign_to_dense module procedure :: dense_assign_to_csr module procedure :: msr_assign_to_dense module procedure :: dense_assign_to_msr module procedure :: csr_assign_to_msr module procedure :: msr_assign_to_csr end interface interface transpose module procedure :: csr_transpose end interface interface sparse_direct_solve module procedure :: csr_solve_sparse_direct end interface interface pgmres_solver module procedure :: csr_pgmres_solver end interface contains ! ****************************************************************************** ! CSR ROUTINES ! ------------------------------------------------------------------------------ function csr_get_element ( this , i , j ) result ( rst ) !! Retrieves the element at the specified row and column. class ( csr_matrix ), intent ( in ) :: this !! The CSR matrix object. integer ( int32 ), intent ( in ) :: i !! The row index. integer ( int32 ), intent ( in ) :: j !! The column index. real ( real64 ) :: rst !! The value at the specified row and column. ! Local Variables integer ( int32 ) :: iadd logical :: sorted ! Initialization sorted = . false . ! Process if (. not . allocated ( this % row_indices ) . or . & . not . allocated ( this % column_indices ) . or . & . not . allocated ( this % values )) & then rst = 0.0d0 return end if rst = getelm ( i , j , this % values , this % column_indices , this % row_indices , & iadd , sorted ) end function ! ------------------------------------------------------------------------------ pure function csr_size ( x , dim ) result ( rst ) !! Returns the size of the matrix along the specified dimension. class ( csr_matrix ), intent ( in ) :: x !! The CSR matrix object. integer ( int32 ), intent ( in ) :: dim !! The dimension to return the size of. integer ( int32 ) :: rst !! The size of the matrix along the specified dimension. ! Process select case ( dim ) case ( 1 ) if ( allocated ( x % row_indices )) then rst = size ( x % row_indices ) - 1 else rst = 0 end if case ( 2 ) rst = x % n case default rst = 0 end select end function ! ------------------------------------------------------------------------------ pure function nonzero_count_csr ( x ) result ( rst ) !! Returns the number of non-zero values in the matrix. class ( csr_matrix ), intent ( in ) :: x !! The CSR matrix object. integer ( int32 ) :: rst !! The number of non-zero values in the matrix. ! Process if ( allocated ( x % values )) then rst = size ( x % values ) else rst = 0 end if end function ! ------------------------------------------------------------------------------ function create_empty_csr_matrix ( m , n , nnz , err ) result ( rst ) !! Creates an empty CSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ) :: nnz !! The number of non-zero values in the matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The empty CSR matrix. ! Local Variables integer ( int32 ) :: flag , m1 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m1 = m + 1 ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( nnz < 0 ) then call errmgr % report_error ( \"create_empty_csr_matrix\" , & \"The number of non-zero values must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Allocation rst % n = n allocate ( rst % row_indices ( m1 ), rst % column_indices ( nnz ), source = 0 , & stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nnz ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_empty_csr_matrix\" , errmgr , flag ) return end if end function ! ------------------------------------------------------------------------------ function dense_to_csr ( a , err ) result ( rst ) !! Converts a dense matrix to a CSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The dense matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , j , k , m , n , nnz real ( real64 ) :: t class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if t = 2.0d0 * epsilon ( t ) m = size ( a , 1 ) n = size ( a , 2 ) nnz = 0 ! Determine how many non-zero values exist do j = 1 , n do i = 1 , m if ( abs ( a ( i , j )) > t ) then nnz = nnz + 1 end if end do end do ! Memory Allocation rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Store the non-zero values k = 1 rst % row_indices ( 1 ) = 1 do i = 1 , m inner_loop : do j = 1 , n if ( abs ( a ( i , j )) < t ) cycle inner_loop rst % column_indices ( k ) = j rst % values ( k ) = a ( i , j ) k = k + 1 end do inner_loop rst % row_indices ( i + 1 ) = k end do end function ! ------------------------------------------------------------------------------ function banded_to_csr ( m , ml , mu , a , err ) result ( rst ) !! Converts a banded matrix to a CSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the banded matrix. integer ( int32 ), intent ( in ) :: ml !! The number of lower diagonals in the banded matrix. integer ( int32 ), intent ( in ) :: mu !! The number of upper diagonals in the banded matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The banded matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: n , nnz , flag , lowd , lda integer ( int32 ), allocatable , dimension (:) :: ia , ja real ( real64 ), allocatable , dimension (:) :: v class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if lda = size ( a , 1 ) n = size ( a , 2 ) nnz = lda * n lowd = ml + mu + 1 ! Input Checking if ( ml < 0 . or . mu < 0 ) then call errmgr % report_error ( \"banded_to_csr\" , \"The bandwidth \" // & \"dimensions cannot be negative.\" , LA_INVALID_INPUT_ERROR ) return end if if ( lda /= ml + mu + 1 ) then call errmgr % report_error ( \"banded_to_csr\" , \"The number of rows in \" // & \"the banded matrix does not match the supplied bandwidth \" // & \"dimensions.\" , LA_MATRIX_FORMAT_ERROR ) return end if ! Allocation allocate ( ia ( m + 1 ), ja ( nnz ), v ( nnz ), stat = flag ) if ( flag /= 0 ) go to 10 ! Process call bndcsr ( m , a , lda , lowd , ml , mu , v , ja , ia , nnz , flag ) nnz = ia ( m + 1 ) - 1 ! Put into the sparse matrix structure allocate ( rst % row_indices ( m + 1 ), source = ia , stat = flag ) if ( flag == 0 ) allocate ( rst % column_indices ( nnz ), source = ja (: nnz ), & stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nnz ), source = v (: nnz ), stat = flag ) if ( flag /= 0 ) go to 10 rst % n = n ! End return ! Memory Error 10 continue call report_memory_error ( \"banded_to_csr\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ subroutine csr_to_dense ( a , x , err ) !! Converts a CSR matrix to a dense matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , j , k , m , n , nnz , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Check if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call report_matrix_size_error ( \"csr_to_dense\" , errmgr , \"x\" , m , n , & size ( x , 1 ), size ( x , 2 )) return end if ! Process do i = 1 , m x ( i ,:) = 0.0d0 do k = a % row_indices ( i ), a % row_indices ( i + 1 ) - 1 j = a % column_indices ( k ) x ( i , j ) = a % values ( k ) end do end do end subroutine ! ------------------------------------------------------------------------------ function diag_to_csr ( a , err ) result ( rst ) !! Converts a diagonal matrix to a CSR matrix. real ( real64 ), intent ( in ), dimension (:) :: a !! The diagonal matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , n , n1 , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a ) n1 = n + 1 ! Allocation allocate ( rst % row_indices ( n1 ), rst % column_indices ( n ), stat = flag ) if ( flag == 0 ) allocate ( rst % values ( n ), source = a , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"diag_to_csr\" , errmgr , flag ) return end if rst % n = n ! Populate IA & JA do i = 1 , n rst % column_indices ( i ) = i rst % row_indices ( i ) = i end do rst % row_indices ( n1 ) = n1 end function ! ------------------------------------------------------------------------------ subroutine csr_assign_to_dense ( dense , sparse ) !! Assigns the values of a CSR matrix to a dense matrix. real ( real64 ), intent ( out ), dimension (:,:) :: dense !! The dense matrix. class ( csr_matrix ), intent ( in ) :: sparse !! The CSR matrix. ! Process call csr_to_dense ( sparse , dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine dense_assign_to_csr ( sparse , dense ) !! Assigns the values of a dense matrix to a CSR matrix. type ( csr_matrix ), intent ( out ) :: sparse !! The CSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: dense !! The dense matrix. ! Process sparse = dense_to_csr ( dense ) end subroutine ! ------------------------------------------------------------------------------ function csr_mtx_mtx_mult ( a , b ) result ( rst ) !! Multiplies two CSR matrices together. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_mult = 0 integer ( int32 ), parameter :: full_mult = 1 integer ( int32 ) :: flag , m , n , k , nnza , nnzb , nnzc , ierr integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Check if ( size ( b , 1 ) /= k ) then call report_inner_matrix_dimension_error ( \"csr_mtx_mtx_mult\" , errmgr , & \"a\" , \"b\" , k , size ( b , 1 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call amub ( m , n , sym_mult , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call amub ( m , n , sym_mult , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actual NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual product call amub ( m , n , full_mult , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_mtx_mult\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_vec_mult ( a , b ) result ( rst ) !! Multiplies a CSR matrix by a vector. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ), dimension (:) :: b !! The vector. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting vector. ! Local Variables integer ( int32 ) :: i , k , k1 , k2 , n , p , flag real ( real64 ) :: t type ( errors ) :: errmgr ! Initialization n = size ( a , 1 ) p = size ( a , 2 ) ! Input Check if ( size ( b ) /= p ) then call report_inner_matrix_dimension_error ( \"csr_mtx_vec_mult\" , errmgr , & \"a\" , \"b\" , p , size ( b )) return end if ! Memory Allocation allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_mtx_vec_mult\" , errmgr , flag ) return end if ! Process do i = 1 , n t = 0.0d0 k1 = a % row_indices ( i ) k2 = a % row_indices ( i + 1 ) - 1 do k = k1 , k2 t = t + a % values ( k ) * b ( a % column_indices ( k )) end do rst ( i ) = t end do end function ! ------------------------------------------------------------------------------ function csr_mtx_add ( a , b ) result ( rst ) !! Adds two CSR matrices. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_add = 0 integer ( int32 ), parameter :: full_add = 1 integer ( int32 ) :: m , n , nnza , nnzb , nnzc , ierr , flag integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Checking if ( size ( b , 1 ) /= m . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"csr_mtx_add\" , errmgr , \"b\" , m , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call aplb ( m , n , sym_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call aplb ( m , n , sym_add , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actuall NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual sum call aplb ( m , n , full_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_add\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_sub ( a , b ) result ( rst ) !! Subtracts two CSR matrices. class ( csr_matrix ), intent ( in ) :: a !! The first CSR matrix. class ( csr_matrix ), intent ( in ) :: b !! The second CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ), parameter :: sym_add = 0 integer ( int32 ) :: m , n , nnza , nnzb , nnzc , ierr , flag integer ( int32 ), allocatable , dimension (:) :: ic , jc , iw real ( real64 ) :: dummy ( 1 ) type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnza = nonzero_count ( a ) nnzb = nonzero_count ( b ) nnzc = nnza + nnzb ! Input Checking if ( size ( b , 1 ) /= m . or . size ( b , 2 ) /= n ) then call report_matrix_size_error ( \"csr_mtx_sub\" , errmgr , \"b\" , m , n , & size ( b , 1 ), size ( b , 2 )) return end if ! Local Memory Allocations allocate ( ic ( m + 1 ), jc ( nnzc ), iw ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Determine the structure of C call aplb ( m , n , sym_add , a % values , a % column_indices , a % row_indices , & b % values , b % column_indices , b % row_indices , dummy , jc , ic , & nnzc , iw , ierr ) if ( ierr /= 0 ) then ! NNZC was too small - try increasing it do while ( ierr /= 0 ) deallocate ( jc ) nnzc = nnzc + nnza + nnzb allocate ( jc ( nnzc ), stat = flag ) if ( flag /= 0 ) go to 10 call aplb ( m , n , sym_add , a % values , a % column_indices , & a % row_indices , b % values , b % column_indices , b % row_indices , & dummy , jc , ic , nnzc , iw , ierr ) end do end if ! Determine the actuall NNZ for C & allocate space for the output nnzc = ic ( m + 1 ) - 1 deallocate ( ic ) deallocate ( jc ) rst = create_empty_csr_matrix ( m , n , nnzc , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the actual sum call aplsb ( m , n , a % values , a % column_indices , a % row_indices , - 1.0d0 , & b % values , b % column_indices , b % row_indices , rst % values , & rst % column_indices , rst % row_indices , nnzc , iw , ierr ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_mtx_sub\" , errmgr , flag ) return end function ! ------------------------------------------------------------------------------ function csr_mtx_mult_scalar_1 ( a , b ) result ( rst ) !! Multiplies a CSR matrix by a scalar. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ) :: b !! The scalar. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = a % row_indices rst % column_indices = a % column_indices rst % values = b * a % values end function ! ------------------------------------------------------------------------------ function csr_mtx_mult_scalar_2 ( a , b ) result ( rst ) !! Multiplies a scalar by a CSR matrix. real ( real64 ), intent ( in ) :: a !! The scalar. class ( csr_matrix ), intent ( in ) :: b !! The CSR matrix. type ( csr_matrix ) :: rst !! The resulting CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( b , 1 ) n = size ( b , 2 ) nnz = nonzero_count ( b ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = b % row_indices rst % column_indices = b % column_indices rst % values = a * b % values end function ! ------------------------------------------------------------------------------ function csr_mtx_divide_scalar_1 ( a , b ) result ( rst ) !! Divides a CSR matrix by a scalar. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( in ) :: b !! The scalar. type ( csr_matrix ) :: rst ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Process rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the product rst % row_indices = a % row_indices rst % column_indices = a % column_indices rst % values = a % values / b end function ! ------------------------------------------------------------------------------ module function csr_transpose ( a ) result ( rst ) !! Transposes a CSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. type ( csr_matrix ) :: rst !! The transposed CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz type ( errors ) :: errmgr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) rst = create_empty_csr_matrix ( n , m , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Process call csrcsc2 ( m , n , 1 , 1 , a % values , a % column_indices , a % row_indices , & rst % values , rst % column_indices , rst % row_indices ) end function ! ------------------------------------------------------------------------------ subroutine csr_extract_diagonal ( a , diag , err ) !! Extracts the diagonal from a CSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix. real ( real64 ), intent ( out ), dimension (:) :: diag !! The diagonal values. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , mn , len , flag integer ( int32 ), allocatable , dimension (:) :: idiag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) ! Input Check if ( size ( diag ) /= mn ) then call report_array_size_error ( \"csr_extract_diagonal\" , errmgr , \"diag\" , & mn , size ( diag )) return end if ! Memory Allocation allocate ( idiag ( mn ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_extract_diagonal\" , errmgr , flag ) return end if ! Process call getdia ( m , n , 0 , a % values , a % column_indices , a % row_indices , len , & diag , idiag , 0 ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_solve_sparse_direct ( a , b , x , droptol , err ) !! Solves a linear system using a direct method. class ( csr_matrix ), intent ( in ) :: a !! The matrix. real ( real64 ), intent ( in ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. real ( real64 ), intent ( in ), optional :: droptol !! The drop tolerance for the ILUT factorization. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: i , m , n , nnz , lfil , iwk , ierr , flag integer ( int32 ), allocatable , dimension (:) :: jlu , ju , jw real ( real64 ), allocatable , dimension (:) :: alu , w real ( real64 ) :: dt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( droptol )) then dt = droptol else dt = sqrt ( epsilon ( dt )) end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Input Checking if ( m /= n ) then call report_square_matrix_error ( \"csr_solve_sparse_direct\" , errmgr , & \"a\" , m , m , n ) return end if if ( size ( x ) /= n ) then call report_inner_matrix_dimension_error ( \"csr_solve_sparse_direct\" , & errmgr , \"a\" , \"x\" , n , size ( x )) return end if if ( size ( b ) /= n ) then call report_array_size_error ( \"csr_solve_sparse_direct\" , errmgr , \"b\" , & n , size ( b )) return end if ! Parameter Determination lfil = 1 do i = 1 , m lfil = max ( lfil , a % row_indices ( i + 1 ) - a % row_indices ( i )) end do iwk = max ( lfil * m , nnz ) ! somewhat arbitrary - can be adjusted ! Local Memory Allocation allocate ( alu ( iwk ), w ( n + 1 ), jlu ( iwk ), ju ( n ), jw ( 2 * n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Factorization do ! Factor the matrix call ilut ( n , a % values , a % column_indices , a % row_indices , lfil , dt , & alu , jlu , ju , iwk , w , jw , ierr ) ! Check the error flag if ( ierr == 0 ) then ! Success exit else if ( ierr > 0 ) then ! Zero pivot else if ( ierr == - 1 ) then ! The input matrix is not formatted correctly go to 20 else if ( ierr == - 2 . or . ierr == - 3 ) then ! ALU and JLU are too small - try something larger iwk = min ( iwk + m + n , m * n ) deallocate ( alu ) deallocate ( jlu ) allocate ( alu ( iwk ), jlu ( iwk ), stat = flag ) if ( flag /= 0 ) go to 10 else if ( ierr == - 4 ) then ! Illegal value for LFIL - reset and try again lfil = n else if ( ierr == - 5 ) then ! Zero row encountered go to 30 else ! We should never get here, but just in case go to 40 end if end do ! Solution call lusol ( n , b , x , alu , jlu , ju ) ! End return ! Memory Error 10 continue call report_memory_error ( \"csr_solve_sparse_direct\" , errmgr , flag ) return ! Matrix Format Error 20 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"The input matrix was incorrectly formatted.  A row with more \" // & \"than N entries was found.\" , LA_MATRIX_FORMAT_ERROR ) return ! Zero Row Error 30 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"A row with all zeros was encountered in the matrix.\" , & LA_SINGULAR_MATRIX_ERROR ) return ! Unknown Error 40 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , \"ILUT encountered \" // & \"an unknown error.  The error code from the ILUT routine is \" // & \"provided in the output.\" , ierr ) return ! Zero Pivot Error 50 continue call errmgr % report_error ( \"csr_solve_sparse_direct\" , & \"A zero pivot was encountered.\" , LA_SINGULAR_MATRIX_ERROR ) return end subroutine ! ****************************************************************************** ! MSR ROUTINES ! ------------------------------------------------------------------------------ ! TO DO: MSR_GET_ELEMENT ! ------------------------------------------------------------------------------ pure function msr_size ( x , dim ) result ( rst ) !! Returns the size of the specified dimension of an MSR matrix. class ( msr_matrix ), intent ( in ) :: x !! The MSR matrix. integer ( int32 ), intent ( in ) :: dim !! The dimension to return the size of. integer ( int32 ) :: rst !! The size of the specified dimension. ! Process select case ( dim ) case ( 1 ) rst = x % m case ( 2 ) rst = x % n case default rst = 0 end select end function ! ------------------------------------------------------------------------------ pure function nonzero_count_msr ( x ) result ( rst ) !! Returns the number of non-zero elements in an MSR matrix. class ( msr_matrix ), intent ( in ) :: x !! The MSR matrix. integer ( int32 ) :: rst !! The number of non-zero elements. ! Process rst = x % nnz end function ! ------------------------------------------------------------------------------ function create_empty_msr_matrix ( m , n , nnz , err ) result ( rst ) !! Creates an empty MSR matrix. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ) :: nnz !! The number of non-zero elements in the matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables integer ( int32 ) :: nelem , mn , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( nnz < 0 ) then call errmgr % report_error ( \"create_empty_msr_matrix\" , & \"The number of non-zero values must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Allocation rst % m = m rst % n = n rst % nnz = nnz mn = min ( m , n ) nelem = m + 1 + nnz - mn allocate ( rst % indices ( nelem ), source = 0 , stat = flag ) if ( flag == 0 ) allocate ( rst % values ( nelem ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_empty_msr_matrix\" , errmgr , flag ) return end if end function ! ------------------------------------------------------------------------------ function csr_to_msr ( a , err ) result ( rst ) !! Converts a CSR matrix to an MSR matrix. class ( csr_matrix ), intent ( in ) :: a !! The CSR matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz , flag integer ( int32 ), allocatable , dimension (:) :: iwork , jc , ic real ( real64 ), allocatable , dimension (:) :: work , ac class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Memory Allocation rst = create_empty_msr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( work ( m ), iwork ( m + 1 ), stat = flag ) if ( flag == 0 ) allocate ( ac ( nnz ), source = a % values , stat = flag ) if ( flag == 0 ) allocate ( jc ( nnz ), source = a % column_indices , stat = flag ) if ( flag == 0 ) allocate ( ic ( m + 1 ), source = a % row_indices , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_to_msr\" , errmgr , flag ) return end if ! Perform the conversion call csrmsr ( m , ac , jc , ic , rst % values , rst % indices , work , iwork ) end function ! ------------------------------------------------------------------------------ function msr_to_csr ( a , err ) result ( rst ) !! Converts an MSR matrix to a CSR matrix. class ( msr_matrix ), intent ( in ) :: a !! The MSR matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: m , n , nnz , flag integer ( int32 ), allocatable , dimension (:) :: iwork real ( real64 ), allocatable , dimension (:) :: work class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) nnz = nonzero_count ( a ) ! Memory Allocation rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( work ( m ), iwork ( m + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"msr_to_csr\" , errmgr , flag ) return end if ! Process call msrcsr ( m , a % values , a % indices , rst % values , rst % column_indices , & rst % row_indices , work , iwork ) end function ! ------------------------------------------------------------------------------ function dense_to_msr ( a , err ) result ( rst ) !! Converts a dense matrix to an MSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: a !! The dense matrix to convert. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( msr_matrix ) :: rst !! The MSR matrix. ! Local Variables type ( csr_matrix ) :: csr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Convert to CSR, and then from CSR to MSR csr = dense_to_csr ( a , errmgr ) ! Convert to MSR rst = csr_to_msr ( csr , errmgr ) end function ! ------------------------------------------------------------------------------ subroutine msr_to_dense ( a , x , err ) !! Converts an MSR matrix to a dense matrix. class ( msr_matrix ), intent ( in ) :: a !! The MSR matrix to convert. real ( real64 ), intent ( out ), dimension (:,:) :: x !! The dense matrix. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: m , n , flag type ( csr_matrix ) :: csr class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( a , 1 ) n = size ( a , 2 ) ! Input Check if ( size ( x , 1 ) /= m . or . size ( x , 2 ) /= n ) then call report_matrix_size_error ( \"msr_to_dense\" , errmgr , \"x\" , m , n , & size ( x , 1 ), size ( x , 2 )) return end if ! Process csr = msr_to_csr ( a , errmgr ) if ( errmgr % has_error_occurred ()) return call csr_to_dense ( csr , x , errmgr ) end subroutine ! ------------------------------------------------------------------------------ subroutine msr_assign_to_dense ( dense , msr ) !! Assigns an MSR matrix to a dense matrix. real ( real64 ), intent ( out ), dimension (:,:) :: dense !! The dense matrix. class ( msr_matrix ), intent ( in ) :: msr !! The MSR matrix. ! Process call msr_to_dense ( msr , dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine dense_assign_to_msr ( msr , dense ) !! Assigns a dense matrix to an MSR matrix. type ( msr_matrix ), intent ( out ) :: msr !! The MSR matrix. real ( real64 ), intent ( in ), dimension (:,:) :: dense !! The dense matrix. ! Process msr = dense_to_msr ( dense ) end subroutine ! ------------------------------------------------------------------------------ subroutine csr_assign_to_msr ( msr , csr ) !! Assigns a CSR matrix to an MSR matrix. type ( msr_matrix ), intent ( out ) :: msr !! The MSR matrix. class ( csr_matrix ), intent ( in ) :: csr !! The CSR matrix. ! Process msr = csr_to_msr ( csr ) end subroutine ! ------------------------------------------------------------------------------ subroutine msr_assign_to_csr ( csr , msr ) !! Assigns an MSR matrix to a CSR matrix. type ( csr_matrix ), intent ( out ) :: csr !! The CSR matrix. class ( msr_matrix ), intent ( in ) :: msr !! The MSR matrix. ! Process csr = msr_to_csr ( msr ) end subroutine ! ------------------------------------------------------------------------------ function create_csr_matrix ( m , n , rows , cols , vals , err ) result ( rst ) !! Creates a CSR matrix from the input data. integer ( int32 ), intent ( in ) :: m !! The number of rows in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns in the matrix. integer ( int32 ), intent ( in ), dimension (:) :: rows !! The row indices. integer ( int32 ), intent ( in ), dimension (:) :: cols !! The column indices. real ( real64 ), intent ( in ), dimension (:) :: vals !! The values. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. type ( csr_matrix ) :: rst !! The CSR matrix. ! Local Variables integer ( int32 ) :: i , flag , nnz integer ( int32 ), allocatable , dimension (:) :: ir class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nnz = size ( rows ) ! Input Checking if ( m < 0 ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The number of rows must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( n < 0 ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The number of columns must be a positive value.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( size ( cols ) /= nnz . or . size ( vals ) /= nnz ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"The size of the input arrays must be the same.\" , & LA_ARRAY_SIZE_ERROR ) return end if do i = 1 , nnz if ( rows ( i ) < 1 . or . rows ( i ) > m ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"All row indices must be within the bounds of the matrix.\" , & LA_INVALID_INPUT_ERROR ) return end if if ( cols ( i ) < 1 . or . cols ( i ) > n ) then call errmgr % report_error ( \"create_csr_matrix\" , & \"All column indices must be within the bounds of the matrix.\" , & LA_INVALID_INPUT_ERROR ) return end if end do allocate ( ir ( nnz ), source = rows , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_csr_matrix\" , errmgr , flag ) return end if ! Create an empty matrix rst = create_empty_csr_matrix ( m , n , nnz , errmgr ) if ( errmgr % has_error_occurred ()) return ! Populate the empty matrix call coocsr ( m , nnz , vals , ir , cols , rst % values , rst % column_indices , & rst % row_indices ) call csort ( m , rst % values , rst % column_indices , rst % row_indices , . true .) end function ! ****************************************************************************** ! ITERATIVE SOLVERS ! ------------------------------------------------------------------------------ ! Additional References: ! - https://www.diva-portal.org/smash/get/diva2:360739/FULLTEXT01.pdf subroutine csr_pgmres_solver ( a , lu , ju , b , x , im , tol , maxits , iout , err ) !! Solves a linear system using the PGMRES method. class ( csr_matrix ), intent ( in ) :: a !! The matrix. class ( msr_matrix ), intent ( in ) :: lu !! The LU factored matrix. integer ( int32 ), intent ( in ), dimension (:) :: ju !! The row tracking array. real ( real64 ), intent ( inout ), dimension (:) :: b !! The right-hand side. real ( real64 ), intent ( out ), dimension (:) :: x !! The solution. integer ( int32 ), intent ( in ), optional :: im !! The Krylov subspace size. integer ( int32 ), intent ( in ), optional :: maxits !! The maximum number of iterations. integer ( int32 ), intent ( in ), optional :: iout !! The output level. real ( real64 ), intent ( in ), optional :: tol !! The convergence tolerance. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , ierr , flag , io , mit , krylov real ( real64 ) :: eps real ( real64 ), allocatable , dimension (:,:) :: vv class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( im )) then krylov = im else krylov = min ( n , 50 ) end if if ( present ( tol )) then eps = tol else eps = sqrt ( epsilon ( eps )) end if if ( present ( maxits )) then mit = maxits else mit = 100 end if if ( present ( iout )) then io = iout else io = 0 end if ! Input Checking if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"csr_pgmres_solver\" , errmgr , \"a\" , n , n , & size ( a , 2 )) return end if if ( size ( lu , 1 ) /= n . or . size ( lu , 2 ) /= n ) then call report_matrix_size_error ( \"csr_pgmres_solver\" , errmgr , \"lu\" , n , n , & size ( lu , 1 ), size ( lu , 2 )) return end if if ( size ( b ) /= n ) then call report_array_size_error ( \"csr_pgmres_solver\" , errmgr , \"b\" , n , size ( b )) return end if if ( size ( x ) /= n ) then call report_array_size_error ( \"csr_pgmres_solver\" , errmgr , \"x\" , n , size ( x )) return end if if ( eps < epsilon ( eps )) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"The convergence tolerance is too small.\" , LA_INVALID_INPUT_ERROR ) return end if if ( mit < 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"Too few iterations allowed.\" , LA_INVALID_INPUT_ERROR ) return end if if ( krylov < 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"The requested Krylov subspace size is too small.\" , & LA_INVALID_INPUT_ERROR ) return end if ! Memory Allocation allocate ( vv ( n , krylov + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"csr_pgmres_solver\" , errmgr , flag ) return end if ! Process call pgmres ( n , krylov , b , x , vv , eps , mit , io , a % values , a % column_indices , & a % row_indices , lu % values , lu % indices , ju , ierr ) if ( ierr == 1 ) then call errmgr % report_error ( \"csr_pgmres_solver\" , & \"Convergence could not be achieved to the requested tolerance \" // & \"in the allowed number of iterations.\" , LA_CONVERGENCE_ERROR ) return end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_sparse.f90.html"},{"title":"linalg_inverse.f90 – LINALG","text":"Source Code module linalg_inverse use iso_fortran_env , only : int32 , real64 use lapack use blas use linalg_errors implicit none private public :: mtx_inverse public :: mtx_pinverse interface mtx_inverse module procedure :: mtx_inverse_dbl module procedure :: mtx_inverse_cmplx end interface interface mtx_pinverse module procedure :: mtx_pinverse_dbl module procedure :: mtx_pinverse_cmplx end interface contains ! ------------------------------------------------------------------------------ subroutine mtx_inverse_dbl ( a , iwork , work , olwork , err ) !! Computes the inverse of a square matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to invert.  On output, the inverted !! matrix. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An optional N-element integer workspace array. real ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , liwork , lwork , istat , flag , itemp ( 1 ) integer ( int32 ), pointer , dimension (:) :: iptr integer ( int32 ), allocatable , target , dimension (:) :: iwrk real ( real64 ), pointer , dimension (:) :: wptr real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) liwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"mtx_inverse_dbl\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call DGETRI ( n , a , n , itemp , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Workspace Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: WORK not sized correctly call report_array_size_error ( \"mtx_inverse_dbl\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_dbl\" , errmgr , istat ) return end if wptr => wrk end if ! Integer Workspace Allocation if ( present ( iwork )) then if ( size ( iwork ) < liwork ) then call report_array_size_error ( \"mtx_inverse_dbl\" , errmgr , \"iwork\" , & liwork , size ( iwork )) return end if iptr => iwork ( 1 : liwork ) else allocate ( iwrk ( liwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_dbl\" , errmgr , istat ) return end if iptr => iwrk end if ! Compute the LU factorization of A call DGETRF ( n , n , a , n , iptr , flag ) ! Compute the inverse of the LU factored matrix call DGETRI ( n , a , n , iptr , wptr , lwork , flag ) ! Check for a singular matrix if ( flag > 0 ) then call errmgr % report_error ( \"mtx_inverse_dbl\" , & \"The matrix is singular; therefore, the inverse could \" // & \"not be computed.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_inverse_cmplx ( a , iwork , work , olwork , err ) !! Computes the inverse of a square matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the N-by-N matrix to invert.  On output, the inverted !! matrix. integer ( int32 ), intent ( out ), target , optional , dimension (:) :: iwork !! An optional N-element integer workspace array. complex ( real64 ), intent ( out ), target , optional , dimension (:) :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Local Variables integer ( int32 ) :: n , liwork , lwork , istat , flag , itemp ( 1 ) integer ( int32 ), pointer , dimension (:) :: iptr integer ( int32 ), allocatable , target , dimension (:) :: iwrk complex ( real64 ), pointer , dimension (:) :: wptr complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ), dimension ( 1 ) :: temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( a , 1 ) liwork = n if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( a , 2 ) /= n ) then call report_square_matrix_error ( \"mtx_inverse_cmplx\" , errmgr , \"a\" , & n , size ( a , 1 ), size ( a , 2 )) return end if ! Workspace Query call ZGETRI ( n , a , n , itemp , temp , - 1 , flag ) lwork = int ( temp ( 1 ), int32 ) if ( present ( olwork )) then olwork = lwork return end if ! Workspace Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_inverse_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_cmplx\" , errmgr , istat ) return end if wptr => wrk end if ! Integer Workspace Allocation if ( present ( iwork )) then if ( size ( iwork ) < liwork ) then call report_array_size_error ( \"mtx_inverse_cmplx\" , errmgr , \"iwork\" , & liwork , size ( iwork )) return end if iptr => iwork ( 1 : liwork ) else allocate ( iwrk ( liwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_inverse_cmplx\" , errmgr , istat ) return end if iptr => iwrk end if ! Compute the LU factorization of A call ZGETRF ( n , n , a , n , iptr , flag ) ! Compute the inverse of the LU factored matrix call ZGETRI ( n , a , n , iptr , wptr , lwork , flag ) ! Check for a singular matrix if ( flag > 0 ) then call errmgr % report_error ( \"mtx_inverse_cmplx\" , & \"The matrix is singular; therefore, the inverse could \" // & \"not be computed.\" , LA_SINGULAR_MATRIX_ERROR ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine mtx_pinverse_dbl ( a , ainv , tol , work , olwork , err ) !! Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the !! singular value decomposition of the matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to invert.  The matrix is overwritten !! on output. real ( real64 ), intent ( out ), dimension (:,:) :: ainv !! The N-by-M matrix where the pseudo-inverse of A will be written. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default tolerance !! on singular values such that singular values less than this !! tolerance are forced to have a reciprocal of zero, as opposed to !! 1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). real ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , istat , flag , i1 , i2a , i2b , i3a , & i3b , i4 , lrwork real ( real64 ), pointer , dimension (:) :: s , wptr , w real ( real64 ), pointer , dimension (:,:) :: u , vt real ( real64 ), allocatable , target , dimension (:) :: wrk real ( real64 ), dimension ( 1 ) :: temp real ( real64 ) :: t , tref , tolcheck , ss class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) i1 = m * mn i2a = i1 + 1 i2b = i2a + n * mn - 1 i3a = i2b + 1 i3b = i3a + mn - 1 i4 = i3b + 1 tolcheck = dlamch ( 's' ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( ainv , 1 ) /= n . or . size ( ainv , 2 ) /= m ) then call report_matrix_size_error ( \"mtx_pinverse_dbl\" , errmgr , \"ainv\" , & n , m , size ( ainv , 1 ), size ( ainv , 2 )) return end if ! Workspace Query call DGESVD ( 'S' , 'S' , m , n , a , m , temp , a , m , a , n , temp , - 1 , flag ) lrwork = int ( temp ( 1 ), int32 ) lwork = lrwork + m * m + n * n + mn if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_pinverse_dbl\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_dbl\" , errmgr , istat ) return end if wptr => wrk end if u ( 1 : m , 1 : mn ) => wptr ( 1 : i1 ) vt ( 1 : mn , 1 : n ) => wptr ( i2a : i2b ) s => wptr ( i3a : i3b ) w => wptr ( i4 : lwork ) ! Compute the SVD of A call DGESVD ( 'S' , 'S' , m , n , a , m , s , u , m , vt , n , w , lrwork , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"mtx_pinverse_dbl\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if !if (t < safe_denom(t)) then if ( t < tolcheck ) then ! The supplied tolerance is too small, simply fall back to the ! default, but issue a warning to the user t = tref ! call errmgr%report_warning(\"pinverse_1\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Compute the pseudoinverse such that pinv(A) = V * inv(S) * U**T by ! first computing inv(S) * U**T do i = 1 , mn if ( s ( i ) < t ) then ss = s ( i ) else ss = 1.0d0 / s ( i ) end if call DSCAL ( m , ss , u (:, i ), 1 ) end do call DGEMM ( \"T\" , \"T\" , n , m , mn , one , vt , n , u , m , zero , ainv , n ) end subroutine ! ------------------------------------------------------------------------------ module subroutine mtx_pinverse_cmplx ( a , ainv , tol , work , olwork , rwork , err ) !! Computes the Moore-Penrose pseudo-inverse of a M-by-N matrix using the !! singular value decomposition of the matrix. complex ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to invert.  The matrix is overwritten !! on output. complex ( real64 ), intent ( out ), dimension (:,:) :: ainv !! The N-by-M matrix where the pseudo-inverse of A will be written. real ( real64 ), intent ( in ), optional :: tol !! An optional input, that if supplied, overrides the default tolerance !! on singular values such that singular values less than this !! tolerance are forced to have a reciprocal of zero, as opposed to !! 1/S(I).  The default tolerance is: MAX(M, N) * EPS * MAX(S). complex ( real64 ), intent ( out ), target , dimension (:), optional :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size.  If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. real ( real64 ), intent ( out ), target , dimension (:), optional :: rwork !! An optional input, that if provided, prevents any local memory !! allocation for real-valued workspaces.  If not provided, the !! memory required is allocated within.  If provided, the length of the !! array must be at least 6 * MIN(M, N). class ( errors ), intent ( inout ), optional , target :: err !! The error object to be updated. ! External Function Interfaces interface function DLAMCH ( cmach ) result ( x ) use , intrinsic :: iso_fortran_env , only : real64 character , intent ( in ) :: cmach real ( real64 ) :: x end function end interface ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , mn , lwork , istat , flag , i1 , i2a , i2b , i3 , & lrwork , j , k real ( real64 ), pointer , dimension (:) :: s , rwptr , rw real ( real64 ), allocatable , target , dimension (:) :: rwrk complex ( real64 ), pointer , dimension (:) :: wptr , w complex ( real64 ), pointer , dimension (:,:) :: u , vt complex ( real64 ), allocatable , target , dimension (:) :: wrk complex ( real64 ) :: temp ( 1 ), val real ( real64 ) :: t , tref , tolcheck , rtemp ( 1 ) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) mn = min ( m , n ) lrwork = 6 * mn i1 = m * mn i2a = i1 + 1 i2b = i2a + n * n - 1 i3 = i2b + 1 tolcheck = dlamch ( 's' ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( ainv , 1 ) /= n . or . size ( ainv , 2 ) /= m ) then call report_matrix_size_error ( \"mtx_pinverse_cmplx\" , errmgr , \"ainv\" , & n , m , size ( ainv , 1 ), size ( ainv , 2 )) return end if ! Workspace Query call ZGESVD ( 'S' , 'A' , m , n , a , m , rtemp , a , m , a , n , temp , - 1 , & rtemp , flag ) lwork = int ( temp ( 1 ), int32 ) lwork = lwork + m * mn + n * n if ( present ( olwork )) then olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then call report_array_size_error ( \"mtx_pinverse_cmplx\" , errmgr , \"work\" , & lwork , size ( work )) return end if wptr => work ( 1 : lwork ) else allocate ( wrk ( lwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_cmplx\" , errmgr , istat ) return end if wptr => wrk end if if ( present ( rwork )) then if ( size ( rwork ) < lrwork ) then call report_array_size_error ( \"mtx_pinverse_cmplx\" , errmgr , & \"rwork\" , lrwork , size ( rwork )) return end if rwptr => rwork ( 1 : lrwork ) else allocate ( rwrk ( lrwork ), stat = istat ) if ( istat /= 0 ) then call report_memory_error ( \"mtx_pinverse_cmplx\" , errmgr , istat ) return end if rwptr => rwrk end if u ( 1 : m , 1 : mn ) => wptr ( 1 : i1 ) vt ( 1 : n , 1 : n ) => wptr ( i2a : i2b ) w => wptr ( i3 : lwork ) s => rwptr ( 1 : mn ) rw => rwptr ( mn + 1 : lrwork ) ! Compute the SVD of A call ZGESVD ( 'S' , 'A' , m , n , a , m , s , u , m , vt , n , w , size ( w ), rw , flag ) ! Check for convergence if ( flag > 0 ) then call errmgr % report_error ( \"mtx_pinverse_cmplx\" , & \"The QR iteration process could not converge.\" , & LA_CONVERGENCE_ERROR ) return end if ! Determine the threshold tolerance for the singular values such that ! singular values less than the threshold result in zero when inverted. tref = max ( m , n ) * epsilon ( t ) * s ( 1 ) if ( present ( tol )) then t = tol else t = tref end if !if (t < safe_denom(t)) then if ( t < tolcheck ) then ! The supplied tolerance is too small, simply fall back to the ! default, but issue a warning to the user t = tref ! call errmgr%report_warning(\"pinverse_1\", \"The supplied tolerance was \" // & !     \"smaller than a value that would result in an overflow \" // & !     \"condition, or is negative; therefore, the tolerance has \" // & !     \"been reset to its default value.\") end if ! Compute the pseudoinverse such that pinv(A) = V * inv(S) * U**T by ! first computing V * inv(S) (result is N-by-M), and store in the first ! MN rows of VT in a transposed manner. do i = 1 , mn ! Apply 1 / S(I) to VT(I,:) if ( s ( i ) < t ) then vt ( i ,:) = zero else ! call recip_mult_array(s(i), vt(i,1:n)) vt ( i , 1 : n ) = conjg ( vt ( i , 1 : n )) / s ( i ) end if end do ! Compute (VT**T * inv(S)) * U**H ! ainv = n-by-m ! vt is n-by-n ! u is m-by-mn such that u**H = mn-by-m ! Compute ainv = vt**T * u**H do j = 1 , m do i = 1 , n val = zero do k = 1 , mn val = val + vt ( k , i ) * conjg ( u ( j , k )) end do ainv ( i , j ) = val end do end do end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\linalg_inverse.f90.html"}]}