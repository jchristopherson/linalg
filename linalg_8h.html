<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linalg: D:/Code/linalg/include/linalg.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">linalg<span id="projectnumber">&#160;1.7.2</span>
   </div>
   <div id="projectbrief">A linear algebra library that provides a user-friendly interface to several BLAS and LAPACK routines.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('linalg_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">linalg.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;complex.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for linalg.h:</div>
<div class="dyncontent">
<div class="center"><img src="linalg_8h__incl.png" border="0" usemap="#a_d_1_2_code_2linalg_2include_2linalg_8h" alt=""/></div>
</div>
</div>
<p><a href="linalg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a160db488235a6488210c6a568b40feac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a160db488235a6488210c6a568b40feac">LA_NO_OPERATION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a160db488235a6488210c6a568b40feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab035511502c13b24f1595b6a14db92b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ab035511502c13b24f1595b6a14db92b5">LA_TRANSPOSE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ab035511502c13b24f1595b6a14db92b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071eb267613728559c01cae60dee12f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aa071eb267613728559c01cae60dee12f">LA_HERMITIAN_TRANSPOSE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aa071eb267613728559c01cae60dee12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619775ccc1cd838dafb88588e44fe440"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a619775ccc1cd838dafb88588e44fe440">LA_NO_ERROR</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a619775ccc1cd838dafb88588e44fe440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f9f45d8670ba8e0a1519cd25f941e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a230f9f45d8670ba8e0a1519cd25f941e">LA_INVALID_INPUT_ERROR</a>&#160;&#160;&#160;101</td></tr>
<tr class="separator:a230f9f45d8670ba8e0a1519cd25f941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee230d04e9d60069f04afa567a0e5a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a3ee230d04e9d60069f04afa567a0e5a1">LA_ARRAY_SIZE_ERROR</a>&#160;&#160;&#160;102</td></tr>
<tr class="separator:a3ee230d04e9d60069f04afa567a0e5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580fe449b937b3204a3a46ca3b9ed73b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a580fe449b937b3204a3a46ca3b9ed73b">LA_SINGULAR_MATRIX_ERROR</a>&#160;&#160;&#160;103</td></tr>
<tr class="separator:a580fe449b937b3204a3a46ca3b9ed73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238e8f48822d3b159799e54b1400bde7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a238e8f48822d3b159799e54b1400bde7">LA_MATRIX_FORMAT_ERROR</a>&#160;&#160;&#160;104</td></tr>
<tr class="separator:a238e8f48822d3b159799e54b1400bde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc24a81ba42bd8eae8f051719700dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aacdc24a81ba42bd8eae8f051719700dc">LA_OUT_OF_MEMORY_ERROR</a>&#160;&#160;&#160;105</td></tr>
<tr class="separator:aacdc24a81ba42bd8eae8f051719700dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd60d207bdd796c2e13b565a42d51d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#acbcd60d207bdd796c2e13b565a42d51d">LA_CONVERGENCE_ERROR</a>&#160;&#160;&#160;106</td></tr>
<tr class="separator:acbcd60d207bdd796c2e13b565a42d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e553840b774f1f646e6862c05c376f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ad0e553840b774f1f646e6862c05c376f">LA_INVALID_OPERATION_ERROR</a>&#160;&#160;&#160;107</td></tr>
<tr class="separator:ad0e553840b774f1f646e6862c05c376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab346fed23fd61f02d65e09c795c26d74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ab346fed23fd61f02d65e09c795c26d74">la_rank1_update</a> (int m, int n, double alpha, const double *x, const double *y, double *a, int lda)</td></tr>
<tr class="separator:ab346fed23fd61f02d65e09c795c26d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c958fe274f8d1663dd0188455a5fe15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a3c958fe274f8d1663dd0188455a5fe15">la_rank1_update_cmplx</a> (int m, int n, double complex alpha, const double complex *x, const double complex *y, double complex *a, int lda)</td></tr>
<tr class="separator:a3c958fe274f8d1663dd0188455a5fe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f611f8f3de7d56120c78e70671c7112"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a7f611f8f3de7d56120c78e70671c7112">la_trace</a> (int m, int n, const double *a, int lda, double *rst)</td></tr>
<tr class="separator:a7f611f8f3de7d56120c78e70671c7112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021fbb7fdccf557ec407a86bace43d85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a021fbb7fdccf557ec407a86bace43d85">la_trace_cmplx</a> (int m, int n, const double complex *a, int lda, double complex *rst)</td></tr>
<tr class="separator:a021fbb7fdccf557ec407a86bace43d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968b10545320af7bbe1030867ae88e8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a968b10545320af7bbe1030867ae88e8c">la_mtx_mult</a> (bool transa, bool transb, int m, int n, int k, double alpha, const double *a, int lda, const double *b, int ldb, double beta, double *c, int ldc)</td></tr>
<tr class="separator:a968b10545320af7bbe1030867ae88e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefefe80e13f74470d5afaf44b3a45e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aefefe80e13f74470d5afaf44b3a45e76">la_mtx_mult_cmplx</a> (int opa, int opb, int m, int n, int k, double complex alpha, const double complex *a, int lda, const double complex *b, int ldb, double complex beta, double complex *c, int ldc)</td></tr>
<tr class="separator:aefefe80e13f74470d5afaf44b3a45e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b74177a8914b109e1bf3aa56c9d9cb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a4b74177a8914b109e1bf3aa56c9d9cb7">la_diag_mtx_mult</a> (bool lside, bool transb, int m, int n, int k, double alpha, const double *a, const double *b, int ldb, double beta, double *c, int ldc)</td></tr>
<tr class="separator:a4b74177a8914b109e1bf3aa56c9d9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bec2daa56fdc4bbf3f45b67ea14f65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a63bec2daa56fdc4bbf3f45b67ea14f65">la_diag_mtx_mult_cmplx</a> (bool lside, int opb, int m, int n, int k, double complex alpha, const double complex *a, const double complex *b, int ldb, double complex beta, double complex *c, int ldc)</td></tr>
<tr class="separator:a63bec2daa56fdc4bbf3f45b67ea14f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5bad18dcc8a52d9594cc21954c572d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a4d5bad18dcc8a52d9594cc21954c572d">la_diag_mtx_mult_mixed</a> (bool lside, int opb, int m, int n, int k, double complex alpha, const double *a, const double complex *b, int ldb, double complex beta, double complex *c, int ldc)</td></tr>
<tr class="separator:a4d5bad18dcc8a52d9594cc21954c572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089690d293303e30c6eef0bb1e982191"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a089690d293303e30c6eef0bb1e982191">la_rank</a> (int m, int n, double *a, int lda, int *rnk)</td></tr>
<tr class="separator:a089690d293303e30c6eef0bb1e982191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc9b7e6ffab89915a082c00ceac7258"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#afdc9b7e6ffab89915a082c00ceac7258">la_rank_cmplx</a> (int m, int n, double complex *a, int lda, int *rnk)</td></tr>
<tr class="separator:afdc9b7e6ffab89915a082c00ceac7258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b4894cd929a106e02a8e37a4d52913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ac7b4894cd929a106e02a8e37a4d52913">la_det</a> (int n, double *a, int lda, double *d)</td></tr>
<tr class="separator:ac7b4894cd929a106e02a8e37a4d52913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9edf6a878ee4dd0b220b75b7db6431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ace9edf6a878ee4dd0b220b75b7db6431">la_det_cmplx</a> (int n, double complex *a, int lda, double complex *d)</td></tr>
<tr class="separator:ace9edf6a878ee4dd0b220b75b7db6431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d70f1ef2a2824772e1bf0f726c257e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ae7d70f1ef2a2824772e1bf0f726c257e">la_tri_mtx_mult</a> (bool upper, double alpha, int n, const double *a, int lda, double beta, double *b, int ldb)</td></tr>
<tr class="separator:ae7d70f1ef2a2824772e1bf0f726c257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c464a9dd95298c91f431ae4d0773e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a02c464a9dd95298c91f431ae4d0773e9">la_tri_mtx_mult_cmplx</a> (bool upper, double complex alpha, int n, const double complex *a, int lda, double complex beta, double complex *b, int ldb)</td></tr>
<tr class="separator:a02c464a9dd95298c91f431ae4d0773e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248142a5f0826cddac5daf1c74f234a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a248142a5f0826cddac5daf1c74f234a6">la_lu_factor</a> (int m, int n, double *a, int lda, int *ipvt)</td></tr>
<tr class="separator:a248142a5f0826cddac5daf1c74f234a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace554b62c12a5d9a2434c8171c756c47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ace554b62c12a5d9a2434c8171c756c47">la_lu_factor_cmplx</a> (int m, int n, double complex *a, int lda, int *ipvt)</td></tr>
<tr class="separator:ace554b62c12a5d9a2434c8171c756c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15774f6323c34d307c99b32ac4f188a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a15774f6323c34d307c99b32ac4f188a7">la_form_lu</a> (int n, double *a, int lda, int *ipvt, double *u, int ldu, double *p, int ldp)</td></tr>
<tr class="separator:a15774f6323c34d307c99b32ac4f188a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bea3ca338925cfa4a58bcaea726a14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a73bea3ca338925cfa4a58bcaea726a14">la_form_lu_cmplx</a> (int n, double complex *a, int lda, int *ipvt, double complex *u, int ldu, double *p, int ldp)</td></tr>
<tr class="separator:a73bea3ca338925cfa4a58bcaea726a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791d5221eb8ad4fcd106cb218590dfc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a791d5221eb8ad4fcd106cb218590dfc9">la_qr_factor</a> (int m, int n, double *a, int lda, double *tau)</td></tr>
<tr class="separator:a791d5221eb8ad4fcd106cb218590dfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ffa6e8d9c850bd41f43f7564bf6896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ae5ffa6e8d9c850bd41f43f7564bf6896">la_qr_factor_cmplx</a> (int m, int n, double complex *a, int lda, double complex *tau)</td></tr>
<tr class="separator:ae5ffa6e8d9c850bd41f43f7564bf6896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc671dad87b42ff285a4241322a3764"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a4bc671dad87b42ff285a4241322a3764">la_qr_factor_pvt</a> (int m, int n, double *a, int lda, double *tau, int *jpvt)</td></tr>
<tr class="separator:a4bc671dad87b42ff285a4241322a3764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3f6dafe185c2985fc76aab3d0abb97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a4a3f6dafe185c2985fc76aab3d0abb97">la_qr_factor_cmplx_pvt</a> (int m, int n, double complex *a, int lda, double complex *tau, int *jpvt)</td></tr>
<tr class="separator:a4a3f6dafe185c2985fc76aab3d0abb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe39765d805c1d9ae93e9aa2f20d8548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#afe39765d805c1d9ae93e9aa2f20d8548">la_form_qr</a> (bool fullq, int m, int n, double *r, int ldr, const double *tau, double *q, int ldq)</td></tr>
<tr class="separator:afe39765d805c1d9ae93e9aa2f20d8548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0338870fe1142f88c96db63495fec615"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a0338870fe1142f88c96db63495fec615">la_form_qr_cmplx</a> (bool fullq, int m, int n, double complex *r, int ldr, const double complex *tau, double complex *q, int ldq)</td></tr>
<tr class="separator:a0338870fe1142f88c96db63495fec615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace787c5b11959a457b936ace4995033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aace787c5b11959a457b936ace4995033">la_form_qr_pvt</a> (bool fullq, int m, int n, double *r, int ldr, const double *tau, const int *pvt, double *q, int ldq, double *p, int ldp)</td></tr>
<tr class="separator:aace787c5b11959a457b936ace4995033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e25c5eb98075e83cc9df493be5b38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ad76e25c5eb98075e83cc9df493be5b38">la_form_qr_cmplx_pvt</a> (bool fullq, int m, int n, double complex *r, int ldr, const double complex *tau, const int *pvt, double complex *q, int ldq, double complex *p, int ldp)</td></tr>
<tr class="separator:ad76e25c5eb98075e83cc9df493be5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f921847131eaedd62a439490d2a801"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a95f921847131eaedd62a439490d2a801">la_mult_qr</a> (bool lside, bool trans, int m, int n, int k, double *a, int lda, const double *tau, double *c, int ldc)</td></tr>
<tr class="separator:a95f921847131eaedd62a439490d2a801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25c0daa53c10ace21a61d78b2e79f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#acc25c0daa53c10ace21a61d78b2e79f3">la_mult_qr_cmplx</a> (bool lside, bool trans, int m, int n, int k, double complex *a, int lda, const double complex *tau, double complex *c, int ldc)</td></tr>
<tr class="separator:acc25c0daa53c10ace21a61d78b2e79f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0639faf9ac0af9bbdb348b92746d5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a9b0639faf9ac0af9bbdb348b92746d5f">la_qr_rank1_update</a> (int m, int n, double *q, int ldq, double *r, int ldr, double *u, double *v)</td></tr>
<tr class="separator:a9b0639faf9ac0af9bbdb348b92746d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3967bc139cba341a513d1353bea62ac9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a3967bc139cba341a513d1353bea62ac9">la_cholesky_factor</a> (bool upper, int n, double *a, int lda)</td></tr>
<tr class="separator:a3967bc139cba341a513d1353bea62ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1734acc61ef569dfff9c83bcad566f67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a1734acc61ef569dfff9c83bcad566f67">la_cholesky_factor_cmplx</a> (bool upper, int n, double complex *a, int lda)</td></tr>
<tr class="separator:a1734acc61ef569dfff9c83bcad566f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb7ee58d4151498be96aa91432f296f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#abeb7ee58d4151498be96aa91432f296f">la_cholesky_rank1_update</a> (int n, double *r, int ldr, double *u)</td></tr>
<tr class="separator:abeb7ee58d4151498be96aa91432f296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292e54c48a8e7f0203bf11f02844691f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a292e54c48a8e7f0203bf11f02844691f">la_cholesky_rank1_downdate</a> (int n, double *r, int ldr, double *u)</td></tr>
<tr class="separator:a292e54c48a8e7f0203bf11f02844691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c15ec713541d15eae1fd0b01897689"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a00c15ec713541d15eae1fd0b01897689">la_cholesky_rank1_downdate_cmplx</a> (int n, double complex *r, int ldr, double complex *u)</td></tr>
<tr class="separator:a00c15ec713541d15eae1fd0b01897689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c0cea99a066e74c8fff9682d5ca92d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a56c0cea99a066e74c8fff9682d5ca92d">la_svd</a> (int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldv)</td></tr>
<tr class="separator:a56c0cea99a066e74c8fff9682d5ca92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbffa0856d75c607a03d3dc7b5b1076e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#afbffa0856d75c607a03d3dc7b5b1076e">la_svd_cmplx</a> (int m, int n, double complex *a, int lda, double *s, double complex *u, int ldu, double complex *vt, int ldv)</td></tr>
<tr class="separator:afbffa0856d75c607a03d3dc7b5b1076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7b29bbff1472ebe805054eb9d8c6d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aed7b29bbff1472ebe805054eb9d8c6d4">la_solve_tri_mtx</a> (bool lside, bool upper, bool trans, bool nounit, int m, int n, double alpha, const double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:aed7b29bbff1472ebe805054eb9d8c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87823d73fb5a319e4262594d147e38c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#af87823d73fb5a319e4262594d147e38c">la_solve_tri_mtx_cmplx</a> (bool lside, bool upper, bool trans, bool nounit, int m, int n, double complex alpha, const double complex *a, int lda, double complex *b, int ldb)</td></tr>
<tr class="separator:af87823d73fb5a319e4262594d147e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae725d3247301d1163c58f89edff3d4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aae725d3247301d1163c58f89edff3d4b">la_solve_lu</a> (int m, int n, const double *a, int lda, const int *ipvt, double *b, int ldb)</td></tr>
<tr class="separator:aae725d3247301d1163c58f89edff3d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa067ac0d3f58e28371d413ab7419da74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aa067ac0d3f58e28371d413ab7419da74">la_solve_lu_cmplx</a> (int m, int n, const double complex *a, int lda, const int *ipvt, double complex *b, int ldb)</td></tr>
<tr class="separator:aa067ac0d3f58e28371d413ab7419da74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdc2e6758482d02a3aa7978f7d5efe0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aefdc2e6758482d02a3aa7978f7d5efe0">la_solve_qr</a> (int m, int n, int k, double *a, int lda, const double *tau, double *b, int ldb)</td></tr>
<tr class="separator:aefdc2e6758482d02a3aa7978f7d5efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff5f2519eb1d2af94e3b4a26dfb10fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a0ff5f2519eb1d2af94e3b4a26dfb10fe">la_solve_qr_cmplx</a> (int m, int n, int k, double complex *a, int lda, const double complex *tau, double complex *b, int ldb)</td></tr>
<tr class="separator:a0ff5f2519eb1d2af94e3b4a26dfb10fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f97b4319f5574aef5e52bbacff14bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a62f97b4319f5574aef5e52bbacff14bb">la_solve_qr_pvt</a> (int m, int n, int k, double *a, int lda, const double *tau, const int *jpvt, double *b, int ldb)</td></tr>
<tr class="separator:a62f97b4319f5574aef5e52bbacff14bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ee4a9c71de62911a71a342790f5070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ad0ee4a9c71de62911a71a342790f5070">la_solve_qr_cmplx_pvt</a> (int m, int n, int k, double complex *a, int lda, const double complex *tau, const int *jpvt, double complex *b, int ldb)</td></tr>
<tr class="separator:ad0ee4a9c71de62911a71a342790f5070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc578507a0cb6ada776142476383590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a0dc578507a0cb6ada776142476383590">la_solve_cholesky</a> (bool upper, int m, int n, const double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:a0dc578507a0cb6ada776142476383590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719ffdff56c8fa0875409c4f4e5e95cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a719ffdff56c8fa0875409c4f4e5e95cf">la_solve_cholesky_cmplx</a> (bool upper, int m, int n, const double complex *a, int lda, double complex *b, int ldb)</td></tr>
<tr class="separator:a719ffdff56c8fa0875409c4f4e5e95cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eb049983dd41f2307bb52594fb210e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a02eb049983dd41f2307bb52594fb210e">la_solve_least_squares</a> (int m, int n, int k, double *a, int lda, double *b, int ldb)</td></tr>
<tr class="separator:a02eb049983dd41f2307bb52594fb210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bb7b959d8cc7400e9b13290a895b64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ac3bb7b959d8cc7400e9b13290a895b64">la_solve_least_squares_cmplx</a> (int m, int n, int k, double complex *a, int lda, double complex *b, int ldb)</td></tr>
<tr class="separator:ac3bb7b959d8cc7400e9b13290a895b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d6ed56844c62d553b940091837014b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a95d6ed56844c62d553b940091837014b">la_inverse</a> (int n, double *a, int lda)</td></tr>
<tr class="separator:a95d6ed56844c62d553b940091837014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a821b41c61670f5710214a4d9178998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a7a821b41c61670f5710214a4d9178998">la_inverse_cmplx</a> (int n, double complex *a, int lda)</td></tr>
<tr class="separator:a7a821b41c61670f5710214a4d9178998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f8185c0f25ad3fb0b89cc98d77b3d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#af7f8185c0f25ad3fb0b89cc98d77b3d6">la_pinverse</a> (int m, int n, double *a, int lda, double *ainv, int ldai)</td></tr>
<tr class="separator:af7f8185c0f25ad3fb0b89cc98d77b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba1a09caca9d59a9d24b95c7ea749b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a71ba1a09caca9d59a9d24b95c7ea749b">la_pinverse_cmplx</a> (int m, int n, double complex *a, int lda, double complex *ainv, int ldai)</td></tr>
<tr class="separator:a71ba1a09caca9d59a9d24b95c7ea749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac208d5e6849972a77ef261f2e368868c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ac208d5e6849972a77ef261f2e368868c">la_eigen_symm</a> (bool vecs, int n, double *a, int lda, double *vals)</td></tr>
<tr class="separator:ac208d5e6849972a77ef261f2e368868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9491626ab4b3664771e1282b61eeaa74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a9491626ab4b3664771e1282b61eeaa74">la_eigen_asymm</a> (bool vecs, int n, double *a, int lda, double complex *vals, double complex *v, int ldv)</td></tr>
<tr class="separator:a9491626ab4b3664771e1282b61eeaa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c6f1a45aee2f275d4b109c9bb660d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#af3c6f1a45aee2f275d4b109c9bb660d2">la_eigen_gen</a> (bool vecs, int n, double *a, int lda, double *b, int ldb, double complex *alpha, double *beta, double complex *v, int ldv)</td></tr>
<tr class="separator:af3c6f1a45aee2f275d4b109c9bb660d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a16375c14c924836c33bafa747a1cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ae5a16375c14c924836c33bafa747a1cf">la_eigen_cmplx</a> (bool vecs, int n, double complex *a, int lda, double complex *vals, double complex *v, int ldv)</td></tr>
<tr class="separator:ae5a16375c14c924836c33bafa747a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5918abab8f97fc2ac5887e051ff493"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#abf5918abab8f97fc2ac5887e051ff493">la_sort_eigen</a> (bool ascend, int n, double *vals, double *vecs, int ldv)</td></tr>
<tr class="separator:abf5918abab8f97fc2ac5887e051ff493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090178a5f99a4b400da80481aad77757"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a090178a5f99a4b400da80481aad77757">la_sort_eigen_cmplx</a> (bool ascend, int n, double complex *vals, double complex *vecs, int ldv)</td></tr>
<tr class="separator:a090178a5f99a4b400da80481aad77757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2048bb219e58f455175041558ac44f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a7b2048bb219e58f455175041558ac44f">la_lq_factor</a> (int m, int n, double *a, int lda, double *tau)</td></tr>
<tr class="separator:a7b2048bb219e58f455175041558ac44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54763802ad5c3966f8e14cdf93fdc96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ac54763802ad5c3966f8e14cdf93fdc96">la_form_lq</a> (int m, int n, double *l, int ldl, const double *tau, double *q, int ldq)</td></tr>
<tr class="separator:ac54763802ad5c3966f8e14cdf93fdc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac575e10e20e9c2d8d40ed8df47179773"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ac575e10e20e9c2d8d40ed8df47179773">la_mult_lq</a> (bool lside, bool trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)</td></tr>
<tr class="separator:ac575e10e20e9c2d8d40ed8df47179773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c485d619c24435be713cf4356285e9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a2c485d619c24435be713cf4356285e9a">la_solve_lq</a> (int m, int n, int k, const double *a, int lda, const double *tau, double *b, int ldb)</td></tr>
<tr class="separator:a2c485d619c24435be713cf4356285e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd42393c8b1931ff11bc4c7e858aef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#acfbd42393c8b1931ff11bc4c7e858aef">la_qr_rank1_update_cmplx</a> (int m, int n, double complex *q, int ldq, double complex *r, int ldr, double complex *u, double complex *v)</td></tr>
<tr class="separator:acfbd42393c8b1931ff11bc4c7e858aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19ebf41be31ee92f657131a8fbf55a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#af19ebf41be31ee92f657131a8fbf55a3">la_cholesky_rank1_update_cmplx</a> (int n, double complex *r, int ldr, double complex *u)</td></tr>
<tr class="separator:af19ebf41be31ee92f657131a8fbf55a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6786c40f8f91e5f16f06e92be71ffa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a5e6786c40f8f91e5f16f06e92be71ffa">la_lq_factor_cmplx</a> (int m, int n, double complex *a, int lda, double complex *tau)</td></tr>
<tr class="separator:a5e6786c40f8f91e5f16f06e92be71ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54b8d224976dca7ef384eed74f50bed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#aa54b8d224976dca7ef384eed74f50bed">la_form_lq_cmplx</a> (int m, int n, double complex *l, int ldl, const double complex *tau, double complex *q, int ldq)</td></tr>
<tr class="separator:aa54b8d224976dca7ef384eed74f50bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb07293cf47d090dfb89c20837ca7b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#adcb07293cf47d090dfb89c20837ca7b5">la_mult_lq_cmplx</a> (bool lside, bool trans, int m, int n, int k, const double complex *a, int lda, const double complex *tau, double complex *c, int ldc)</td></tr>
<tr class="separator:adcb07293cf47d090dfb89c20837ca7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee9d9ab89b88b0ca682f70bc6c3c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a54ee9d9ab89b88b0ca682f70bc6c3c54">la_solve_lq_cmplx</a> (int m, int n, int k, const double complex *a, int lda, const double complex *tau, double complex *b, int ldb)</td></tr>
<tr class="separator:a54ee9d9ab89b88b0ca682f70bc6c3c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3ee230d04e9d60069f04afa567a0e5a1" name="a3ee230d04e9d60069f04afa567a0e5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee230d04e9d60069f04afa567a0e5a1">&#9670;&#160;</a></span>LA_ARRAY_SIZE_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_ARRAY_SIZE_ERROR&#160;&#160;&#160;102</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00200">200</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="acbcd60d207bdd796c2e13b565a42d51d" name="acbcd60d207bdd796c2e13b565a42d51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcd60d207bdd796c2e13b565a42d51d">&#9670;&#160;</a></span>LA_CONVERGENCE_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_CONVERGENCE_ERROR&#160;&#160;&#160;106</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00204">204</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="aa071eb267613728559c01cae60dee12f" name="aa071eb267613728559c01cae60dee12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa071eb267613728559c01cae60dee12f">&#9670;&#160;</a></span>LA_HERMITIAN_TRANSPOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_HERMITIAN_TRANSPOSE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00197">197</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="a230f9f45d8670ba8e0a1519cd25f941e" name="a230f9f45d8670ba8e0a1519cd25f941e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230f9f45d8670ba8e0a1519cd25f941e">&#9670;&#160;</a></span>LA_INVALID_INPUT_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_INVALID_INPUT_ERROR&#160;&#160;&#160;101</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00199">199</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="ad0e553840b774f1f646e6862c05c376f" name="ad0e553840b774f1f646e6862c05c376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e553840b774f1f646e6862c05c376f">&#9670;&#160;</a></span>LA_INVALID_OPERATION_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_INVALID_OPERATION_ERROR&#160;&#160;&#160;107</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00205">205</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="a238e8f48822d3b159799e54b1400bde7" name="a238e8f48822d3b159799e54b1400bde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238e8f48822d3b159799e54b1400bde7">&#9670;&#160;</a></span>LA_MATRIX_FORMAT_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_MATRIX_FORMAT_ERROR&#160;&#160;&#160;104</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00202">202</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="a619775ccc1cd838dafb88588e44fe440" name="a619775ccc1cd838dafb88588e44fe440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619775ccc1cd838dafb88588e44fe440">&#9670;&#160;</a></span>LA_NO_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_NO_ERROR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00198">198</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="a160db488235a6488210c6a568b40feac" name="a160db488235a6488210c6a568b40feac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160db488235a6488210c6a568b40feac">&#9670;&#160;</a></span>LA_NO_OPERATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_NO_OPERATION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00195">195</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="aacdc24a81ba42bd8eae8f051719700dc" name="aacdc24a81ba42bd8eae8f051719700dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc24a81ba42bd8eae8f051719700dc">&#9670;&#160;</a></span>LA_OUT_OF_MEMORY_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_OUT_OF_MEMORY_ERROR&#160;&#160;&#160;105</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00203">203</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="a580fe449b937b3204a3a46ca3b9ed73b" name="a580fe449b937b3204a3a46ca3b9ed73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580fe449b937b3204a3a46ca3b9ed73b">&#9670;&#160;</a></span>LA_SINGULAR_MATRIX_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_SINGULAR_MATRIX_ERROR&#160;&#160;&#160;103</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00201">201</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<a id="ab035511502c13b24f1595b6a14db92b5" name="ab035511502c13b24f1595b6a14db92b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab035511502c13b24f1595b6a14db92b5">&#9670;&#160;</a></span>LA_TRANSPOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LA_TRANSPOSE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linalg_8h_source.html#l00196">196</a> of file <a class="el" href="linalg_8h_source.html">linalg.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3967bc139cba341a513d1353bea62ac9" name="a3967bc139cba341a513d1353bea62ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3967bc139cba341a513d1353bea62ac9">&#9670;&#160;</a></span>la_cholesky_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the Cholesky factorization of a symmetric, positive definite matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true to compute the upper triangular factoriztion \( A = U^T U \); else, set to false to compute the lower triangular factorzation \( A = L L^T \). </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of matrix A. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix to factor. On output, the factored matrix is returned in either the upper or lower triangular portion of the matrix, dependent upon the value of <code>upper</code>. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if <code>a</code> is not positive definite. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1734acc61ef569dfff9c83bcad566f67" name="a1734acc61ef569dfff9c83bcad566f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1734acc61ef569dfff9c83bcad566f67">&#9670;&#160;</a></span>la_cholesky_factor_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_factor_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the Cholesky factorization of a symmetric, positive definite matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true to compute the upper triangular factoriztion \( A = U^T U \); else, set to false to compute the lower triangular factorzation \( A = L L^T \). </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of matrix A. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix to factor. On output, the factored matrix is returned in either the upper or lower triangular portion of the matrix, dependent upon the value of <code>upper</code>. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if <code>a</code> is not positive definite. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a292e54c48a8e7f0203bf11f02844691f" name="a292e54c48a8e7f0203bf11f02844691f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292e54c48a8e7f0203bf11f02844691f">&#9670;&#160;</a></span>la_cholesky_rank1_downdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_rank1_downdate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not positive definite. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a00c15ec713541d15eae1fd0b01897689" name="a00c15ec713541d15eae1fd0b01897689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c15ec713541d15eae1fd0b01897689">&#9670;&#160;</a></span>la_cholesky_rank1_downdate_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_rank1_downdate_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 downdate to a Cholesky factored matrix (upper triangular).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_MATRIX_FORMAT_ERROR: Occurs if the downdated matrix is not positive definite. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abeb7ee58d4151498be96aa91432f296f" name="abeb7ee58d4151498be96aa91432f296f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb7ee58d4151498be96aa91432f296f">&#9670;&#160;</a></span>la_cholesky_rank1_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_rank1_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 update to a Cholesky factored matrix (upper triangular).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af19ebf41be31ee92f657131a8fbf55a3" name="af19ebf41be31ee92f657131a8fbf55a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19ebf41be31ee92f657131a8fbf55a3">&#9670;&#160;</a></span>la_cholesky_rank1_update_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_cholesky_rank1_update_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 update to a Cholesky factored matrix (upper triangular).</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the N-by-N upper triangular matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the N-element update vector U. On output, the rotation sines used to transform R to R1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac7b4894cd929a106e02a8e37a4d52913" name="ac7b4894cd929a106e02a8e37a4d52913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b4894cd929a106e02a8e37a4d52913">&#9670;&#160;</a></span>la_det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_det </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the determinant of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The N-by-N matrix. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of the matrix. </td></tr>
    <tr><td class="paramname">d</td><td>The determinant of <code>a</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ace9edf6a878ee4dd0b220b75b7db6431" name="ace9edf6a878ee4dd0b220b75b7db6431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9edf6a878ee4dd0b220b75b7db6431">&#9670;&#160;</a></span>la_det_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_det_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the determinant of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The N-by-N matrix. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of the matrix. </td></tr>
    <tr><td class="paramname">d</td><td>The determinant of <code>a</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not sized appropriately.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4b74177a8914b109e1bf3aa56c9d9cb7" name="a4b74177a8914b109e1bf3aa56c9d9cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b74177a8914b109e1bf3aa56c9d9cb7">&#9670;&#160;</a></span>la_diag_mtx_mult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_diag_mtx_mult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the matrix operation: \( C = \alpha A op(B) + \beta C \), or \( C = \alpha op(B) A + \beta C \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply matrix A from the left; else, set to false to apply matrix A from the left. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true if op(B) == B**T; else, set to false if op(B) == B. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The inner dimension of the matrix product A * op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">a</td><td>A P-element array containing the diagonal elements of matrix A where P = MIN(<code>m</code>, <code>k</code>) if <code>lside</code> is true; else, P = MIN(<code>n</code>, <code>k</code>) if <code>lside</code> is false. </td></tr>
    <tr><td class="paramname">b</td><td>The LDB-by-TDB matrix B where (LDB = leading dimension of B, and TDB = trailing dimension of B):<ul>
<li><code>lside</code> == true &amp; <code>trans</code> == true: LDB = <code>n</code>, TDB = <code>k</code> </li>
<li><code>lside</code> == true &amp; <code>trans</code> == false: LDB = <code>k</code>, TDB = <code>n</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == true: LDB = <code>k</code>, TDB = <code>m</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == false: LDB = <code>m</code>, TDB = <code>k</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">c</td><td>The <code>m</code> by <code>n</code> matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldb</code>, or <code>ldc</code> are not correct.</li>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a63bec2daa56fdc4bbf3f45b67ea14f65" name="a63bec2daa56fdc4bbf3f45b67ea14f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bec2daa56fdc4bbf3f45b67ea14f65">&#9670;&#160;</a></span>la_diag_mtx_mult_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_diag_mtx_mult_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the matrix operation: \( C = \alpha A op(B) + \beta C \), or \( C = \alpha op(B) A + \beta * C \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply matrix A from the left; else, set to false to apply matrix A from the left. </td></tr>
    <tr><td class="paramname">opb</td><td>Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B, set to LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose of B, otherwise, set to LA_NO_OPERATION to compute op(B) as B. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The inner dimension of the matrix product A * op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">a</td><td>A P-element array containing the diagonal elements of matrix A where P = MIN(<code>m</code>, <code>k</code>) if <code>lside</code> is true; else, P = MIN(<code>n</code>, <code>k</code>) if <code>lside</code> is false. </td></tr>
    <tr><td class="paramname">b</td><td>The LDB-by-TDB matrix B where (LDB = leading dimension of B, and TDB = trailing dimension of B):<ul>
<li><code>lside</code> == true &amp; <code>trans</code> == true: LDB = <code>n</code>, TDB = <code>k</code> </li>
<li><code>lside</code> == true &amp; <code>trans</code> == false: LDB = <code>k</code>, TDB = <code>n</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == true: LDB = <code>k</code>, TDB = <code>m</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == false: LDB = <code>m</code>, TDB = <code>k</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">c</td><td>The <code>m</code> by <code>n</code> matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldb</code>, or <code>ldc</code> are not correct.</li>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4d5bad18dcc8a52d9594cc21954c572d" name="a4d5bad18dcc8a52d9594cc21954c572d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5bad18dcc8a52d9594cc21954c572d">&#9670;&#160;</a></span>la_diag_mtx_mult_mixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_diag_mtx_mult_mixed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the matrix operation: \( C = \alpha A op(B) + \beta C \), or \( C = \alpha op(B) A + \beta C \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply matrix A from the left; else, set to false to apply matrix A from the left. </td></tr>
    <tr><td class="paramname">opb</td><td>Set to LA_TRANSPOSE to compute op(B) as a direct transpose of B, set to LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose of B, otherwise, set to LA_NO_OPERATION to compute op(B) as B. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The inner dimension of the matrix product A * op(B). </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">a</td><td>A P-element array containing the diagonal elements of matrix A where P = MIN(<code>m</code>, <code>k</code>) if <code>lside</code> is true; else, P = MIN(<code>n</code>, <code>k</code>) if <code>lside</code> is false. </td></tr>
    <tr><td class="paramname">b</td><td>The LDB-by-TDB matrix B where (LDB = leading dimension of B, and TDB = trailing dimension of B):<ul>
<li><code>lside</code> == true &amp; <code>trans</code> == true: LDB = <code>n</code>, TDB = <code>k</code> </li>
<li><code>lside</code> == true &amp; <code>trans</code> == false: LDB = <code>k</code>, TDB = <code>n</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == true: LDB = <code>k</code>, TDB = <code>m</code> </li>
<li><code>lside</code> == false &amp; <code>trans</code> == false: LDB = <code>m</code>, TDB = <code>k</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">c</td><td>The <code>m</code> by <code>n</code> matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldb</code>, or <code>ldc</code> are not correct.</li>
<li>LA_ARRAY_SIZE_ERROR: Occurs if any of the input array sizes are incorrect. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9491626ab4b3664771e1282b61eeaa74" name="a9491626ab4b3664771e1282b61eeaa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9491626ab4b3664771e1282b61eeaa74">&#9670;&#160;</a></span>la_eigen_asymm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_eigen_asymm </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the eigenvalues, and optionally the right eigenvectors of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>Set to true to compute the eigenvectors as well as the eigenvalues; else, set to false to just compute the eigenvalues. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix on which to operate. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">vals</td><td>An N-element array containing the eigenvalues of the matrix. The eigenvalues are not sorted. </td></tr>
    <tr><td class="paramname">v</td><td>An N-by-N matrix where the right eigenvectors will be written (one per column).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae5a16375c14c924836c33bafa747a1cf" name="ae5a16375c14c924836c33bafa747a1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a16375c14c924836c33bafa747a1cf">&#9670;&#160;</a></span>la_eigen_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_eigen_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the eigenvalues, and optionally the right eigenvectors of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>Set to true to compute the eigenvectors as well as the eigenvalues; else, set to false to just compute the eigenvalues. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix on which to operate. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">vals</td><td>An N-element array containing the eigenvalues of the matrix. The eigenvalues are not sorted. </td></tr>
    <tr><td class="paramname">v</td><td>An N-by-N matrix where the right eigenvectors will be written (one per column).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af3c6f1a45aee2f275d4b109c9bb660d2" name="af3c6f1a45aee2f275d4b109c9bb660d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c6f1a45aee2f275d4b109c9bb660d2">&#9670;&#160;</a></span>la_eigen_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_eigen_gen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the eigenvalues, and optionally the right eigenvectors of a square matrix assuming the structure of the eigenvalue problem is \( A X = \lambda B X \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>Set to true to compute the eigenvectors as well as the eigenvalues; else, set to false to just compute the eigenvalues. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix A. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the N-by-N matrix B. On output, the contents of this matrix are overwritten. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B. </td></tr>
    <tr><td class="paramname">alpha</td><td>An N-element array a factor of the eigenvalues. The eigenvalues must be computed as ALPHA / BETA. This however, is not as trivial as it seems as it is entirely possible, and likely, that ALPHA / BETA can overflow or underflow. With that said, the values in ALPHA will always be less than and usually comparable with the NORM(A). </td></tr>
    <tr><td class="paramname">beta</td><td>An N-element array that contains the denominator used to determine the eigenvalues as ALPHA / BETA. If used, the values in this array will always be less than and usually comparable with the NORM(B). </td></tr>
    <tr><td class="paramname">v</td><td>An N-by-N matrix where the right eigenvectors will be written (one per column).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac208d5e6849972a77ef261f2e368868c" name="ac208d5e6849972a77ef261f2e368868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac208d5e6849972a77ef261f2e368868c">&#9670;&#160;</a></span>la_eigen_symm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_eigen_symm </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the eigenvalues, and optionally the eigenvectors of a real, symmetric matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>Set to true to compute the eigenvectors as well as the eigenvalues; else, set to false to just compute the eigenvalues. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N symmetric matrix on which to operate. On output, and if <code>vecs</code> is set to true, the matrix will contain the eigenvectors (one per column) corresponding to each eigenvalue in <code>vals</code>. If <code>vecs</code> is set to false, the lower triangular portion of the matrix is overwritten. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">vals</td><td>An N-element array that will contain the eigenvalues sorted into ascending order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs if the algorithm failed to converge. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac54763802ad5c3966f8e14cdf93fdc96" name="ac54763802ad5c3966f8e14cdf93fdc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54763802ad5c3966f8e14cdf93fdc96">&#9670;&#160;</a></span>la_form_lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_lq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the matrix Q with orthonormal rows from the elementary reflectors returned by the base QR factorization algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">l</td><td>On input, the M-by-N factored matrix as returned by the LQ factorization routine. On output, the lower triangular matrix L. </td></tr>
    <tr><td class="paramname">ldl</td><td>The leading dimension of matrix L. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">q</td><td>An N-by-N matrix where the Q matrix will be written. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldl</code> or <code>ldq</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa54b8d224976dca7ef384eed74f50bed" name="aa54b8d224976dca7ef384eed74f50bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54b8d224976dca7ef384eed74f50bed">&#9670;&#160;</a></span>la_form_lq_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_lq_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the matrix Q with orthonormal rows from the elementary reflectors returned by the base QR factorization algorithm.</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">l</td><td>On input, the M-by-N factored matrix as returned by the LQ factorization routine. On output, the lower triangular matrix L. </td></tr>
    <tr><td class="paramname">ldl</td><td>The leading dimension of matrix L. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">q</td><td>An N-by-N matrix where the Q matrix will be written. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldl</code> or <code>ldq</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a15774f6323c34d307c99b32ac4f188a7" name="a15774f6323c34d307c99b32ac4f188a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15774f6323c34d307c99b32ac4f188a7">&#9670;&#160;</a></span>la_form_lu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_lu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts the L, U, and P matrices from the LU factorization output from la_lu_factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the input matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix as output by <a class="el" href="linalg_8h.html#a248142a5f0826cddac5daf1c74f234a6">la_lu_factor</a>. On output, the N-by-N lower triangular matrix L. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of <code>a</code>. </td></tr>
    <tr><td class="paramname">ipvt</td><td>The N-element pivot array as output by <a class="el" href="linalg_8h.html#a248142a5f0826cddac5daf1c74f234a6">la_lu_factor</a>. </td></tr>
    <tr><td class="paramname">u</td><td>An N-by-N matrix where the U matrix will be written. </td></tr>
    <tr><td class="paramname">ldu</td><td>The leading dimension of <code>u</code>. </td></tr>
    <tr><td class="paramname">p</td><td>An N-by-N matrix where the row permutation matrix will be written. </td></tr>
    <tr><td class="paramname">ldp</td><td>The leading dimension of <code>p</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldu</code>, or <code>ldp</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a73bea3ca338925cfa4a58bcaea726a14" name="a73bea3ca338925cfa4a58bcaea726a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bea3ca338925cfa4a58bcaea726a14">&#9670;&#160;</a></span>la_form_lu_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_lu_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts the L, U, and P matrices from the LU factorization output from la_lu_factor_cmplx.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of the input matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix as output by <a class="el" href="linalg_8h.html#ace554b62c12a5d9a2434c8171c756c47">la_lu_factor_cmplx</a>. On output, the N-by-N lower triangular matrix L. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of <code>a</code>. </td></tr>
    <tr><td class="paramname">ipvt</td><td>The N-element pivot array as output by <a class="el" href="linalg_8h.html#ace554b62c12a5d9a2434c8171c756c47">la_lu_factor_cmplx</a>. </td></tr>
    <tr><td class="paramname">u</td><td>An N-by-N matrix where the U matrix will be written. </td></tr>
    <tr><td class="paramname">ldu</td><td>The leading dimension of <code>u</code>. </td></tr>
    <tr><td class="paramname">p</td><td>An N-by-N matrix where the row permutation matrix will be written. </td></tr>
    <tr><td class="paramname">ldp</td><td>The leading dimension of <code>p</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldu</code>, or <code>ldp</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afe39765d805c1d9ae93e9aa2f20d8548" name="afe39765d805c1d9ae93e9aa2f20d8548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe39765d805c1d9ae93e9aa2f20d8548">&#9670;&#160;</a></span>la_form_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_qr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullq</td><td>Set to true to always return the full Q matrix; else, set to false, and in the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N factored matrix as returned by the QR factorization routine. On output, the upper triangular matrix R. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">q</td><td>An M-by-M matrix where the full Q matrix will be written. In the event that <code>fullq</code> is set to false, and M &gt; N, this matrix need only by M-by-N. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> or <code>ldq</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0338870fe1142f88c96db63495fec615" name="a0338870fe1142f88c96db63495fec615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0338870fe1142f88c96db63495fec615">&#9670;&#160;</a></span>la_form_qr_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_qr_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullq</td><td>Set to true to always return the full Q matrix; else, set to false, and in the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N factored matrix as returned by the QR factorization routine. On output, the upper triangular matrix R. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">q</td><td>An M-by-M matrix where the full Q matrix will be written. In the event that <code>fullq</code> is set to false, and M &gt; N, this matrix need only by M-by-N. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldr</code> or <code>ldq</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad76e25c5eb98075e83cc9df493be5b38" name="ad76e25c5eb98075e83cc9df493be5b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76e25c5eb98075e83cc9df493be5b38">&#9670;&#160;</a></span>la_form_qr_cmplx_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_qr_cmplx_pvt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. This routine also inflates the pivot array into an N-by-N matrix P such that \( A P = Q R \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullq</td><td>Set to true to always return the full Q matrix; else, set to false, and in the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N factored matrix as returned by the QR factorization routine. On output, the upper triangular matrix R. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">pvt</td><td>An N-element array containing the pivot information from the QR factorization. </td></tr>
    <tr><td class="paramname">q</td><td>An M-by-M matrix where the full Q matrix will be written. In the event that <code>fullq</code> is set to false, and M &gt; N, this matrix need only by M-by-N. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q. </td></tr>
    <tr><td class="paramname">p</td><td>An N-by-N matrix where the pivot matrix P will be written. </td></tr>
    <tr><td class="paramname">ldp</td><td>The leading dimension of matrix P.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aace787c5b11959a457b936ace4995033" name="aace787c5b11959a457b936ace4995033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace787c5b11959a457b936ace4995033">&#9670;&#160;</a></span>la_form_qr_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_form_qr_pvt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forms the full M-by-M orthogonal matrix Q from the elementary reflectors returned by the base QR factorization algorithm. This routine also inflates the pivot array into an N-by-N matrix P such that \( A P = Q R \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullq</td><td>Set to true to always return the full Q matrix; else, set to false, and in the event that M &gt; N, Q may be supplied as M-by-N, and therefore only return the useful submatrix Q1 (Q = [Q1, Q2]) as the factorization can be written as Q * R = [Q1, Q2] * [R1; 0]. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N factored matrix as returned by the QR factorization routine. On output, the upper triangular matrix R. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of each elementary reflector defined in <code>r</code>. </td></tr>
    <tr><td class="paramname">pvt</td><td>An N-element array containing the pivot information from the QR factorization. </td></tr>
    <tr><td class="paramname">q</td><td>An M-by-M matrix where the full Q matrix will be written. In the event that <code>fullq</code> is set to false, and M &gt; N, this matrix need only by M-by-N. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q. </td></tr>
    <tr><td class="paramname">p</td><td>An N-by-N matrix where the pivot matrix P will be written. </td></tr>
    <tr><td class="paramname">ldp</td><td>The leading dimension of matrix P.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a95d6ed56844c62d553b940091837014b" name="a95d6ed56844c62d553b940091837014b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d6ed56844c62d553b940091837014b">&#9670;&#160;</a></span>la_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_inverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the inverse of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of matrix A. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix to invert. On output, the inverted matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7a821b41c61670f5710214a4d9178998" name="a7a821b41c61670f5710214a4d9178998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a821b41c61670f5710214a4d9178998">&#9670;&#160;</a></span>la_inverse_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_inverse_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the inverse of a square matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The dimension of matrix A. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the N-by-N matrix to invert. On output, the inverted matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs if the input matrix is singular. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7b2048bb219e58f455175041558ac44f" name="a7b2048bb219e58f455175041558ac44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2048bb219e58f455175041558ac44f">&#9670;&#160;</a></span>la_lq_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_lq_factor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the LQ factorization of an M-by-N matrix without pivoting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5e6786c40f8f91e5f16f06e92be71ffa" name="a5e6786c40f8f91e5f16f06e92be71ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6786c40f8f91e5f16f06e92be71ffa">&#9670;&#160;</a></span>la_lq_factor_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_lq_factor_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the LQ factorization of an M-by-N matrix without pivoting.</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a248142a5f0826cddac5daf1c74f234a6" name="a248142a5f0826cddac5daf1c74f234a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248142a5f0826cddac5daf1c74f234a6">&#9670;&#160;</a></span>la_lu_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_lu_factor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipvt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the LU factorization of an M-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix on which to operate. On output, the LU factored matrix in the form [L\U] where the unit diagonal elements of L are not stored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ipvt</td><td>An MIN(M, N)-element array used to track row-pivot operations. The array stored pivot information such that row I is interchanged with row IPVT(I).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if <code>a</code> is found to be singular. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ace554b62c12a5d9a2434c8171c756c47" name="ace554b62c12a5d9a2434c8171c756c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace554b62c12a5d9a2434c8171c756c47">&#9670;&#160;</a></span>la_lu_factor_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_lu_factor_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipvt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the LU factorization of an M-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix on which to operate. On output, the LU factored matrix in the form [L\U] where the unit diagonal elements of L are not stored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ipvt</td><td>An MIN(M, N)-element array used to track row-pivot operations. The array stored pivot information such that row I is interchanged with row IPVT(I).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_SINGULAR_MATRIX_ERROR: Occurs as a warning if <code>a</code> is found to be singular. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a968b10545320af7bbe1030867ae88e8c" name="a968b10545320af7bbe1030867ae88e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968b10545320af7bbe1030867ae88e8c">&#9670;&#160;</a></span>la_mtx_mult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mtx_mult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the matrix operation \( C = \alpha op(A) op(B) + \beta C \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transa</td><td>Set to true to compute op(A) as the transpose of A; else, set to false to compute op(A) as A. </td></tr>
    <tr><td class="paramname">transb</td><td>Set to true to compute op(B) as the transpose of B; else, set to false to compute op(B) as B. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in <code>c</code>. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in <code>c</code>. </td></tr>
    <tr><td class="paramname">k</td><td>The interior dimension of the product <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">a</td><td>If <code>transa</code> is true, this matrix must be <code>k</code> by <code>m</code>; else, if <code>transa</code> is false, this matrix must be <code>m</code> by <code>k</code>. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix <code>a</code>. </td></tr>
    <tr><td class="paramname">b</td><td>If <code>transb</code> is true, this matrix must be <code>n</code> by <code>k</code>; else, if <code>transb</code> is false, this matrix must be <code>k</code> by <code>n</code>. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix <code>b</code>. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">c</td><td>The <code>m</code> by <code>n</code> matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix <code>c</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldb</code>, or <code>ldc</code> are not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aefefe80e13f74470d5afaf44b3a45e76" name="aefefe80e13f74470d5afaf44b3a45e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefefe80e13f74470d5afaf44b3a45e76">&#9670;&#160;</a></span>la_mtx_mult_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mtx_mult_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the matrix operation \( C = \alpha op(A) op(B) + \beta C \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opa</td><td>Set to LA_TRANSPOSE to compute op(A) as a direct transpose of A, set to LA_HERMITIAN_TRANSPOSE to compute op(A) as the Hermitian transpose of A, otherwise, set to LA_NO_OPERATION to compute op(A) as A. </td></tr>
    <tr><td class="paramname">opb</td><td>Set to TLA_RANSPOSE to compute op(B) as a direct transpose of B, set to LA_HERMITIAN_TRANSPOSE to compute op(B) as the Hermitian transpose of B, otherwise, set to LA_NO_OPERATION to compute op(B) as B. </td></tr>
    <tr><td class="paramname">mThe</td><td>number of rows in <code>c</code>. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in <code>c</code>. </td></tr>
    <tr><td class="paramname">k</td><td>The interior dimension of the product <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">a</td><td>If <code>opa</code> is LA_TRANSPOSE or LA_HERMITIAN_TRANSPOSE, this matrix must be <code>k</code> by <code>m</code>; else, this matrix must be <code>m</code> by <code>k</code>. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix <code>a</code>. </td></tr>
    <tr><td class="paramname">b</td><td>If <code>opb</code> is LA_TRANSPOSE or LA_HERMITIAN_TRANSPOSE, this matrix must be <code>n</code> by <code>k</code>; else, this matrix must be <code>k</code> by <code>n</code>. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix <code>b</code>. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">c</td><td>The <code>m</code> by <code>n</code> matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix <code>c</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldb</code>, or <code>ldc</code> are not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac575e10e20e9c2d8d40ed8df47179773" name="ac575e10e20e9c2d8d40ed8df47179773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac575e10e20e9c2d8d40ed8df47179773">&#9670;&#160;</a></span>la_mult_lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mult_lq </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplies a general matrix by the orthogonal matrix Q from a LQ factorization such that: \( C = op(Q) C \), or \( C = C op(Q) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply \( Q \) or \( Q^T \) from the left; else, set to false to apply \( Q \) or \( Q^T \) from the right. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true to apply \( Q^T \); else, set to false. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The number of elementary reflectors whose product defines the matrix Q. </td></tr>
    <tr><td class="paramname">a</td><td>On input, an K-by-P matrix containing the elementary reflectors output from the LQ factorization. If <code>lside</code> is set to true, P = M; else, if <code>lside</code> is set to false, P = N. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldc</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adcb07293cf47d090dfb89c20837ca7b5" name="adcb07293cf47d090dfb89c20837ca7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb07293cf47d090dfb89c20837ca7b5">&#9670;&#160;</a></span>la_mult_lq_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mult_lq_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplies a general matrix by the orthogonal matrix Q from a LQ factorization such that: \( C = op(Q) C \), or \( C = C op(Q) \).</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply \( Q \) or \( Q^H \) from the left; else, set to false to apply \( Q \) or \( Q^H \) from the right. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true to apply \( Q^H \); else, set to false. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The number of elementary reflectors whose product defines the matrix Q. </td></tr>
    <tr><td class="paramname">a</td><td>On input, an K-by-P matrix containing the elementary reflectors output from the LQ factorization. If <code>lside</code> is set to true, P = M; else, if <code>lside</code> is set to false, P = N. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldc</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a95f921847131eaedd62a439490d2a801" name="a95f921847131eaedd62a439490d2a801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f921847131eaedd62a439490d2a801">&#9670;&#160;</a></span>la_mult_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mult_qr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: \( C = op(Q) C \), or \( C = C op(Q) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply \( Q \) or \( Q^T \) from the left; else, set to false to apply \( Q \) or \( Q^T \) from the right. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true to apply \( Q^T \); else, set to false. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The number of elementary reflectors whose product defines the matrix Q. </td></tr>
    <tr><td class="paramname">a</td><td>On input, an LDA-by-K matrix containing the elementary reflectors output from the QR factorization. If <code>lside</code> is set to true, LDA = M, and M &gt;= K &gt;= 0; else, if <code>lside</code> is set to false, LDA = N, and N &gt;= K &gt;= 0. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldc</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acc25c0daa53c10ace21a61d78b2e79f3" name="acc25c0daa53c10ace21a61d78b2e79f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc25c0daa53c10ace21a61d78b2e79f3">&#9670;&#160;</a></span>la_mult_qr_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_mult_qr_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiplies a general matrix by the orthogonal matrix Q from a QR factorization such that: \( C = op(Q) C \), or \( C = C op(Q) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to apply \( Q \) or \( Q^H \) from the left; else, set to false to apply \( Q \) or \( Q^H \) from the right. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true to apply \( Q^H \); else, set to false. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix C. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix C. </td></tr>
    <tr><td class="paramname">k</td><td>The number of elementary reflectors whose product defines the matrix Q. </td></tr>
    <tr><td class="paramname">a</td><td>On input, an LDA-by-K matrix containing the elementary reflectors output from the QR factorization. If <code>lside</code> is set to true, LDA = M, and M &gt;= K &gt;= 0; else, if <code>lside</code> is set to false, LDA = N, and N &gt;= K &gt;= 0. Notice, the contents of this matrix are restored on exit. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A K-element array containing the scalar factors of each elementary reflector defined in <code>a</code>. </td></tr>
    <tr><td class="paramname">c</td><td>On input, the M-by-N matrix C. On output, the product of the orthogonal matrix Q and the original matrix C. </td></tr>
    <tr><td class="paramname">ldc</td><td>The leading dimension of matrix C.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldc</code> are not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af7f8185c0f25ad3fb0b89cc98d77b3d6" name="af7f8185c0f25ad3fb0b89cc98d77b3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f8185c0f25ad3fb0b89cc98d77b3d6">&#9670;&#160;</a></span>la_pinverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_pinverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ainv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldai</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by means of singular value decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. @parma n The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to invert. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ainv</td><td>The N-by-M matrix where the pseudo-inverse of <code>a</code> will be written. </td></tr>
    <tr><td class="paramname">ldai</td><td>The leading dimension of matrix AINV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldai</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a71ba1a09caca9d59a9d24b95c7ea749b" name="a71ba1a09caca9d59a9d24b95c7ea749b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba1a09caca9d59a9d24b95c7ea749b">&#9670;&#160;</a></span>la_pinverse_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_pinverse_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>ainv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldai</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the Moore-Penrose pseudo-inverse of an M-by-N matrix by means of singular value decomposition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. @parma n The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to invert. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ainv</td><td>The N-by-M matrix where the pseudo-inverse of <code>a</code> will be written. </td></tr>
    <tr><td class="paramname">ldai</td><td>The leading dimension of matrix AINV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldai</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a791d5221eb8ad4fcd106cb218590dfc9" name="a791d5221eb8ad4fcd106cb218590dfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791d5221eb8ad4fcd106cb218590dfc9">&#9670;&#160;</a></span>la_qr_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_factor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the QR factorization of an M-by-N matrix without pivoting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae5ffa6e8d9c850bd41f43f7564bf6896" name="ae5ffa6e8d9c850bd41f43f7564bf6896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ffa6e8d9c850bd41f43f7564bf6896">&#9670;&#160;</a></span>la_qr_factor_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_factor_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the QR factorization of an M-by-N matrix without pivoting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4a3f6dafe185c2985fc76aab3d0abb97" name="a4a3f6dafe185c2985fc76aab3d0abb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3f6dafe185c2985fc76aab3d0abb97">&#9670;&#160;</a></span>la_qr_factor_cmplx_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_factor_cmplx_pvt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the QR factorization of an M-by-N matrix with column pivoting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramname">jpvt</td><td>On input, an N-element array that if JPVT(I) .ne. 0, the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th column of A is a free column. On output, if JPVT(I) = K, then the I-th column of A * P was the K-th column of A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4bc671dad87b42ff285a4241322a3764" name="a4bc671dad87b42ff285a4241322a3764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc671dad87b42ff285a4241322a3764">&#9670;&#160;</a></span>la_qr_factor_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_factor_pvt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>jpvt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the QR factorization of an M-by-N matrix with column pivoting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. On output, the elements on and above the diagonal contain the MIN(M, N)-by-N upper trapezoidal matrix R (R is upper triangular if M &gt;= N). The elements below the diagonal, along with the array <code>tau</code>, represent the orthogonal matrix Q as a product of elementary reflectors. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array used to store the scalar factors of the elementary reflectors. </td></tr>
    <tr><td class="paramname">jpvt</td><td>On input, an N-element array that if JPVT(I) .ne. 0, the I-th column of A is permuted to the front of A * P; if JPVT(I) = 0, the I-th column of A is a free column. On output, if JPVT(I) = K, then the I-th column of A * P was the K-th column of A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9b0639faf9ac0af9bbdb348b92746d5f" name="a9b0639faf9ac0af9bbdb348b92746d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0639faf9ac0af9bbdb348b92746d5f">&#9670;&#160;</a></span>la_qr_rank1_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_rank1_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where \( A = Q R \), and \( A1 = A + U V^T \) such that \( A1 = Q1 R1 \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">q</td><td>On input, the original M-by-K orthogonal matrix Q. On output, the updated matrix Q1. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the M-element U update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramname">v</td><td>On input, the N-element V update vector. On output, the original content of the array is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldq</code> or <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acfbd42393c8b1931ff11bc4c7e858aef" name="acfbd42393c8b1931ff11bc4c7e858aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd42393c8b1931ff11bc4c7e858aef">&#9670;&#160;</a></span>la_qr_rank1_update_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_qr_rank1_update_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank 1 update to an M-by-N QR factored matrix A (M &gt;= N) where \( A = Q R \), and \( A1 = A + U V^H \) such that \( A1 = Q1 R1 \).</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in R. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in R. </td></tr>
    <tr><td class="paramname">q</td><td>On input, the original M-by-K orthogonal matrix Q. On output, the updated matrix Q1. </td></tr>
    <tr><td class="paramname">ldq</td><td>The leading dimension of matrix Q. </td></tr>
    <tr><td class="paramname">r</td><td>On input, the M-by-N matrix R. On output, the updated matrix R1. </td></tr>
    <tr><td class="paramname">ldr</td><td>The leading dimension of matrix R. </td></tr>
    <tr><td class="paramname">u</td><td>On input, the M-element U update vector. On output, the original content of the array is overwritten. </td></tr>
    <tr><td class="paramname">v</td><td>On input, the N-element V update vector. On output, the original content of the array is overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldq</code> or <code>ldr</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a089690d293303e30c6eef0bb1e982191" name="a089690d293303e30c6eef0bb1e982191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089690d293303e30c6eef0bb1e982191">&#9670;&#160;</a></span>la_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_rank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rnk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank of a matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-N matrix. The matrix is overwritten as part of this operation. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">rnk</td><td>The rank of <code>a</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab346fed23fd61f02d65e09c795c26d74" name="ab346fed23fd61f02d65e09c795c26d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab346fed23fd61f02d65e09c795c26d74">&#9670;&#160;</a></span>la_rank1_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_rank1_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs the rank-1 update to matrix A such that: \( A = \alpha X Y^T + A \), where \( A \) is an M-by-N matrix, \( \alpha \) is a scalar, \( X \) is an M-element array, and \( Y \) is an N-element array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar multiplier. </td></tr>
    <tr><td class="paramname">x</td><td>An M-element array. </td></tr>
    <tr><td class="paramname">y</td><td>An N-element array. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to update. On output, the updated M-by-N matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3c958fe274f8d1663dd0188455a5fe15" name="a3c958fe274f8d1663dd0188455a5fe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c958fe274f8d1663dd0188455a5fe15">&#9670;&#160;</a></span>la_rank1_update_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_rank1_update_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs the rank-1 update to matrix A such that: \( A = \alpha X Y^H + A \), where \( A \) is an M-by-N matrix, \( \alpha \) is a scalar, \( X \) is an M-element array, and \( Y \) is an N-element array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar multiplier. </td></tr>
    <tr><td class="paramname">x</td><td>An M-element array. </td></tr>
    <tr><td class="paramname">y</td><td>An N-element array. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to update. On output, the updated M-by-N matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afdc9b7e6ffab89915a082c00ceac7258" name="afdc9b7e6ffab89915a082c00ceac7258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc9b7e6ffab89915a082c00ceac7258">&#9670;&#160;</a></span>la_rank_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_rank_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rnk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the rank of a matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-N matrix. The matrix is overwritten as part of this operation. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">rnk</td><td>The rank of <code>a</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0dc578507a0cb6ada776142476383590" name="a0dc578507a0cb6ada776142476383590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc578507a0cb6ada776142476383590">&#9670;&#160;</a></span>la_solve_cholesky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_cholesky </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of Cholesky factored equations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true if the original matrix A was factored such that \( A = U^T U \); else, set to false if the factorization of A was \( A = L^T L \). </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-M Cholesky factored matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side matrix B. On output, the M-by-N solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a719ffdff56c8fa0875409c4f4e5e95cf" name="a719ffdff56c8fa0875409c4f4e5e95cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719ffdff56c8fa0875409c4f4e5e95cf">&#9670;&#160;</a></span>la_solve_cholesky_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_cholesky_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of Cholesky factored equations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true if the original matrix A was factored such that \( A = U^T U \); else, set to false if the factorization of A was \( A = L^T L \). </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-M Cholesky factored matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side matrix B. On output, the M-by-N solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a02eb049983dd41f2307bb52594fb210e" name="a02eb049983dd41f2307bb52594fb210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eb049983dd41f2307bb52594fb210e">&#9670;&#160;</a></span>la_solve_least_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_least_squares </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves the overdetermined or underdetermined system ( \( A X = B \)) of M equations of N unknowns using a QR or LQ factorization of the matrix A. Notice, it is assumed that matrix A has full rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix A. On output, if M &gt;= N, the QR factorization of A in the form as output by qr_factor; else, if M &lt; N, the LQ factorization of A. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>If M &gt;= N, the M-by-NRHS matrix B. On output, the first N rows contain the N-by-NRHS solution matrix X. If M &lt; N, an N-by-NRHS matrix with the first M rows containing the matrix B. On output, the N-by-NRHS solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_INVALID_OPERATION_ERROR: Occurs if <code>a</code> is not of full rank. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac3bb7b959d8cc7400e9b13290a895b64" name="ac3bb7b959d8cc7400e9b13290a895b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bb7b959d8cc7400e9b13290a895b64">&#9670;&#160;</a></span>la_solve_least_squares_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_least_squares_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves the overdetermined or underdetermined system ( \( A X = B \)) of M equations of N unknowns using a QR or LQ factorization of the matrix A. Notice, it is assumed that matrix A has full rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix A. On output, if M &gt;= N, the QR factorization of A in the form as output by qr_factor; else, if M &lt; N, the LQ factorization of A. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>If M &gt;= N, the M-by-NRHS matrix B. On output, the first N rows contain the N-by-NRHS solution matrix X. If M &lt; N, an N-by-NRHS matrix with the first M rows containing the matrix B. On output, the N-by-NRHS solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_INVALID_OPERATION_ERROR: Occurs if <code>a</code> is not of full rank. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2c485d619c24435be713cf4356285e9a" name="a2c485d619c24435be713cf4356285e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c485d619c24435be713cf4356285e9a">&#9670;&#160;</a></span>la_solve_lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_lq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns where N &gt;= M.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by lq_factor. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by lq_factor. </td></tr>
    <tr><td class="paramname">b</td><td>On input, an N-by-K matrix containing the first M rows of the right-hand-side matrix. On output, the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct, or if <code>m</code> is less than <code>n</code>.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a54ee9d9ab89b88b0ca682f70bc6c3c54" name="a54ee9d9ab89b88b0ca682f70bc6c3c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee9d9ab89b88b0ca682f70bc6c3c54">&#9670;&#160;</a></span>la_solve_lq_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_lq_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns where N &gt;= M.</p>
<dl class="section user"><dt>WARNING</dt><dd>Untested code that needs more work before being ready for normal use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by lq_factor. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by lq_factor. </td></tr>
    <tr><td class="paramname">b</td><td>On input, an N-by-K matrix containing the first M rows of the right-hand-side matrix. On output, the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct, or if <code>m</code> is less than <code>n</code>.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aae725d3247301d1163c58f89edff3d4b" name="aae725d3247301d1163c58f89edff3d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae725d3247301d1163c58f89edff3d4b">&#9670;&#160;</a></span>la_solve_lu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_lu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of LU-factored equations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-M LU factored matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ipvt</td><td>The M-element pivot array from the LU factorization. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side. On output, the M-by-N solution. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa067ac0d3f58e28371d413ab7419da74" name="aa067ac0d3f58e28371d413ab7419da74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa067ac0d3f58e28371d413ab7419da74">&#9670;&#160;</a></span>la_solve_lu_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_lu_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ipvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of LU-factored equations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-M LU factored matrix. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">ipvt</td><td>The M-element pivot array from the LU factorization. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side. On output, the M-by-N solution. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aefdc2e6758482d02a3aa7978f7d5efe0" name="aefdc2e6758482d02a3aa7978f7d5efe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdc2e6758482d02a3aa7978f7d5efe0">&#9670;&#160;</a></span>la_solve_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_qr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns where M &gt;= N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-K right-hand-side matrix. On output, the first N rows are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct, or if <code>m</code> is less than <code>n</code>.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0ff5f2519eb1d2af94e3b4a26dfb10fe" name="a0ff5f2519eb1d2af94e3b4a26dfb10fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff5f2519eb1d2af94e3b4a26dfb10fe">&#9670;&#160;</a></span>la_solve_qr_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_qr_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns where M &gt;= N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-K right-hand-side matrix. On output, the first N rows are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct, or if <code>m</code> is less than <code>n</code>.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad0ee4a9c71de62911a71a342790f5070" name="ad0ee4a9c71de62911a71a342790f5070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ee4a9c71de62911a71a342790f5070">&#9670;&#160;</a></span>la_solve_qr_cmplx_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_qr_cmplx_pvt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramname">jpvt</td><td>The N-element array that was used to track the column pivoting operations in the QR factorization. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-K right-hand-side matrix. On output, the first N rows are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a62f97b4319f5574aef5e52bbacff14bb" name="a62f97b4319f5574aef5e52bbacff14bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f97b4319f5574aef5e52bbacff14bb">&#9670;&#160;</a></span>la_solve_qr_pvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_qr_pvt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jpvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves a system of M QR-factored equations of N unknowns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of equations (rows in matrix A). </td></tr>
    <tr><td class="paramname">n</td><td>The number of unknowns (columns in matrix A). </td></tr>
    <tr><td class="paramname">k</td><td>The number of columns in the right-hand-side matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N QR factored matrix as returned by qr_factor. On output, the contents of this matrix are restored. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">tau</td><td>A MIN(M, N)-element array containing the scalar factors of the elementary reflectors as returned by qr_factor. </td></tr>
    <tr><td class="paramname">jpvt</td><td>The N-element array that was used to track the column pivoting operations in the QR factorization. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-K right-hand-side matrix. On output, the first N rows are overwritten by the solution matrix X. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aed7b29bbff1472ebe805054eb9d8c6d4" name="aed7b29bbff1472ebe805054eb9d8c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7b29bbff1472ebe805054eb9d8c6d4">&#9670;&#160;</a></span>la_solve_tri_mtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_tri_mtx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nounit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves one of the matrix equations: \( op(A) X = \alpha B \), or \( X op(A) = \alpha B \), where \( A \) is a triangular matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to solve \( op(A) X = \alpha B \); else, set to false to solve \( X op(A) = \alpha B \). </td></tr>
    <tr><td class="paramname">upper</td><td>Set to true if A is an upper triangular matrix; else, set to false if A is a lower triangular matrix. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true if \( op(A) = A^T \); else, set to false if \( op(A) = A \). </td></tr>
    <tr><td class="paramname">nounit</td><td>Set to true if A is not a unit-diagonal matrix (ones on every diagonal element); else, set to false if A is a unit-diagonal matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar multiplier to B. </td></tr>
    <tr><td class="paramname">a</td><td>If <code>lside</code> is true, the M-by-M triangular matrix on which to operate; else, if <code>lside</code> is false, the N-by-N triangular matrix on which to operate. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side. On output, the M-by-N solution. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af87823d73fb5a319e4262594d147e38c" name="af87823d73fb5a319e4262594d147e38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87823d73fb5a319e4262594d147e38c">&#9670;&#160;</a></span>la_solve_tri_mtx_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_solve_tri_mtx_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nounit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solves one of the matrix equations: \( op(A) X = \alpha B \), or \( X op(A) = \alpha B \), where \( A \) is a triangular matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lside</td><td>Set to true to solve \( op(A) X = \alpha B \); else, set to false to solve \( X op(A) = \alpha B \). </td></tr>
    <tr><td class="paramname">upper</td><td>Set to true if A is an upper triangular matrix; else, set to false if A is a lower triangular matrix. </td></tr>
    <tr><td class="paramname">trans</td><td>Set to true if \( op(A) = A^H \); else, set to false if \( op(A) = A \). </td></tr>
    <tr><td class="paramname">nounit</td><td>Set to true if A is not a unit-diagonal matrix (ones on every diagonal element); else, set to false if A is a unit-diagonal matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in matrix B. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in matrix B. </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar multiplier to B. </td></tr>
    <tr><td class="paramname">a</td><td>If <code>lside</code> is true, the M-by-M triangular matrix on which to operate; else, if <code>lside</code> is false, the N-by-N triangular matrix on which to operate. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the M-by-N right-hand-side. On output, the M-by-N solution. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, or <code>ldb</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abf5918abab8f97fc2ac5887e051ff493" name="abf5918abab8f97fc2ac5887e051ff493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5918abab8f97fc2ac5887e051ff493">&#9670;&#160;</a></span>la_sort_eigen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_sort_eigen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ascend</td><td></td></tr>
    <tr><td class="paramname">n</td><td>The number of eigenvalues. </td></tr>
    <tr><td class="paramname">vals</td><td>On input, an N-element array containing the eigenvalues. On output, the sorted eigenvalues. </td></tr>
    <tr><td class="paramname">vecs</td><td>On input, an N-by-N matrix containing the eigenvectors associated with <code>vals</code> (one vector per column). On output, the sorted eigenvector matrix. </td></tr>
    <tr><td class="paramname">ldv</td><td>The leading dimension of <code>vecs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a090178a5f99a4b400da80481aad77757" name="a090178a5f99a4b400da80481aad77757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090178a5f99a4b400da80481aad77757">&#9670;&#160;</a></span>la_sort_eigen_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_sort_eigen_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A sorting routine specifically tailored for sorting of eigenvalues and their associated eigenvectors using a quick-sort approach.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ascend</td><td></td></tr>
    <tr><td class="paramname">n</td><td>The number of eigenvalues. </td></tr>
    <tr><td class="paramname">vals</td><td>On input, an N-element array containing the eigenvalues. On output, the sorted eigenvalues. </td></tr>
    <tr><td class="paramname">vecs</td><td>On input, an N-by-N matrix containing the eigenvectors associated with <code>vals</code> (one vector per column). On output, the sorted eigenvector matrix. </td></tr>
    <tr><td class="paramname">ldv</td><td>The leading dimension of <code>vecs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a56c0cea99a066e74c8fff9682d5ca92d" name="a56c0cea99a066e74c8fff9682d5ca92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c0cea99a066e74c8fff9682d5ca92d">&#9670;&#160;</a></span>la_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_svd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the singular value decomposition of a matrix \( A \). The SVD is defined as: \( A = U S V^T \), where \( U \) is an M-by-M orthogonal matrix, \( S \) is an M-by-N diagonal matrix, and \( V \) is an N-by-N orthogonal matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">s</td><td>A MIN(M, N)-element array containing the singular values of <code>a</code> sorted in descending order. </td></tr>
    <tr><td class="paramname">u</td><td>An M-by-M matrix where the orthogonal U matrix will be written. </td></tr>
    <tr><td class="paramname">ldu</td><td>The leading dimension of matrix U. </td></tr>
    <tr><td class="paramname">vt</td><td>An N-by-N matrix where the transpose of the right singular vector matrix V. </td></tr>
    <tr><td class="paramname">ldv</td><td>The leading dimension of matrix V.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldu</code>, or <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afbffa0856d75c607a03d3dc7b5b1076e" name="afbffa0856d75c607a03d3dc7b5b1076e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbffa0856d75c607a03d3dc7b5b1076e">&#9670;&#160;</a></span>la_svd_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_svd_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the singular value decomposition of a matrix \( A \). The SVD is defined as: \( A = U S V^H \), where \( U \) is an M-by-M orthogonal matrix, \( S \) is an M-by-N diagonal matrix, and \( V \) is an N-by-N orthogonal matrix. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>On input, the M-by-N matrix to factor. The matrix is overwritten on output. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">s</td><td>A MIN(M, N)-element array containing the singular values of <code>a</code> sorted in descending order. </td></tr>
    <tr><td class="paramname">u</td><td>An M-by-M matrix where the orthogonal U matrix will be written. </td></tr>
    <tr><td class="paramname">ldu</td><td>The leading dimension of matrix U. </td></tr>
    <tr><td class="paramname">vt</td><td>An N-by-N matrix where the conjugate transpose of the right singular vector matrix V. </td></tr>
    <tr><td class="paramname">ldv</td><td>The leading dimension of <code>vt</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code>, <code>ldu</code>, or <code>ldv</code> is not correct.</li>
<li>LA_OUT_OF_MEMORY_ERROR: Occurs if local memory must be allocated, and there is insufficient memory available.</li>
<li>LA_CONVERGENCE_ERROR: Occurs as a warning if the QR iteration process could not converge to a zero value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7f611f8f3de7d56120c78e70671c7112" name="a7f611f8f3de7d56120c78e70671c7112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f611f8f3de7d56120c78e70671c7112">&#9670;&#160;</a></span>la_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the trace of a matrix (the sum of the main diagonal elements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-N matrix on which to operate. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of the matrix. </td></tr>
    <tr><td class="paramname">rst</td><td>The results of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a021fbb7fdccf557ec407a86bace43d85" name="a021fbb7fdccf557ec407a86bace43d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021fbb7fdccf557ec407a86bace43d85">&#9670;&#160;</a></span>la_trace_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_trace_cmplx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>rst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the trace of a matrix (the sum of the main diagonal elements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The M-by-N matrix on which to operate. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of the matrix. </td></tr>
    <tr><td class="paramname">rst</td><td>The results of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae7d70f1ef2a2824772e1bf0f726c257e" name="ae7d70f1ef2a2824772e1bf0f726c257e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d70f1ef2a2824772e1bf0f726c257e">&#9670;&#160;</a></span>la_tri_mtx_mult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_tri_mtx_mult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the triangular matrix operation: \( B = \alpha A^T A + \beta B \), or \( B = \alpha A A^T + \beta B \), where \( A \) is a triangular matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true if matrix \( A \) is upper triangular, and \( B = \alpha A^T A + \beta B \) is to be calculated; else, set to false if \( A \) is lower triangular, and \( B = \alpha A A^T + \beta B \) is to be computed. </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The <code>n</code> by <code>n</code> triangular matrix A. Notice, if <code>upper</code> is true, only the upper triangular portion of this matrix is referenced; else, if <code>upper</code> is false, only the lower triangular portion of this matrix is referenced. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the <code>n</code> by <code>n</code> matrix B. On output, the <code>n</code> by <code>n</code> resulting matrix. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldb</code> are not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a02c464a9dd95298c91f431ae4d0773e9" name="a02c464a9dd95298c91f431ae4d0773e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c464a9dd95298c91f431ae4d0773e9">&#9670;&#160;</a></span>la_tri_mtx_mult_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int la_tri_mtx_mult_cmplx </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the triangular matrix operation: \( B = \alpha A^T A + \beta B \), or \( B = \alpha A A^T + \beta B \), where \( A \) is a triangular matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Set to true if matrix \( A \) is upper triangular, and \( B = \alpha A^T A + \beta B \) is to be calculated; else, set to false if \( A \) is lower triangular, and \( B = \alpha A A^T + \beta B \) is to be computed. </td></tr>
    <tr><td class="paramname">alpha</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension of the matrix. </td></tr>
    <tr><td class="paramname">a</td><td>The <code>n</code> by <code>n</code> triangular matrix A. Notice, if <code>upper</code> is true, only the upper triangular portion of this matrix is referenced; else, if <code>upper</code> is false, only the lower triangular portion of this matrix is referenced. </td></tr>
    <tr><td class="paramname">lda</td><td>The leading dimension of matrix A. </td></tr>
    <tr><td class="paramname">beta</td><td>A scalar multiplier. </td></tr>
    <tr><td class="paramname">b</td><td>On input, the <code>n</code> by <code>n</code> matrix B. On output, the <code>n</code> by <code>n</code> resulting matrix. </td></tr>
    <tr><td class="paramname">ldb</td><td>The leading dimension of matrix B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. The following codes are possible.<ul>
<li>LA_NO_ERROR: No error occurred. Successful operation.</li>
<li>LA_INVALID_INPUT_ERROR: Occurs if <code>lda</code> or <code>ldb</code> are not correct. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="linalg_8h.html">linalg.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
